{"A-Navigation/B-项目🧵":{"title":"B 项目🧵","links":["C-Knowledge/财务自由/买房","D-Unsorted/驾考","C-Knowledge/项目/开源项目","C-Knowledge/项目/文档翻译","C-Knowledge/项目/技术文章"],"tags":["编程/个人项目"],"content":"\n买房\n驾考\n开源项目\n文档翻译\n技术文章\n"},"A-Navigation/C-科学-🔬":{"title":"C 科学 🔬","links":["C-Knowledge/前端/计算机科学","D-Unsorted/语言学","D-Unsorted/心理学","D-Unsorted/思维科学","D-Unsorted/教育学","D-Unsorted/经济学","D-Unsorted/医学","D-Unsorted/性学"],"tags":[],"content":"\n计算机科学\n语言学\n心理学\n思维科学\n教育学\n经济学\n医学\n性学\n"},"A-Navigation/D-文化🐲":{"title":"D 文化🐲","links":["C-Knowledge/认知卡片/常用思维模型","C-Knowledge/认知卡片/可逆决定和不可逆决定","D-Unsorted/寻求启发，而不是寻求认可","C-Knowledge/认知卡片/着陆式年度计划法","C-Knowledge/认知卡片/刻意练习","C-Knowledge/认知卡片/培养习惯","C-Knowledge/认知卡片/思维曲线","C-Knowledge/认知卡片/成为工具的主人","D-Unsorted/课题分离","D-Unsorted/外置大脑","C-Knowledge/认知卡片/金句🍊","C-Knowledge/学习进化/大佬智库🤔️","D-Unsorted/习惯","D-Unsorted/计划管理","D-Unsorted/知识管理","C-Knowledge/前端/开发技术/Git/Github","D-Unsorted/语雀","ClashX","D-Unsorted/Obsidian","D-Unsorted/Notion","D-Unsorted/Apple","D-Unsorted/科研","D-Unsorted/职场","D-Unsorted/财富自由","D-Unsorted/保障","D-Unsorted/读书笔记"],"tags":[],"content":"\n认知\n\n常用思维模型\n可逆决定和不可逆决定\n寻求启发，而不是寻求认可\n着陆式年度计划法\n刻意练习\n培养习惯\n思维曲线\n成为工具的主人\n课题分离\n外置大脑\n金句🍊\n大佬智库🤔️\n\n\n效率\n\n习惯\n计划管理\n知识管理\n\n\nApps\n\nGithub\n语雀\nClashX\nObsidian\nNotion\nApple\n\n\n科研\n职场\n财富自由\n保障\n读书笔记\n"},"A-Navigation/E-艺术-🎨":{"title":"E 艺术 🎨","links":["D-Unsorted/《10倍写作术》","C-Knowledge/读书笔记/《技术写作指南-张鑫旭》读后整理","C-Knowledge/读书笔记/《卡片笔记写作法》","C-Knowledge/学习进化/如何写一篇好文章","D-Unsorted/写作｜《认知觉醒》","C-Knowledge/读书笔记/《摄影入门：人像摄影超级简单》","E-Day-planner/2024/四月/踏青出游拍照要诀，快来学！","C-Knowledge/学习进化/摄影学习资源","C-Knowledge/学习进化/魔方"],"tags":[],"content":"写作\n\n《10倍写作术》\n《技术写作指南-张鑫旭》读后整理\n《卡片笔记写作法》\n如何写一篇好文章\n写作｜《认知觉醒》\n\n摄影\n\n《摄影入门：人像摄影超级简单》\n踏青出游拍照要诀，快来学！\n摄影学习资源\n\n爱好\n\n魔方\n"},"A-Navigation/F-时光日志📔":{"title":"F 时光日志📔","links":["E-Day-planner/2024/四月/2024_04_22｜星期一","E-Day-planner/2024/二月/2024_02_25｜星期日","E-Day-planner/2024/二月/2024_02_19｜星期一","E-Diary/2024_01_20｜周六｜☔️","E-Diary/2024_01_19｜周五｜☀️","E-Diary/防抖和节流｜2024_01_17｜周三｜☀️","E-Diary/2024_01_15｜周一｜☀️","E-Diary/2024_01_14｜周日｜☀️","E-Diary/2024_01_13｜周六｜☀️","E-Diary/2024_01_12｜周五｜☀️","E-Diary/2024_01_11｜周四｜☀️","E-Diary/域名备案通过｜2024_01_10｜周三｜☀️","E-Diary/2024_01_09｜周二｜☀️","E-Diary/2024_01_07｜周日｜☀️","E-Diary/2024_01_05｜周五｜🌁","E-Diary/2024_01_04｜周四｜☁️","E-Diary/2024_01_03｜周三｜☁️","E-Diary/2023_12_10｜周日｜☀️","E-Diary/2023_12_09｜周六｜☀️","E-Diary/2023_12_08｜周五｜☀️","E-Diary/2023_12_07｜周四｜🌁","E-Diary/2023_12_06｜周三｜☀️","E-Diary/2023_12_05｜周二｜🌁","E-Diary/2023_12_04｜周一｜☁️","E-Diary/2023_12_03｜周日｜☁️","E-Diary/2023_12_02｜周六｜🌧️","E-Diary/2023_12_01｜周五｜☔️","E-Diary/2023_11_30｜周日｜☔️","E-Diary/2023_11_29｜周三｜☀️","E-Diary/2023_11_28｜周二｜☀️","E-Diary/2023_11_27｜周一｜☀️","E-Diary/2023_11_26｜周日｜☀️","E-Diary/2023_11_25｜周六｜☀️","E-Diary/2023_11_24｜周五｜☀️","E-Diary/2023_11_23｜周四｜☀️","E-Diary/2023_11_22｜周三｜☀️","E-Diary/2023_11_21｜周二｜☀️","E-Diary/2023_11_20｜周一｜☀️","E-Diary/2023_11_19｜周日｜☀️","E-Diary/2023_11_18｜周六｜☀️","E-Diary/2023_11_17｜周五｜☀️","E-Diary/2023_11_16｜周四｜☀️","E-Diary/2023_11_15｜周三｜🌁","D-Unsorted/⛩️｜2023_11_14｜周二｜☔️","E-Diary/2023_11_13｜周一｜🌧️","E-Diary/2023_11_12｜周日｜🌧️","E-Diary/2023_11_11｜周六｜☔️","E-Diary/2023_11_10｜周五｜☀️","E-Diary/语雀悬浮胶囊｜2023_11_09｜周四｜☀️","E-Diary/2023_11_08｜周三｜☀️","E-Diary/2023_11_07｜周二｜☀️","E-Diary/2023_11_06｜周一｜☀️","E-Diary/2023_11_05｜周日｜☀️","E-Diary/2023_11_04｜周六｜☀️","E-Diary/2023_11_03｜周五｜☔️","E-Diary/2023_11_02｜周四｜☀️","E-Diary/2023_11_01｜周三｜☀️","E-Diary/2023_10_31｜周二｜☀️","E-Diary/2023_10_30｜周一｜☀️","E-Diary/2023_10_29｜周日｜☀️","E-Diary/Osmo-Pocket-3｜2023_10_28｜周六｜☀️","E-Diary/Notion-可视化｜2023_10_27｜周五｜☔️","E-Diary/停电｜2023_10_26｜周四｜☔️","E-Diary/Notion-可视化｜2023_10_25｜周三｜☔️","E-Diary/2023_10_24｜周二｜☀️","E-Diary/Notion-Button-｜2023_10_23｜周一｜☀️","E-Diary/种花｜2023_10_22｜周日｜☀️","E-Diary/渐进式笔记｜2023_10_21｜周六｜☀️","E-Diary/自律｜2023_10_20｜周五｜☀️","E-Diary/生育｜2023_10_19｜周四｜☀️","E-Diary/Obsidian｜2023_10_18｜周三｜☔️","E-Diary/膝盖｜2023_10_17｜周二｜☀️","E-Diary/博物馆｜2023_10_16｜周一｜☀️","E-Diary/Obsidian-Git｜2023_10_15｜周日｜☀️","E-Diary/墨脱｜2023_10_14｜周六｜☀️","E-Diary/牙齿🦷｜2023_10_13｜周五｜☁️","E-Diary/The-Great-Divide｜2023_10_12｜周四｜☔️","E-Diary/Code-Review｜2023_10_11｜周三｜☔️","E-Diary/GIF、APNG、WebP｜2023_10_10｜周二｜☁️","E-Diary/codesandbox｜2023_10_09｜周一｜☔️","E-Diary/2023_10_08｜周日｜☀️","E-Diary/子弹笔记｜2023_10_07｜周六｜☀️","E-Diary/2023_10_06｜周五｜☔️","E-Diary/近视👓｜2023_10_05｜周四｜☔️","E-Diary/2023_10_04｜周三｜☔️","E-Diary/2023_10_03｜周二｜☔️","E-Diary/Obsidian入门指南｜2023_10_02｜周一｜☁️","E-Diary/Logseq｜2023_10_01｜周日｜☁️","E-Diary/2023_09_30｜周六｜☀️","E-Diary/《感恩日记》｜2023_09_29｜周五｜☁️","E-Diary/WaterMinder-｜2023_09_28｜周四｜☁️","E-Diary/Lighthouse｜2023_09_27｜周三｜☁️","E-Diary/Obsidian｜2023_09_26｜周二｜☁️","E-Diary/Loudly-Thinking-｜2023_09_25｜周一｜☔️","E-Diary/2023_09_24｜周日｜☔️","E-Diary/《今天也要重新出发》｜2023_09_23｜周六｜☔️","E-Diary/面试的四个层次｜2023_09_22｜周五｜☔️","E-Diary/电子爱好者｜2023_09_21｜周四｜🌧️","E-Diary/Apple-生态｜2023_09_20｜周三｜☔️","E-Diary/重新学习-scrollIntoview｜2023_09_19｜周二｜🌧️","E-Diary/国人为什么重男轻女！｜2023_09_18｜周一｜☀️","E-Diary/2023_09_17｜周日｜☀️","E-Diary/读书笔记📒｜2023_09_16｜周六｜☀️","E-Diary/Code-Review｜2023_09_15｜周五｜☀️","E-Diary/秋日🍂暖阳🌞｜2023_09_14｜周四｜☀️","E-Diary/早读冥写跑复记｜2023_09_13｜周三｜🌁","E-Diary/2023_09_12｜周二｜☁️","E-Diary/JavaScript里面的二进制｜2023_09_11｜🌧️｜周一","E-Diary/回家｜-2023_09_10｜周日｜☔️","E-Diary/全程备考规划｜2023_09_09｜周六｜☀️","E-Diary/连续200天｜2023_09_08｜周五｜☀️","E-Diary/混元大模型｜2023_09_07｜周四｜☀️","E-Diary/小玉壶｜2023_09_06｜周三｜☀️","E-Diary/2023_09_05｜周二｜☀️","E-Diary/2023_09_04｜周一｜☀️","E-Diary/搭建了个人图书馆和影院｜2023_09_03｜周日｜☀️","E-Diary/日🌞月🌛同辉｜2023_09_02｜周六｜☀️","E-Diary/开学了｜2023_09_01｜周五｜☀️","E-Diary/8月复盘-脚踏实地一步一个脚印👣","E-Diary/GTD（Get-Things-Done）｜2023_08_30｜周三｜☀️","E-Diary/《稻草人》｜2023_08_29｜周二｜☀️","E-Diary/冥想🧘｜2023_08_28｜周一｜☀️","E-Diary/前端性能优化｜2023_08_27｜周日｜☀️","E-Diary/glTF｜2023_08_26｜周六｜☔️","E-Diary/天亮变晚，天气变凉｜2023_08_25｜周五｜☁️","E-Diary/《黑客与画家》｜2023_08_24｜周四｜🌧️","E-Diary/写作｜2023_08_23｜周三｜☀️","E-Diary/致青春｜2023_08_22｜周二｜☀️","E-Diary/2023_08_21｜周一｜🌁","E-Diary/电子产品｜2023_08_20｜周日｜☀️","E-Diary/理发｜2023_08_19｜周六｜☀️","E-Diary/2023_08_18｜周五｜🌧️","E-Diary/不许动｜2023_08_17｜周四｜☀️","E-Diary/庄稼收割之后｜2023_08_16｜周三｜☀️","E-Diary/云彩上有没有住着神仙｜2023_08_15｜周二｜☀️","E-Diary/龙眼熟了｜2023_08_14｜周一｜☀️","E-Diary/植物🌳养护｜2023_08_13｜周日｜☀️","E-Diary/2023_08_12｜周六｜☀️","E-Diary/吃瓜｜2023_08_11｜周五｜☀️","E-Diary/好运书单｜2023_08_10｜周四｜☀️","E-Diary/好运书单｜2023_08_09｜周三｜☀️","E-Diary/博客搭建｜2023_08_08｜周二｜☀️","E-Diary/写作｜2023_08_07｜周一｜☀️","E-Diary/2023_08_06｜周日｜☔️","E-Diary/2023_08_05｜周六｜☀️","E-Diary/2023_08_04｜周五｜☀️","E-Diary/2023_08_03｜周四｜☀️","E-Diary/2023_08_02｜周三｜☀️","E-Diary/2023_08_01｜周二｜☔️","E-Diary/7月复盘-全力备考","E-Diary/2023_07_31｜周一｜☀️｜第二大脑","E-Diary/2023_07_30｜周日｜☀️","E-Diary/2023_07_29｜周六｜☀️","E-Diary/2023_07_28｜周五｜☀️","E-Diary/2023_07_27｜周四｜🌧️｜CSS-3D图片","E-Diary/2023_07_26｜周三｜☔️｜写日记","E-Diary/2023_07_25｜周二｜🌧️","E-Diary/2023_07_24｜周一｜🌧️","E-Diary/2023_07_23｜周日｜☀️","E-Diary/2023_07_22｜周六｜☀️","E-Diary/2023_07_21｜周五｜☀️","E-Diary/2023_07_20｜周四｜😨","E-Diary/2023_07_19｜周三｜☔️","E-Diary/2023_07_18｜周二｜☀️","E-Diary/2023_07_17｜周一｜☀️｜WebGL","E-Diary/2023_07_16｜周日｜☀️","E-Diary/2023_07_15｜周六｜☀️","E-Diary/2023_07_14｜周五｜☀️","E-Diary/2023_07_13｜周四｜😌｜安装空调","E-Diary/2023_07_12｜周三｜☀️","E-Diary/2023_07_11｜周二｜☀️","E-Diary/2023_07_10｜周一｜🥵｜自我管理","E-Diary/2023_07_09｜周日｜☀️","E-Diary/2023_07_08｜周六｜☀️","E-Diary/2023_07_07｜周五｜☀️","E-Diary/2023_07_06｜周四｜☀️｜开会了","E-Diary/2023_07_05｜周三｜☀️","E-Diary/2023_07_04｜周二｜☀️","E-Diary/2023_07_03｜周一｜🌧️","E-Diary/2023_07_02｜周日｜☀️","E-Diary/2023_07_01｜周六｜☀️","E-Diary/6月复盘-结束基础全面进入强化","E-Diary/2023_06_30｜周五｜☀️","E-Diary/2023_06_29｜周四｜☀️","E-Diary/2023_06_28｜周三｜☔️","E-Diary/2023_06_27｜周二｜🥵","E-Diary/2023_06_26｜周一｜🥵｜填志愿","E-Diary/2023_06_25｜周日｜☀️","E-Diary/2023_06_24｜周六｜☀️","E-Diary/2023_06_23｜周五｜☀️","E-Diary/2023_06_22｜周四｜☀️｜5000天后的世界","E-Diary/2023_06_21｜周三｜☔️","E-Diary/2023_06_20｜周二｜🌧️","E-Diary/2023_06_19｜周一｜☀️｜新增运动日志","E-Diary/2023_06_18｜周日｜☀️","E-Diary/2023_06_17｜周六｜☁️","E-Diary/2023_06_16｜周五｜☁️｜连续100天","E-Diary/2023_06_15｜周四｜☁️｜概率完成，基础结束","E-Diary/2023_06_14｜周三｜🌧️","E-Diary/2023_06_13｜周二｜☀️","E-Diary/2023_06_12｜周一｜☀️","E-Diary/2023_06_11｜周日｜☀️","E-Diary/2023_06_10｜周六｜☀️","E-Diary/2023_06_09｜周五｜☀️","E-Diary/2023_06_08｜周四｜☀️｜音视频","E-Diary/2023_06_07｜周三｜☀️","E-Diary/2023_06_06｜周二｜☀️","E-Diary/2023_06_05｜周一｜☁️","E-Diary/2023_06_04｜周日｜☁️","E-Diary/2023_06_03｜周六｜☔️","E-Diary/2023_06_02｜周五｜🌧️","E-Diary/2023_06_01｜周四｜☀️","E-Diary/5月复盘-渐渐进入正轨","E-Diary/2023_05_31｜周三｜⛈️｜开始概率","E-Diary/2023_05_30｜周二｜☀️｜线代完成","E-Diary/2023_05_29｜周一｜🌧️｜全程规划","E-Diary/2023_05_28｜周日｜☀️","E-Diary/2023_05_27｜周六｜☀️","E-Diary/2023_05_26｜周五｜☀️","E-Diary/2023_05_25｜周四｜☁️","E-Diary/2023_05_24｜周三｜☀️","E-Diary/2023_05_23｜周二｜☀️","E-Diary/2023_05_22｜周一｜☀️","E-Diary/2023_05_21｜周日｜☁️","E-Diary/2023_05_20｜周六｜🌧️","E-Diary/2023_05_19｜周五｜☁️｜Midjourney","E-Diary/2023_05_18｜周四｜🌧️","E-Diary/2023_05_17｜周三｜🌧️｜整理基本公式","E-Diary/2023_05_16｜周二｜☀️","E-Diary/2023_05_15｜周一｜☀️｜让子弹飞一会儿","E-Diary/2023_05_14｜周日｜☀️｜开始线代","E-Diary/2023_05_13｜周六｜☀️｜阅读如何改变我的命运","E-Diary/2023_05_12｜周五｜☀️｜科技爱好者周刊","E-Diary/2023_05_11｜周四｜☀️｜两个多月完成了高数学习","E-Diary/2023_05_10｜周三｜🌧️｜解锁Notion甘特图","E-Diary/2023_05_09｜周三｜🌧️｜寻找同路人","E-Diary/2023_05_08｜周一｜☀️｜电影推荐","E-Diary/2022_05_07｜周日｜🌧️｜五天爬五岳","E-Diary/2023_05_06｜周六｜☁️｜重庆扫街","E-Diary/2023_05_05｜周五｜⚡️","E-Diary/2023_05_04｜周四｜☀️｜完成无穷级数学习","E-Diary/2023_05_03｜周三｜☀️｜什么是我想要的生活！","E-Diary/2023_05_02｜周二｜☀️｜4月复盘","E-Diary/2023_05_01｜周一｜☀️｜存在","4月复盘-愿景不清，目标不明","E-Diary/2023-04-30｜周日｜☀️｜有一点失眠了","E-Diary/2023-04-29｜周六｜☀️｜设计封面-and-Git指令速查","E-Diary/2023-04-28｜周五｜☀️｜两周学完了多元积分学","E-Diary/2023-04-27｜周四｜☀️｜在线图形绘制工具","E-Diary/2023-04-26｜周三｜🌞｜前端学习资源整理","E-Diary/2023-04-25｜周二｜🌞｜浩瀚星空-and-《认知觉醒》","E-Diary/2023-04-24｜周一｜🌧️｜记单词-and-积分计算","E-Diary/2023-04-23｜周日｜🌧️｜世界读书日","E-Diary/2023-04-22｜周六｜🌧️｜休息♨️-and-《人生之路》看完","E-Diary/2023-04-21｜周五｜晴｜三重积分和第一型曲线积分-and-科技爱好者周刊","E-Diary/2022-04-20｜周四｜晴｜玫瑰花开了两朵-and-如何学习","E-Diary/2023-04-19｜周三｜晴｜二重积分-and-练字","E-Diary/2023-04-18｜周二｜小雨｜喂鸡-and-喂猪-and-扫圈","E-Diary/2023-04-17｜周一｜小雨｜完成多元微分学","E-Diary/2023-04-16｜周日｜晴｜夏天快到了","E-Diary/2023-04-15｜周六｜晴｜休息-and-督促外婆洗澡-and-跑步","E-Diary/2023-04-14｜周五｜晴｜程璧-and-时来运转","E-Diary/2023-04-13｜周四｜晴｜葡萄藤🍇","E-Diary/2023-04-12｜周三｜阴天｜聊小说","E-Diary/2023-04-11｜周二｜雷雨｜下雨天，好入眠","E-Diary/2023-04-10｜周一｜瓢泼大雨｜专注的完成了计划，解决微分法问题","E-Diary/2023-04-09｜周日｜晴｜事故留存和家庭保障整理","E-Diary/2023-04-08｜周六｜晴｜打印了手译本，开始做真题","E-Diary/2023-04-07｜周五｜晴｜学习了LaTex，很有成就感","E-Diary/2023-04-05｜周三｜晴｜有些过度反思了","E-Diary/2023-04-04｜周二｜晴｜进步本（成功日记）","E-Diary/2023-04-03｜周一｜晴｜一缕曙光","E-Diary/2023-04-02｜周日｜晴｜科技感","E-Diary/2023-04-01｜周六｜晴｜有所成长","E-Diary/2023-03-30｜周四｜晴｜挑战自我","E-Diary/2023-03-29｜周三｜小雨｜丰富多彩的一天","E-Diary/2023-03-28｜周二｜阴天｜情绪波动有点大","E-Diary/2023-03-27｜周一｜小雨｜充满干劲的一天","E-Diary/2023-03-26｜周日｜阴天｜稀松平常的一天","E-Diary/2023-03-25｜周六｜阴天｜认识了书友","E-Diary/2023-03-24｜周五｜阴天｜完成情况还算不错","E-Diary/2023-03-23｜周四｜小雨｜渐渐恢复状态","E-Diary/2023-03-22｜周三｜晴｜颓废且懈怠的一天","E-Diary/2023-03-21｜周二｜晴｜去爬山⛰️","E-Diary/2023-03-20｜周一｜晴｜😊","E-Diary/2023-03-19｜周日｜晴｜😔","E-Diary/2023-03-18｜周六｜小雨｜😝","E-Diary/2023-03-17｜周五｜晴｜😊","E-Diary/2023-03-16｜周四｜晴｜😊","E-Diary/2023-03-15｜周三｜阴｜😊","E-Diary/2023-03-14｜周二｜晴｜😄","E-Diary/2023-03-13｜周一｜晴｜😄","E-Diary/2023-03-12｜周日｜小雨｜一般","E-Diary/2023-03-11｜周六｜晴｜😊","E-Diary/2023-03-10｜周五｜晴｜😊","E-Diary/2023-03-09｜周四｜晴｜😄"],"tags":["Logs/日记"],"content":"2024 年\n4 月\n2024_04_22｜星期一\n2 月\n2024_02_25｜星期日\n2024_02_19｜星期一\n1 月\n月中\n2024_01_20｜周六｜☔️\n2024_01_19｜周五｜☀️\n防抖和节流｜2024_01_17｜周三｜☀️\n2024_01_15｜周一｜☀️\n2024_01_14｜周日｜☀️\n2024_01_13｜周六｜☀️\n2024_01_12｜周五｜☀️\n2024_01_11｜周四｜☀️\n月初\n域名备案通过｜2024_01_10｜周三｜☀️\n2024_01_09｜周二｜☀️\n2024_01_07｜周日｜☀️\n2024_01_05｜周五｜🌁\n2024_01_04｜周四｜☁️\n2024_01_03｜周三｜☁️\n2023年\n12 月\n月初\n2023_12_10｜周日｜☀️\n2023_12_09｜周六｜☀️\n2023_12_08｜周五｜☀️\n2023_12_07｜周四｜🌁\n2023_12_06｜周三｜☀️\n2023_12_05｜周二｜🌁\n2023_12_04｜周一｜☁️\n2023_12_03｜周日｜☁️\n2023_12_02｜周六｜🌧️\n2023_12_01｜周五｜☔️\n11 月\n月末\n2023_11_30｜周日｜☔️\n2023_11_29｜周三｜☀️\n2023_11_28｜周二｜☀️\n2023_11_27｜周一｜☀️\n2023_11_26｜周日｜☀️\n2023_11_25｜周六｜☀️\n2023_11_24｜周五｜☀️\n2023_11_23｜周四｜☀️\n2023_11_22｜周三｜☀️\n2023_11_21｜周二｜☀️\n月中\n2023_11_20｜周一｜☀️\n2023_11_19｜周日｜☀️\n2023_11_18｜周六｜☀️\n2023_11_17｜周五｜☀️\n2023_11_16｜周四｜☀️\n2023_11_15｜周三｜🌁\n⛩️｜2023_11_14｜周二｜☔️\n2023_11_13｜周一｜🌧️\n2023_11_12｜周日｜🌧️\n2023_11_11｜周六｜☔️\n月初\n2023_11_10｜周五｜☀️\n语雀悬浮胶囊｜2023_11_09｜周四｜☀️\n2023_11_08｜周三｜☀️\n2023_11_07｜周二｜☀️\n2023_11_06｜周一｜☀️\n2023_11_05｜周日｜☀️\n2023_11_04｜周六｜☀️\n2023_11_03｜周五｜☔️\n2023_11_02｜周四｜☀️\n2023_11_01｜周三｜☀️\n10月\n月末\n2023_10_31｜周二｜☀️\n2023_10_30｜周一｜☀️\n2023_10_29｜周日｜☀️\nOsmo Pocket 3｜2023_10_28｜周六｜☀️\nNotion 可视化｜2023_10_27｜周五｜☔️\n停电｜2023_10_26｜周四｜☔️\nNotion 可视化｜2023_10_25｜周三｜☔️\n2023_10_24｜周二｜☀️\nNotion Button ｜2023_10_23｜周一｜☀️\n种花｜2023_10_22｜周日｜☀️\n渐进式笔记｜2023_10_21｜周六｜☀️\n月中\n自律｜2023_10_20｜周五｜☀️\n生育｜2023_10_19｜周四｜☀️\nObsidian｜2023_10_18｜周三｜☔️\n膝盖｜2023_10_17｜周二｜☀️\n博物馆｜2023_10_16｜周一｜☀️\nObsidian-Git｜2023_10_15｜周日｜☀️\n墨脱｜2023_10_14｜周六｜☀️\n牙齿🦷｜2023_10_13｜周五｜☁️\nThe Great Divide｜2023_10_12｜周四｜☔️\nCode Review｜2023_10_11｜周三｜☔️\n月初\nGIF、APNG、WebP｜2023_10_10｜周二｜☁️\ncodesandbox｜2023_10_09｜周一｜☔️\n2023_10_08｜周日｜☀️\n子弹笔记｜2023_10_07｜周六｜☀️\n2023_10_06｜周五｜☔️\n近视👓｜2023_10_05｜周四｜☔️\n2023_10_04｜周三｜☔️\n2023_10_03｜周二｜☔️\nObsidian入门指南｜2023_10_02｜周一｜☁️\nLogseq｜2023_10_01｜周日｜☁️\n9 月\n月末\n2023_09_30｜周六｜☀️\n《感恩日记》｜2023_09_29｜周五｜☁️\nWaterMinder ｜2023_09_28｜周四｜☁️\nLighthouse｜2023_09_27｜周三｜☁️\nObsidian｜2023_09_26｜周二｜☁️\nLoudly Thinking ｜2023_09_25｜周一｜☔️\n2023_09_24｜周日｜☔️\n《今天也要重新出发》｜2023_09_23｜周六｜☔️\n面试的四个层次｜2023_09_22｜周五｜☔️\n电子爱好者｜2023_09_21｜周四｜🌧️\n月中\nApple 生态｜2023_09_20｜周三｜☔️\n重新学习 scrollIntoview｜2023_09_19｜周二｜🌧️\n国人为什么重男轻女！｜2023_09_18｜周一｜☀️\n2023_09_17｜周日｜☀️\n读书笔记📒｜2023_09_16｜周六｜☀️\nCode Review｜2023_09_15｜周五｜☀️\n秋日🍂暖阳🌞｜2023_09_14｜周四｜☀️\n早读冥写跑复记｜2023_09_13｜周三｜🌁\n2023_09_12｜周二｜☁️\nJavaScript里面的二进制｜2023_09_11｜🌧️｜周一\n月初\n回家｜ 2023_09_10｜周日｜☔️\n全程备考规划｜2023_09_09｜周六｜☀️\n连续200天｜2023_09_08｜周五｜☀️\n混元大模型｜2023_09_07｜周四｜☀️\n小玉壶｜2023_09_06｜周三｜☀️\n2023_09_05｜周二｜☀️\n2023_09_04｜周一｜☀️\n搭建了个人图书馆和影院｜2023_09_03｜周日｜☀️\n日🌞月🌛同辉｜2023_09_02｜周六｜☀️\n开学了｜2023_09_01｜周五｜☀️\n8月复盘-脚踏实地一步一个脚印👣\n月末\nGTD（Get Things Done）｜2023_08_30｜周三｜☀️\n《稻草人》｜2023_08_29｜周二｜☀️\n冥想🧘｜2023_08_28｜周一｜☀️\n前端性能优化｜2023_08_27｜周日｜☀️\nglTF｜2023_08_26｜周六｜☔️\n天亮变晚，天气变凉｜2023_08_25｜周五｜☁️\n《黑客与画家》｜2023_08_24｜周四｜🌧️\n写作｜2023_08_23｜周三｜☀️\n致青春｜2023_08_22｜周二｜☀️\n2023_08_21｜周一｜🌁\n月中\n电子产品｜2023_08_20｜周日｜☀️\n理发｜2023_08_19｜周六｜☀️\n2023_08_18｜周五｜🌧️\n不许动｜2023_08_17｜周四｜☀️\n庄稼收割之后｜2023_08_16｜周三｜☀️\n云彩上有没有住着神仙｜2023_08_15｜周二｜☀️\n龙眼熟了｜2023_08_14｜周一｜☀️\n植物🌳养护｜2023_08_13｜周日｜☀️\n2023_08_12｜周六｜☀️\n吃瓜｜2023_08_11｜周五｜☀️\n月初\n好运书单｜2023_08_10｜周四｜☀️\n好运书单｜2023_08_09｜周三｜☀️\n博客搭建｜2023_08_08｜周二｜☀️\n写作｜2023_08_07｜周一｜☀️\n2023_08_06｜周日｜☔️\n2023_08_05｜周六｜☀️\n2023_08_04｜周五｜☀️\n2023_08_03｜周四｜☀️\n2023_08_02｜周三｜☀️\n2023_08_01｜周二｜☔️\n7月复盘-全力备考\n月末\n2023_07_31｜周一｜☀️｜第二大脑\n2023_07_30｜周日｜☀️\n2023_07_29｜周六｜☀️\n2023_07_28｜周五｜☀️\n2023_07_27｜周四｜🌧️｜CSS 3D图片\n2023_07_26｜周三｜☔️｜写日记\n2023_07_25｜周二｜🌧️\n2023_07_24｜周一｜🌧️\n2023_07_23｜周日｜☀️\n2023_07_22｜周六｜☀️\n2023_07_21｜周五｜☀️\n月中\n2023_07_20｜周四｜😨\n2023_07_19｜周三｜☔️\n2023_07_18｜周二｜☀️\n2023_07_17｜周一｜☀️｜WebGL\n2023_07_16｜周日｜☀️\n2023_07_15｜周六｜☀️\n2023_07_14｜周五｜☀️\n2023_07_13｜周四｜😌｜安装空调\n2023_07_12｜周三｜☀️\n2023_07_11｜周二｜☀️\n月初\n2023_07_10｜周一｜🥵｜自我管理\n2023_07_09｜周日｜☀️\n2023_07_08｜周六｜☀️\n2023_07_07｜周五｜☀️\n2023_07_06｜周四｜☀️｜开会了\n2023_07_05｜周三｜☀️\n2023_07_04｜周二｜☀️\n2023_07_03｜周一｜🌧️\n2023_07_02｜周日｜☀️\n2023_07_01｜周六｜☀️\n6月复盘-结束基础全面进入强化\n月末\n2023_06_30｜周五｜☀️\n2023_06_29｜周四｜☀️\n2023_06_28｜周三｜☔️\n2023_06_27｜周二｜🥵\n2023_06_26｜周一｜🥵｜填志愿\n2023_06_25｜周日｜☀️\n2023_06_24｜周六｜☀️\n2023_06_23｜周五｜☀️\n2023_06_22｜周四｜☀️｜5000天后的世界\n2023_06_21｜周三｜☔️\n月中\n2023_06_20｜周二｜🌧️\n2023_06_19｜周一｜☀️｜新增运动日志\n2023_06_18｜周日｜☀️\n2023_06_17｜周六｜☁️\n2023_06_16｜周五｜☁️｜连续100天\n2023_06_15｜周四｜☁️｜概率完成，基础结束\n2023_06_14｜周三｜🌧️\n2023_06_13｜周二｜☀️\n2023_06_12｜周一｜☀️\n2023_06_11｜周日｜☀️\n月初\n2023_06_10｜周六｜☀️\n2023_06_09｜周五｜☀️\n2023_06_08｜周四｜☀️｜音视频\n2023_06_07｜周三｜☀️\n2023_06_06｜周二｜☀️\n2023_06_05｜周一｜☁️\n2023_06_04｜周日｜☁️\n2023_06_03｜周六｜☔️\n2023_06_02｜周五｜🌧️\n2023_06_01｜周四｜☀️\n5月复盘-渐渐进入正轨\n2023_05_31｜周三｜⛈️｜开始概率\n2023_05_30｜周二｜☀️｜线代完成\n2023_05_29｜周一｜🌧️｜全程规划\n2023_05_28｜周日｜☀️\n2023_05_27｜周六｜☀️\n2023_05_26｜周五｜☀️\n2023_05_25｜周四｜☁️\n2023_05_24｜周三｜☀️\n2023_05_23｜周二｜☀️\n2023_05_22｜周一｜☀️\n2023_05_21｜周日｜☁️\n2023_05_20｜周六｜🌧️\n2023_05_19｜周五｜☁️｜Midjourney\n2023_05_18｜周四｜🌧️\n2023_05_17｜周三｜🌧️｜整理基本公式\n2023_05_16｜周二｜☀️\n2023_05_15｜周一｜☀️｜让子弹飞一会儿\n2023_05_14｜周日｜☀️｜开始线代\n2023_05_13｜周六｜☀️｜阅读如何改变我的命运\n2023_05_12｜周五｜☀️｜科技爱好者周刊\n2023_05_11｜周四｜☀️｜两个多月完成了高数学习\n2023_05_10｜周三｜🌧️｜解锁Notion甘特图\n2023_05_09｜周三｜🌧️｜寻找同路人\n2023_05_08｜周一｜☀️｜电影推荐\n2022_05_07｜周日｜🌧️｜五天爬五岳\n2023_05_06｜周六｜☁️｜重庆扫街\n2023_05_05｜周五｜⚡️\n2023_05_04｜周四｜☀️｜完成无穷级数学习\n2023_05_03｜周三｜☀️｜什么是我想要的生活！\n2023_05_02｜周二｜☀️｜4月复盘\n2023_05_01｜周一｜☀️｜存在\n4月复盘-愿景不清，目标不明\n2023-04-30｜周日｜☀️｜有一点失眠了\n2023-04-29｜周六｜☀️｜设计封面&amp;Git指令速查\n2023-04-28｜周五｜☀️｜两周学完了多元积分学\n2023-04-27｜周四｜☀️｜在线图形绘制工具\n2023-04-26｜周三｜🌞｜前端学习资源整理\n2023-04-25｜周二｜🌞｜浩瀚星空&amp;《认知觉醒》\n2023-04-24｜周一｜🌧️｜记单词&amp;积分计算\n2023-04-23｜周日｜🌧️｜世界读书日\n2023-04-22｜周六｜🌧️｜休息♨️&amp;《人生之路》看完\n2023-04-21｜周五｜晴｜三重积分和第一型曲线积分&amp;科技爱好者周刊\n2022-04-20｜周四｜晴｜玫瑰花开了两朵&amp;如何学习\n2023-04-19｜周三｜晴｜二重积分&amp;练字\n2023-04-18｜周二｜小雨｜喂鸡&amp;喂猪&amp;扫圈\n2023-04-17｜周一｜小雨｜完成多元微分学\n2023-04-16｜周日｜晴｜夏天快到了\n2023-04-15｜周六｜晴｜休息&amp;督促外婆洗澡&amp;跑步\n2023-04-14｜周五｜晴｜程璧&amp;时来运转\n2023-04-13｜周四｜晴｜葡萄藤🍇\n2023-04-12｜周三｜阴天｜聊小说\n2023-04-11｜周二｜雷雨｜下雨天，好入眠\n2023-04-10｜周一｜瓢泼大雨｜专注的完成了计划，解决微分法问题\n2023-04-09｜周日｜晴｜事故留存和家庭保障整理\n2023-04-08｜周六｜晴｜打印了手译本，开始做真题\n2023-04-07｜周五｜晴｜学习了LaTex，很有成就感\n2023-04-05｜周三｜晴｜有些过度反思了\n2023-04-04｜周二｜晴｜进步本（成功日记）\n2023-04-03｜周一｜晴｜一缕曙光\n2023-04-02｜周日｜晴｜科技感\n2023-04-01｜周六｜晴｜有所成长\n3 月\n2023-03-30｜周四｜晴｜挑战自我\n2023-03-29｜周三｜小雨｜丰富多彩的一天\n2023-03-28｜周二｜阴天｜情绪波动有点大\n2023-03-27｜周一｜小雨｜充满干劲的一天\n2023-03-26｜周日｜阴天｜稀松平常的一天\n2023-03-25｜周六｜阴天｜认识了书友\n2023-03-24｜周五｜阴天｜完成情况还算不错\n2023-03-23｜周四｜小雨｜渐渐恢复状态\n2023-03-22｜周三｜晴｜颓废且懈怠的一天\n2023-03-21｜周二｜晴｜去爬山⛰️\n2023-03-20｜周一｜晴｜😊\n2023-03-19｜周日｜晴｜😔\n2023-03-18｜周六｜小雨｜😝\n2023-03-17｜周五｜晴｜😊\n2023-03-16｜周四｜晴｜😊\n2023-03-15｜周三｜阴｜😊\n2023-03-14｜周二｜晴｜😄\n2023-03-13｜周一｜晴｜😄\n2023-03-12｜周日｜小雨｜一般\n2023-03-11｜周六｜晴｜😊\n2023-03-10｜周五｜晴｜😊\n2023-03-09｜周四｜晴｜😄"},"C-Knowledge/前端/dev-box":{"title":"dev-box","links":[],"tags":["编程/个人项目/dev-box"],"content":""},"C-Knowledge/前端/个人项目":{"title":"个人项目","links":["C-Knowledge/前端/dev-box","C-Knowledge/前端/博客/leancloud","C-Knowledge/前端/博客/个人博客"],"tags":["编程/个人项目"],"content":"\n开发宝盒： github.com/songxingguo/dev-box\n个人主页： github.com/songxingguo/hi\n\n预览地址： www.songxingguo.com/ \nleancloud:  leancloud\n性能报告：\n\n\n个人简历： github.com/songxingguo/resume\n\n预览地址：resume.songxingguo.com/\n性能报告：\n\n\n个人博客： github.com/songxingguo/songxingguo.github.io\n\n预览地址：blog.songxingguo.com/\n性能报告：\n\n\n第二大脑（本地）： github.com/songxingguo/second-brain\n第二大脑:  github.com/songxingguo/brain\n\n在线地址](brain.songxingguo.com/)\n\n\n数字花园： github.com/songxingguo/garden\n\n在线地址\n\n\n"},"C-Knowledge/前端/什么是链式调用！":{"title":"什么是链式调用！","links":["C-Knowledge/前端/链式调用等待方法","Web-Clip/@JS函数链式调用的几种方式---掘金","C-Knowledge/前端/技术书籍/ES6-入门教程/Generator-函数的语法"],"tags":["编程/思想"],"content":"链式操作的结构\n\n链式对象：能够进行链式操作的对象\n链式方法：链式对象上能进行链式操作的方法\n链式数据：链式操作最终想要获得结果是通过被操作数据\n\n链式对象\n原理：在构造函数中创建方法时，return this 返回当前调用方法的对象，可以实现链式调用方法。\nlet f = {\n  name: &#039;dell&#039;,\n  sayHi: function () {\n    console.log(`hello, my name is ${this.name}`)\n    return this\n  },\n  sayBye: function () {\n    console.log(`byebye~~~~`)\n    return this\n  }\n}\nf.sayHi().sayBye()\n链式方法\nfunction numsChain(num){\n    var nums = num;\n    function chain(num){\n        nums = `${nums} -&gt; ${num}`;\n        return chain;\n    }\n    chain.get = () =&gt; nums;\n    return chain;\n}\nvar des = numsChain(1)(2)(3).get();\nconsole.log(des); // 1 -&gt; 2 -&gt; 3\n链式数据\nvar pipe = function (value) {\n  var funcStack = [];\n  var oproxy = new Proxy({} , {\n    get : function (pipeObject, fnName) {\n      if (fnName === &#039;get&#039;) {\n        return funcStack.reduce(function (val, fn) {\n          return fn(val);\n        },value);\n      }\n      funcStack.push(window[fnName]);\n      return oproxy;\n    }\n  });\n \n  return oproxy;\n}\n \nvar double = n =&gt; n * 2;\nvar pow    = n =&gt; n * n;\nvar reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;\n \npipe(3).double.pow.reverseInt.get; // 63\n上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。\n扩展阅读\n\n链式调用等待方法\n@JS函数链式调用的几种方式 - 掘金\nJavaScript 有多灵活？\nJavascript异步编程的4种方法\nGenerator 函数的语法\n"},"C-Knowledge/前端/博客/giscus：Discussions-功能集成":{"title":"giscus：Discussions 功能集成","links":[],"tags":["场景/博客"],"content":"选择 giscus 连接到的仓库。请确保：\n\n该仓库是公开的，否则访客将无法查看 discussion。\ngiscus app 已安装，否则访客将无法评论和回应。\nDiscussions 功能已在你的仓库中启用。\n"},"C-Knowledge/前端/博客/obsidian-quartz：石英":{"title":"obsidian-quartz：石英","links":["RSS订阅","C-Knowledge/前端/开发工具/服务器/Nginx","D-Unsorted/COS-自建静态网站"],"tags":["Apps/Obsidian"],"content":"布局\nexport interface FullPageLayout {\n  head: QuartzComponent // single component\n  header: QuartzComponent[] // laid out horizontally\n  beforeBody: QuartzComponent[] // laid out vertically\n  pageBody: QuartzComponent // single component\n  left: QuartzComponent[] // vertical on desktop, horizontal on mobile\n  right: QuartzComponent[] // vertical on desktop, horizontal on mobile\n  footer: QuartzComponent // single component\n}\n\n功能列表\nWikilinks： 双向链接\n语法\n\n[[Path to file]] ：生成指向 Path to file.md （或 Path-to-file.md ）的链接，其中包含文本 Path to file\n[[Path to file | Here&#039;s the title override]] ：生成指向 Path to file.md 文本 Here&#039;s the title override 的链接\n[[Path to file#anchor|Anchor]] ：生成指向文件中 Path to file.md 锚点 Anchor 的链接\n[[Path to file#^block-ref|^block-ref]] ：生成指向文件中 Path to file.md 特定块 block-ref 的链接\n\n 嵌入\n\n![[Path to image]] ：将图像嵌入到页面中\n![[Path to image|100x145]] ：将尺寸为 100 像素 x 145 像素的图像嵌入到页面中\n![[Path to file]] ：包含整个页面\n![[Path to file#anchor|Anchor]] ：包含标题 Anchor 下的所有内容\n![[Path to file#^b15695|^b15695]] ：具有 ID ^b15695 的嵌入块\n\nPopover Previews ：双向链接预览\n原理是通过 popover-hint 类来选中所有 HTML 元素来实现。\n图片双向链接也可以做为提示框实现预览。\n自定义配置。\n\n删除 popovers: 在 quartz.config.ts 中设置 enablePopovers 为 false。\n样式: quartz/components/styles/popover.scss\n脚本: quartz/components/scripts/popover.inline.ts\n\nRecent Notes：最近的笔记\n在 quartz. layout. ts 文件中配置，  Component.RecentNotes 。\nPrivate Pages： 页面私有化\nGraph View：关系图谱\nExplorer： 资源管理器\nQuartz 具有一个资源管理器，可让您浏览网站上的所有文件和文件夹。它支持嵌套文件夹，并且高度可定制。\nCallouts： 提示语法\nBacklinks： 反向链接\nRSS Feed：RSS订阅\nLaTeX： LaTeX 语法\nMermaid Diagrams： 绘图\nFull-text Search:  全局搜索\n\n ⌘ / ctrl + K：搜索文章内容，自定义为 ⌘ / ctrl + O。\n⌘ / ctrl + shift + K：搜索标签，⌘ / ctrl + shift + O。\nTab and Shift+Tab： 切换搜索结果，也可以使用 ArrowUp and ArrowDown。\n\n\n\n                  \n                  注意❗ \n                  \n                \n搜索要求配置中存在 ContentIndex emitter 插件.\n\n自定义配：\n\n删除搜索：删除 from quartz.layout.ts 的所有 Component.Search() 用法。\n 组件： quartz/components/Search.tsx\n 样式： quartz/components/styles/search.scss\n 脚本： quartz/components/scripts/search.inline.ts\n您可以编辑 contextWindowWords ， numSearchResults 或 numTagResults 根据您的需要\n\nDocker Support： Docker 支持\n插件列表\nContentIndex： 生成 html 。\nFlexsearch： 全文本搜索，10 ms 能搜索 500 万字。\n组件列表\n\n案例展示\n\nQuartz Documentation (this site!)\nJacky Zhao’s Garden\n\n\n\nSocratica Toolbox\n\n\n\noldwinter の数字花园\nAaron Pham’s Garden\n\n\n\nThe Quantum Garden\n\n\n\n\nAbhijeet’s Math Wiki\nMatt Dunn’s Second Brain\n\n\n\nPelayo Arbues’ Notes\n\n\n\nVince Imbat’s Talahardin\n\n\n\n🧠🌳 Chad’s Mind Garden\n\n\n\nPedro MC Fernandes’s Topo da Mente\n\n\n\nMau Camargo’s Notkesto\n\n\n\nCaicai’s Novels\n\n\n\n🌊 Collapsed Wave\n\n\n\nSideny’s 3D Artist’s Handbook\n\n\n\nMike’s AI Garden 🤖🪴\n\n\n\nBrandon Boswell’s Garden\n\n\n\nScaling Synthesis - A hypertext research notebook\n\n\n\nData Dictionary 🧠\n\n\n\nsspaeti.com’s Second Brain\n\n\n\n🪴Aster’s notebook\n\n\n\n🥷🏻🌳🍃 Computer Science &amp; Thinkering Garden\n\n\n常见问题\nQuartz 生成的链接不包含 .html 扩展\n将 public 目录复制到 Web 服务器，并将其配置为提供文件。您可以使用任何 Web 服务器来托管您的站点。由于 Quartz 生成的链接不包含 .html 扩展，因此您需要让您的 Web 服务器知道如何处理它。\n 使用 Nginx\n下面是如何使用 Nginx 执行此操作的示例：\nnginx.conf\nserver {\n    listen 80;\n    server_name example.com;\n    root /path/to/quartz/public;\n    index index.html;\n    error_page 404 /404.html;\n \n    location / {\n        try_files $uri $uri.html $uri/ =404;\n    }\n}\n腾讯云服务器开启忽略  .html\n"},"C-Knowledge/前端/博客/个人博客":{"title":"个人博客","links":["C-Knowledge/前端/博客/图床","C-Knowledge/前端/博客/gitalk","C-Knowledge/前端/博客/giscus：Discussions-功能集成","C-Knowledge/学习进化/公众号","C-Knowledge/前端/博客/leancloud","C-Knowledge/前端/开发技术/Git/Github静态博客部署到-Coding"],"tags":["场景/博客"],"content":"图床\n\n图床\n\n评论\n\ngitalk\ngiscus：Discussions 功能集成\n\n其他\n\n公众号\nleancloud\nGithub静态博客部署到 Coding\n"},"C-Knowledge/前端/开发工具/Apple/Mac-常用-Apps":{"title":"Mac-常用 Apps","links":["D-Unsorted/Notion","D-Unsorted/Obsidian","D-Unsorted/Numbers常用语法","D-Unsorted/Lightroom","D-Unsorted/OmniGraffle","D-Unsorted/WPS","D-Unsorted/Toggle-Track","D-Unsorted/滴答清单","C-Knowledge/前端/开发工具/Apple/Zotero"],"tags":["场景/Apple"],"content":"\nLaTeXiT\nduf\n\n磁盘空间占用统计工具，支持 Linux 和 MacOS。\npap.er\n\n一个 Mac 电脑的桌面应用，每天获取来自全球的新鲜精美壁纸\ndynamicwallpaper\n动态壁纸\nBing Wallpaper\n\n这个项目使用 GitHub Actions，收集 Bing 搜索引擎每天的壁纸，提供下载，详见这篇说明文章。\nFlameDisk\n\nMacOS 应用，通过火焰图，进行磁盘可视化分析和清理。\n其他软件\n\n欧路词典:  单词翻译\nCubox： 网页收藏\nNotion\nObsidian\nNumbers常用语法\nLightroom\nOmniGraffle\nWPS\nToggle Track\nMOZE 3.0: 记账软件\n滴答清单\nZotero\n"},"C-Knowledge/前端/开发工具/Apple/Zotero-Obsidian-Citations":{"title":"Zotero Obsidian Citations","links":["Web-Clip/@obsidian和zotero连用（Citation插件介绍）-_-软通达"],"tags":["Apps/Obsidian"],"content":"\n数据路径配置\n\n\n自动更新配置文件\n\n\n模版配置\n\n\n扩展阅读\n\n视频地址\nobsidian-citation-plugin\n配置文件\n@obsidian和zotero连用（Citation插件介绍） _ 软通达\n"},"C-Knowledge/前端/开发工具/Apple/Zotero":{"title":"Zotero","links":["C-Knowledge/前端/开发工具/Apple/zotlit","C-Knowledge/前端/开发工具/Apple/Zotero-Obsidian-Citations"],"tags":["Apps"],"content":"入门\n数据与文件的同步\n数据的同步指 条目字段信息、批注、笔记 的同步，这些数据仅能通过 Zotero 官方提供的服务同步。\n\n\n文件的同步指 PDF 附件、网页附件、Word 文档、EPub 文件 等所有附件的同步。这些文件既可以通过 Zotero 官方服务同步，也可以通过 WebDAV 网盘来同步。\n目前国内支持 WebDAV 同步的只有坚果云网盘，常见的如百度网盘、阿里云盘、OneDrive 等均不支持 WebDAV 同步。后续教程将以坚果云网盘为例。\n坚果云免费用户具有以下限制：\n\n\n流量与空间限制：每月上传流量 1G/月、下载流量 3G/月、空间受限于上传流量，\n\n\n文件上传大小限制：当前 WebDAV 客户端和网页端上传大小的限制是一致的，默认为 500M（私有云可以通过相关设置调整）。\n\n\n访问频率限制：由于 WebDAV 协议比较占用系统资源，免费版用户限制访问频率为每 30 分钟不超过 600 次请求。付费用户限制访问频率为每 30 分钟不超过 1500 次请求。\n\n\n当然对于大部分用户免费账户是完全够用的（虽然每个月只有 1g 上传流量，但是好处是每个月都可以有 1g，一年最多可以拥有 12g）。对于小部分用户，可通过付费购买专业版open in new window或者使用其他支持 WebDAV 同步的网盘。\n\n选择安全选项，下滑到底，点击添加应用。\n\n\n\n打开 Zotero，编辑——设置——同步——文件同步，使用 Zotero 改成 WebDAV，并填写你的坚果云的服务器地址：dav.jianguoyun.com/dav。  用户名是坚果云账号，密码是上一步中的应用密码（非坚果云账号登录密码），设置好后点击 Verify Server 即可。\n\n\n\n回到首页，点击右边的绿色的圈就可以同步更新，如果是第一次设置，会提示在坚果云里自动创建一个名叫 Zotero 的文件夹，用于存放同步更新的文件。\n\n\n数据文件位置\n\n查找 Zotero 数据的最简单、最可靠的方法是单击 Zotero 设置 的 高级 选项卡中的 显示数据目录 按钮。这将始终显示当前正在使用的数据目录，并且是查找数据目录的推荐方法。\n如果您无法访问 Zotero 设置，搜索文件名zotero.sqlite也可以帮助您找到 Zotero 数据目录。\n插件\n\nzotlit\nZotero Integration\nmdnotes\n\ngithub 地址\n\n\nZotero Obsidian Citations:\nzotero-better-bibtex \n"},"C-Knowledge/前端/开发工具/Apple/zotlit":{"title":"zotlit","links":[],"tags":["Apps/Obsidian","编程"],"content":"\nObsidian+Zotero，实现文献笔记一体化\nobsidian读取zotero笔记并跳转（obsdian-zotero插件介绍）\n"},"C-Knowledge/前端/开发工具/OS/Windows命名要求":{"title":"Windows命名要求","links":[],"tags":["Apps/Windows","编程/Git"],"content":"不能出现以下字符：\nindows文件名或文件夹名中不能出现以下字符：\n\\、/、:、*、?、&quot;、&lt;、&gt;、| 。\n\nwindows、mac系统文件（夹）名称非法字符检测-正则表达式\nlet reg = /[\\\\\\\\/:*?\\&quot;&lt;&gt;|]/img; //  eslint-disable-line\nlet value = &#039;你&lt;&lt;好&gt;&gt;\\我/好*大*家|好&#039;;\n// 使用 startsWith 检测字符是否以 . 开头\nif(value.startsWith(&#039;.&#039;)) console.log(&#039;不能以 ‘.’ 字符开头！&#039;);\nlet aMatch = value.match(reg); // [&#039;&lt;&#039;, &#039;&lt;&#039;, &#039;&gt;&#039;, &#039;&gt;&#039;, &#039;/&#039;, &#039;*&#039;, &#039;*&#039;, &#039;|&#039;]\nlet aLimit = [...new Set(aMatch)]; // [&#039;&lt;&#039;, &#039;&gt;&#039;, &#039;/&#039;, &#039;*&#039;, &#039;|&#039;]\nconsole.log(`不能输入 ${aLimit .join(&#039; &#039;)} 特殊字符哦`); // 不能输入 &lt; &gt; / * | 特殊字符哦\n扩展阅读\n\n[[Git问题#githubgit-checkout-returns-error-invalid-path-on-windows|github/git Checkout Returns &#039;error invalid path&#039; on Windows]]\n"},"C-Knowledge/前端/开发工具/开发工具":{"title":"开发工具","links":["推荐两个CSS生成器，专治各种不规则形状，建议收藏","C-Knowledge/前端/开发工具/json-server","D-Unsorted/hoppscotch","E-Day-planner/2024/三月/前端调试工具超全汇总，效率翻倍！"],"tags":["场景/工具"],"content":"技术选型\n\ncaniuse :  用于查询前端属性各大浏览器是否支持\n\ncaniuse.com/\n\n\n编辑器插件 : www.tabnine.com/\nJavascript 库 CDN : www.bootcdn.cn/\n\n文档编写\n在线代码展示\n\n码上掘金 ： code.juejin.cn/\n偏视觉、偏交互效果的在线演示\n\ncodepen.io/\njsfiddle.net/\n\n\nJs 代码运行： jsbin.com/ ,output\n运行代码依赖于框架或环境 ： codesandbox.io/\n在线调试： runkit.com/home\n在线编码： stackblitz.com/\n\nAPI 文档\n\nSwagger： 编写在线 API 文档\nvue-styleguidist：UI 文档\n\n代码\n\n在线格式化 playground\n漂亮的代码截图：\n\nray.so/\n\n\n\n\ncarbon.now.sh/\n\n\n\n\ncodecopy： 在线格式化和发布代码\n\n\n\n绘图工具\n\n在线画图\n\napp.diagrams.net/\n\n\n在线做图\n\nwww.figma.com/\n\n\n流程图\n\nexcalidraw.com/\nmiro.com/signup/\n\n\n\n\n\n\n\n开发中\n在线 IDE\n\nCloudStudio\n\n命名\n\ncodelf\n\n占位\n\n\n随机占位图\n\n正方形： picsum.photos/200\n长方形： picsum.photos/536/354\n根据种子获取不同的图片：picsum.photos/seed/ {seed}/536/354\n\npicsum.photos/seed/picsum/200/300\n\n\n\n\n\nplaceholder\n\n\nvia.placeholder.com/210/fff\n\n\n\n艺术图片占位\n\n\ngenerative-placeholders.glitch.me/image\n\n\n\n美女\n\n\ng.hiphotos.baidu.com/image/pic/item/6d81800a19d8bc3e770bd00d868ba61ea9d345f2.jpg\n\n\n\n朋克\n\n\nfuss10.elemecdn.com/8/27/f01c15bb73e1ef3793e64e6b7bbccjpeg.jpeg\n\n\n\n不跨域\n\nraw.githubusercontent.com/songxingguo/songxingguo.github.io/0744a15dd3a7005bb7e572c62be74becf822a321/themes/next/source/images/test.jpeg\n\n\n\n视频：\n\ngw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4\nlf3-static.bytednsdoc.com/obj/eden-cn/nupenuvpxnuvo/xgplayer_doc/xgplayer-demo.mp4\nmp4、3gp、mkv、flv格式测试视频\n\n\n\nCSS 效果\n\n加载中： loading.io/\nCSS 三角形生成器 ： www.dute.org/css-arrow\nCSS 条纹生成器： stripesgenerator.com\nCavepaint CSS\n\n一个可以在线调节主要参数（CSS 变量）的 CSS 框架。\ncavepaint.github.io/cavepaintcss/\n\n\ncss-generators: 一个集合多种 CSS 生成器的网站，旨在帮助开发者和设计人员快速生成他们需要的 CSS 代码。此网站提供了各种 CSS 生成器，包括渐变生成器、阴影生成器、转换生成器等，让开发者能够减少手写 CSS 代码的时间，并专注于更加重要的工作。\n\nbennettfeely: 一个在线工具，旨在帮助用户生成各种独特的 CSS 路径裁剪（clip-path）代码。CSS 路径裁剪是一种强大的技术，允许您通过定义一个路径来裁剪元素的可见区域，从而创建出各种各样有趣的形状和效果。可以将裁剪路径导出为SVG，这样可以利用SVG的SMIL动画技术设置路径动画，从而使路径裁剪在页面上呈现出更加生动和引人注目的外观。\n\n\n\n正则表达式\n\n正则表达式可视化\n[正则可视化]( jex.im/regulex/#!flags=&amp;re=%5E (a%7 Cb)*%3 F%24)\n常用正则表达式​\n正则表达式搜索\n表达式全集： tool.oschina.net/uploads/apidocs/jquery/regexp.html\n\n网页骨架布局生成器\n\n有些网页加载时，会显示一个骨架布局（上图），获取正式内容后再替换掉。这个在线工具就用来生成骨架布局，支持 React、React Native、Vue 和普通 HTML。\nskeletonreact.com/\n\n调试\n\nJSON 格式化： www.json.cn/\n抓包工具\n\n一个 Go 语言写的 HTTP 抓包分析器，带有 Web 界面: github.com/ga0/netgraph\n\n\n数据模拟\n\n模拟请求数据: designer.mocky.io/\n随机数据\n\nmockjs.com/\nrandom-data-api.com/\n\n\n一个模拟服务器 API 返回结果的前端 JS 库： miragejs.com/\n生成虚拟 JSON 数据： next.json-generator.com/\njson-server ： Get a full fake REST API with zero coding in less than 30 seconds (seriously)\n\n\nhttp 调试\n\n调试 Webhook 返回的数据： ngrok.com/\nDiode 可以将本机（localhost）的网站公开到互联网上，提供一个二级域名，使得外部用户可以访问： support.diode.io/article/ss32engxlq\n接口调试：\nhoppscotch： hoppscotch.io/\n\napifox\n\n\n一个 DNS 工具，可以为 IP 地址生成任意子域名。比如，IP 地址是 127.0.0.1，那么 foo. 127.0.0.1. xip. io 就会指向 127.0.0.1： xip.io/\n一个命令行工具，查看本机发出的所有 DNS 请求和获得的回应： jvns.ca/blog/2021/03/31/dnspeep-tool/\nHTTP Cats ：一个展示 HTTP 状态码的网站\n- http.cat/\ncurl → fetch​\n\nkigiri.github.io/fetch/\n\n\n\n\n\n图标库\n\nnext 主题中使用 ： fontawesome.dashgame.com/\n阿里图标库： www.iconfont.cn/\n\n加密\n\nMD5 Hash 加密\n\n转码\n\n转化器\n\n设计\n\n图片\n\n测试\n\n性能\n\nPageSpeed Insights：谷歌官方的网页性能的在线评分工具\n\n\n压测\n\n一个服务器和数据库的性能压测工具，具有图形界面： www.2n.pl/blog\n一个开源的负载压测工具： locust.io/\n\n\n兼容性\n\n不同屏幕大小兼容性测试\n\n\n\n代码提交\n\nGit 提交信息表情: gitmoji.dev/\n\n\n\n\n一个命令行的彩色 diff 工具: www.jefftk.com/icdiff\n\n\n\n运维\n\n自动化运维管理平台: github.com/openspug/spug\nNginx 的图形配置界面: www.digitalocean.com/community/tools/nginx\n\n其他\n\n提取背景图 hash：BlurHash\n可视化浮点数： evanw.github.io/float-toy/\n工具备忘录： devhints.io/\n\n\n\n性能优化\n\nPageSpeed Insights： 同时获取实验室性能数据和用户实测数据\nLighthouse：可获取实验室性能数据以及网页整体优化建议（包括但不限于性能建议）\n\n其他工具\n\n前端调试工具超全汇总，效率翻倍！\n"},"C-Knowledge/前端/开发工具/服务器/dynadot":{"title":"dynadot","links":[],"tags":["场景/域名","编程"],"content":"基本使用\n\n注册您的.IM域名\n解析不行使用跳转：\n\n常见问题\n\n\n为什么我的网站无法访问？\n\n查看是否同步：\n\n\n\nDNS CNAME的一些细节\n\n"},"C-Knowledge/前端/开发技术/Canvas学习资源":{"title":"Canvas学习资源","links":[],"tags":["编程/Canvas"],"content":"\nCanvas教程\n"},"C-Knowledge/前端/开发技术/Deno":{"title":"Deno","links":[],"tags":["编程/JavaScript"],"content":"\nDeno 初学者指南\nDeno 运行时入门教程：Node.js 的替代品\n"},"C-Knowledge/前端/开发技术/ElementUI":{"title":"ElementUI","links":["C-Knowledge/前端/开发技术/HTML-and-CSS/ElementUI-注意事项","C-Knowledge/前端/开发技术/el-upload","/"],"tags":["编程/前端/UI框架"],"content":"\nElementUI 注意事项\n\n使用方法\nel-upload\n样式重置\n&lt;style scoped&gt;\n:deep(.el-ipnut),\n:deep(.el-select),\n:deep(.el-input-number) {\n    width: 100%;\n}\n&lt;/style&gt;\n常见问题\n\nelement-ui中的el-form表单验证，只有在提交按钮点击时才进行验证： :validate-event=&quot;false&quot;\nel-radio 规则校验必填不生效\n\n// 验证等级不能为零\nconst validateLevel = (rule: any, value: any, callback: any) =&gt; {\n\tif (value) {\n\t\t// 当值为0的时候当做没选择\n\t\tif (value == 0) {\n\t\t\tcallback(new Error(&#039;请请填写难度等级&#039;));\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t} else {\n\t\tcallback(new Error(&#039;请请填写难度等级&#039;));\n\t}\nrules: {\n\tlevel: [{ required: true, validator: validateLevel, trigger: &#039;blur&#039; }],\n}"},"C-Knowledge/前端/开发技术/Git/Git-库":{"title":"Git 库","links":["C-Knowledge/前端/开发技术/Git/checkout"],"tags":["编程/Git"],"content":"\ncz-git: AI生成的 commit 信息\ncheckout: GitAction 检出代码\n"},"C-Knowledge/前端/开发技术/Git/Git":{"title":"Git","links":["C-Knowledge/前端/开发技术/Git/Git指令","D-Unsorted/Commit-message","D-Unsorted/Git规范","D-Unsorted/Git-入门","C-Knowledge/前端/开发技术/Git/Git-库","C-Knowledge/前端/开发技术/Git/Git问题","C-Knowledge/前端/开发技术/Git学习资源"],"tags":["编程/Git"],"content":"\nGit指令\nCommit message\nGit规范\nGit 入门\nGit 库\nGit问题\nGit学习资源\n"},"C-Knowledge/前端/开发技术/Git/Github-Action":{"title":"Github Action","links":["D-Unsorted/如何将语雀文章发布到Hexo博客","Web-Clip/@如何远程触发-GitHub-Action-–-陈少文的网站","Web-Clip/@GitHub-Actions-教程：定时发送天气邮件---阮一峰的网络日志","C-Knowledge/前端/开发技术/Git/checkout","C-Knowledge/前端/开发技术/Git/Github静态博客部署到-Coding","D-Unsorted/使用Github-Action部署静态网站","Web-Clip/@GitHub-Actions-手动触发方式进化史---P3TERX-ZONE","Web-Clip/@使用GithubActions自动化工作流---黄思喆的博客-_-Hsz's-Blog"],"tags":["编程/Git/GitHub"],"content":"使用方法\n触发条件\n\n\n                  \n                  提示💡 \n                  \n                \n\n参数说明\n\n\nrepository_dispatch\n若想要触发 GitHub 外部发生的活动的工作流，可以使用 GitHub API 触发名为 repository_dispatch 的 Webhook 事件。\n请求地址格式为：/repos/{owner}/{repo}/dispatches 。\nconst axios = require(&#039;axios&#039;);\n \nconst options = {\n  method: &#039;POST&#039;,\n  url: &#039;api.github.com/repos/songxingguo/songxingguo.github.io/dispatches&#039;,\n  headers: {\n    &#039;content-type&#039;: &#039;application/json&#039;,\n    Accept: &#039;application/vnd.github+json&#039;,\n    Authorization: &#039;Bearer GITHUB_TOKEN&#039;\n  },\n  data: {event_type: &#039;publish&#039;, client_payload: {slug}}\n};\n \naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n\n如何将语雀文章发布到Hexo博客\n@如何远程触发 GitHub Action – 陈少文的网站\n\n多条件触发\non:\n  push:\n    branches:\n      - &quot;main&quot;\n  repository_dispatch:\n    types: [second_brain_sync]\nworkflow_dispatch : 手动触发\n定时执行\non:\n  schedule:\n    - cron: &quot;0 8 * * *&quot;\n\n一个简单的Github Action CI脚本,每天早上8点调用指定代码库中的接口\n\n执行脚本\nstatic.yml\nname: 更新数字花园\non: [push]\njobs:\n  garden-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: &#039;Checkout codes&#039;\n        uses: actions/checkout@v4\n        with:\n          sparse-checkout: |\n            garden.sh\n          sparse-checkout-cone-mode: false\n      - name: &quot;触发garden的GithubAction&quot;\n        run: bash ./garden.sh\n        env:\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\ngarden.sh\n#!/bin/sh\n \nset -eux\n \ncurl --request POST \\\n  --url api.github.com/repos/songxingguo/garden/dispatches \\\n  --header &quot;Accept: application/vnd.github+json&quot; \\\n  --header &quot;Authorization: Bearer $GH_TOKEN&quot; \\\n  --header &#039;content-type: application/json&#039; \\\n  --data &#039;\n{\n  &quot;event_type&quot;:&quot;second_brain_sync&quot;\n}&#039;\n\n如果在另一个仓库中推送，则触发 GitHub Actions。\n当另一个仓库更新（推送、拉取请求）时触发Github Action\n@GitHub Actions 教程：定时发送天气邮件 - 阮一峰的网络日志\n\n检出代码\n\ncheckout\n\n指定 node 版本\n  - name: Setup Node.js\n\tuses: actions/setup-node@master\n\twith:\n\t  node-version: &quot;18.13.0&quot;\n推送代码\n推送到其他仓库\n - name: Push to another repository\n\tuses: cpina/github-action-push-to-another-repository@main\n\tenv:\n\t  API_TOKEN_GITHUB: ${{ secrets.API_TOKEN_GITHUB }}\n\twith:\n\t  source-directory: &#039;dist&#039;   // 要提交的目标文件\n\t  destination-github-username:  ${{ secrets.STORE_USER_NAME }}\n\t  destination-repository-name: ${{ secrets.STORE_ANOTHER_NAME }}\n\t  user-email: ${{ secrets.USER_EMAIL }}\n\t  target-branch: master  // 目标分支\n\nGithub实现push触发自动构建（包括提交代码到另一个仓库中和发布npm）\n\n部署博客\nname: GitHub Actions Build and Deploy\non:\n  push:\n    branches:\n      - main\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout 🛎️\n        uses: actions/checkout@v3\n        with:\n          persist-credentials: false   \n          \n      - name: Setup Node.js\n        uses: actions/setup-node@master\n        with:\n          node-version: &quot;18.13.0&quot;\n \n      - name: Install and Build 🔧\n        run: |\n          npm i --force\n          npm run build\n      - name: 推送到代码仓库\n        env:\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\n          GH_REF: &quot;github.com/songxingguo/brain.git&quot;\n          CO_TOKEN: ${{ secrets.CO_TOKEN }}\n          CO_REF: &quot;e.coding.net/songxingguo/songxingguo.coding.me/brain.git&quot;\n        run: |\n          cd ./src/.vuepress/dist\n          git init\n          git config user.name &quot;songxingguo&quot;\n          git config user.email &quot;1328989942@qq.com&quot;\n          git add .\n          git commit -m &quot;Update Blog By GithubAction With Build $TRAVIS_BUILD_NUMBER&quot;\n          # Github Pages\n          git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:gh-pages\n          # Coding Pages\n          git push --force --quiet &quot;https://zrUWsPQJyF:${CO_TOKEN}@${CO_REF}&quot; master:master\nGitHub Actions\n\nGithub静态博客部署到 Coding\n使用Github Action部署静态网站\n\nIP 地址\n\n GitHub Actions 服务器的 IP 范围\n GitHub 的 IP 地址\n“将 CIDR 转换为 IPv4”站点\nCIDR 表示法\n\ndocker\n常见问题\nAction 写入权限\ndenied: permission_denied: The token provided does not match expected scopes.\n\n和下面的\n\n\nUnable to push to ghcr.io from Github Actions \nraise ghcr unexpected status: 403 Forbidden when push ghcr image\n\n参考资料\n\nGitHub Actions 入门教程\n@GitHub Actions 手动触发方式进化史 - P3TERX ZONE\n@使用GithubActions自动化工作流 - 黄思喆的博客 _ Hsz’s Blog\n玩转 GitHub Actions\nGithub Actions总结\n"},"C-Knowledge/前端/开发技术/Git/Github":{"title":"Github","links":["C-Knowledge/前端/开发工具/Apple/Mac","C-Knowledge/前端/开发技术/Git/Github-Action","D-Unsorted/Gitee","C-Knowledge/前端/开发技术/Git/Coding.net","D-Unsorted/Github搜索语法","D-Unsorted/2FA","D-Unsorted/GitHub-仓库","C-Knowledge/前端/开发技术/Git/Github-首页美化","C-Knowledge/前端/开发技术/Git/Github-Webhooks"],"tags":["编程/Git/Github"],"content":"文件大小限制\n\n文件大小\n添加 .ignore\nTransclude of Mac#^ce355e\n\n\nGithub Action\nGitee\nCoding.net\nGithub搜索语法\n2FA\nGitHub 仓库\nGithub 首页美化\nGithub Webhooks\n"},"C-Knowledge/前端/开发技术/Git/Git指令-submodule":{"title":"Git指令-submodule","links":[],"tags":["编程/Git"],"content":"\n子模块是链接；子树是复制的。\n\n添加\n添加子模块。\ngit submodule add &lt;url&gt; &lt;path&gt;\nadd 时使用 -b 参数确定跟踪分支\ngit submodule add -b &lt;branch&gt; &lt;repo&gt; &lt;project-path&gt;\n可以看到 .gitmodules 文件中多记录了一个分支信息如下\n[submodule &quot;themes/next&quot;]  \n    path = themes/next  \n    url = git@github.com:Orange-C/hexo-theme-next.git  \n    branch = master\n\n更新\n初始化并检出子模块\ngit submodule init\ngit submodule update\n从远程子库拉取最新的子库代码\ngit submodule update --remote\n使用子模块和子树来管理 Git 项目\n移除\n# 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空\ngit submodule deinit {MOD_NAME} \n# 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）\ngit rm --cached {MOD_NAME} \n# 提交更改到代码库，可观察到&#039;.gitmodules&#039;内容发生变更\ngit commit -am &quot;Remove a submodule.&quot;\ngit submodule deinit -f path/to/submodule\nrm -rf .git/modules/path/to/submodule\ngit rm -f path/to/submodule\nGit删除子模块和远程分支\n扩展阅读\n\nGit submodule 知识总结\n"},"C-Knowledge/前端/开发技术/Git/Git指令-全局":{"title":"Git指令-全局","links":[],"tags":["编程/Git"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令描述版本信息git —versiongit 版本指令帮助git [指令] -h查看指令帮助信息git [指令] —help打开指令详细帮助页面查看日志：Git - 查看提交历史git log -n 20查看日志 (最近 20 条)，可省略 n 为-20；参数—graph 可视化显示分支关系git log —follow [file]显示某个文件的版本历史，包括文件改名git log -n 20 —graph参数“—graph”可视化显示分支关系git log —follow [file]显示某个文件的版本历史git reflog查看所有可用的历史版本记录（实际是 HEAD 变更记录），包含被回退的记录，常用来撤销回退git blame [file]以列表形式查看指定文件的历史修改记录格式化日志git log -n 20 —oneline参数“—oneline”可以让日志输出更简洁（一行）git log —pretty=oneline一行显示提交信息 git log —pretty=format: “%h %s” —graph自定义输出格式 筛选日志git log —pretty=format: “%s” —since=“2019-07-17 07:36pm” —until=“2019-07-29 08:28pm”查询指定时间区间的提交git log —pretty=format: “%s” —since=“2019-07-17 07:36pm” —until=“2019-07-29 08:28pm” —grep=“feat”查询包含指定字段的提交导出日志git log &gt; log. txt导出 Git log 日志git log —pretty=format: “%s” —graph —since=“2019-10-14 02 18 pm” —grep=“feat” &gt; log. txt同上，日志格式化后导出日志创建仓库git init [文件目录]初始化创建 Git 仓库，如果不指定[文件目录]，则在当前目录创建Git 配置git config —list查看配置信息，包括系统（—system）+全局（—global）+项目（—local）配置git config —list —system查看系统配置，全局（—global）、项目（—local）配置配置类似git config —global user. name “名称”配置用户名git config —global user. email “邮箱”配置邮箱查看文件cat [file]读取一个文件，展示其文件内容"},"C-Knowledge/前端/开发技术/Git/Git指令":{"title":"Git指令","links":["D-Unsorted/Git-入门","C-Knowledge/前端/开发技术/Git/Git指令-全局","C-Knowledge/前端/开发技术/Git/Git指令-代码","C-Knowledge/前端/开发技术/Git/Git指令-提交","C-Knowledge/前端/开发技术/Git/Git指令-储藏","C-Knowledge/前端/开发技术/Git/Git指令-仓库","C-Knowledge/前端/开发技术/Git/Git指令-分支","C-Knowledge/前端/开发技术/Git/Git指令-标签","C-Knowledge/前端/开发技术/Git/Git指令-bisect","C-Knowledge/前端/开发技术/Git/Git指令-diff","C-Knowledge/前端/开发技术/Git/Git指令-submodule"],"tags":["编程/Git"],"content":"Git 入门\n全局指令\nGit指令-全局\n本地操作\n\nGit指令-代码\nGit指令-提交\nGit指令-储藏\n远程交互\n\nGit指令-仓库\nGit指令-分支\nGit指令-标签\n高级操作\nGit指令-bisect\nGit指令-diff\nGit指令-submodule\n最佳实践\n使用原则\n\n多建分支，没有什么是新建一个分支无法解决的。\n多提交代码，方便后续如果有问题可以进行快速回滚。\n善于使用变基命令整理没有推送的提交，让提交记录更加整洁。注意⚠️只在从未推送至共用仓库的提交上执行变基命令。\n\n工作流\n\nGit 练习场\n\nLearn Git Branching，Git 在线练习。\nGit Exercises，Git 学习网站，通过示例仓库，提供一系列 Git 的小练习，帮助用户掌握这个版本管理工具。\n\n参考链接\n\ngit 使用学习总结\n"},"C-Knowledge/前端/开发技术/Git/jenkins":{"title":"jenkins","links":["Web-Clip/@我早就看现在的工作流不爽了！--前端使用-Jenkins","Web-Clip/@Jenkins-真得很牛逼！只是大部分人不会用而已~(保姆级教程)"],"tags":["编程/FE/工程化"],"content":"入门\n\n@我早就看现在的工作流不爽了！- 前端使用 Jenkins\n@Jenkins 真得很牛逼！只是大部分人不会用而已~(保姆级教程)\n\n常见问题\nNode 构建常见问题\n自定义构建环境\n\n在开始中，全局指定 node 版本 \n阶段指定环境\n\n"},"C-Knowledge/前端/开发技术/HTML-and-CSS/less":{"title":"less","links":[],"tags":["编程/FE/CSS"],"content":""},"C-Knowledge/前端/开发技术/HTML-and-CSS/sass":{"title":"sass","links":[],"tags":["编程/FE/CSS"],"content":"@mixin and @include"},"C-Knowledge/前端/开发技术/HTML-and-CSS/text-indent":{"title":"text-indent","links":["C-Knowledge/前端/技术书籍/CSS世界/文本的控制"],"tags":["编程/FE/CSS"],"content":"使用方法\n首行缩进。\n.indent { text-indent: 2em; }\n第二行缩进。\n.indent {  \n　　text-indent: -2em;  \n　　margin-left: 2em;  \n}\n\n\n                  \n                  注意❗ \n                  \n                \n注：div标签不要忘记起始符。text-indent只对p或div标签有效，对br标签不生效，原因是br标签是换行标签不是分段标签。\n\n扩展阅读\n\n文本的控制\n"},"C-Knowledge/前端/开发技术/HTML-and-CSS/富文本显示（承诺书）":{"title":"富文本显示（承诺书）","links":["E-Day-planner/2024/五月/2024_05_14｜星期二"],"tags":["编程/FE/CSS","编程/FE/Vue"],"content":"&lt;div class=&quot;fullTextContent&quot;&gt;\n  &lt;p v-html=&quot;lawFullText&quot;&gt;&lt;/p&gt;\n&lt;/div&gt;;\n.fullTextContent {\n    line-height: 1.7;\n}\n \n:deep(.indent) {\n    margin: 10px 0 10px 50px;\n}\nconst lawFullText = ref(&quot;&quot;);\nlawFullText.value = `    \n            &lt;p&gt; 我作为评审专家,现作出如下承诺:&lt;/p&gt;\n            &lt;ol class=&quot;indent&quot;&gt;\n                &lt;li&gt;本人坚决贯彻落实习近平总书记关于教育的重要论述精神，认真开展评审工作，促进教育科学研究高质量发展。 &lt;/li&gt;\n                &lt;li&gt;本人在参与本评审之前，未与学生、学校等评审相关利害关系人发生可能影响评审结果的接触，未与评审相关利害关系人有经济利益关系，未收受可能影响对课题公正评审的相关利害关系人的任何好处（包括现金、有价证券和礼物等），本人直系亲属未参与本次课题申报，本人不存在按照法律法规需要回避的情形。\n                &lt;/li&gt;\n                &lt;li&gt;本人将严格按照评审标准、规则和流程等要求，对所有作品独立评审，客观公正地履行职责，遵守职业道德，充分体现评审专业水平，对所提出的评审意见承担个人责任。&lt;/li&gt;\n                &lt;li&gt;本人严格遵守相关法律法规、规章制度及各项工作纪律，在评审过程中提出客观公正、合理的意见，不发表有引导性、倾向性、歧视性言论，对评审过程中所获知的各种信息和秘密予以保密；\n                    评审结束后立即销毁所有过程性资料，不将评审过程中任何资料和信息向除相关上级单位以外的任何第三方透露，不向相关利益关系人透露课题评审结果以及与评审有关的其他信息。&lt;/li&gt;\n                &lt;li&gt;本人积极配合相关上级单位回复相关质疑，积极配合行政监督部门处理质疑投诉、重新评审和法律诉讼等事项；并按照有关规定合理收取劳务报酬。&lt;/li&gt;\n            &lt;/ol&gt;\n            &lt;p&gt;若违反上述行为，本人自愿承担相关责任，接受行政监督管理部门、纪检监察部门或司法机关调查处理。&lt;/p&gt;`;\n\n扩展阅读\n\n2024_05_14｜星期二\n"},"C-Knowledge/前端/开发技术/JavaScript/CountUp.js":{"title":"CountUp.js","links":[],"tags":["编程/JavaScript"],"content":"/**\n * 数字滚动\n */\nmodule.exports = class CountUp {\n  constructor ({speed = 1350, refreshInterval = 100, decimals = 0, formatter = this._formatter} = {}) {\n    this.speed = speed // 从起始值到目标值到时间\n    this.refreshInterval = refreshInterval // 更新间隔\n    this.loops = this._getLoops()// 循环次数\n    this.decimals = decimals // 保留几位小数\n    this.formatter = formatter\n    this.onUpdate = null\n    this.onComplete = null\n  }\n \n  start ({from = 0, to = 0} = {}, onUpdate) {\n    this.from = from\n    this.to = to\n    this.value = from\n    this.loopCount = 0 // 循环计数器\n    this.increment = this._getIncrement() // 每次更新的增量\n    this.onUpdate = onUpdate\n    this._updateTimer()\n  }\n \n  _formatter (value, decimals) {\n    return value.toFixed(decimals);\n  }\n \n  _getLoops () {\n    return Math.ceil(this.speed / this.refreshInterval)\n  }\n \n  _getIncrement () {\n    return (this.to - this.from) / this.loops\n  }\n \n  _updateTimer () {\n    this.value += this.increment\n    this.loopCount++\n    if (this.onUpdate) this.onUpdate(this.formatter(this.value, this.decimals))\n    if (this.loopCount &gt;= this.loops) {\n      this.value = this.to\n      clearInterval(this.timer)\n      if (this.onComplete) this.onComplete()\n      return\n    }\n    this.timer = setTimeout(() =&gt; {\n      this._updateTimer()\n    }, this.refreshInterval)\n  }\n}\n/**\n * 数字滚动\n */\nconst Countdown = require(&#039;./countdown&#039;);\nmodule.exports = class CountUp {\n  constructor ({speed = 1350, refreshInterval = 100, decimals = 0, formatter = this._formatter} = {}) {\n    this.speed = speed; // 从起始值到目标值到时间\n    this.refreshInterval = refreshInterval; // 更新间隔\n    this.loops = this._getLoops();// 循环次数\n    this.decimals = decimals; // 保留几位小数\n    this.formatter = formatter;\n    this.onComplete = null;\n  }\n \n  start ({from = 0, to = 0} = {}, onUpdate) {\n    this.from = from;\n    this.to = to;\n    this.value = from;\n    this.increment = this._getIncrement(); // 每次更新的增量\n    this.countdown = new Countdown(this.increment);\n    this.countdown.start(this.to, () =&gt; {\n      onUpdate(this.formatter(this.value, this.decimals));\n      this.value += this.increment;\n      console.log(this.value)\n    })\n    this.countdown.onFinish = () =&gt; {\n      if (this.onComplete) this.onComplete()\n      this.countdown.cancel()\n    }\n  }\n \n  _formatter (value, decimals) {\n    return value.toFixed(decimals);\n  }\n \n  _getLoops () {\n    return Math.ceil(this.speed / this.refreshInterval)\n  }\n \n  _getIncrement () {\n    return (this.to - this.from) / this.loops\n  }\n};\n/**\n * 数字滚动\n */\nconst Countdown = require(&#039;./countdown&#039;)\nmodule.exports = class CountUp {\n  constructor ({speed = 1350, refreshInterval = 100, decimals = 0, formatter = this._formatter} = {}) {\n    this.speed = speed // 从起始值到目标值到时间\n    this.refreshInterval = refreshInterval // 更新间隔\n    this.loops = this._getLoops()// 循环次数\n    this.decimals = decimals // 保留几位小数\n    this.formatter = formatter\n  }\n \n  start ({from = 0, to = 0} = {}, onUpdate) {\n    this.from = from\n    this.to = to\n    this.value = from\n    this.increment = this._getIncrement() // 每次更新的增量\n    const countdown = new Countdown(this.refreshInterval);\n    countdown.start(this.speed, (cd) =&gt; {\n      this.value += this.increment\n      if (onUpdate) onUpdate(this.formatter(this.value, this.decimals))\n    })\n    countdown.onFinish = () =&gt; {\n      if (onUpdate) onUpdate(this.formatter(this.to, this.decimals))\n    }\n  }\n \n  _formatter (value, decimals) {\n    return value.toFixed(decimals);\n  }\n \n  _getLoops () {\n    return Math.ceil(this.speed / this.refreshInterval)\n  }\n \n  _getIncrement () {\n    return (this.to - this.from) / (this.loops + 1)\n  }\n}"},"C-Knowledge/前端/开发技术/JavaScript/Countdown.js":{"title":"Countdown.js","links":[],"tags":["编程/JavaScript"],"content":"/**\n * 自动定时器，支持自定义步长，支持onFinish回调\n */\nmodule.exports = class Countdown {\n  constructor (step = 1000) {\n    this.countdown = 0\n    this.step = step\n    this.timer = null\n    this.frame = null\n    this.fn = null\n    this.onFinish = null\n    this.preStartTime = null\n  }\n \n  /**\n   * 是否在工作\n   * @returns {Boolean}\n   */\n  isWorking () {\n    return this.countdown !== 0\n  }\n \n  /**\n   * 启动定时器\n   * @param {Number} countdown millisecond\n   * @param {Function} fn 每步回调\n   */\n  start (countdown, fn) {\n    this.cancel()\n    if (typeof countdown !== &#039;number&#039; || countdown &lt;= 0) return\n    this.countdown = countdown\n    this.fn = fn\n    this._isTimeUp()\n  }\n \n  /**\n   * 取消倒计时\n   */\n  cancel () {\n    if (this.timer) clearTimeout(this.timer)\n    if (this.frame) cancelAnimationFrame(this.frame)\n    this.resetPreStartTime()\n  }\n \n  resetPreStartTime () {\n    this.preStartTime = null\n  }\n \n  _isTimeUp () {\n    // TODO 计时器使用Worker控制\n    // 由于setTimeout的异步特点，此处给予时间补偿。正数说明滞后执行，负数说明提前执行，只有为0时说明刚好执行无需补偿，滞后需要减掉，提前需要加上，那么减负数就是加上。\n    let realIntervalTime = this.preStartTime ? (new Date()).getTime() - this.preStartTime : 0\n    let needSetCountDown = realIntervalTime - this.step\n    if (this.countdown &gt; this.step &amp;&amp; realIntervalTime !== 0 &amp;&amp; needSetCountDown !== 0) {\n      this.countdown -= needSetCountDown\n    }\n    if (this.countdown &lt;= 0) this.countdown = 0\n    if (this.fn) this.fn(this.countdown)\n    if (this.countdown === 0) {\n      this.resetPreStartTime()\n      if (this.onFinish &amp;&amp; typeof this.onFinish === &#039;function&#039;) this.onFinish()\n      return\n    }\n    let delay = this.countdown - this.step &gt; 0 ? this.step : this.countdown\n    this.countdown -= delay\n    this.preStartTime = (new Date()).getTime()\n    // this.frame = requestAnimationFrame(() =&gt; {\n    //   this._isTimeUp()\n    // })\n    this.timer = setTimeout(() =&gt; {\n      this._isTimeUp()\n    }, delay)\n  }\n}"},"C-Knowledge/前端/开发技术/JavaScript/beam":{"title":"beam","links":[],"tags":["编程/FE/Three"],"content":"基本概念\n\nShader 着色器，是存放图形算法的对象。相比于在 CPU 上单线程执行的 JS 代码，着色器在 GPU 上并行执行，计算出每帧数百万个像素各自的颜色。\nResource 资源，是存放图形数据的对象。就像 JSON 成为 Web App 的数据那样，资源是传递给着色器的数据，包括大段的顶点数组、纹理图像，以及全局的配置项等。\nDraw 绘制，是选好资源后运行着色器的请求。要想渲染真实际的场景，一般需要多组着色器与多个资源，来回绘制多次才能完成一帧。每次绘制前，我们都需要选好着色器，并为其关联好不同的资源，也都会启动一次图形渲染管线。\nCommand 命令，是执行绘制前的配置。WebGL 是非常有状态的。每次绘制前，我们都必须小心地处理好状态机。这些状态变更就是通过命令来实现的。Beam 基于一些约定大幅简化了人工的命令管理，当然你也可以定制自己的命令。\n\n\n\n图形渲染管线\n\n可编程渲染管线\n\n顶点着色器输入原始的顶点坐标，输出根据你的需求变换后的坐标。\n片元着色器输入一个像素位置，输出根据你的需求计算出的像素颜色。\n\n\n既要见树木也要见森林。\n\n参考链接\n\n如何设计一个 WebGL 基础库\n实用 WebGL 图像处理入门\n用网页模拟生命：WebGL 版康威生命游戏\n"},"C-Knowledge/前端/开发技术/JavaScript/danmu.js":{"title":"danmu.js","links":[],"tags":["编程/JavaScript"],"content":"class DanMuItem {\n  constructor({ id, content, style }) {\n    this.display = true;\n    this.id = id;\n    this.content = content;\n    this.style = style;\n    this._createAt = Date.now();\n  }\n \n  freshDisplay(duration) {\n    return (this.display = Date.now() - this._createAt &lt;= duration);\n  }\n}\n \nclass DanMu {\n  constructor({\n    duration = 3000,\n    lineHeight = 42,\n    lineCount = 8,\n    maxSize = 300,\n  } = {}) {\n    this.id = 0;\n    this.duration = duration;\n    this.lineCount = lineCount;\n    this.lineHeight = lineHeight;\n    this.danMuList = [];\n    this._lineArr = [];\n    this._lineNum = 0;\n    this._maxSize = maxSize;\n  }\n \n  getLineNum() {\n    let lineNum = 0;\n    let isFull = true;\n    const basePercent = 0.25;\n    for (; lineNum &lt; this.lineCount; lineNum++) {\n      const lineStartTime = this._lineArr[lineNum] || Date.now();\n      const linePercent = (Date.now() - lineStartTime) / this.duration;\n      if (linePercent == 0 || linePercent &gt; basePercent) {\n        isFull = false;\n        this._lineNum = lineNum;\n        this._lineArr[lineNum] = Date.now();\n        break;\n      }\n    }\n    if (isFull) {\n      lineNum = ++this._lineNum % this.lineCount;\n    }\n    return lineNum;\n  }\n \n  send(content, volatilize = true) {\n    const len = this.danMuList.length;\n    if (volatilize &amp;&amp; len &gt;= this._maxSize) return;\n    const lineNum = this.getLineNum();\n    const style = `top:${lineNum * this.lineHeight}rpx;animation: danMu ${this.duration}ms linear forwards;`;\n    const item = new DanMuItem({ id: this.id++, content, style });\n    this.danMuList.push(item);\n  }\n \n  render() {\n    this.danMuList = this.danMuList.filter((item) =&gt;\n      item.freshDisplay(this.duration),\n    );\n    return this.danMuList;\n  }\n}\n \nmodule.exports = DanMu;"},"C-Knowledge/前端/开发技术/JavaScript/event-bus.js":{"title":"event-bus.js","links":[],"tags":["编程/FE/Vue"],"content":"/**\n * 事件总线\n */\nclass EventBus {\n  constructor() {\n    this.events = {};\n  }\n \n  emit(eventName, ...args) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach((item) =&gt; item(...args));\n  }\n \n  on(eventName, callback) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(callback);\n  }\n \n  off(eventName, callback) {\n    const index = (this.events[eventName] || []).findIndex(\n      (item) =&gt; item === callback,\n    );\n    if (index &gt; -1) this.events[eventName].splice(index, 1);\n  }\n}\n \nmodule.exports = EventBus;"},"C-Knowledge/前端/开发技术/JavaScript/什么是防抖和节流！有什么区别！如何实现！":{"title":"什么是防抖和节流！有什么区别！如何实现！","links":["C-Knowledge/前端/开发技术/JavaScript/高阶函数","C-Knowledge/前端/开发技术/JavaScript/decorator.js","C-Knowledge/前端/开发技术/React/useDebounceFn：防抖函数","C-Knowledge/前端/开发技术/React/useDebounce：防抖值","C-Knowledge/前端/开发技术/React/useThrottleFn：节流函数","C-Knowledge/前端/开发技术/React/useThrottle：节流值","D-Unsorted/谈谈前端开发中的防抖和节流"],"tags":["编程/JavaScript"],"content":"防抖和节流是前端开发中常用的函数优化手段，它们可以限制函数的执行频率，提升性能和用户体验。主要用于处理高频触发的事件，例如：用户的滚动、输入、点击和表单的重复提交等。它们都可以使用高阶函数实现\n防抖（ 停止一段时间后触发，最后触发）\n是什么\n防抖：如果一个函数持续地、频繁地触发，那么只在它结束后过一段时间才开始执行。简而言之，防抖是在事件停止触发后延迟执行函数。\n具体实现\n实现防抖的基本方式是利用定时器，每次触发事件时都清除上一次的定时器，然后重新设置一个新的定时器。\n\n函数防抖的要点，也是需要一个 setTimeout 来辅助实现。延迟执行需要跑的代码。\n如果方法多次触发，则把上次记录的延迟执行代码用 clearTimeout 清掉，重新开始。\n如果计时完毕，没有方法进来访问触发，则执行代码。\n\n// 防抖函数  \nfunction debounce(func, wait) {  \n\tlet timeout;  \n\treturn function (...args) {  \n\t  const context = this;  \n\t  clearTimeout(timeout);  \n\t  timeout = setTimeout(() =&gt; func.apply(context, args), wait);  \n\t};  \n}  \n防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：\nfunction debounce(func, wait, immediate) {\n \n    let timeout;\n \n    return function () {\n        let context = this;\n        let args = arguments;\n \n        if (timeout) clearTimeout(timeout); // timeout 不为null\n        if (immediate) {\n            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发\n            timeout = setTimeout(function () {\n                timeout = null;\n            }, wait)\n            if (callNow) {\n                func.apply(context, args)\n            }\n        }\n        else {\n            timeout = setTimeout(function () {\n                func.apply(context, args)\n            }, wait);\n        }\n    }\n}\n应用场景\n防抖的应用场景：\n\n输入框搜索：当用户在搜索框中输入关键字时，使用防抖可以避免频繁发送搜索请求，而是在用户停止输入一段时间后才发送请求，减轻服务器压力。\n用户注册时候的手机号码验证和邮箱验证。\n按钮点击：当用户点击按钮时，使用防抖可以避免用户多次点击造成的多次提交或重复操作。\n\n手机号码验证和邮箱验证\n只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析：\n// 函数防抖\nvar timer = false;\ndocument.getElementById(&quot;debounce&quot;).onscroll = function(){\n    clearTimeout(timer); // 清除未执行的代码，重置回初始化状态\n \n    timer = setTimeout(function(){\n        console.log(&quot;函数防抖&quot;);\n    }, 300);\n};\n节流（ 固定时间触发，均匀触发）\n是什么\n节流：如果你持续触发事件，每隔一段时间，事件处理函数只执行一次。简而言之，节流是按照固定的时间间隔执行函数。\n具体实现\n节流的方式也是利用定时器，但与防抖不同的是，节流会保证在一个固定的时间间隔内至少执行一次事件处理函数。\n\n函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。\n如果空闲，则可以正常触发方法执行。\n如果代码正在执行，则取消这次方法执行。\n\n// 节流函数  \nfunction throttle(func, limit) {  \n\tlet inThrottle;  \n\treturn function (...args) {  \n\t  const context = this;  \n\t  if (!inThrottle) {  \n\t\tfunc.apply(context, args);  \n\t\tinThrottle = true;  \n\t\tsetTimeout(() =&gt; inThrottle = false, limit);  \n\t  }  \n\t};  \n}\n\n\n                  \n                  重点 \n                  \n                \n函数防抖的实现重点，就是巧用setTimeout做缓存池，而且可以轻易地清除待执行的代码。其实，用队列的方式也可以做到这种效果。这里就不深入了。\n\n使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行\nfunction throttled1(fn, delay = 500) {\n    let oldtime = Date.now()\n    return function (...args) {\n        let newtime = Date.now()\n        if (newtime - oldtime &gt;= delay) {\n            fn.apply(null, args)\n            oldtime = Date.now()\n        }\n    }\n}\n可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下\nfunction throttled(fn, delay) {\n    let timer = null\n    let starttime = Date.now()\n    return function () {\n        let curTime = Date.now() // 当前时间\n        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间\n        let context = this\n        let args = arguments\n        clearTimeout(timer)\n        if (remaining &lt;= 0) {\n            fn.apply(context, args)\n            starttime = Date.now()\n        } else {\n            timer = setTimeout(fn, remaining);\n        }\n    }\n}\n应用场景\n节流的应用场景：\n\n页面滚动：当页面滚动时，使用节流可以限制滚动事件的触发频率，减少事件处理的次数，提高页面的响应性能。\n按钮点击：当用户点击按钮时，使用节流可以减少事件处理的次数，避免过于频繁的操作。\n窗口大小调整\n\n页面滚动\n函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：\n// 函数节流\nvar canRun = true;\ndocument.getElementById(&quot;throttle&quot;).onscroll = function(){\n    if(!canRun){\n        // 判断是否已空闲，如果在执行中，则直接return\n        return;\n    }\n \n    canRun = false;\n    setTimeout(function(){\n        console.log(&quot;函数节流&quot;);\n        canRun = true;\n    }, 300);\n};\n总结\n区别\n相同点：\n\n都可以通过使用 setTimeout 实现\n目的都是，降低回调执行频率。节省计算资源\n\n不同点：\n\n函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能\n函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次\n\n例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次\n如下图所示：\n\n应用场景\n防抖在连续的事件，只需触发一次回调的场景有：\n\n搜索框搜索输入。只需用户最后一次输入完，再发送请求\n手机号、邮箱验证输入检测\n窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。\n\n节流在间隔一段时间执行一次回调的场景有：\n\n滚动加载，加载更多或滚到底部监听\n搜索框，搜索联想功能\n\n其他实现\n装饰器\n\ndecorator.js\n\nHooks\n\nuseDebounceFn：防抖函数\nuseDebounce：防抖值\nuseThrottleFn：节流函数\nuseThrottle：节流值\n\n扩展阅读\n\n谈谈前端开发中的防抖和节流\nJavaScript函数节流和函数防抖之间的区别\n"},"C-Knowledge/前端/开发技术/Lodash":{"title":"Lodash","links":[],"tags":["编程/JavaScript"],"content":""},"C-Knowledge/前端/开发技术/Node/Node.js":{"title":"Node.js","links":["C-Knowledge/前端/开发技术/Node/npm","C-Knowledge/前端/开发技术/Node/nvm","C-Knowledge/前端/开发工具/OS/Linux/常用软件","C-Knowledge/前端/开发技术/Node/Node教程","C-Knowledge/前端/开发技术/Node/Node-框架","C-Knowledge/前端/开发技术/Node学习资源"],"tags":["编程/FE/Node"],"content":"\nnpm: Node 包管理器\nnvm ：Node 源管理器\nNode常用命令\nNode教程\nNode 框架\nNode学习资源\n"},"C-Knowledge/前端/开发技术/Node/npm":{"title":"npm","links":["C-Knowledge/学习进化/设置淘宝镜像","C-Knowledge/前端/开发技术/Node/nrm","C-Knowledge/前端/开发技术/Node/什么是-npm-ci！它与“npm-install”命令有何不同！","C-Knowledge/前端/开发技术/Node/发布-npm","C-Knowledge/前端/开发工具/OS/Linux/pm2","C-Knowledge/前端/开发技术/Node/node-sass"],"tags":["编程/FE/Node"],"content":"npm 入门\n\n安装包\n\nnpm i socket.io@2.0.0\n\nnpm 查看安装了哪些包\n\n# 查看已经安装在当前项目中的所有包\nnpm list\n# 查看全局已经安装的包\nnpm list -g\n# 只查看当前项目的直接依赖，不会显示它们的依赖\nnpm list --depth=0\n# 查看项目中未使用到的包\nnpm ls --depth=0 --parseable --dev\n\n卸载重装\n\nnpm -rf node_modules\nnpm cache clean\nnpm install\nnpm uninstall xxx #同时删除package.json的&quot;dependencies&quot;的记录\n\n设置淘宝镜像\nnrm： npm 源管理器\n什么是 npm-ci！它与“npm-install”命令有何不同！\n\nnpm 进阶\n\n发布 npm\n\n常用  npm 包\n\npm2\nnode-sass\n\n常见问题\n\n\n                  \n                  错误 \n                  \n                \nUnable to resolve dependency tree error when installing npm packages\n\nnpm install --legacy-peer-deps\nnpm config set legacy-peer-deps true\nnpm cache clean --force"},"C-Knowledge/前端/开发技术/Node/nvm":{"title":"nvm","links":[],"tags":["编程/Node"],"content":"nvm 入门\n安装 nvm\n# installs NVM (Node Version Manager)\ncurl -o- raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n \n# 验证是否安装成功\ncommand -v nvm\n \n# 安装系统版本 node\nnvm install 20 \n \n# verifies the right Node.js version is in the environment\nnode -v # should print `v20.12.1`\n \n# verifies the right NPM version is in the environment\nnpm -v # should print `10.5.0`\n常用命令\n# 远端可用node版本\nnvm ls-remote\n# 安装并使用最新版node\nnvm install node\nnvm use node\nnvm run node --version\n# 使用系统版本\nnvm use system\nnvm run system --version\n# 卸载nvm\nnvm_dir=&quot;${NVM_DIR:-~/.nvm}&quot;\nnvm unload\nrm -rf &quot;/Users/sxg/.nvm&quot;\n# 清除nvm缓存\nnvm cache clear\n# 更新nvm\nnvm install-latest-npm\n# 更新Node.js\nnvm install node --reinstall-packages-from=node\n# 查看本机安装的 nvm 的安装目录地址\nnvm root\n手动更新\ncd &quot;/Users/sxg/.nvm&quot;\ngit fetch --tags origin\ngit checkout `git describe --abbrev=0 --tags --match &quot;v0.9.0&quot; \n \n\\. &quot;/Users/sxg/.nvm/nvm.sh&quot;\n# 查询最新版本\ngit rev-list --tags --max-count=1\n常见 BUG\nFailed to connect to raw. githubusercontent. com port 443\n\n\n                  \n                  错误 \n                  \n                \nHomebrew installation on Mac OS X Failed to connect to raw.githubusercontent.com port 443\n\nIf you are behind a proxy, try this:\nsudo vim /etc/hosts\nadd the line below and :wq\n199.232.28.133 raw.githubusercontent.com\n也可以切换网络后在重试。\nnvm ls-remote 结果为 N/A 的解决方案\n\n临时请使用导出用于抓取内容的镜像的非 https 版本：\n\nexport NVM_NODEJS_ORG_MIRROR=nodejs.org/dist\n\n长久解决方案：\n\n若您运行 curl $NVM\\_NODEJS\\_ORG_MIRROR 出现。\ncurl: (56) Recv failure: Connection reset by peer\n\n则考虑修改 ~/.nvm/nvm.sh  ，在函数 nvm_download() 里修改，加上 curl -k $*\n if nvm_has &quot;curl&quot;; then\n    curl -k $*  #新加的\n  elif nvm_has &quot;wget&quot;; then\n    # Emulate curl with wget\n...\n}"},"C-Knowledge/前端/开发技术/React/useCountDown：倒计时管理":{"title":"useCountDown：倒计时管理","links":["Web-Clip/@阿里面试：写一个倒计时功能刷掉了80-percent-的人"],"tags":["编程/React/Hooks"],"content":"功能介绍\n用于管理倒计时的 Hooks。在日常工作中我们时常需要倒计时的帮助，但处理时间总是比较麻烦的事，而 useCountDown 可以帮助我们解决这类困难。\n我们先思考一下实际的场景，假设我们要两天后的倒计时，那么我们要知道两天后距离现在的时间戳，然后通过对应的时间戳转换为对应的 天、时、分、秒，完成倒计时。\n可看出，要想计算倒计时，就得具备两个条件：\n\ntargetDate：目标时间，如：上述示例的两天后；\ninterval：变化的时间，通常为 1s === 1000 ms。\n\n返参只要返回目标时间距离当前时间的时间戳（remainTime），和转化后的天、时、分等（formattedTime）即可。\nuseCountDown 的 targetDate 可能存在多种形式，比如字符串、数字、日期等格式，转化起来相对麻烦，所以我们这里直接用 dayjs 库，来帮助我们解决这个问题。\n目标时间与当前时间的时间差：\nconst calcRemain = (target?: TDate) =&gt; {\n  if (!target) return 0;\n  const remain = dayjs(target).valueOf() - Date.now();\n  return remain &lt; 0 ? 0 : remain;\n};\n时间戳进行转化：\nconst calcFormat = (milliseconds: number): FormattedRes =&gt; {\n  return {\n    days: Math.floor(milliseconds / 86400000),\n    hours: Math.floor(milliseconds / 3600000) % 24,\n    minutes: Math.floor(milliseconds / 60000) % 60,\n    seconds: Math.floor(milliseconds / 1000) % 60,\n    milliseconds: Math.floor(milliseconds) % 1000,\n  };\n};\n时间变化的条件：targetDate、interval。 每秒都会变化，所以这里我们依靠 setInterval 的即可。\nuseEffect(() =&gt; {\n\tif (!targetDate) return setRemainTime(0);\n\tsetRemainTime(calcRemain(targetDate));\n\t\n\tconst timer = setInterval(() =&gt; {\n\t  const remain = calcRemain(targetDate);\n\t  setRemainTime(remain);\n\t  if (remain === 0) {\n\t\tclearInterval(timer);\n\t  }\n\t}, interval);\n\t\n\treturn () =&gt; clearInterval(timer);\n}, [targetDate, interval]);\ntargetTime 和 onEnd\nuseCountDown 除了上述功能外，我们可以扩展些额外的功能，让 useCountDown 更加完美，如：\n\ntargetTime： 剩余时间，当前时间 + 剩余时间 = 目标时间；\nonEnd： 当倒计时结束后，触发回调函数。\n\n可以看出 targetTime 相当于 targetDate 是个简化的版本，所以我们只需要做个兼容即可：\nconst target = useCreation(() =&gt; {\n\tif (targetTime) {\n\t  return targetTime &gt; 0 ? Date.now() + targetTime : undefined;\n\t} else {\n\t  return targetDate;\n\t}\n}, [targetTime, targetDate]);\n而 onEnd 触发的时机为 remain === 0 时即可。\n单元测试\n日期测试\n在 useCountDown 的单元测试中，涉及到了时间的测试，在这里，我们需要 jest.useFakeTimers 的帮助。\njest.useFakeTimers：模拟假计时器，当我们需要日期、性能、时间、计时器的功能，如：Date、setTimeout()、clearTimeout()、setInterval()、clearInterval() 等，都可以通过它来实现。\n但在 Jest 之前的版本中，jest.useFakeTimers 的使用比较麻烦，但在 Jest 26 中，加入 modern 方式来激活定时器的配置（参考文档），如：\njest.useFakeTimers(&quot;modern&quot;)\n但调用 jest.useFakeTimers 会对文件中的所有测试使用假计时器，这种行为是一个全局操作，会影响同一文件的其他测试。\n所以，在使用 jest.useFakeTimers 的时候必须配合使用 jest.useRealTimers，它的作用是恢复全局日期、性能、时间和计时器 API 的原始实现。\nbeforeAll(() =&gt; {\n jest.useFakeTimers(&quot;modern&quot;);\n});\n \nafterAll(() =&gt; {\n jest.useRealTimers();\n});\n定时器测试\n当我们设置好环境后，还需要掌握 Jest 中测试定时器的方法：jest.advanceTimersByTime(msToRun)，它可以执行宏任务队列。\n换句话说，我们在开发中使用的 setTimeout() 、setInterval()、setImmediate() 都可通过 jest.advanceTimersByTime 进行对应的模拟操作。\n测试用例：\nit(&quot;测试 targetTime&quot;, () =&gt; {\n\tconst { result } = renderHook(\n\t  (\n\t\tprops: any = {\n\t\t  targetTime: 3000,\n\t\t}\n\t  ) =&gt; useCountDown(props)\n\t);\n\texpect(result.current[0]).toBe(3000);\n\texpect(result.current[1].seconds).toBe(3);\n\t\n\tact(() =&gt; {\n\t  jest.advanceTimersByTime(1000);\n\t});\n\texpect(result.current[0]).toBe(2000);\n\texpect(result.current[1].seconds).toBe(2);\n});\n简要地说明下：首先我们通过 renderHook 设置 useCountDowen 的剩余时间还剩 3s，然后执行 jest.advanceTimersByTime(1000) 模拟定时器执行一秒，所以此时剩余的时间还剩 2s。\n\n\n                  \n                  注意❗ \n                  \n                \n注意：jest. advanceTimersByTime 模拟是定时器的操作，所以它依然要放入 act 中才会有效果。\n\n设置系统时间\n在 useCountDown 的设计中，有可能目标的时间小于当前时间，此时返回的应该为 0，但对应的测试中，我们想要自由地去设置当前的时间，这种情况下就可以使用 jest.setSystemTime 的帮助。\njest.setSystemTime(now?: number | Date)： 模拟程序中运行时的系统时钟，会影响当前时间，但它本身不会触发定时器等。\n举个小例子：\nbeforeAll(() =&gt; {\n\tjest.useFakeTimers(&quot;modern&quot;);\n\tjest.setSystemTime(new Date(&quot;2020-01-01&quot;).getTime());\n\t});\n\t\n\tit(&quot;测试 targetDate 小于当前时间&quot;, () =&gt; {\n\tconst { result } = renderHook(() =&gt;\n\t  useCountDown({\n\t\ttargetDate: new Date(&quot;2021-01-01&quot;).getTime(),\n\t  })\n\t);\n\texpect(result.current[0]).toBe(0);\n});\n在测试 targetDate 小于当前时间时，我们给的目标时间是 2021-01-01，是小于 2023 年的，但我们通过 jest.setSystemTime 更改后变为了 2020-01-01，此时测试的时间就会大于当前时间，也就是时间戳并不为 0。如：\n\n所以我们要想测试这个用例，比 2020-01-01 小就 OK 了，当然，如果不设置 jest.setSystemTime 会默认为当前时间。\n扩展阅读\n\n@阿里面试：写一个倒计时功能刷掉了80% 的人\n"},"C-Knowledge/前端/开发技术/UI库":{"title":"UI库","links":["C-Knowledge/前端/开发技术/ElementUI"],"tags":["编程/前端/UI框架"],"content":"\nElementUI\n"},"C-Knowledge/前端/开发技术/Vue/Vue-教程":{"title":"Vue 教程","links":["C-Knowledge/前端/开发技术/Vue/Vue-创建项目","C-Knowledge/前端/开发技术/Vue/Vue语法","C-Knowledge/前端/开发技术/Vue/Vue2-API","C-Knowledge/前端/开发技术/Vue/Vue3-API","D-Unsorted/项目目录结构","C-Knowledge/前端/开发技术/Vue/Vuex","C-Knowledge/前端/开发技术/Vue/Vue常用Hooks","Vue-Router","C-Knowledge/前端/开发技术/Vue/Pinia","E-Day-planner/2024/三月/最全系列的vue3入门教程『图文并茂』"],"tags":["编程/FE/Vue"],"content":"入门\n\nVue 创建项目\nVue语法\nVue2 API\nVue3 API\n项目目录结构\n\n进阶\n\nVuex\nVue常用Hooks\nVue Router\nPinia\n\n扩展阅读\n\n最全系列的vue3入门教程『图文并茂』\n"},"C-Knowledge/前端/开发技术/Vue/Vue.js":{"title":"Vue.js","links":["C-Knowledge/前端/开发技术/Vue/Vue-教程","C-Knowledge/前端/开发技术/Vue/Vue-开发工具","C-Knowledge/前端/开发技术/Vue/Vue库","C-Knowledge/前端/开发技术/Vue/Vue-学习资源"],"tags":["编程/FE/Vue"],"content":"\nVue 教程\nVue 开发工具\nVue库\nVue 学习资源\n"},"C-Knowledge/前端/开发技术/Vue/VueUse":{"title":"VueUse","links":[],"tags":["编程/FE/Vue"],"content":"常有hooks\n\nuseResizeObserver\nuseTitle\nuseClipboard\nuseDraggable\n"},"C-Knowledge/前端/开发技术/Vue/Vue常用Hooks":{"title":"Vue常用Hooks","links":["C-Knowledge/前端/开发技术/Vue/useDialog()","C-Knowledge/前端/开发技术/Vue/useTable()","C-Knowledge/前端/开发技术/Vue/useToggle()","C-Knowledge/前端/开发技术/Vue/vhook","Web-Clip/@Vue3-自定义hooks-大集合-你要的自定义hooks-都在这，快来看吧！---知乎"],"tags":["编程/FE/Vue"],"content":"\nuseDialog()\nuseTable()\nuseToggle()\n\n扩展阅读\n\n使用Vue hooks封装表单操作方法\n使用Vue3 hooks封装一个表格操作的方法\nable表相关api的统一hooks封装(表单数据的增删改查)\nVue3系列 如何封装一个操作表单数据的hook\nvhook\nvue-hooks\n@Vue3 自定义hooks 大集合 你要的自定义hooks 都在这，快来看吧！ - 知乎\n记录—在Vue3这样子写页面更快更高效- 林恒\nvue3 + ts + element-plus 使用hooks封装表格CRUD方法\ncrud增删改查文件——自定义钩子函数\n"},"C-Knowledge/前端/开发技术/Vue/useDialog()":{"title":"useDialog()","links":[],"tags":["编程/FE/Vue"],"content":"扩展阅读\n\nvue3.0全局打开弹窗hooks函数封装:  全局弹窗，JS 唤起\n技术分享 | 弹窗开发中，如何使用 Hook 封装 el-dialog？\nVue3这样子结合hook写弹窗组件更快更高效\n\nuseDialog\n在线demo地址\n\n\n"},"C-Knowledge/前端/开发技术/Vue/useTable()":{"title":"useTable()","links":["E-Day-planner/2024/三月/如何封装一个超级好用的-Hook-！"],"tags":["编程/FE/Vue"],"content":"import { reactive, ref } from &#039;vue&#039;;\nimport { usePagination } from &#039;./usePagination&#039;;\nimport { get, has, defaults } from &#039;lodash-es&#039;;\n \n/**\n * 表格 Hook\n * @param api 返回Promise的接口函数\n * @param params 接口调用传递的参数\n * @param options 配置接口数据路径和加载时机\n * @returns 返回一个数组 [data, refresh, pagination, table]，分别是列表数据数组、刷新数据方法、分页属性、和表格属性\n */\ntype keyPath = Array&lt;string&gt; | string;\nexport function useTable&lt;T&gt;(\n\tapi: (params: any) =&gt; Promise&lt;T&gt;,\n\tparams: object | (() =&gt; object) = {},\n\toptions: {\n\t\tpath?: { data?: keyPath; total?: keyPath; page?: string; size?: string };\n\t\timmediate?: boolean;\n\t} = {}\n) {\n\tdefaults(options, {\n\t\tpath: {\n\t\t\tdata: &#039;data.result.items&#039;,\n\t\t\ttotal: &#039;data.result.total&#039;,\n\t\t\tpage: &#039;page&#039;,\n\t\t\tsize: &#039;pageSize&#039;,\n\t\t},\n\t\timmediate: false,\n\t});\n \n\t// 使用()=&gt;fn()而不是fn()区别在于后者只是一个值且立即执行\n\tconst [pagination, , , setTotal] = usePagination((extraData?: object) =&gt; (extraData ? refresh(extraData) : refresh()));\n\tconst data = ref([]);\n\tconst table = reactive({\n\t\tloading: false,\n\t\tcurData: {}, // 当前选中数据\n\t\t// 按属性进行排序\n\t\tonSortChange: (column: any) =&gt; {\n\t\t\trefresh({ field: column.prop, order: column.order });\n\t\t},\n\t\t// 改变当前选中的行\n\t\tonCurrentChange: (val: any = { id: &#039;&#039; }) =&gt; {\n\t\t\ttable.curData = val;\n\t\t},\n\t});\n \n\tconst refresh = (extraData?: object | (() =&gt; object)) =&gt; {\n\t\ttable.onCurrentChange(); // 接口刷新就重置当前选中\n\t\tconst requestData = {\n\t\t\t[options?.path?.page as string]: pagination.current,\n\t\t\t[options?.path?.size as string]: pagination.size,\n\t\t};\n\t\tif (extraData) {\n\t\t\tif (typeof extraData === &#039;function&#039;) {\n\t\t\t\tObject.assign(requestData, extraData());\n\t\t\t} else {\n\t\t\t\tObject.assign(requestData, extraData);\n\t\t\t}\n\t\t}\n\t\tif (params) {\n\t\t\tif (typeof params === &#039;function&#039;) {\n\t\t\t\tObject.assign(requestData, params());\n\t\t\t} else {\n\t\t\t\tObject.assign(requestData, params);\n\t\t\t}\n\t\t}\n\t\ttable.loading = true;\n\t\treturn api(requestData)\n\t\t\t.then((res) =&gt; {\n\t\t\t\tdata.value = get(res, options!.path?.data, []);\n\t\t\t\tsetTotal(get(res, options!.path?.total, 0));\n\t\t\t\t// 友好提示\n\t\t\t\tif (!has(res, options!.path?.data) || !has(res, options!.path?.total)) {\n\t\t\t\t\tconsole.warn(&#039;useTable：响应数据缺少所需字段&#039;);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.finally(() =&gt; {\n\t\t\t\ttable.loading = false;\n\t\t\t});\n\t};\n \n\t// 立即执行\n\toptions!.immediate &amp;&amp; refresh();\n \n\treturn [data, refresh, pagination, table];\n}\n扩展阅读\n\n如何封装一个超级好用的 Hook ！\n"},"C-Knowledge/前端/开发技术/Vue/useToggle()":{"title":"useToggle()","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对vue的mixin的理解，有什么应用场景！"],"tags":[],"content":"import { ref, Ref, DeepReadonly, readonly } from &#039;vue&#039;;\n \nexport type ToggleParamType = string | number | boolean | undefined | null;\n \nexport interface ToggleReturn {\n\tstate: DeepReadonly&lt;Ref&lt;boolean&gt;&gt;;\n\ttoggle: (next?: boolean) =&gt; void;\n\tsetDefault: () =&gt; void;\n\tsetRight: () =&gt; void;\n}\n \nexport interface ITwoType&lt;T extends ToggleParamType = ToggleParamType, U extends ToggleParamType = ToggleParamType&gt; extends Omit&lt;ToggleReturn, &#039;state&#039; | &#039;toggle&#039;&gt; {\n\tstate: DeepReadonly&lt;Ref&lt;T | U&gt;&gt;;\n\ttoggle: (next?: T | U) =&gt; void;\n}\n \nexport interface IToggle {\n\t(): ToggleReturn;\n\t(defaultValue: boolean): ToggleReturn;\n\t&lt;T extends ToggleParamType = ToggleParamType, U extends ToggleParamType = ToggleParamType&gt;(defaultValue: T, resetValue?: U): ITwoType&lt;T, U&gt;;\n}\n \nexport const useToggle: IToggle = &lt;T extends ToggleParamType = ToggleParamType, U extends ToggleParamType = ToggleParamType&gt;(defaultValue: T = false as T, reverseValue?: U) =&gt; {\n\tconst state = ref(defaultValue) as Ref&lt;T | U&gt;;\n\tconst reverseTo = (reverseValue === undefined ? !defaultValue : reverseValue) as T | U;\n \n\tconst toggle = (next?: T | U) =&gt; {\n\t\tif (next !== undefined) {\n\t\t\tstate.value = next;\n\t\t} else {\n\t\t\tstate.value = state.value === defaultValue ? reverseTo : defaultValue;\n\t\t}\n\t};\n\tconst setDefault = () =&gt; {\n\t\tstate.value = defaultValue;\n\t};\n\tconst setRight = () =&gt; {\n\t\tstate.value = reverseTo;\n\t};\n\treturn {\n\t\tstate: readonly(state),\n\t\tsetDefault,\n\t\tsetRight,\n\t\ttoggle,\n\t};\n};\n扩展阅读\n\ntoggle切换\nuseToggle\n"},"C-Knowledge/前端/开发技术/Vue/组件---插槽":{"title":"组件 - 插槽","links":[],"tags":["编程/FE/Vue"],"content":"插槽内容与出口​\n在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。\n举例来说，这里有一个 &lt;FancyButton&gt; 组件，可以像这样使用：\n&lt;FancyButton&gt;\n  Click me! &lt;!-- 插槽内容 --&gt;\n&lt;/FancyButton&gt;\n而 &lt;FancyButton&gt; 的模板是这样的：\n&lt;button class=&quot;fancy-btn&quot;&gt;\n  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;\n&lt;/button&gt;\n&lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。\n\n最终渲染出的 DOM 是这样：\n&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt;\n在演练场中尝试一下\n通过使用插槽，&lt;FancyButton&gt; 仅负责渲染外层的 &lt;button&gt; (以及相应的样式)，而其内部的内容由父组件提供。\n理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：\n// 父元素传入插槽内容\nFancyButton(&#039;Click me!&#039;)\n \n// FancyButton 在自己的模板中渲染插槽内容\nfunction FancyButton(slotContent) {\n  return `&lt;button class=&quot;fancy-btn&quot;&gt;\n      ${slotContent}\n    &lt;/button&gt;`\n}\n插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：\n&lt;FancyButton&gt;\n  &lt;span style=&quot;color:red&quot;&gt;Click me!&lt;/span&gt;\n  &lt;AwesomeIcon name=&quot;plus&quot; /&gt;\n&lt;/FancyButton&gt;\n在演练场中尝试一下\n通过使用插槽，&lt;FancyButton&gt; 组件更加灵活和具有可复用性。现在组件可以用在不同的地方渲染各异的内容，但同时还保证都具有相同的样式。\nVue 组件的插槽机制是受原生 Web Component &lt;slot&gt; 元素的启发而诞生，同时还做了一些功能拓展，这些拓展的功能我们后面会学习到。\n渲染作用域​\n插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：\n&lt;span&gt;{{ message }}&lt;/span&gt;\n&lt;FancyButton&gt;{{ message }}&lt;/FancyButton&gt;\n这里的两个 {{ message }} 插值表达式渲染的内容都是一样的。\n插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：\n\n父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。\n\n默认内容​\n在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 &lt;SubmitButton&gt; 组件：\n&lt;button type=&quot;submit&quot;&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n&lt;/button&gt;\n如果我们想在父组件没有提供任何插槽内容时在 &lt;button&gt; 内渲染“Submit”，只需要将“Submit”写在 &lt;slot&gt; 标签之间来作为默认内容：\n&lt;button type=&quot;submit&quot;&gt;\n  &lt;slot&gt;\n    Submit &lt;!-- 默认内容 --&gt;\n  &lt;/slot&gt;\n&lt;/button&gt;\n现在，当我们在父组件中使用 &lt;SubmitButton&gt; 且没有提供任何插槽内容时：\n&lt;SubmitButton /&gt;\n“Submit”将会被作为默认内容渲染：\n&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\n但如果我们提供了插槽内容：\n&lt;SubmitButton&gt;Save&lt;/SubmitButton&gt;\n那么被显式提供的内容会取代默认内容：\n&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;\n在演练场中尝试一下\n具名插槽​\n有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 &lt;BaseLayout&gt; 组件中，有如下模板：\n&lt;div class=&quot;container&quot;&gt;\n  &lt;header&gt;\n    &lt;!-- 标题内容放这里 --&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;!-- 主要内容放这里 --&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;!-- 底部内容放这里 --&gt;\n  &lt;/footer&gt;\n&lt;/div&gt;\n对于这种场景，&lt;slot&gt; 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：\n&lt;div class=&quot;container&quot;&gt;\n  &lt;header&gt;\n    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n  &lt;/footer&gt;\n&lt;/div&gt;\n这类带 name 的插槽被称为具名插槽 (named slots)。没有提供 name 的 &lt;slot&gt; 出口会隐式地命名为“default”。\n在父组件中使用 &lt;BaseLayout&gt; 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到具名插槽了：\n要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 &lt;template&gt; 元素，并将目标插槽的名字传给该指令：\n&lt;BaseLayout&gt;\n  &lt;template v-slot:header&gt;\n    &lt;!-- header 插槽的内容放这里 --&gt;\n  &lt;/template&gt;\n&lt;/BaseLayout&gt;\nv-slot 有对应的简写 #，因此 &lt;template v-slot:header&gt; 可以简写为 &lt;template #header&gt;。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\n下面我们给出完整的、向 &lt;BaseLayout&gt; 传递插槽内容的代码，指令均使用的是缩写形式：\n&lt;BaseLayout&gt;\n  &lt;template #header&gt;\n    &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n  &lt;/template&gt;\n \n  &lt;template #default&gt;\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n  &lt;/template&gt;\n \n  &lt;template #footer&gt;\n    &lt;p&gt;Here&#039;s some contact info&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/BaseLayout&gt;\n当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 &lt;template&gt; 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：\n&lt;BaseLayout&gt;\n  &lt;template #header&gt;\n    &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n  &lt;/template&gt;\n \n  &lt;!-- 隐式的默认插槽 --&gt;\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n  &lt;p&gt;And another one.&lt;/p&gt;\n \n  &lt;template #footer&gt;\n    &lt;p&gt;Here&#039;s some contact info&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/BaseLayout&gt;\n现在 &lt;template&gt; 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：\n&lt;div class=&quot;container&quot;&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;p&gt;Here&#039;s some contact info&lt;/p&gt;\n  &lt;/footer&gt;\n&lt;/div&gt;\n在演练场中尝试一下\n使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：\n// 传入不同的内容给不同名字的插槽\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n \n// &lt;BaseLayout&gt; 渲染插槽内容到对应位置\nfunction BaseLayout(slots) {\n  return `&lt;div class=&quot;container&quot;&gt;\n      &lt;header&gt;${slots.header}&lt;/header&gt;\n      &lt;main&gt;${slots.default}&lt;/main&gt;\n      &lt;footer&gt;${slots.footer}&lt;/footer&gt;\n    &lt;/div&gt;`\n}\n条件插槽​\n有时你需要根据插槽是否存在来渲染某些内容。\n你可以结合使用 $slots 属性与 v-if 来实现。\n在下面的示例中，我们定义了一个卡片组件，它拥有三个条件插槽：header、footer 和 default。 当 header、footer 或 default 存在时，我们希望包装它们以提供额外的样式：\n&lt;template&gt;\n  &lt;div class=&quot;card&quot;&gt;\n    &lt;div v-if=&quot;$slots.header&quot; class=&quot;card-header&quot;&gt;\n      &lt;slot name=&quot;header&quot; /&gt;\n    &lt;/div&gt;\n    \n    &lt;div v-if=&quot;$slots.default&quot; class=&quot;card-content&quot;&gt;\n      &lt;slot /&gt;\n    &lt;/div&gt;\n    \n    &lt;div v-if=&quot;$slots.footer&quot; class=&quot;card-footer&quot;&gt;\n      &lt;slot name=&quot;footer&quot; /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n在演练场中尝试一下\n动态插槽名​\n动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名：\n&lt;base-layout&gt;\n  &lt;template v-slot:[dynamicSlotName]&gt;\n    ...\n  &lt;/template&gt;\n \n  &lt;!-- 缩写为 --&gt;\n  &lt;template #[dynamicSlotName]&gt;\n    ...\n  &lt;/template&gt;\n&lt;/base-layout&gt;\n注意这里的表达式和动态指令参数受相同的语法限制。\n作用域插槽​\n在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。\n我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：\n&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;\n&lt;div&gt;\n  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;\n&lt;/div&gt;\n当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：\n&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;\n  {{ slotProps.text }} {{ slotProps.count }}\n&lt;/MyComponent&gt;\n\n在演练场中尝试一下\n子组件传入插槽的 props 作为了 v-slot 指令的值，可以在插槽内的表达式中访问。\n你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) =&gt; {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n \nfunction MyComponent(slots) {\n  const greetingMessage = &#039;hello&#039;\n  return `&lt;div&gt;${\n    // 在插槽函数调用时传入 props\n    slots.default({ text: greetingMessage, count: 1 })\n  }&lt;/div&gt;`\n}\n实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写渲染函数时使用作用域插槽的方式非常类似了。\nv-slot=&quot;slotProps&quot; 可以类比这里的函数签名，和函数的参数类似，我们也可以在 v-slot 中使用解构：\n&lt;MyComponent v-slot=&quot;{ text, count }&quot;&gt;\n  {{ text }} {{ count }}\n&lt;/MyComponent&gt;\n具名作用域插槽​\n具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name=&quot;slotProps&quot;。当使用缩写时是这样：\n&lt;MyComponent&gt;\n  &lt;template #header=&quot;headerProps&quot;&gt;\n    {{ headerProps }}\n  &lt;/template&gt;\n \n  &lt;template #default=&quot;defaultProps&quot;&gt;\n    {{ defaultProps }}\n  &lt;/template&gt;\n \n  &lt;template #footer=&quot;footerProps&quot;&gt;\n    {{ footerProps }}\n  &lt;/template&gt;\n&lt;/MyComponent&gt;\n向具名插槽中传入 props：\n&lt;slot name=&quot;header&quot; message=&quot;hello&quot;&gt;&lt;/slot&gt;\n注意插槽上的 name 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 headerProps 的结果是 { message: &#039;hello&#039; }。\n如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的 &lt;template&gt; 标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：\n&lt;!-- 该模板无法编译 --&gt;\n&lt;template&gt;\n  &lt;MyComponent v-slot=&quot;{ message }&quot;&gt;\n    &lt;p&gt;{{ message }}&lt;/p&gt;\n    &lt;template #footer&gt;\n      &lt;!-- message 属于默认插槽，此处不可用 --&gt;\n      &lt;p&gt;{{ message }}&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/MyComponent&gt;\n&lt;/template&gt;\n为默认插槽使用显式的 &lt;template&gt; 标签有助于更清晰地指出 message 属性在其他插槽中不可用：\n&lt;template&gt;\n  &lt;MyComponent&gt;\n    &lt;!-- 使用显式的默认插槽 --&gt;\n    &lt;template #default=&quot;{ message }&quot;&gt;\n      &lt;p&gt;{{ message }}&lt;/p&gt;\n    &lt;/template&gt;\n \n    &lt;template #footer&gt;\n      &lt;p&gt;Here&#039;s some contact info&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/MyComponent&gt;\n&lt;/template&gt;\n高级列表组件示例​\n你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 &lt;FancyList&gt; 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的：\n&lt;FancyList :api-url=&quot;url&quot; :per-page=&quot;10&quot;&gt;\n  &lt;template #item=&quot;{ body, username, likes }&quot;&gt;\n    &lt;div class=&quot;item&quot;&gt;\n      &lt;p&gt;{{ body }}&lt;/p&gt;\n      &lt;p&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/template&gt;\n&lt;/FancyList&gt;\n在 &lt;FancyList&gt; 之中，我们可以多次渲染 &lt;slot&gt; 并每次都提供不同的数据 (注意我们这里使用了 v-bind 来传递插槽的 props)：\n&lt;ul&gt;\n  &lt;li v-for=&quot;item in items&quot;&gt;\n    &lt;slot name=&quot;item&quot; v-bind=&quot;item&quot;&gt;&lt;/slot&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n在演练场中尝试一下\n无渲染组件​\n上面的 &lt;FancyList&gt; 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。\n如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。\n这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件：\n&lt;MouseTracker v-slot=&quot;{ x, y }&quot;&gt;\n  Mouse is at: {{ x }}, {{ y }}\n&lt;/MouseTracker&gt;\n在演练场中尝试一下\n虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。之后我们会在组合式函数一章中介绍如何更高效地实现追踪鼠标位置的功能。\n尽管如此，作用域插槽在需要同时封装逻辑、组合视图界面时还是很有用，就像上面的 &lt;FancyList&gt; 组件那样。"},"C-Knowledge/前端/开发技术/el-upload":{"title":"el-upload","links":["C-Knowledge/前端/开发技术/如何做到发送一次请求上传多个文件","D-Unsorted/表单，FormData-对象","C-Knowledge/前端/技术书籍/JavaScript教程/'input'"],"tags":["编程/前端/UI框架"],"content":"\n如何做到发送一次请求上传多个文件\n关于el-upload看这一篇就够了\n文件上传\n文件上传按钮的特有属性\n原生JS实现文件上传\nel-upload上传组件accept属性限制文件类型\nvue实现多文件上传\n"},"C-Knowledge/前端/开发技术/web-vitals":{"title":"web-vitals","links":[],"tags":["编程/性能"],"content":""},"C-Knowledge/前端/开发技术/免费技术书籍":{"title":"免费技术书籍","links":["C-Knowledge/前端/开发技术/音视频/音视频"],"tags":["编程/书籍"],"content":"一、Web 开发\nJavaScript\n\n现代 JavaScript 教程\n你不知道的 JS\nTypeScript 教程\nNode 入门\nNode.js 调试指南\nOAuth 2.0 Servers\n\n音视频\n\nWebRTC 零基础开发者教程（中文）\nWebRTC 教程\n\n其他\n\nhttp3-explained\nCSS Animation 101\nChrome 扩展及应用开发\n网站可靠性工作手册\n实用排版指南\n\n二、系统管理\n\nLinux 命令行\n\n中文版本\n\n\nBash 脚本教程\nDocker 初学者教程\n\n三、编程语言\nPython\n\nPython 编程基础（PDF）\nPython 编程入门\nPython 语法笔记\n廖雪峰 Python 教程（中文）\n\n编程思想\n\nJS 函数式编程指南\n"},"C-Knowledge/前端/开发技术/大前端":{"title":"大前端","links":["E-Diary/Notion-可视化｜2023_10_27｜周五｜☔️","C-Knowledge/前端/开发技术/HTML-and-CSS/HTML","C-Knowledge/前端/开发技术/HTML-and-CSS/CSS","C-Knowledge/前端/开发技术/JavaScript/JavaScript","C-Knowledge/前端/开发技术/TypeScript","C-Knowledge/前端/开发技术/Vue/Vue.js","C-Knowledge/前端/开发技术/React/React","C-Knowledge/前端/开发技术/微信小程序","C-Knowledge/前端/开发技术/uni-app/uni-app","C-Knowledge/前端/开发技术/Vue/Nuxt.-js","C-Knowledge/前端/开发技术/React/Next.js","Flutter","Electron","Weex","C-Knowledge/前端/开发技术/Git/Git","C-Knowledge/前端/开发工具/VSCode/VSCode","C-Knowledge/前端/开发技术/Webpack","C-Knowledge/前端/开发技术/Vue/Vite","C-Knowledge/前端/职业规划/前端面试宝典/八股文/前端性能优化","C-Knowledge/前端/开发技术/如何调试Webhooks","C-Knowledge/前端/开发技术/前端库","C-Knowledge/学习进化/LaTeX","C-Knowledge/前端/开发技术/移动端适配","C-Knowledge/前端/开发技术/音视频/音视频","C-Knowledge/前端/开发技术/JavaScript/three.js","C-Knowledge/前端/开发技术/Node/Node.js","C-Knowledge/前端/开发技术/Deno","C-Knowledge/前端/开发工具/OS/Linux/Linux","redis","k8s"],"tags":["场景/导航"],"content":"大前端是什么？\n\nFront-End\n黄玄：前端已死，前端永生\n\n前端开发\n前端基础\n\nHTML\nCSS\nJavaScript\nTypeScript\nVue.js\nReact\n\n小程序\n\n微信小程序\nuni-app ：Vue 跨端开发框架\n\nSSR\n\nNuxt. js: Vue 服务端渲染框架\nNext.js：React 服务器端渲染框架（SSR）\n\n桌面端\n\nFlutter： 使用 Dart 编程语言开发客户端。\nElectron： 使用 HTML、CSS 和 JavaScript 构建客户端。\n\n移动端\n\nFlutter： 使用 Dart 编程语言开发客户端。\nWeex： Vue native 开发框架。\n\n开发工具\n\nGit\nVSCode\n\n工程化\n\nWebpack\nVite\n\n其他\n\n前端性能优化\n如何调试Webhooks\n前端库\nLaTeX\n移动端适配\n\n数据可视化\n\n音视频\nthree.js\n\n服务器\n\nNode.js\nDeno：新的 JavaScript 运行时\nLinux\nredis\nk8s\n"},"C-Knowledge/前端/开发技术/如何做到发送一次请求上传多个文件":{"title":"如何做到发送一次请求上传多个文件","links":[],"tags":["编程/前端/UI框架"],"content":"方法一：通过配置file-list（推荐使用）\nhtml部分：\n&lt;el-upload\n    class=&quot;upload-demo list-uploadbtn&quot;\n    ref=&quot;upload&quot;\n    :action=&quot;curBastUrl&quot;\n    :auto-upload=&quot;false&quot;\n    :on-remove=&quot;updataRemove&quot;\n    :before-upload=&quot;beforeUpload&quot;\n    :on-change=&quot;updatachange&quot;\n    :file-list=&quot;fileList&quot;\n    :multiple=&quot;true&quot;&gt;\n    &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;\n&lt;/el-upload&gt;\n&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt;\njs部分：\nsubmitUpload() {  // 导入\n    let formData = new FormData();  //  用FormData存放上传文件\n    this.fileList.forEach(file =&gt; { \n        formData.append(&#039;file&#039;, file.raw)\t\t\n    }) \n    　　    \n    formData.append(&#039;categoryDirectory&#039;, this.filedata.categoryDirectory)\n \n    // importCase是上传接口\n    importCase(formData).then((res) =&gt; { \n        //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 \n    　　this.updataSuccess(res.data) \n    }, (err) =&gt; {\n    　　 \n    })\n}\n关键代码说明：\n\nauto-upload 设置为 false 用于关闭组件的自动上传；\nfile-list 配置一个数组用于接收上传的文件列表；\nmultiple 设置为 true 表示支持多选文件；\naction 配置为完整的上传接口url，不配置会报错\n不用配置 data、on-success、on-error等参数，因为手动上传不会用到这些配置信息；\n最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData 把 fileList  的文件存进去。\n\n方法二：通过配置http-request\nhtml部分：\n&lt;el-upload\n    class=&quot;upload-demo list-uploadbtn&quot;\n    ref=&quot;upload&quot;\n    :action=&quot;curBastUrl&quot;\n    :auto-upload=&quot;false&quot;\n    :http-request=&quot;uploadFile&quot;\n    :on-remove=&quot;updataRemove&quot;\n    :before-upload=&quot;beforeUpload&quot;\n    :on-change=&quot;updatachange&quot;\n    :multiple=&quot;true&quot;&gt;\n    &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;\n&lt;/el-upload&gt;\n&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt;\njs部分：\nsubmitUpload() {  // 导入\n    let tempData =  this.filedata\n    this.filedata = new FormData()  //  用FormData存放上传文件\n    this.$refs.upload.submit()  // 会循环调用uploadFile方法，多个文件调用多次\n \n    this.filedata.append(&#039;categoryDirectory&#039;, tempData.categoryDirectory)\n \n    // importCase是上传接口\n    importCase(this.filedata).then((res) =&gt; { \n    //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 \n    　　this.updataSuccess(res.data) \n    }, (err) =&gt; {\n    　　 \n    })\n}\nuploadFile(file) {\n    this.filedata.append(&#039;file&#039;, file.file)\n}\n关键代码说明：\n\nhttp-request 自定义上传方法；\n最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData, 调用 upload 组件的 submit 方法的时候会循环调用 http-request 配置的方法，从而往 FormData  里存放文件。\n"},"C-Knowledge/前端/开发技术/看过最简洁的-TSConfig-介绍":{"title":"看过最简洁的 TSConfig 介绍","links":[],"tags":["编程/TypeScript"],"content":"JavaScript 正在不断发展，从一个简单的脚本语言演变成强大的现代工具，用于构建复杂的应用程序。为了管理越来越大、越来越复杂的代码库，JavaScript 开发人员不断寻找提高工作流程、代码质量和生产力的方法。TypeScript 通过添加类型来改善代码质量和维护，因此毫不奇怪它是增长最快的语言之一。\n如果你从未使用过编译语言或编译器，可能会觉得 TypeScript 有点可怕。或许你用过，但遇到了一个复杂的 tsconfig.json 文件，而你并不完全理解。这篇博客文章是对 TypeScript (TS) 的介绍，以及如何轻松地配置你的项目以使用 TypeScript。\n从 JS 到 TS\nTypeScript 是建立在 JavaScript 之上的。它是一个超集 —— 任何有效的 JavaScript 都是有效的 TypeScript。如果你刚接触 TypeScript，可以简单地将其看作是一个“超级力量的 linter”，为语言增加了新功能，帮助你安全地编写 JavaScript。它旨在严格增加 —— 去掉类型的 TypeScript 就是 JavaScript，但有了类型，你将获得大大改善的工具、调试以及整体开发者体验。\n因为 JavaScript 生态系统随着时间的推移而有机地发展，TypeScript 旨在与你现有的工具集成。现代编辑器、构建工具、包管理器、测试框架和 CI/CD 工具都与 TypeScript 集成。为了采纳 TypeScript，并根据你的具体项目要求和工具进行定制，你需要配置 TypeScript 编译器。这可以通过一个叫做 tsconfig.json 的文件来完成。\n如果你是第一次在一个新的代码库中做 TypeScript，你可能会将 tsconfig.json 中的大多数选项保留为默认值。对于需要互操作性的工具或有特定怪癖的项目，tsconfig.json 提供了你可能需要拉动的所有操纵杆以与你的生态系统互动。\nTSConfig 配置\ntsconfig.json 文件允许你配置 TypeScript 编译器如何处理你的 TypeScript 代码。tsconfig.json 文件只是一个具有定义编译器选项和项目设置的属性的 JSON 对象。我们将透过一些你在设置自己的 tsconfig.json 文件时可能需要的属性。\n首先要看的属性是 compilerOptions，在此指定编译器设置。\ncompilerOptions 中的编译器设置\n\ncompilerOptions 属性是你定义 TypeScript 编译器设置的地方。这些选项包括：\ntarget – 指定输出 JavaScript 的 ECMAScript 目标版本。默认为 ES3。为确保最大兼容性，请将其设置为你的代码需要运行的最低版本。ESNext 设置允许你针对最新支持的提议特性。\nmodule – 定义要使用的模块系统（CommonJS、AMD、ES6 等）。使用取决于你项目的需求和代码将运行的环境。大多数现代项目将使用 ES6 或 ESNext。\noutDir – 指定编译 JavaScript 文件的输出目录。通常设置为 dist，为你的编译文件创建一个 dist 目录。\nstrict – 启用严格类型检查选项，以帮助捕获代码中的错误。设置为 true 进行严格类型检查。\nalwaysStrict – 如果启用了 strict，则自动设置为 true，它会在 JavaScript 严格模式下解析代码，并为每个源文件发出 use strict。\nesModuleInterop – 在 JavaScript 中，有两种主要的模块系统：ECMAScript 模块（ESM）和 CommonJS 模块（CJS）。它们对于导入和导出有不同的语法和语义。在使用 ESM 和 CJS 模块的 TypeScript 项目中工作时，将 esModuleInterop 设置为 true 可确保 TypeScript 以与两种模块系统都兼容的方式处理导入和导出。如果你正在使用同时使用 CJS 和 ESM 的第三方库，建议这样做。\nlib – 指定在类型检查时要包含的库。TypeScript 包括了 JavaScript 内置对象（如 Array、String、Promise 等）的类型声明（类型定义）。这些声明定义了这些对象的形状和行为，允许 TypeScript 提供准确的类型检查和 IntelliSense 支持。默认情况下，TypeScript 根据您的项目目标的 ECMAScript 版本，包含了一套标准的库声明（dom、es5、es6 等）。但是，您可以使用 “lib” 选项自定义要包含的库，以更精确地匹配您项目的环境。例如，如果您仅面向 Node.js，您可能会排除像 dom 这样的浏览器特定声明。\nsourceMap – 生成源映射文件（.map），以帮助调试。源映射文件是将生成的 JavaScript 代码映射回其原始 TypeScript 源代码的文件。在使用调试工具时，源映射允许您设置断点、检查变量，并逐步执行您的 TypeScript 代码，就像您在调试原始 TypeScript 源代码一样。设置为 true 以启用源映射的使用。\n\n其他可能有用的设置：\n\njsx – 如果您使用 JSX（例如与 React 一起），此设置决定 您的 JSX 文件应如何被处理（preserve、react、react-native 等）。\nremoveComments – 从您编译的代码中去除注释。如果您要压缩编译后的代码，这非常有帮助。\nsourceRoot – 指定调试器在调试时应该在何处定位 TypeScript 文件，而不是源位置。如果运行时的源文件位置与设计时不同，使用此标志。指定的位置将被嵌入到源映射中，以引导您的调试器。\n\n其他 TSConfig 设置\n\ninclude – 指定 TypeScript 应该在编译过程中包含的文件路径或 glob 模式的数组。只有匹配指定模式的文件才会被考虑进行编译。您可以使用 glob 模式（如：“src/**/*.ts”）来包括特定目录或特定文件扩展名的文件。如果没有指定 include，TypeScript 默认将项目目录中的所有 .ts、.tsx 和 .d.ts 文件纳入编译。\nexclude – 此设置指定 TypeScript 应该从编译过程中排除的文件路径或通配模式数组（即使它们与 include 设置中指定的模式匹配）。您可以使用 exclude 忽略您不想要编译的文件或目录，例如测试文件、构建产物或第三方库。通常您会想要排除您的 node_modules 文件夹。\n\nTSConfig 的额外功能和能力\n声明映射 – 如果在您的 tsconfig.json 中将 declarationMap 设置为 true，TypeScript 可以生成声明映射文件（.d.ts.map）以及声明文件（.d.ts）。声明映射和源映射文件类似，但是特定于 TypeScript 声明文件。这些声明映射提供了生成的声明文件和其对应的源映射文件之间的映射，有助于调试并提供更好的工具支持。\n观察模式 – TypeScript 的观察模式 tsc --watch 监控您的 TypeScript 文件的更改，并在它们被修改时自动重新编译。这在开发过程中非常有用，因为它加快了反馈循环并消除了在每次更改后手动触发编译的需要。\n增量构建 – TypeScript 的增量构建功能跟踪您项目文件和依赖的更改，允许它只重新构建自上次编译以来已更改的项目部分。这可以提高大型项目的编译时间。\n覆盖选项 – 您可以使用 TypeScript 源文件中的注释指令覆盖特定文件或一组文件的特定编译器选项。例如，您可以使用 // @ts-ignore 禁用某些严格检查或者为代码的特定部分指定自定义编译器选项 // @ts-nocheck。\n使用您的 tsconfig.json 文件作为一个通道，释放 TypeScript 在您项目中的全部潜力。通过理解其目的并利用它的能力，您可以自信地拥抱 TypeScript，获得更可靠、高效和愉快的开发体验。\n为了让您开始，这里有一个由社区拥有的 TSConfig 基础文件的仓库，适用于您选择的运行时环境，然后您只需要关注项目的独特选择。\n接下来是什么？\n越来越多的开发者使用 TypeScript 来构建更高质量的代码库并且提高生产力。希望这篇文章能够使大家对使用 tsconfig.json 设置新的 TypeScript 项目时有所启发。\n不过，如果您有兴趣在不进行任何配置的情况下深入了解 TypeScript，Deno 原生支持 TypeScript。只需创建一个 .ts 文件，编写一些类型定义，然后立即使用 deno run your_file.ts 运行它。"},"C-Knowledge/前端/开发技术/移动端适配":{"title":"移动端适配","links":["Web-Clip/@移动端适配原理与方案详解---掘金","C-Knowledge/前端/职业规划/前端面试宝典/八股文/实现小于-1px-像素的边","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别！"],"tags":["编程/FE/适配"],"content":"扩展阅读\n\n@移动端适配原理与方案详解 - 掘金\n实现小于 1px 像素的边\n说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别！\n"},"C-Knowledge/前端/开发技术/编程学习资源":{"title":"编程学习资源","links":["C-Knowledge/前端/开发技术/极客时间","C-Knowledge/前端/开发技术/慕课网","C-Knowledge/前端/开发技术/B-站课程","C-Knowledge/前端/开发技术/掘金小册子","C-Knowledge/前端/开发技术/牛客网","C-Knowledge/前端/开发技术/面试学习资源","D-Unsorted/Python-学习资源","C-Knowledge/前端/工程化/工程化学习资源","C-Knowledge/前端/开发工具/浏览器/浏览器学习资源","C-Knowledge/前端/开发技术/HTML-and-CSS/CSS-学习资源","D-Unsorted/HTML-学习资源","C-Knowledge/前端/开发技术/JavaScript/Javascript学习资源","C-Knowledge/前端/开发技术/Typescript-学习资源","C-Knowledge/前端/开发技术/Vue/Vue-学习资源","C-Knowledge/前端/开发技术/可视化学习资源","C-Knowledge/前端/开发技术/音视频/音视频学习资源","C-Knowledge/前端/开发技术/React/React-学习资源","D-Unsorted/WebGL学习资源","D-Unsorted/three.js-学习资源","C-Knowledge/前端/开发技术/网络学习资源","C-Knowledge/前端/开发工具/服务器/Docker学习资源","C-Knowledge/前端/开发工具/OS/Linux/Linux学习资源","C-Knowledge/前端/开发技术/Node学习资源","C-Knowledge/前端/开发技术/Git学习资源","C-Knowledge/前端/开发技术/AI学习资源","C-Knowledge/前端/开发技术/Canvas学习资源","C-Knowledge/前端/开发技术/免费技术书籍"],"tags":["编程"],"content":"学习课程\n\n极客时间\n慕课网\nB 站课程\n掘金小册子\n牛客网\n\n学习资源\n\n面试学习资源\nPython 学习资源.md\n工程化学习资源\n浏览器学习资源\nCSS 学习资源\nHTML 学习资源\nJavascript学习资源\nTypescript 学习资源\nVue 学习资源\n可视化学习资源\n音视频学习资源\nReact 学习资源\nWebGL学习资源\nthree.js 学习资源\n网络学习资源\nDocker学习资源\nLinux学习资源\nNode学习资源\nGit学习资源\nAI学习资源\nCanvas学习资源\n\n技术书籍\n\n免费技术书籍\n"},"C-Knowledge/前端/开发技术/音视频/MSE":{"title":"MSE","links":["C-Knowledge/前端/技术书籍/JavaScript教程/video，audio"],"tags":["编程/FE/音视频"],"content":"媒体源扩展 API（MSE） 提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。\n该规范允许通过 JavaScript 为 &lt;audio&gt; 和  &lt;video&gt; 动态构造媒体源，它定义了 MediaSource 对象，作为 HTML 5 中 HTMLMediaElement 的媒体数据源。MediaSource 对象可以有一个或多个 SourceBuffer 对象。应用程序可以向 SourceBuffer 对象动态添加数据片段，并可以根据系统性能及其他因素自适应调整所添加媒体数据的数据质量。来自 SourceBuffer 对象的数据可以解码为音频、视频或文本数据，并由浏览器或播放器处理。与媒体源扩展一同使用的，还是包括媒体原扩展字节流格式注册表及一组预定义的字节流格式规范。\n\n什么是 MSE？\nMSE 全称为 Media Source Extensions。\n此规范扩展了 HTML Media Element [HTML] 允许 JavaScript 生成媒体流以进行播放。允许 JavaScript 生成流支持各种用例，如自适应流和时间转移直播流。\n此规范允许 JavaScript 为 audio 和 video 动态构造媒体流。它定义了一个 MediaSource 对象，该对象可以作为 HtmlMedia 元素的媒体数据源。MediaSource 对象具有一个或多个 SourceBuffer 对象。应用程序将数据段附加到 SourceBuffer 对象，并可以根据系统性能和其他因素调整附加数据的质量。来自 SourceBuffer 对象的数据作为解码和播放的音频、视频和文本数据的曲目缓冲区进行管理。与这些扩展一起使用的字节流规范可在字节流格式注册表 [MSE-registry] 中找到。\n背景\nMSE 大大地扩展了浏览器的媒体播放功能，提供允许 JavaScript  生成媒体流。这可以用于自适应流（adaptive streaming）及随时间变化的视频直播流（live streaming）等应用场景。\n在这之前，浏览器提供的媒体播放功能（音频、视频）都是相当简陋的，一个 video 或者 audio 标签再加上相对应的数据 url 就搞定了。\n&lt;video src=&quot;/xxxx.mp4&quot;&gt;&lt;/video&gt;\n但这缺少了诸如视频分段加载、视频码率切换、部分加载等等现代播放器应该有的功能，所以绝大部分的浏览器视频播放器过去都是基于 Flash 开发的，这也是为什么直到现在2017年中旬，Flash 这个老古董依然在各大视频网站上活着的原因。\nMediaSource 的简单使用\nvar supportMediaSource = &#039;MediaSource&#039; in window // 判断是否支持 MediaSource\nif (supportMediaSource) {\n  // 新建一个 MediaSource 对象，并且把 mediaSource 作为 objectURL 附加到 video 标签上\n  var mediaSource = new MediaSource()\n  var video = document.querySelector(&#039;video&#039;)\n  video.src = URL.createObjectURL(mediaSource)\n  \n  // 监听 mediaSource 上的 sourceOpen 事件\n  mediaSource.addEventListener(&#039;sourceopen&#039;, sourceOpen);\n  function sourceOpen {\n    // todo...\n  }\n}\nSourceBuffer\nSourceBuffer 对象提供了一系列接口，可以 动态地向 MediaSource 中添加视频/音频片段（对于一个 MediaSource，可以同时存在多个 SourceBuffer）。\nfunction sourceOpen () {\n    var mime = &#039;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#039;\n    // 新建一个 sourceBuffer\n    var sourceBuffer = mediaSource.addSourceBuffer(mime);\n \n    // 加载一段 chunk，然后 append 到 sourceBuffer 中\n    fetchBuffer(&#039;/xxxx.mp4&#039;, buffer =&gt; {\n        sourceBuffer.appendBuffer(buffer)\n    })\n}\n \n// 以二进制格式请求某个url\nfunction fetchBuffer (url, callback) {\n    var xhr = new XMLHttpRequest;\n    xhr.open(&#039;get&#039;, url);\n    xhr.responseType = &#039;arraybuffer&#039;;\n    xhr.onload = function () {\n        callback(xhr.response);\n    };\n    xhr.send();\n}\n浏览器兼容性\n\n参考文档\n\nHLS.js：过去，当下和未来\n"},"C-Knowledge/前端/开发技术/音视频/音视频":{"title":"音视频","links":["C-Knowledge/前端/开发技术/音视频/音视频教程","C-Knowledge/前端/开发技术/音视频/音视频开源框架","C-Knowledge/前端/开发技术/音视频/音视频相关协议和标准","C-Knowledge/前端/职业规划/前端面试宝典/八股文/音视频八股文","C-Knowledge/前端/开发技术/音视频/音视频相关案例","C-Knowledge/前端/开发技术/音视频/音视频学习资源"],"tags":["编程/FE/音视频"],"content":"\n音视频教程\n音视频开源框架\n音视频相关协议和标准\n音视频八股文\n音视频相关案例\n音视频学习资源\n"},"C-Knowledge/前端/开发技术/音视频/音视频学习资源":{"title":"音视频学习资源","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/多媒体前端手册","C-Knowledge/前端/开发技术/音视频/WebRTC-教程-阮一峰","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/从-0-打造音视频直播系统","C-Knowledge/前端/开发技术/音视频/H264系列--压缩编码技术","C-Knowledge/前端/开发技术/音视频/webrtc建立连接之ICE框架","C-Knowledge/前端/开发技术/音视频/流媒体协议介绍（rtp-and-rtcp-and-rtsp-and-rtmp-and-mms-and-hls）","C-Knowledge/前端/开发技术/音视频/常见音视频编码格式"],"tags":["编程/学习资源","编程/FE/音视频"],"content":"前端多媒体\n音视频库\n\nHLS.js：过去，当下和未来\n快手 · 音视频技术入门课\n多媒体前端手册\n\nWebRTC\n\nWebRTC：实现私有化会议直播系统\n\nWebRTC 在线测试地址\n\n\nWebRTC 教程-阮一峰\n从 0 打造音视频直播系统\n\n原理\n\nH 264 编码原理\n视频的基本知识封装格式、编码、码率、帧率、分辨率\nHTML5点播m3u8(hls)格式视频\nH264系列—压缩编码技术\nwebrtc建立连接之ICE框架\n流媒体协议介绍（rtp&amp;rtcp&amp;rtsp&amp;rtmp&amp;mms&amp;hls）\n常见音视频编码格式\n"},"C-Knowledge/前端/技术书籍/CSS-新世界/CSS-新世界":{"title":"CSS 新世界","links":["C-Knowledge/前端/技术书籍/CSS-新世界/CSS新世界概述","C-Knowledge/前端/技术书籍/CSS-新世界/互通互联的-CSS-数据类型","C-Knowledge/前端/技术书籍/CSS-新世界/学会看懂CSS属性值定义语法","C-Knowledge/前端/技术书籍/CSS-新世界/了解CSS全局关键字属性值","C-Knowledge/前端/技术书籍/CSS-新世界/指代所有CSS属性的all属性","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-新特性的渐进增强处理技巧","C-Knowledge/前端/技术书籍/CSS-新世界/贯穿全书的尺寸体系","C-Knowledge/前端/技术书籍/CSS-新世界/深入了解-CSS-逻辑属性","C-Knowledge/前端/技术书籍/CSS-新世界/在-CSS-边框上做文章","C-Knowledge/前端/技术书籍/CSS-新世界/position-属性的增强","C-Knowledge/前端/技术书籍/CSS-新世界/font-family-属性和@font-face-规则新特性","C-Knowledge/前端/技术书籍/CSS-新世界/字符单元的中断与换行","C-Knowledge/前端/技术书籍/CSS-新世界/text-align-属性相关的新特性","C-Knowledge/前端/技术书籍/CSS-新世界/text-decoration-属性全新升级","C-Knowledge/前端/技术书籍/CSS-新世界/color-属性与颜色设置","C-Knowledge/前端/技术书籍/CSS-新世界/必学必会的-background-属性新特性","C-Knowledge/前端/技术书籍/CSS-新世界/outline-相关新属性-outline-offset","C-Knowledge/前端/技术书籍/CSS-新世界/cursor-属性新增的手形效果","C-Knowledge/前端/技术书籍/CSS-新世界/透明度控制属性-opacity","深入了解圆角属性-border-radius","C-Knowledge/前端/技术书籍/CSS-新世界/box-shadow-盒阴影","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-2D-变换","C-Knowledge/前端/技术书籍/CSS-新世界/简单实用的-calc-()函数","C-Knowledge/前端/技术书籍/CSS-新世界/CSS渐变","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-3D-变换","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-过渡","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-动画","C-Knowledge/前端/技术书籍/CSS-新世界/分栏布局","C-Knowledge/前端/技术书籍/CSS-新世界/弹性布局","C-Knowledge/前端/技术书籍/CSS-新世界/网格布局","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-Shapes-布局","C-Knowledge/前端/技术书籍/CSS-新世界/@media-规则","C-Knowledge/前端/技术书籍/CSS-新世界/环境变量函数-env-()","C-Knowledge/前端/技术书籍/CSS-新世界/rem-和-vw-单位与移动端适配最佳实践","C-Knowledge/前端/技术书籍/CSS-新世界/使用-touch-action-属性控制设备的触摸行为","C-Knowledge/前端/技术书籍/CSS-新世界/image-set-()函数与多倍图设置","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-变量的语法、特性和细节","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-自定义属性的设置与获取","C-Knowledge/前端/技术书籍/CSS-新世界/使用-content-属性显示-CSS-自定义属性值的技巧","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-变量的自定义语法技术简介","C-Knowledge/前端/技术书籍/CSS-新世界/文字的美化与装饰","C-Knowledge/前端/技术书籍/CSS-新世界/文字的旋转与阅读方向","C-Knowledge/前端/技术书籍/CSS-新世界/文本字符的尺寸控制","C-Knowledge/前端/技术书籍/CSS-新世界/文字渲染与字体呈现","C-Knowledge/前端/技术书籍/CSS-新世界/字体特征和变体","C-Knowledge/前端/技术书籍/CSS-新世界/可变字体","C-Knowledge/前端/技术书籍/CSS-新世界/图片和视频元素的内在尺寸控制","C-Knowledge/前端/技术书籍/CSS-新世界/使用-image-orientation-属性纠正图片的方向","C-Knowledge/前端/技术书籍/CSS-新世界/image-rendering-属性与图像的渲染","C-Knowledge/前端/技术书籍/CSS-新世界/不常用的图像类型函数","C-Knowledge/前端/技术书籍/CSS-新世界/深入了解-CSS-滤镜属性-filter","C-Knowledge/前端/技术书籍/CSS-新世界/姐妹花滤镜属性-backdrop-filter","C-Knowledge/前端/技术书籍/CSS-新世界/深入了解-CSS-混合模式","C-Knowledge/前端/技术书籍/CSS-新世界/混合模式属性-background-blend-mode","C-Knowledge/前端/技术书籍/CSS-新世界/使用-isolation-isolate-声明隔离混合模式","C-Knowledge/前端/技术书籍/CSS-新世界/超级实用的-CSS-遮罩","C-Knowledge/前端/技术书籍/CSS-新世界/同样实用的-CSS-剪裁属性-clip-path","C-Knowledge/前端/技术书籍/CSS-新世界/-webkit-box-reflect-属性与倒影效果的实现","C-Knowledge/前端/技术书籍/CSS-新世界/使用-offset-属性实现元素的不规则运动","C-Knowledge/前端/技术书籍/CSS-新世界/滚动行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/点击行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/拉伸行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/输入行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/选择行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/打印行为相关","C-Knowledge/前端/技术书籍/CSS-新世界/性能增强","C-Knowledge/前端/技术书籍/CSS-新世界/SVG-元素的-CSS-控制","C-Knowledge/前端/技术书籍/CSS-新世界/Houdini-是-CSS-新的未来"],"tags":["编程/FE/CSS"],"content":"概述\n需要提前了解的知识\n\n互通互联的 CSS 数据类型\n学会看懂CSS属性值定义语法\n了解CSS全局关键字属性值\n指代所有CSS属性的all属性\nCSS 新特性的渐进增强处理技巧\n\n从增强已有的 CSS 属性开始\n\n贯穿全书的尺寸体系\n深入了解 CSS 逻辑属性\n在 CSS 边框上做文章\nposition 属性的增强\nfont-family 属性和@font-face 规则新特性\n字符单元的中断与换行\ntext-align 属性相关的新特性\ntext-decoration 属性全新升级\ncolor 属性与颜色设置\n必学必会的 background 属性新特性\noutline 相关新属性 outline-offset\ncursor 属性新增的手形效果\n\n更细致的样式表现\n\n透明度控制属性 opacity\n[深入了解圆角属性 border-radius]\nbox-shadow 盒阴影\nCSS 2D 变换\n简单实用的 calc ()函数\n\n更强的视觉表现\n\nCSS渐变\nCSS 3D 变换\nCSS 过渡\nCSS 动画\n\n全新的布局方式\n\n分栏布局\n弹性布局\n网格布局\nCSS Shapes 布局\n\n不同设备的适配与响应\n\n@media 规则\n环境变量函数 env ()\nrem 和 vw 单位与移动端适配最佳实践\n使用 touch-action 属性控制设备的触摸行为\nimage-set ()函数与多倍图设置\n\nCSS 的变量函数 var ()与自定义属性\n\nCSS 变量的语法、特性和细节\nCSS 自定义属性的设置与获取\n使用 content 属性显示 CSS 自定义属性值的技巧\nCSS 变量的自定义语法技术简介\n\n文本字符处理能力的升级\n\n文字的美化与装饰\n文字的旋转与阅读方向\n文本字符的尺寸控制\n文字渲染与字体呈现\n字体特征和变体\n可变字体\n\n图片等多媒体的处理\n\n图片和视频元素的内在尺寸控制\n使用 image-orientation 属性纠正图片的方向\nimage-rendering 属性与图像的渲染\n不常用的图像类型函数\n\n更绚丽的视觉表现\n\n深入了解 CSS 滤镜属性 filter\n姐妹花滤镜属性 backdrop-filter\n深入了解 CSS 混合模式\n混合模式属性 background-blend-mode\n使用 isolation-isolate 声明隔离混合模式\n\n更丰富的图形处理\n\n超级实用的 CSS 遮罩\n同样实用的 CSS 剪裁属性 clip-path\n-webkit-box-reflect 属性与倒影效果的实现\n使用 offset 属性实现元素的不规则运动\n\n用户行为与体验增强\n\n滚动行为相关\n点击行为相关\n拉伸行为相关\n输入行为相关\n选择行为相关\n打印行为相关\n性能增强\n\nSVG 元素的 CSS 控制\nHoudini 是 CSS 新的未来"},"C-Knowledge/前端/技术书籍/CSS世界/CSS世界":{"title":"CSS世界","links":["C-Knowledge/前端/技术书籍/CSS世界/CSS世界的“世界观”","C-Knowledge/前端/技术书籍/CSS世界/世界都是创造出来的","C-Knowledge/前端/技术书籍/CSS世界/CSS完胜SVG的武器——流","C-Knowledge/前端/技术书籍/CSS世界/CSS世界的开启从IE8开始","C-Knowledge/前端/技术书籍/CSS世界/table自己的世界","C-Knowledge/前端/技术书籍/CSS世界/CSS新世界——CSS3","C-Knowledge/前端/技术书籍/CSS世界/务必了解的CSS世界的专业术语","C-Knowledge/前端/技术书籍/CSS世界/了解CSS世界中的“未定义行为”","C-Knowledge/前端/技术书籍/CSS世界/块级元素","C-Knowledge/前端/技术书籍/CSS世界/width和height作用的具体细节","C-Knowledge/前端/技术书籍/CSS世界/CSS-min-width或max-width-和-min-height或max-height-二三事max-height-二三事","C-Knowledge/前端/技术书籍/CSS世界/内联元素","C-Knowledge/前端/技术书籍/CSS世界/深入理解content","C-Knowledge/前端/技术书籍/CSS世界/温和的padding属性","C-Knowledge/前端/技术书籍/CSS世界/激进的margin属性","C-Knowledge/前端/技术书籍/CSS世界/功勋卓越的-border-属性","C-Knowledge/前端/技术书籍/CSS世界/字母-x-——CSS-世界中隐匿的举足轻重的角色","C-Knowledge/前端/技术书籍/CSS世界/内联元素的基石line-height","C-Knowledge/前端/技术书籍/CSS世界/line-height-的好朋友-vertical-align","C-Knowledge/前端/技术书籍/CSS世界/魔鬼属性float","C-Knowledge/前端/技术书籍/CSS世界/float-的天然克星-clear","C-Knowledge/前端/技术书籍/CSS世界/CSS-世界的结界——BFC","C-Knowledge/前端/技术书籍/CSS世界/最佳结界-overflow","C-Knowledge/前端/技术书籍/CSS世界/float-的兄弟-position：absolute","C-Knowledge/前端/技术书籍/CSS世界/absolute-与-overflow","C-Knowledge/前端/技术书籍/CSS世界/absolute与clip","C-Knowledge/前端/技术书籍/CSS世界/absolute的流体特性","C-Knowledge/前端/技术书籍/CSS世界/position：relative-才是大哥","C-Knowledge/前端/技术书籍/CSS世界/强悍的position：fixed固定定位","C-Knowledge/前端/技术书籍/CSS世界/CSS-世界的层叠规则","C-Knowledge/前端/技术书籍/CSS世界/line-height-的另外一个朋友-font-size","C-Knowledge/前端/技术书籍/CSS世界/字体属性家族的大家长-font-family","C-Knowledge/前端/技术书籍/CSS世界/字体家族其他成员","C-Knowledge/前端/技术书籍/CSS世界/font-属性","C-Knowledge/前端/技术书籍/CSS世界/真正了解@font-face-规则","C-Knowledge/前端/技术书籍/CSS世界/文本的控制","C-Knowledge/前端/技术书籍/CSS世界/了解：first-letter：first-line-伪元素","C-Knowledge/前端/技术书籍/CSS世界/CSS-世界的-color-很单调","C-Knowledge/前端/技术书籍/CSS世界/CSS-世界的-background-很单调","C-Knowledge/前端/技术书籍/CSS世界/display-与元素的显隐","C-Knowledge/前端/技术书籍/CSS世界/visibility-与元素的显隐","C-Knowledge/前端/技术书籍/CSS世界/和-border-形似的-outline-属性","C-Knowledge/前端/技术书籍/CSS世界/光标属性-cursor","C-Knowledge/前端/技术书籍/CSS世界/改变水平流向的-direction","C-Knowledge/前端/技术书籍/CSS世界/改变-CSS-世界纵横规则的-writing-mode"],"tags":["编程/FE/CSS"],"content":"概述\n\nCSS世界的“世界观”\n世界都是创造出来的\nCSS完胜SVG的武器——流\nCSS世界的开启从IE8开始\ntable自己的世界\nCSS新世界——CSS3\n\n需提前了解的术语和概念\n\n务必了解的CSS世界的专业术语\n了解CSS世界中的“未定义行为”\n\n流、元素与基本尺寸\n\n块级元素\nwidth和height作用的具体细节\nCSS min-width或max-width 和 min-height或max-height 二三事max-height 二三事\n内联元素\n\n盒子尺寸四大家族\n\n深入理解content\n温和的padding属性\n激进的margin属性\n功勋卓越的 border 属性\n\n内联元素与流\n\n字母 x ——CSS 世界中隐匿的举足轻重的角色\n内联元素的基石line-height\nline-height 的好朋友 vertical-align\n\n流的破坏与保护\n\n魔鬼属性float\nfloat 的天然克星 clear\nCSS 世界的结界——BFC\n最佳结界 overflow\nfloat 的兄弟 position：absolute\nabsolute 与 overflow\nabsolute与clip\nabsolute的流体特性\nposition：relative 才是大哥\n强悍的position：fixed固定定位\n\nCSS 世界的层叠规则\n强大的文本处理能力\n\nline-height 的另外一个朋友 font-size\n字体属性家族的大家长 font-family\n字体家族其他成员\nfont 属性\n真正了解@font face 规则\n文本的控制\n了解：first-letter：first-line 伪元素\n\n元素的装饰与美化\n\nCSS 世界的 color 很单调\nCSS 世界的 background 很单调\n\n元素的显示与隐藏\n\ndisplay 与元素的显隐\nvisibility 与元素的显隐\n\n用户界面样式\n\n和 border 形似的 outline 属性\n光标属性 cursor\n\n流向的改变\n\n改变水平流向的 direction\n改变 CSS 世界纵横规则的 writing-mode\n"},"C-Knowledge/前端/技术书籍/ES6-入门教程/ES6-入门教程":{"title":"ES6 入门教程","links":["C-Knowledge/前端/技术书籍/ES6-入门教程/ECMAScript-6-简介","C-Knowledge/前端/技术书籍/ES6-入门教程/let-和-const-命令","C-Knowledge/前端/技术书籍/ES6-入门教程/变量的解构赋值","C-Knowledge/前端/技术书籍/ES6-入门教程/字符串的扩展","D-Unsorted/字符串的新增方法","D-Unsorted/正则的扩展","C-Knowledge/前端/技术书籍/ES6-入门教程/数值的扩展","C-Knowledge/前端/技术书籍/ES6-入门教程/函数的扩展","C-Knowledge/前端/技术书籍/ES6-入门教程/数组的扩展","D-Unsorted/对象的扩展","D-Unsorted/对象的新增方法","D-Unsorted/运算符的扩展","D-Unsorted/Symbol","C-Knowledge/前端/技术书籍/ES6-入门教程/Set-和-Map-数据结构","C-Knowledge/前端/技术书籍/ES6-入门教程/Proxy","C-Knowledge/前端/技术书籍/ES6-入门教程/Reflect","C-Knowledge/前端/技术书籍/ES6-入门教程/Promise-对象","D-Unsorted/Iterator-和-for...of-循环","C-Knowledge/前端/技术书籍/ES6-入门教程/Generator-函数的语法","D-Unsorted/Generator-函数的异步应用","D-Unsorted/async-函数","D-Unsorted/Class-的基本语法","D-Unsorted/Class-的继承","C-Knowledge/前端/技术书籍/ES6-入门教程/Module-的语法","D-Unsorted/Module-的加载实现","D-Unsorted/编程风格","D-Unsorted/读懂规格","D-Unsorted/异步遍历器","C-Knowledge/前端/技术书籍/ES6-入门教程/ArrayBuffer","D-Unsorted/最新提案","C-Knowledge/前端/技术书籍/ES6-入门教程/Decorator","C-Knowledge/前端/技术书籍/ES6-入门教程/ES6-参考链接"],"tags":["编程/书籍","编程/ES6","编程/JavaScript"],"content":"\nECMAScript 6 简介\nlet 和 const 命令\n变量的解构赋值\n字符串的扩展\n字符串的新增方法\n正则的扩展\n数值的扩展\n函数的扩展\n数组的扩展\n对象的扩展\n对象的新增方法\n运算符的扩展\nSymbol\nSet 和 Map 数据结构\nProxy\nReflect\nPromise 对象\nIterator 和 for…of 循环\nGenerator 函数的语法\nGenerator 函数的异步应用\nasync 函数\nClass 的基本语法\nClass 的继承\nModule 的语法\nModule 的加载实现\n编程风格\n读懂规格\n异步遍历器\nArrayBuffer\n最新提案\nDecorator\nES6-参考链接\n"},"C-Knowledge/前端/技术书籍/HTML-教程/'img'":{"title":"'img'","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/解决canvas图片getImageData,toDataURL跨域问题"],"tags":["编程/FE/HTML"],"content":"概述\n&lt;img&gt;元素用于插入图片，主要继承了 HTMLImageElement 接口。\n浏览器提供一个原生构造函数Image，用于生成HTMLImageElement实例。\nvar img = new Image();\nimg instanceof Image // true\nimg instanceof HTMLImageElement // true\nImage构造函数可以接受两个整数作为参数，分别表示&lt;img&gt;元素的宽度和高度。\n// 语法\nImage(width, height)\n \n// 用法\nvar myImage = new Image(100, 200);\n&lt;img&gt;实例的src属性可以定义图像的网址。\nvar img = new Image();\nimg.src = &#039;picture.jpg&#039;;\n新生成的&lt;img&gt;实例并不属于文档的一部分。如果想让它显示在文档中，必须手动插入文档。\nvar img = new Image();\nimg.src = &#039;image1.png&#039;;\ndocument.body.appendChild(img);\n除了使用Image构造，下面的方法也可以得到HTMLImageElement实例。\n\ndocument.images的成员\n节点选取方法（比如document.getElementById）得到的&lt;img&gt;节点\ndocument.createElement(&#039;img&#039;)生成的&lt;img&gt;节点\n\ndocument.images[0] instanceof HTMLImageElement\n// true\n \nvar img = document.getElementById(&#039;myImg&#039;);\nimg instanceof HTMLImageElement\n// true\n \nvar img = document.createElement(&#039;img&#039;);\nimg instanceof HTMLImageElement\n// true\nHTMLImageElement实例除了具有 Node、Element、HTMLElement 接口以外，还拥有一些独有的属性。这个接口没有定义自己的方法。\n特性相关的属性\n（1）HTMLImageElement.src\nHTMLImageElement.src属性返回图像的完整网址。\n// HTML 代码如下\n// &lt;img width=&quot;300&quot; height=&quot;400&quot; id=&quot;myImg&quot; src=&quot;example.com/pic.jpg&quot;&gt;\nvar img = document.getElementById(&#039;img&#039;);\nimg.src // example.com/pic.jpg\n（2）HTMLImageElement.currentSrc\nHTMLImageElement.currentSrc属性返回当前正在展示的图像的网址。JavaScript 和 CSS 的 mediaQuery 都可能改变正在展示的图像。\n（3）HTMLImageElement.alt\nHTMLImageElement.alt属性可以读写&lt;img&gt;的 HTML 属性alt，表示对图片的文字说明。\n（4）HTMLImageElement.isMap，HTMLImageElement.useMap\nHTMLImageElement.isMap属性对应&lt;img&gt;元素的 HTML 属性ismap，返回一个布尔值，表示图像是否为服务器端的图像映射的一部分。\nHTMLImageElement.useMap属性对应&lt;img&gt;元素的 HTML 属性usemap，表示当前图像对应的&lt;map&gt;元素。\n（5）HTMLImageElement.srcset，HTMLImageElement.sizes\nHTMLImageElement.srcset 属性和 HTMLImageElement.sizes 属性，分别用于读写 &lt;img&gt; 元素的 srcset 属性和 sizes 属性。它们用于 &lt;img&gt; 元素的响应式加载。srcset 属性可以单独使用，但是 sizes 属性必须与 srcset 属性同时使用。\n// HTML 代码如下\n// &lt;img srcset=&quot;example-320w.jpg 320w,\n//              example-480w.jpg 480w,\n//              example-800w.jpg 800w&quot;\n//      sizes=&quot;(max-width: 320px) 280px,\n//             (max-width: 480px) 440px,\n//             800px&quot;\n//      id=&quot;myImg&quot;\n//      src=&quot;example-800w.jpg&quot;&gt;\nvar img = document.getElementById(&#039;myImg&#039;);\nimg.srcset\n// &quot;example-320w.jpg 320w,\n//  example-480w.jpg 480w,\n//  example-800w.jpg 800w&quot;\n \nimg.sizes\n// &quot;(max-width: 320px) 280px,\n//  (max-width: 480px) 440px,\n//  800px&quot;\n上面代码中，sizes属性指定，对于小于320px的屏幕，图像的宽度为280px；对于小于480px的屏幕，图像宽度为440px；其他情况下，图像宽度为800px。然后，浏览器会根据当前屏幕下的图像宽度，到srcset属性加载宽度最接近的图像。\nHTMLImageElement.width，HTMLImageElement.height\nwidth属性表示&lt;img&gt;的 HTML 宽度，height属性表示高度。这两个属性返回的都是整数。\n// HTML 代码如下\n// &lt;img width=&quot;300&quot; height=&quot;400&quot; id=&quot;myImg&quot; src=&quot;pic.jpg&quot;&gt;\nvar img = document.getElementById(&#039;img&#039;);\nimg.width // 300\nimg.height // 400\n如果图像还没有加载，这两个属性返回的都是0。\n如果 HTML 代码没有设置width和height属性，则它们返回的是图像的实际宽度和高度，即HTMLImageElement.naturalWidth属性和HTMLImageElement.naturalHeight属性。\nHTMLImageElement.naturalWidth，HTMLImageElement.naturalHeight\nHTMLImageElement.naturalWidth属性表示图像的实际宽度（单位像素），HTMLImageElement.naturalHeight属性表示实际高度。这两个属性返回的都是整数。\n如果图像还没有指定或不可得，这两个属性都等于0。\nvar img = document.getElementById(&#039;img&#039;);\nif (img.naturalHeight &gt; img.naturalWidth) {\n  img.classList.add(&#039;portrait&#039;);\n}\n上面代码中，如果图片的高度大于宽度，则设为portrait模式。\nHTMLImageElement.complete\nHTMLImageElement.complete属性返回一个布尔值，表示图表是否已经加载完成。如果&lt;img&gt;元素没有src属性，也会返回true。\nHTMLImageElement.crossOrigin\nHTMLImageElement.crossOrigin属性用于读写&lt;img&gt;元素的crossorigin属性，表示 跨域设置。\n这个属性有两个可能的值。\n\nanonymous：跨域请求不要求用户身份（credentials），这是默认值。\nuse-credentials：跨域请求要求用户身份。\n\n// HTML 代码如下\n// &lt;img crossorigin=&quot;anonymous&quot; id=&quot;myImg&quot; src=&quot;pic.jpg&quot;&gt;\nvar img = document.getElementById(&#039;img&#039;);\nimg.crossOrigin // &quot;anonymous&quot;\nHTMLImageElement.referrerPolicy\nHTMLImageElement.referrerPolicy用来读写&lt;img&gt;元素的 HTML 属性referrerpolicy，表示请求图像资源时，如何处理 HTTP 请求的referrer字段。\n它有五个可能的值。\n\nno-referrer：不带有referrer字段。\nno-referrer-when-downgrade：如果请求的地址不是 HTTPS 协议，就不带有referrer字段，这是默认值。\norigin：referrer字段是当前网页的地址，包含协议、域名和端口。\norigin-when-cross-origin：如果请求的地址与当前网页是同源关系，那么referrer字段将带有完整路径，否则将只包含协议、域名和端口。\nunsafe-url：referrer字段包含当前网页的地址，除了协议、域名和端口以外，还包括路径。这个设置是不安全的，因为会泄漏路径信息。\n\nHTMLImageElement.x，HTMLImageElement.y\nHTMLImageElement.x属性返回图像左上角相对于页面左上角的横坐标，HTMLImageElement.y属性返回纵坐标。\n事件属性\n图像加载完成，会触发onload属性指定的回调函数。\n// HTML 代码为 &lt;img src=&quot;example.jpg&quot; onload=&quot;loadImage()&quot;&gt;\nfunction loadImage() {\n  console.log(&#039;Image is loaded&#039;);\n}\n图像加载过程中发生错误，会触发onerror属性指定的回调函数。\n// HTML 代码为 &lt;img src=&quot;image.gif&quot; onerror=&quot;myFunction()&quot;&gt;\nfunction myFunction() {\n  console.log(&#039;There is something wrong&#039;);\n}"},"C-Knowledge/前端/技术书籍/HTML-教程/HTML-教程":{"title":"HTML 教程","links":["C-Knowledge/前端/技术书籍/HTML-教程/HTML-简介","C-Knowledge/前端/技术书籍/HTML-教程/URL-简介","C-Knowledge/前端/技术书籍/HTML-教程/元素的属性","C-Knowledge/前端/技术书籍/HTML-教程/字符编码","C-Knowledge/前端/技术书籍/HTML-教程/语义结构","C-Knowledge/前端/技术书籍/HTML-教程/文本标签","C-Knowledge/前端/技术书籍/HTML-教程/列表标签","C-Knowledge/前端/技术书籍/HTML-教程/图像标签","C-Knowledge/前端/技术书籍/HTML-教程/'a'","C-Knowledge/前端/技术书籍/HTML-教程/'link'","C-Knowledge/前端/技术书籍/HTML-教程/'script'，'noscript'","C-Knowledge/前端/技术书籍/HTML-教程/多媒体标签","C-Knowledge/前端/技术书籍/HTML-教程/iframe","C-Knowledge/前端/技术书籍/HTML-教程/表格","C-Knowledge/前端/技术书籍/HTML-教程/表单","C-Knowledge/前端/技术书籍/HTML-教程/其他标签"],"tags":["编程/FE/HTML"],"content":"\n HTML 简介\n URL 简介\n 元素的属性\n 字符编码\n 语义结构\n 文本标签\n 列表标签\n 图像标签\n ‘a’\n ‘link’\n ‘script’，‘noscript’\n 多媒体标签\n iframe\n 表格\n 表单\n 其他标签\n"},"C-Knowledge/前端/技术书籍/JavaScript教程/History-对象":{"title":"History 对象","links":[],"tags":["编程/JavaScript/浏览器"],"content":"概述\nwindow.history属性指向 History 对象，它表示当前窗口的浏览历史。\nHistory 对象保存了当前窗口访问过的所有页面网址。下面代码表示当前窗口一共访问过3个网址。\nwindow.history.length // 3\n由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。\n// 后退到前一个网址\nhistory.back()\n \n// 等同于\nhistory.go(-1)\n浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。\n属性\nHistory 对象主要有两个属性。\n\nHistory.length：当前窗口访问过的网址数量（包括当前网页）\nHistory.state：History 堆栈最上层的状态值（详见下文）\n\n// 当前窗口访问过多少个网页\nwindow.history.length // 1\n \n// History 对象的当前状态\n// 通常是 undefined，即未设置\nwindow.history.state // undefined\n方法\nHistory.back()、History.forward()、History.go()\n这三个方法用于在历史之中移动。\n\nHistory.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。\nHistory.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。\nHistory.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如go(1)相当于forward()，go(-1)相当于back()。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。\n\nhistory.back();\nhistory.forward();\nhistory.go(-2);\nhistory.go(0)相当于刷新当前页面。\nhistory.go(0); // 刷新当前页面\n\n\n                  \n                  注意❗ \n                  \n                \n注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页 。\n\nHistory.pushState()\nHistory.pushState()方法用于在历史中添加一条记录。\nwindow.history.pushState(state, title, url)\n该方法接受三个参数，依次为：\n\nstate：一个与添加的记录相关联的状态对象，主要用于popstate事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填null。\ntitle：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。\nurl：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。\n\n假定当前网址是example.com/1.html，使用pushState()方法在浏览记录（History 对象）中添加一个新记录。\nvar stateObj = { foo: &#039;bar&#039; };\nhistory.pushState(stateObj, &#039;page 2&#039;, &#039;2.html&#039;);\n添加新记录后，浏览器地址栏立刻显示example.com/2.html，但并不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问google.com)，然后点击了倒退按钮，页面的 URL 将显示2.html；你再点击一次倒退按钮，URL 将显示1.html。\n总之，pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。\n使用该方法之后，就可以用History.state属性读出状态对象。\nvar stateObj = { foo: &#039;bar&#039; };\nhistory.pushState(stateObj, &#039;page 2&#039;, &#039;2.html&#039;);\nhistory.state // {foo: &quot;bar&quot;}\n如果pushState的 URL 参数设置了一个新的锚点值（即hash），并不会触发hashchange事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。\n如果pushState()方法设置了一个跨域网址，则会报错。\n// 报错\n// 当前网址为 example.com\nhistory.pushState(null, &#039;&#039;, &#039;twitter.com/hello&#039;);\n上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。\nHistory.replaceState()\nHistory.replaceState()方法用来修改 History 对象的当前记录，其他都与pushState()方法一模一样。\n假定当前网页是example.com/example.html。\nhistory.pushState({page: 1}, &#039;title 1&#039;, &#039;?page=1&#039;)\n// URL 显示为 example.com/example.html\n \nhistory.pushState({page: 2}, &#039;title 2&#039;, &#039;?page=2&#039;);\n// URL 显示为 example.com/example.html\n \nhistory.replaceState({page: 3}, &#039;title 3&#039;, &#039;?page=3&#039;);\n// URL 显示为 example.com/example.html\n \nhistory.back()\n// URL 显示为 example.com/example.html\n \nhistory.back()\n// URL 显示为 example.com/example.html\n \nhistory.go(2)\n// URL 显示为 example.com/example.html\npopstate 事件\n每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，仅仅调用 pushState() 方法或 replaceState() 方法，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 History.back()、History.forward()、History.go() 方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n使用的时候，可以为popstate事件指定回调函数。\nwindow.onpopstate = function (event) {\n  console.log(&#039;location: &#039; + document.location);\n  console.log(&#039;state: &#039; + JSON.stringify(event.state));\n};\n \n// 或者\nwindow.addEventListener(&#039;popstate&#039;, function(event) {\n  console.log(&#039;location: &#039; + document.location);\n  console.log(&#039;state: &#039; + JSON.stringify(event.state));\n});\n回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的event.state，就是通过pushState和replaceState方法，为当前 URL 绑定的state对象。\n这个state对象也可以直接通过history对象读取。\nvar currentState = history.state;\n\n\n                  \n                  注意❗ \n                  \n                \n注意，页面第一次加载的时候，浏览器不会触发 popstate 事件。\n"},"C-Knowledge/前端/技术书籍/JavaScript教程/JavaScript-教程":{"title":"JavaScript 教程","links":["D-Unsorted/JavaScript-教程-导论","D-Unsorted/JavaScript-的历史","D-Unsorted/JavaScript-的基本语法","D-Unsorted/数据类型概述","D-Unsorted/null，undefined-和布尔值","D-Unsorted/数值","D-Unsorted/字符串","C-Knowledge/前端/技术书籍/JavaScript教程/对象","D-Unsorted/函数","D-Unsorted/数组","D-Unsorted/算术运算符","D-Unsorted/比较运算符","C-Knowledge/前端/技术书籍/JavaScript教程/布尔运算符","C-Knowledge/前端/技术书籍/JavaScript教程/二进制位运算符","D-Unsorted/其他运算符，运算顺序","C-Knowledge/前端/技术书籍/JavaScript教程/数据类型转换","D-Unsorted/错误处理机制","D-Unsorted/JavaScript-教程编程风格","D-Unsorted/console-对象与控制台","C-Knowledge/前端/技术书籍/JavaScript教程/Object-对象","C-Knowledge/前端/技术书籍/JavaScript教程/属性描述对象","C-Knowledge/前端/技术书籍/JavaScript教程/Array-对象","D-Unsorted/包装对象","D-Unsorted/Boolean-对象","D-Unsorted/Number-对象","C-Knowledge/前端/技术书籍/JavaScript教程/String-对象","C-Knowledge/前端/技术书籍/JavaScript教程/Math-对象","D-Unsorted/Date-对象","C-Knowledge/前端/技术书籍/JavaScript教程/RegExp对象","D-Unsorted/JSON-对象","D-Unsorted/实例对象与-new-命令","C-Knowledge/前端/技术书籍/JavaScript教程/this-关键字","D-Unsorted/对象的继承","C-Knowledge/前端/技术书籍/JavaScript教程/Object-对象的相关方法","D-Unsorted/严格模式","D-Unsorted/异步操作概述","D-Unsorted/定时器","D-Unsorted/异步操作Promise-对象","D-Unsorted/DOM-概述","D-Unsorted/Node-接口","D-Unsorted/NodeList-接口，HTMLCollection-接口","D-Unsorted/ParentNode-接口，ChildNode-接口","C-Knowledge/前端/技术书籍/JavaScript教程/Document-节点","D-Unsorted/Element-节点","D-Unsorted/属性的操作","D-Unsorted/Text-节点和-DocumentFragment-节点","D-Unsorted/CSS-操作","D-Unsorted/Mutation-Observer-API","D-Unsorted/EventTarget-接口","C-Knowledge/前端/技术书籍/JavaScript教程/事件模型","D-Unsorted/Event-对象","D-Unsorted/鼠标事件","D-Unsorted/键盘事件","D-Unsorted/进度事件","D-Unsorted/表单事件","D-Unsorted/触摸事件","D-Unsorted/拖拉事件","D-Unsorted/其他常见事件","D-Unsorted/GlobalEventHandlers-接口","D-Unsorted/浏览器模型概述","C-Knowledge/前端/技术书籍/JavaScript教程/window-对象","D-Unsorted/Navigator-对象，Screen-对象","D-Unsorted/Cookie","D-Unsorted/XMLHttpRequest-对象","D-Unsorted/同源限制","D-Unsorted/CORS-通信","C-Knowledge/前端/技术书籍/JavaScript教程/Storage-接口","C-Knowledge/前端/技术书籍/JavaScript教程/History-对象","D-Unsorted/Location-对象，URL-对象，URLSearchParams-对象","C-Knowledge/前端/技术书籍/JavaScript教程/ArrayBuffer-对象，Blob-对象","D-Unsorted/File-对象，FileList-对象，FileReader-对象","D-Unsorted/表单，FormData-对象","D-Unsorted/IndexedDB-API","C-Knowledge/前端/技术书籍/JavaScript教程/Web-Worker","C-Knowledge/前端/技术书籍/HTML-教程/'img'","C-Knowledge/前端/技术书籍/JavaScript教程/'form'","C-Knowledge/前端/技术书籍/JavaScript教程/'input'","C-Knowledge/前端/技术书籍/JavaScript教程/'button'","C-Knowledge/前端/技术书籍/JavaScript教程/'option'","C-Knowledge/前端/技术书籍/JavaScript教程/video，audio"],"tags":["编程/JavaScript"],"content":"入门篇\n\n导论\n历史\nJavaScript 的基本语法\n\n数据类型\n\n概述\nnull，undefined 和布尔值\n数值\n字符串\n对象\n函数\n数组\n\n运算符\n\n算术运算符\n比较运算符\n布尔运算符\n二进制位运算符\n其他运算符，运算顺序\n\n语法专题\n\n数据类型的转换\n错误处理机制\n编程风格\nconsole 对象与控制台\n\n标准库\n\nObject 对象\n属性描述对象\nArray 对象\n包装对象\nBoolean 对象\nNumber 对象\nString 对象\nMath 对象\nDate 对象\nRegExp对象\nJSON 对象\n\n面向对象编程\n\n实例对象与 new 命令\nthis 关键字\n对象的继承\nObject 对象的相关方法\n严格模式\n\n异步操作\n\n概述\n定时器\n异步操作Promise 对象\n\nDOM\n\n概述\nNode 接口\nNodeList 接口，HTMLCollection 接口\nParentNode 接口，ChildNode 接口\nDocument 节点\nElement 节点\n属性的操作\nText 节点和 DocumentFragment 节点\nCSS 操作\nMutation Observer API\n\n事件\n\nEventTarget 接口\n事件模型\nEvent 对象\n鼠标事件\n键盘事件\n进度事件\n表单事件\n触摸事件\n拖拉事件\n其他常见事件\nGlobalEventHandlers 接口\n\n浏览器模型\n\n浏览器模型概述\nwindow 对象\nNavigator 对象，Screen 对象\nCookie\nXMLHttpRequest 对象\n同源限制\nCORS 通信\nStorage 接口\nHistory 对象\nLocation 对象，URL 对象，URLSearchParams 对象\nArrayBuffer 对象，Blob 对象\nFile 对象，FileList 对象，FileReader 对象\n表单，FormData 对象\nIndexedDB API\nWeb Worker\n\n附录：网页元素接口\n\n[[JavaScript-‘a’|&lt;a&gt;]]\n‘img&#039;\n&#039;form&#039;\n&#039;input&#039;\n&#039;button&#039;\n&#039;option’\nvideo，audio\n"},"C-Knowledge/前端/技术书籍/JavaScript教程/video-标签谷歌实现原理":{"title":"video 标签谷歌实现原理","links":[],"tags":["编程/FE/浏览器"],"content":"\n\nHTML5 Audio &amp; Video\nMedia Source Extensions\nEncrypted Media Extensions\n"},"C-Knowledge/前端/技术书籍/JavaScript教程/video，audio":{"title":"video，audio","links":["C-Knowledge/前端/技术书籍/JavaScript教程/video-标签谷歌实现原理"],"tags":["编程/FE/HTML"],"content":"概述\n&lt;video&gt;元素用来加载视频，是HTMLVideoElement对象的实例。&lt;audio&gt;元素用来加载音频，是HTMLAudioElement对象的实例。而HTMLVideoElement和HTMLAudioElement都继承了HTMLMediaElement，所以这两个 HTML 元素有许多共同的属性和方法，可以放在一起介绍。\n理论上，这两个 HTML 元素直接用src属性指定媒体文件，就可以使用了。\n&lt;audio src=&quot;background_music.mp3&quot;/&gt;\n&lt;video src=&quot;news.mov&quot; width=320 height=240/&gt;\n\n\n                  \n                  注意❗ \n                  \n                \n注意，&lt;video&gt; 元素有 width 属性和 height 属性，可以指定宽和高。&lt;audio&gt; 元素没有这两个属性，因为它的播放器外形是浏览器给定的，不能指定。\n\n实际上，不同的浏览器支持不同的媒体格式，我们不得不用&lt;source&gt;元素指定同一个媒体文件的不同格式。\n&lt;audio id=&quot;music&quot;&gt;\n  &lt;source src=&quot;music.mp3&quot; type=&quot;audio/mpeg&quot;&gt;  \n  &lt;source src=&quot;music.ogg&quot; type=&#039;audio/ogg; codec=&quot;vorbis&quot;&#039;&gt;\n&lt;/audio&gt;\n浏览器遇到支持的格式，就会忽略后面的格式。\n这两个元素都有一个controls属性，只有打开这个属性，才会显示控制条。注意，&lt;audio&gt;元素如果不打开controls属性，根本不会显示，而是直接在背景播放。\nHTMLMediaElement 接口\nHTMLMediaElement并没有对应的 HTML 元素，而是作为&lt;video&gt;和&lt;audio&gt;的基类，定义一些它们共同的属性和方法。\nHTMLMediaElement接口有以下属性。\n\nHTMLMediaElement.audioTracks：返回一个类似数组的对象，表示媒体文件包含的音轨。\nHTMLMediaElement.autoplay：布尔值，表示媒体文件是否自动播放，对应 HTML 属性autoplay。\nHTMLMediaElement.buffered：返回一个 TimeRanges 对象，表示浏览器缓冲的内容。该对象的length属性返回缓存里面有多少段内容，start(rangeId)方法返回指定的某段内容（从0开始）开始的时间点，end()返回指定的某段内容结束的时间点。该属性只读。\nHTMLMediaElement.controls：布尔值，表示是否显示媒体文件的控制栏，对应 HTML 属性controls。\nHTMLMediaElement.controlsList：返回一个类似数组的对象，表示是否显示控制栏的某些控件。该对象包含三个可能的值：nodownload、nofullscreen和noremoteplayback。该属性只读。\nHTMLMediaElement.crossOrigin：字符串，表示跨域请求时是否附带用户信息（比如 Cookie），对应 HTML 属性crossorigin。该属性只有两个可能的值：anonymous和use-credentials。\nHTMLMediaElement.currentSrc：字符串，表示当前正在播放的媒体文件的绝对路径。该属性只读。\nHTMLMediaElement.currentTime：浮点数，表示当前播放的时间点。\nHTMLMediaElement.defaultMuted：布尔值，表示默认是否关闭音量，对应 HTML 属性muted。\nHTMLMediaElement.defaultPlaybackRate：浮点数，表示默认的播放速率，默认是1.0。\nHTMLMediaElement.disableRemotePlayback：布尔值，是否允许远程回放，即远程回放的时候是否会有工具栏。\nHTMLMediaElement.duration：浮点数，表示媒体文件的时间长度（单位秒）。如果当前没有媒体文件，该属性返回0。该属性只读。\nHTMLMediaElement.ended：布尔值，表示当前媒体文件是否已经播放结束。该属性只读。\nHTMLMediaElement.error：返回最近一次报错的错误对象，如果没有报错，返回null。\nHTMLMediaElement.loop：布尔值，表示媒体文件是否会循环播放，对应 HTML 属性loop。\nHTMLMediaElement.muted：布尔值，表示音量是否关闭。\nHTMLMediaElement.networkState：当前网络状态，共有四个可能的值。0表示没有数据；1表示媒体元素处在激活状态，但是还没开始下载；2表示下载中；3表示没有找到媒体文件。\nHTMLMediaElement.paused：布尔值，表示媒体文件是否处在暂停状态。该属性只读。\nHTMLMediaElement.playbackRate：浮点数，表示媒体文件的播放速度，1.0是正常速度。如果是负数，表示向后播放。\nHTMLMediaElement.played：返回一个 TimeRanges 对象，表示播放的媒体内容。该属性只读。\nHTMLMediaElement.preload：字符串，表示应该预加载哪些内容，可能的值为none、metadata和auto。\nHTMLMediaElement.readyState：整数，表示媒体文件的准备状态，可能的值为0（没有任何数据）、1（已获取元数据）、2（可播放当前帧，但不足以播放多个帧）、3（可以播放多帧，至少为两帧）、4（可以流畅播放）。该属性只读。\nHTMLMediaElement.seekable：返回一个 TimeRanges 对象，表示一个用户可以搜索的媒体内容范围。该属性只读。\nHTMLMediaElement.seeking：布尔值，表示媒体文件是否正在寻找新位置。该属性只读。\nHTMLMediaElement.src：字符串，表示媒体文件所在的 URL，对应 HTML 属性src。\nHTMLMediaElement.srcObject：返回src属性对应的媒体文件资源，可能是MediaStream、MediaSource、Blob或File对象。直接指定这个属性，就可以播放媒体文件。\nHTMLMediaElement.textTracks：返回一个类似数组的对象，包含所有文本轨道。该属性只读。\nHTMLMediaElement.videoTracks：返回一个类似数组的对象，包含多有视频轨道。该属性只读。\nHTMLMediaElement.volume：浮点数，表示音量。0.0 表示静音，1.0 表示最大音量。\n\nHTMLMediaElement接口有如下方法。\n\nHTMLMediaElement.addTextTrack()：添加文本轨道（比如字幕）到媒体文件。\nHTMLMediaElement.captureStream()：返回一个 MediaStream 对象，用来捕获当前媒体文件的流内容。\nHTMLMediaElement.canPlayType()：该方法接受一个 MIME 字符串作为参数，用来判断这种类型的媒体文件是否可以播放。该方法返回一个字符串，有三种可能的值，probably表示似乎可播放，maybe表示无法在不播放的情况下判断是否可播放，空字符串表示无法播放。\nHTMLMediaElement.fastSeek()：该方法接受一个浮点数作为参数，表示指定的时间（单位秒）。该方法将媒体文件移动到指定时间。\nHTMLMediaElement.load()：重新加载媒体文件。\nHTMLMediaElement.pause()：暂停播放。该方法没有返回值。\nHTMLMediaElement.play()：开始播放。该方法返回一个 Promise 对象。\n\n下面是play()方法的一个例子。\nvar myVideo = document.getElementById(&#039;myVideoElement&#039;);\n \nmyVideo\n.play()\n.then(() =&gt; {\n  console.log(&#039;playing&#039;);\n})\n.catch((error) =&gt; {\n  console.log(error);\n});\nHTMLVideoElement 接口\nHTMLVideoElement接口代表了&lt;video&gt;元素。这个接口继承了HTMLMediaElement接口，并且有一些自己的属性和方法。\nHTMLVideoElement 接口的属性。\n\nHTMLVideoElement.height：字符串，表示视频播放区域的高度（单位像素），对应 HTML 属性height。\nHTMLVideoElement.width：字符串，表示视频播放区域的宽度（单位像素），对应 HTML 属性width。\nHTMLVideoElement.videoHeight：该属性只读，返回一个整数，表示视频文件自身的高度（单位像素）。\nHTMLVideoElement.videoWidth：该属性只读，返回一个整数，表示视频文件自身的宽度（单位像素）。\nHTMLVideoElement.poster：字符串，表示一个图像文件的 URL，用来在无法获取视频文件时替代显示，对应 HTML 属性poster。\n\nHTMLVideoElement 接口的方法。\n\nHTMLVideoElement.getVideoPlaybackQuality()：返回一个对象，包含了当前视频回放的一些数据。\n\nHTMLAudioElement 接口\nHTMLAudioElement接口代表了&lt;audio&gt;元素。\n该接口继承了HTMLMediaElement，但是没有定义自己的属性和方法。浏览器原生提供一个Audio()构造函数，返回的就是HTMLAudioElement实例。\nvar song = new Audio([URLString]);\nAudio()构造函数接受一个字符串作为参数，表示媒体文件的 URL。如果省略这个参数，可以稍后通过src属性指定。\n生成HTMLAudioElement实例以后，不用插入 DOM，可以直接用play()方法在背景播放。\nvar a = new Audio();\nif (a.canPlayType(&#039;audio/wav&#039;)) {\n  a.src = &#039;soundeffect.wav&#039;;\n  a.play();\n}\n事件\n&lt;video&gt;和&lt;audio&gt;元素有以下事件。\n\nloadstart：开始加载媒体文件时触发。\nprogress：媒体文件加载过程中触发，大概是每秒触发2到8次。\nloadedmetadata：媒体文件元数据加载成功时触发。\nloadeddata：当前播放位置加载成功后触发。\ncanplay：已经加载了足够的数据，可以开始播放时触发，后面可能还会请求数据。\ncanplaythrough：已经加载了足够的数据，可以一直播放时触发，后面不需要继续请求数据。\nsuspend：已经缓冲了足够的数据，暂时停止下载时触发。\nstalled：尝试加载数据，但是没有数据返回时触发。\nplay：调用play()方法时或自动播放启动时触发。如果已经加载了足够的数据，这个事件后面会紧跟playing事件，否则会触发waiting事件。\nwaiting：由于没有足够的缓存数据，无法播放或播放停止时触发。一旦缓冲数据足够开始播放，后面就会紧跟playing事件。\nplaying：媒体开始播放时触发。\ntimeupdate：currentTime属性变化时触发，每秒可能触发4到60次。\npause：调用pause()方法、播放暂停时触发。\nseeking：脚本或者用户要求播放某个没有缓冲的位置，播放停止开始加载数据时触发。此时，seeking属性返回true。\nseeked：seeking属性变回false时触发。\nended：媒体文件播放完毕时触发。\ndurationchange：duration属性变化时触发。\nvolumechange：音量变化时触发。\nratechange：播放速度或默认的播放速度变化时触发。\nabort：停止加载媒体文件时触发，通常是用户主动要求停止下载。\nerror：网络或其他原因导致媒体文件无法加载时触发。\nemptied：由于 error 或 abort 事件导致 networkState 属性变成无法获取数据时触发。\n\n\n\nvideo 标签谷歌实现原理\n"},"C-Knowledge/前端/技术书籍/JavaScript教程/事件模型":{"title":"事件模型","links":[],"tags":["编程/JavaScript/事件"],"content":"监听函数\n浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。\nJavaScript 有三种方法，可以为事件绑定监听函数。\nHTML 的 on- 属性\nHTML 语言允许在元素的属性中，直接定义某些事件的监听代码。\n&lt;body onload=&quot;doSomething()&quot;&gt;\n&lt;div onclick=&quot;console.log(&#039;触发事件&#039;)&quot;&gt;\n上面代码为body节点的load事件、div节点的click事件，指定了监听代码。一旦事件发生，就会执行这段代码。\n元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，这些属性的值是将会执行的代码，而不是一个函数。\n\n&lt;!-- 正确 --&gt;\n&lt;body onload=&quot;doSomething()&quot;&gt;\n \n&lt;!-- 错误 --&gt;\n&lt;body onload=&quot;doSomething&quot;&gt;\n一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。\n使用这个方法指定的监听代码，只会在冒泡阶段触发。\n&lt;div onclick=&quot;console.log(2)&quot;&gt;\n  &lt;button onclick=&quot;console.log(1)&quot;&gt;点击&lt;/button&gt;\n&lt;/div&gt;\n上面代码中，&lt;button&gt;是&lt;div&gt;的子元素。&lt;button&gt;的click事件，也会触发&lt;div&gt;的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。\n直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。\nel.setAttribute(&#039;onclick&#039;, &#039;doSomething()&#039;);\n// 等同于\n// &lt;Element onclick=&quot;doSomething()&quot;&gt;\n元素节点的事件属性\n元素节点对象的事件属性，同样可以指定监听函数。\nwindow.onload = doSomething;\n \ndiv.onclick = function (event) {\n  console.log(&#039;触发事件&#039;);\n};\n使用这个方法指定的监听函数，也是只会在冒泡阶段触发。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，这种方法与 HTML 的 on- 属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。\n\nEventTarget.addEventListener()\n所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。\nwindow.addEventListener(&#039;load&#039;, doSomething, false);\naddEventListener 方法的详细介绍，参见 [[EventTarget 接口| EventTarget]] 章节。\n小结\n上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。\n第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。\n第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：\n\n同一个事件可以添加多个监听函数。\n能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。\n除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。\n\nthis 的指向\n监听函数内部的this指向触发事件的那个元素节点。\n&lt;button id=&quot;btn&quot; onclick=&quot;console.log(this.id)&quot;&gt;点击&lt;/button&gt;\n执行上面代码，点击后会输出btn。\n其他两种监听函数的写法，this的指向也是如此。\n// HTML 代码如下\n// &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;\nvar btn = document.getElementById(&#039;btn&#039;);\n \n// 写法一\nbtn.onclick = function () {\n  console.log(this.id);\n};\n \n// 写法二\nbtn.addEventListener(\n  &#039;click&#039;,\n  function (e) {\n    console.log(this.id);\n  },\n  false\n);\n上面两种写法，点击按钮以后也是输出btn。\n事件的传播\n\n\n                  \n                  重点 \n                  \n                \n一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。\n\n第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。\n第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。\n第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。\n\n\n这种三阶段的传播模型，使得同一个事件会在多个节点上触发。\n&lt;div&gt;\n  &lt;p&gt;点击&lt;/p&gt;\n&lt;/div&gt;\n上面代码中，&lt;div&gt;节点之中有一个&lt;p&gt;节点。\n如果对这两个节点，都设置click事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对&lt;p&gt;点击，click事件会触发四次。\nvar phases = {\n  1: &#039;capture&#039;,\n  2: &#039;target&#039;,\n  3: &#039;bubble&#039;\n};\n \nvar div = document.querySelector(&#039;div&#039;);\nvar p = document.querySelector(&#039;p&#039;);\n \ndiv.addEventListener(&#039;click&#039;, callback, true);\np.addEventListener(&#039;click&#039;, callback, true);\ndiv.addEventListener(&#039;click&#039;, callback, false);\np.addEventListener(&#039;click&#039;, callback, false);\n \nfunction callback(event) {\n  var tag = event.currentTarget.tagName;\n  var phase = phases[event.eventPhase];\n  console.log(&quot;Tag: &#039;&quot; + tag + &quot;&#039;. EventPhase: &#039;&quot; + phase + &quot;&#039;&quot;);\n}\n \n// 点击以后的结果\n// Tag: &#039;DIV&#039;. EventPhase: &#039;capture&#039;\n// Tag: &#039;P&#039;. EventPhase: &#039;target&#039;\n// Tag: &#039;P&#039;. EventPhase: &#039;target&#039;\n// Tag: &#039;DIV&#039;. EventPhase: &#039;bubble&#039;\n上面代码表示，click事件被触发了四次：&lt;div&gt;节点的捕获阶段和冒泡阶段各1次，&lt;p&gt;节点的目标阶段触发了2次。\n\n捕获阶段：事件从&lt;div&gt;向&lt;p&gt;传播时，触发&lt;div&gt;的click事件；\n目标阶段：事件从&lt;div&gt;到达&lt;p&gt;时，触发&lt;p&gt;的click事件；\n冒泡阶段：事件从&lt;p&gt;传回&lt;div&gt;时，再次触发&lt;div&gt;的click事件。\n\n其中，&lt;p&gt;节点有两个监听函数（addEventListener方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为click事件触发一次。所以，&lt;p&gt;会在target阶段有两次输出。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，浏览器总是假定 click 事件的目标节点，就是点击位置嵌套最深的那个节点（本例是 &lt;div&gt; 节点里面的 &lt;p&gt; 节点）。所以，&lt;p&gt; 节点的捕获阶段和冒泡阶段，都会显示为 target 阶段。\n\n事件传播的最上层对象是window，接着依次是document，html（document.documentElement）和body（document.body）。也就是说，上例的事件传播顺序，在捕获阶段依次为window、document、html、body、div、p，在冒泡阶段依次为p、div、body、html、document、window。\n事件的代理\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。\nvar ul = document.querySelector(&#039;ul&#039;);\n \nul.addEventListener(&#039;click&#039;, function (event) {\n  if (event.target.tagName.toLowerCase() === &#039;li&#039;) {\n    // some code\n  }\n});\n上面代码中，click事件的监听函数定义在&lt;ul&gt;节点，但是实际上，它处理的是子节点&lt;li&gt;的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个&lt;li&gt;节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。\n如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。\n// 事件传播到 p 元素后，就不再向下传播了\np.addEventListener(&#039;click&#039;, function (event) {\n  event.stopPropagation();\n}, true);\n \n// 事件冒泡到 p 元素后，就不再向上冒泡了\np.addEventListener(&#039;click&#039;, function (event) {\n  event.stopPropagation();\n}, false);\n上面代码中，stopPropagation方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。\n但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发&lt;p&gt;节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。\np.addEventListener(&#039;click&#039;, function (event) {\n  event.stopPropagation();\n  console.log(1);\n});\n \np.addEventListener(&#039;click&#039;, function(event) {\n  // 会触发\n  console.log(2);\n});\n上面代码中，p元素绑定了两个click事件的监听函数。stopPropagation方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。\n如果想要彻底取消该事件，不再触发后面所有click的监听函数，==可以使用stopImmediatePropagation方法==。\np.addEventListener(&#039;click&#039;, function (event) {\n  event.stopImmediatePropagation();\n  console.log(1);\n});\n \np.addEventListener(&#039;click&#039;, function(event) {\n  // 不会被触发\n  console.log(2);\n});\n上面代码中，stopImmediatePropagation方法可以彻底取消这个事件，使得后面绑定的所有click监听函数都不再触发。所以，只会输出1，不会输出2。"},"C-Knowledge/前端/技术书籍/JavaScript教程/二进制位运算符":{"title":"二进制位运算符","links":["D-Unsorted/任意数值转为32位整数","D-Unsorted/取整方法","D-Unsorted/交换变量的值","D-Unsorted/转为32位无符号整数"],"tags":["编程/JavaScript/运算符"],"content":"概述\n二进制位运算符用于直接对二进制位进行计算，一共有7个。\n\n二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。\n二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。\n二进制否运算符（not）：符号为~，表示对一个二进制位取反。\n异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。\n左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。\n右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。\n头部补零的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。\n\n这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。\n\n\n                  \n                  注意❗ \n                  \n                \n有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 32 位带符号的整数进行运算的，并且返回值也是一个 32 位带符号的整数。\n\ni = i | 0;\n上面这行代码的意思，就是将i（不管是整数或小数）转为32位整数。\n利用这个特性，可以写出一个函数，将任意数值转为32位整数。\nfunction toInt32(x) {\n  return x | 0;\n}\n上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。\ntoInt32(1.001) // 1\ntoInt32(1.999) // 1\ntoInt32(1) // 1\ntoInt32(-1) // -1\ntoInt32(Math.pow(2, 32) + 1) // 1\ntoInt32(Math.pow(2, 32) - 1) // -1\n上面代码中，toInt32可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。\n二进制或运算符\n二进制或运算符（|）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。\n0 | 3 // 3\n上面代码中，0和3的二进制形式分别是00和11，所以进行二进制或运算会得到11（即3）。\n位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。\n2.9 | 0 // 2\n-2.9 | 0 // -2\n需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。\n2147483649.4 | 0;\n// -2147483647\n二进制与运算符\n二进制与运算符（&amp;）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1。\n0 &amp; 3 // 0\n上面代码中，0（二进制00）和3（二进制11）进行二进制与运算会得到00（即0）。\n二进制否运算符\n二进制否运算符（~）将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。\n~ 3 // -4\n上面表达式对3进行二进制否运算，得到-4。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。\n3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。\n~ -3 // 2\n上面表达式可以这样算，-3 的取反值等于 -1 减去 -3，结果为 2。\n对一个整数连续两次二进制否运算，得到它自身。\n~~3 // 3\n所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。\n~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n使用二进制否运算取整，是所有取整方法中最快的一种。\n对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。\n// 相当于~Number(&#039;011&#039;)\n~&#039;011&#039;  // -12\n \n// 相当于~Number(&#039;42 cats&#039;)\n~&#039;42 cats&#039; // -1\n \n// 相当于~Number(&#039;0xcafebabe&#039;)\n~&#039;0xcafebabe&#039; // 889275713\n \n// 相当于~Number(&#039;deadbeef&#039;)\n~&#039;deadbeef&#039; // -1\nNumber函数将字符串转为数值的规则，参见《数据的类型转换》一章。\n对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。\n// 相当于 ~Number([])\n~[] // -1\n \n// 相当于 ~Number(NaN)\n~NaN // -1\n \n// 相当于 ~Number(null)\n~null // -1\n异或运算符\n异或运算（^）在两个二进制位不同时返回1，相同时返回0。\n0 ^ 3 // 3\n上面表达式中，0（二进制00）与3（二进制11）进行异或运算，它们每一个二进制位都不同，所以得到11（即3）。\n“异或运算”有一个特殊运用，连续对两个数 a 和 b 进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。\nvar a = 10;\nvar b = 99;\n \na ^= b, b ^= a, a ^= b;\n \na // 99\nb // 10\n这是互换两个变量的值的最快方法。\n异或运算也可以用来 取整。\n12.9 ^ 0 // 12\n左移运算符\n左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的。\n// 4 的二进制形式为100，\n// 左移一位为1000（即十进制的8）\n// 相当于乘以2的1次方\n4 &lt;&lt; 1\n// 8\n \n-4 &lt;&lt; 1\n// -8\n上面代码中，-4左移一位得到-8，是因为-4的二进制形式是11111111111111111111111111111100，左移一位后得到11111111111111111111111111111000，该数转为十进制（减去1后取反，再加上负号）即为-8。\n如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。\n13.5 &lt;&lt; 0\n// 13\n \n-13.5 &lt;&lt; 0\n// -13\n左移运算符用于二进制数值非常方便。\nvar color = {r: 186, g: 218, b: 85};\n \n// RGB to HEX\n// (1 &lt;&lt; 24)的作用为保证结果是6位数\nvar rgb2hex = function(r, g, b) {\n  return &#039;#&#039; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b)\n    .toString(16) // 先转成十六进制，然后返回字符串\n    .substr(1);   // 去除字符串的最高位，返回后面六个字符串\n}\n \nrgb2hex(color.r, color.g, color.b)\n// &quot;#bada55&quot;\n上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。\n右移运算符\n右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。\n4 &gt;&gt; 1\n// 2\n/*\n// 因为4的二进制形式为 00000000000000000000000000000100，\n// 右移一位得到 00000000000000000000000000000010，\n// 即为十进制的2\n*/\n \n-4 &gt;&gt; 1\n// -2\n/*\n// 因为-4的二进制形式为 11111111111111111111111111111100，\n// 右移一位，头部补1，得到 11111111111111111111111111111110,\n// 即为十进制的-2\n*/\n右移运算可以模拟 2 的整除运算。\n5 &gt;&gt; 1\n// 2\n// 相当于 5 / 2 = 2\n \n21 &gt;&gt; 2\n// 5\n// 相当于 21 / 4 = 5\n \n21 &gt;&gt; 3\n// 2\n// 相当于 21 / 8 = 2\n \n21 &gt;&gt; 4\n// 1\n// 相当于 21 / 16 = 1\n头部补零的右移运算符\n头部补零的右移运算符（&gt;&gt;&gt;）与右移运算符（&gt;&gt;）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。\n4 &gt;&gt;&gt; 1\n// 2\n \n-4 &gt;&gt;&gt; 1\n// 2147483646\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 带符号位的右移一位，得到01111111111111111111111111111110，\n// 即为十进制的2147483646。\n*/\n这个运算实际上将一个值**转为32位无符号整数**。\n查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。\n-1 &gt;&gt;&gt; 0 // 4294967295\n上面代码表示，-1作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即(2^32)-1，等于11111111111111111111111111111111）。\n开关作用\n位运算符可以用作设置对象属性的开关。\n假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。\nvar FLAG_A = 1; // 0001\nvar FLAG_B = 2; // 0010\nvar FLAG_C = 4; // 0100\nvar FLAG_D = 8; // 1000\n上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。\n然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。\nvar flags = 5; // 二进制的0101\n \nif (flags &amp; FLAG_C) {\n  // ...\n}\n// 0101 &amp; 0100 =&gt; 0100 =&gt; true\n上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。\n现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。\nvar mask = FLAG_A | FLAG_B | FLAG_D;\n// 0001 | 0010 | 1000 =&gt; 1011\n上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。\n有了掩码，二进制或运算可以确保打开指定的开关。\nflags = flags | mask;\n上面代码中，计算后得到的flags变量，代表三个开关的二进制位都打开了。\n二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。\nflags = flags &amp; mask;\n异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。\nflags = flags ^ mask;\n二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。\nflags = ~flags;\n参考链接\n\nMichal Budzynski, JavaScript: The less known parts. Bitwise Operators\nAxel Rauschmayer, Basic JavaScript for the impatient programmer\nMozilla Developer Network, Bitwise Operators\n"},"C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-教程":{"title":"TypeScript 教程","links":["C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-语言简介","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-基本用法","C-Knowledge/前端/技术书籍/TypeScript教程/any-类型","C-Knowledge/前端/技术书籍/TypeScript教程/类型系统","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的数组类型","C-Knowledge/前端/技术书籍/TypeScript教程/元组","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的-symbol-类型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的函数类型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的对象类型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的-interface-接口","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的-class-类型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-泛型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的-Enum-类型","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的类型断言","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-模块","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-namespace","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-装饰器","C-Knowledge/前端/技术书籍/TypeScript教程/装饰器（旧语法）","C-Knowledge/前端/技术书籍/TypeScript教程/declare-关键字","C-Knowledge/前端/技术书籍/TypeScript教程/d.ts-类型声明文件","C-Knowledge/前端/技术书籍/TypeScript教程/类型运算符","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的类型映射","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-类型工具","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-的注释指令","C-Knowledge/前端/技术书籍/TypeScript教程/tsconfig.json-文件","C-Knowledge/前端/技术书籍/TypeScript教程/tsc-命令行编译器"],"tags":["编程/TypeScript"],"content":"\nTypeScript 语言简介\nTypeScript 基本用法\nany 类型\n 类型系统\n 数组\n 元组\n symbol 类型\n 函数\n 对象\n interface|\n 类\n 泛型\n Enum 类型\n 类型断言\n 模块\n namespace\n 装饰器\n 装饰器（旧语法）\n declare 关键字\n d.ts 类型声明文件\n 类型运算符\n 类型映射\n 类型工具\n 注释指令\n tsconfig.json 文件\n tsc 命令\n"},"C-Knowledge/前端/技术书籍/Web-API-教程/Web-API-教程":{"title":"Web API 教程","links":["C-Knowledge/前端/技术书籍/Web-API-教程/Canvas-API"],"tags":["编程/JavaScript"],"content":"\n Canvas API\n Clipboard API\n Fetch API\n FontFace API\n FormData 对象\n Geolocation API\n Headers 对象\n IntersectionObserver\n Intl.RelativeTimeFormat\n Intl.Segmenter API\n Page Lifecycle API\n Page Visibility API\n Request API\n Response API\n Server-Sent Events\n SVG 图像\n URL 对象\n URLSearchParams 对象\n WebSocket\n Web Share API\n"},"C-Knowledge/前端/技术书籍/Web前端面试官系列/Web前端面试官系列":{"title":"Web前端面试官系列","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何在Vue项目中应用TypeScript！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对vue的mixin的理解，有什么应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对slot的理解！slot使用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-keep-alive-的理解是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Vue-3.0中Treeshaking特性！举例说明一下！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件中的-data-为什么是一个函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/用Vue3.0-写过组件吗！如果想实现一个-Modal你会怎么设计！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/有使用过vue吗！说说你对vue的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/动态给vue的data添加一个新的属性时会发生什么！怎样解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你知道vue中key的原理吗！说说你对它的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你有写过自定义指令吗！自定义指令的应用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么处理vue项目中的错误的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解vue的diff算法吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解axios的原理吗！有看过它的源码吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】Vue中的-$nextTick-作用及实现原理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue项目本地开发完成后部署到服务器后报404是什么原因呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-if-和-v-show-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-if-和-v-for-哪个优先级更高","C-Knowledge/前端/职业规划/前端面试宝典/八股文/state-和-props-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue项目中有封装过axios吗！主要是封装哪方面的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue项目中你是如何解决跨域的呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue组件之间的通信方式都有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue常用的修饰符有哪些有什么应用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue实例挂载的过程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中组件和插件有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中的过滤器了解吗！过滤器的应用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2-的生命周期有哪些","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue.observable你有了解过吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SSR-解决了什么问题！有做过-SSR-吗！你是怎么做的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SPA首屏加载速度慢的怎么解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0的设计目标是什么！做了哪些优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0性能提升主要是通过哪几方面体现的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0-所采用的-Composition-Api-与-Vue2.x-使用的-Options-Api-有什么不同！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue3有了解过吗！能说说跟vue2的区别吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对象新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6新增Set、Map两种数据结构的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中Module的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中-Promise的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中-Decorator-的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解-ES6中-Proxy-的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/var、let、const-的差异！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ES6中数组新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ES6中函数新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/大文件上传如何做断点续传！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/==-、-===--和-Object.is()-的区别是什么！分别在什么情况使用","D-Unsorted/说说-JavaScript-中内存泄漏的几种情况！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/谈谈this对象的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/谈谈-JavaScript-中的类型转换机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对闭包的理解！闭包使用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对事件循环的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对BOM的理解，常见的BOM对象你了解哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说new操作符具体干了什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Javascript-数字精度丢失的问题，如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释下什么是事件代理！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/深拷贝浅拷贝的区别！如何实现一个深拷贝！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数组的常用方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数据类型判断-instanceof-和-typeof-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现上拉加载，下拉刷新！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何判断一个元素是否在可视区域中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是单点登录！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是作用域-！-什么是作用域链-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/举例说明你对尾递归的理解，有哪些应用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/bind、call、apply-区别！如何实现一个bind！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ajax原理是什么！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript如何实现继承！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript中如何实现函数缓存！函数缓存有哪些应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript字符串的常用方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript原型，原型链-！-有什么特点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript中执行上下文和执行栈是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JS-中的-8-种数据类型及区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/DOM常见的操作有哪些！","C-Knowledge/前端/开发技术/JavaScript/说说JavaScript中的事件模型","C-Knowledge/前端/开发技术/JavaScript/说说对WebSocket的理解！应用场景！","C-Knowledge/前端/开发技术/JavaScript/什么是防抖和节流！有什么区别！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对盒子模型的理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说flexbox（弹性盒布局模型）,以及适用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说em-and-px-and-rem-and-vh-and-vw区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/让Chrome支持小于12px-的文字方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么理解回流跟重绘！什么场景下会触发！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如果要做优化，CSS提高性能的方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现单行-and-多行文本溢出的省略样式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现两栏布局，右侧自适应！三栏布局中间自适应呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用css完成视差滚动效果！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/元素水平垂直居中的方法有哪些！如果元素不定宽高呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下grid网格布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是响应式设计！响应式设计的基本原理是什么！如何做！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/css选择器有哪些！优先级！哪些属性可以继承！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/css中，有哪些方式可以隐藏页面元素！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS如何画一个三角形！原理是什么","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS3新增了哪些新特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS3动画有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何借助webpack来优化前端性能！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对webpack的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的热更新是如何做到的！原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的构建流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack中常见的Plugin！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack中常见的Loader！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack-proxy工作原理！为什么能解决跨域！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Loader和Plugin的区别！编写Loader，Plugin的思路！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何提高webpack的构建速度！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/与webpack类似的工具还有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说TCP为什么需要三次握手和四次挥手！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-HTTP-常见的请求头有哪些！-作用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一下-GET-和-POST-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解UDP-和-TCP！-区别！-应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解TCP-and-IP协议！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解OSI七层模型！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解CDN！说说实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是HTTP！-HTTP-和-HTTPS-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么说HTTPS比HTTP安全！-HTTPS是如何保证安全的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTTP1-and-HTTP1.1、HTTP2、HTTP3各自解决的问题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/DNS协议-是什么！说说DNS-完整的查询过程！","C-Knowledge/前端/编程基础/网络/说说HTTP-常见的状态码有哪些，适用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对中间件概念的理解，如何封装-node-中间件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Nodejs中的事件循环机制理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-process-的理解！有哪些常用方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-fs模块的理解！-有哪些常用方法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Stream-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Buffer-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Node.js-的理解！优缺点！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Node中的EventEmitter！-如何实现一个EventEmitter！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Node.-js-有哪些全局对象！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Node-文件查找的优先级以及-Require-方法的文件查找策略！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如果让你来设计一个分页功能,-你会怎么设计！-前后端如何交互！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现文件上传！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现jwt鉴权机制！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node性能如何进行监控以及优化！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对高阶组件的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对受控组件和非受控组件的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Redux中间件的理解！常用的中间件有哪些！实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React中类组件和函数组件的理解！有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React-refs-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React-Hooks的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Fiber架构的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-React-的理解！有哪些特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你是如何提高组件的渲染效率的！在React中如何避免不必要的render！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对immutable的理解！如何应用在react项目中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Redux的理解！其工作原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对React-Router的理解！常用的Router组件有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你在使用React-过程中遇到的常见问题！如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你在React项目是如何捕获错误的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说react中引入css的方式有哪几种！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React的事件机制！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React服务端渲染怎么做！原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-render方法的原理！在什么时候会被触发！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-diff的原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-Router有几种模式！实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-Jsx转换成真实DOM过程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Real-DOM-和-Virtual-DOM-的区别！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React中的setState执行机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React-生命周期有哪些不同阶段！每个阶段对应的方法是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React-性能优化的手段有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在react中组件间过渡动画如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你在React项目中是如何使用Redux的！-项目结构是如何划分的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/super()-和-super(props)-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React构建组件的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React事件绑定的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React中的key有什么作用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-中组件之间如何通信！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对git-pull-和-git-fetch-的理解！有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对版本管理的理解！常用的版本管理工具有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-stash-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-reset-和-git-revert-的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-rebase-和-git-merge的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Git的理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git中-fork,-clone,branch这三个概念，有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git-中-HEAD、工作树和索引之间的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-git-发生冲突的场景！如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对输入输出重定向和管道的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对操作系统的理解！核心概念有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-shell-的理解！常见的命令！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-linux-用户管理的理解！相关的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说什么是进程！什么是线程！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-linux系统下-文件操作常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-linux-系统下-文本编辑常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-TypeScript-中命名空间与模块的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何在-React-项目中应用-TypeScript！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-装饰器的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-的理解！与-JavaScript-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中高级类型的理解！有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中类的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中泛型的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中枚举类型的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中函数的理解！与-JavaScript-函数的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-typescript-的数据类型有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说常见的排序算法有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对选择排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对贪心算法、回溯算法的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法中时间复杂度，空间复杂度的理解！如何计算！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对插入排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对快速排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对归并排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对分而治之、动态规划的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对冒泡排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对二分查找的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对树的理解！相关的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对集合的理解！常见的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对链表的理解！常见的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对栈、队列的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对数据结构的理解！有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对堆的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对图的理解！相关操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说提高微信小程序的应用速度的手段有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的登录流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的生命周期函数有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的支付流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的发布流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序中路由跳转的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对微信小程序的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对设计模式的理解！常见的设计模式有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对策略模式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对工厂模式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对发布订阅、观察者模式的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对单例模式的理解！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对代理模式的理解！应用场景！"],"tags":["场景/面试"],"content":"Vue系列\n\n说说如何在Vue项目中应用TypeScript！\n说说你对vue的mixin的理解，有什么应用场景！\n说说你对slot的理解！slot使用场景有哪些！\n说说你对 keep-alive 的理解是什么！\n说说Vue 3.0中Treeshaking特性！举例说明一下！\n说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢！\n组件中的 data 为什么是一个函数！\n用Vue3.0 写过组件吗！如果想实现一个 Modal你会怎么设计！\n有使用过vue吗！说说你对vue的理解\n动态给vue的data添加一个新的属性时会发生什么！怎样解决！\n你知道vue中key的原理吗！说说你对它的理解\n你有写过自定义指令吗！自定义指令的应用场景有哪些！\n你是怎么处理vue项目中的错误的！\n你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢\n你了解vue的diff算法吗！说说看\n你了解axios的原理吗！有看过它的源码吗！\n什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路\n为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty\n【延伸问答】Vue中的 $nextTick 作用及实现原理\nvue项目本地开发完成后部署到服务器后报404是什么原因呢！\nvue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！\nv-if 和 v-show 的区别\nv-if 和 v-for 哪个优先级更高\nstate 和 props 有什么区别！\nVue项目中有封装过axios吗！主要是封装哪方面的！\nVue项目中你是如何解决跨域的呢！\nVue组件之间的通信方式都有哪些！\nVue常用的修饰符有哪些有什么应用场景\nVue实例挂载的过程\nVue中组件和插件有什么区别！\nVue中的过滤器了解吗！过滤器的应用场景有哪些！\nVue2 的生命周期有哪些\nVue 的双向数据绑定是如何实现的\nVue.observable你有了解过吗！说说看\nSSR 解决了什么问题！有做过 SSR 吗！你是怎么做的！\nSPA首屏加载速度慢的怎么解决！\n\nVue3系列\n\n说说Vue 3.0中Treeshaking特性！举例说明一下！\n用Vue3.0 写过组件吗！如果想实现一个 Modal你会怎么设计！\nVue3.0的设计目标是什么！做了哪些优化\nVue3.0性能提升主要是通过哪几方面体现的！\nVue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同！\nvue3有了解过吗！能说说跟vue2的区别吗！\n\nES6系列\n\n对象新增了哪些扩展！\n你是怎么理解ES6新增Set、Map两种数据结构的！\n你是怎么理解ES6中Module的！使用场景！\n你是怎么理解ES6中 Promise的！使用场景！\n你是怎么理解ES6中 Decorator 的！使用场景！\n你是怎么理解 ES6中 Proxy 的！使用场景！\nvar、let、const 的差异！\nES6中数组新增了哪些扩展！\nES6中函数新增了哪些扩展！\n\nJavaScript系列\n\n大文件上传如何做断点续传！\n 、 =  和 Object.is() 的区别是什么！分别在什么情况使用\n说说 JavaScript 中内存泄漏的几种情况！\n谈谈this对象的理解\n谈谈 JavaScript 中的类型转换机制\n说说你对闭包的理解！闭包使用场景\n说说你对函数式编程的理解！优缺点！\n说说你对事件循环的理解\n说说你对BOM的理解，常见的BOM对象你了解哪些！\n说说new操作符具体干了什么！\n说说 Javascript 数字精度丢失的问题，如何解决！\n解释下什么是事件代理！应用场景！\n深拷贝浅拷贝的区别！如何实现一个深拷贝！\n数组的常用方法有哪些！\n数据类型判断 instanceof 和 typeof 的区别\n如何实现上拉加载，下拉刷新！\n如何判断一个元素是否在可视区域中！\n什么是单点登录！如何实现！\n什么是作用域 ！ 什么是作用域链 ！\n举例说明你对尾递归的理解，有哪些应用场景\nbind、call、apply 区别！如何实现一个bind！\najax原理是什么！如何实现！\nJavascript如何实现继承！\nJavascript中如何实现函数缓存！函数缓存有哪些应用场景！\nJavaScript字符串的常用方法有哪些！\nJavaScript原型，原型链 ！ 有什么特点！\nJavaScript中执行上下文和执行栈是什么！\nJS 中的 8 种数据类型及区别\nDOM常见的操作有哪些！\n说说JavaScript中的事件模型\n说说对WebSocket的理解！应用场景！\n什么是防抖和节流！有什么区别！如何实现！\n\nCSS系列\n\n说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别！\n说说你对盒子模型的理解！\n说说flexbox（弹性盒布局模型）,以及适用场景！\n说说em&amp;px&amp;rem&amp;vh&amp;vw区别！\n让Chrome支持小于12px 的文字方式有哪些！区别！\n怎么理解回流跟重绘！什么场景下会触发！\n如果要做优化，CSS提高性能的方法有哪些！\n如何实现单行&amp;多行文本溢出的省略样式！\n如何实现两栏布局，右侧自适应！三栏布局中间自适应呢！\n如何使用css完成视差滚动效果！\n元素水平垂直居中的方法有哪些！如果元素不定宽高呢！\n介绍一下grid网格布局\n什么是响应式设计！响应式设计的基本原理是什么！如何做！\ncss选择器有哪些！优先级！哪些属性可以继承！\ncss中，有哪些方式可以隐藏页面元素！区别！\nCSS如何画一个三角形！原理是什么\nCSS3新增了哪些新特性！\nCSS3动画有哪些！\n\nWebpack系列\n\n说说如何借助webpack来优化前端性能！\n说说你对webpack的理解！解决了什么问题！\n说说webpack的热更新是如何做到的！原理是什么！\n说说webpack的构建流程！\n说说webpack中常见的Plugin！解决了什么问题！\n说说webpack中常见的Loader！解决了什么问题！\n说说webpack proxy工作原理！为什么能解决跨域！\n说说Loader和Plugin的区别！编写Loader，Plugin的思路！\n如何提高webpack的构建速度！\n与webpack类似的工具还有哪些！区别！\n\nHTTP系列\n\n说说TCP为什么需要三次握手和四次挥手！\n说说 HTTP 常见的请求头有哪些！ 作用！\n说一下 GET 和 POST 的区别！\n如何理解UDP 和 TCP！ 区别！ 应用场景！\n如何理解TCP&amp;IP协议！\n如何理解OSI七层模型！\n如何理解CDN！说说实现原理！\n什么是HTTP！ HTTP 和 HTTPS 的区别！\n为什么说HTTPS比HTTP安全！ HTTPS是如何保证安全的！\nHTTP1&amp;HTTP1.1、HTTP2、HTTP3各自解决的问题\nDNS协议 是什么！说说DNS 完整的查询过程！\n说说HTTP 常见的状态码有哪些，适用场景！\n\nNodeJS系列\n\n说说对中间件概念的理解，如何封装 node 中间件！\n说说对Nodejs中的事件循环机制理解！\n说说对 Node 中的 process 的理解！有哪些常用方法！\n说说对 Node 中的 fs模块的理解！ 有哪些常用方法\n说说对 Node 中的 Stream 的理解！应用场景！\n说说对 Node 中的 Buffer 的理解！应用场景！\n说说你对Node.js 的理解！优缺点！应用场景！\n说说Node中的EventEmitter！ 如何实现一个EventEmitter！\n说说 Node. js 有哪些全局对象！\n说说 Node 文件查找的优先级以及 Require 方法的文件查找策略！\n如果让你来设计一个分页功能, 你会怎么设计！ 前后端如何交互！\n如何实现文件上传！说说你的思路\n如何实现jwt鉴权机制！说说你的思路\nNode性能如何进行监控以及优化！\n\nReact系列\n\n说说对高阶组件的理解！应用场景！\n说说对受控组件和非受控组件的理解！应用场景！\n说说对Redux中间件的理解！常用的中间件有哪些！实现原理！\n说说对React中类组件和函数组件的理解！有什么区别！\n说说对React refs 的理解！应用场景！\n说说对React Hooks的理解！解决了什么问题！\n说说对Fiber架构的理解！解决了什么问题！\n说说对 React 的理解！有哪些特性！\n说说你是如何提高组件的渲染效率的！在React中如何避免不必要的render！\n说说你对immutable的理解！如何应用在react项目中！\n说说你对Redux的理解！其工作原理！\n说说你对React Router的理解！常用的Router组件有哪些！\n说说你在使用React 过程中遇到的常见问题！如何解决！\n说说你在React项目是如何捕获错误的！\n说说react中引入css的方式有哪几种！区别！\n说说React的事件机制！\n说说React服务端渲染怎么做！原理是什么！\n说说React render方法的原理！在什么时候会被触发！\n说说React diff的原理是什么！\n说说React Router有几种模式！实现原理！\n说说React Jsx转换成真实DOM过程！\n说说 Real DOM 和 Virtual DOM 的区别！优缺点！\n说说 React中的setState执行机制\n说说 React 生命周期有哪些不同阶段！每个阶段对应的方法是！\n说说 React 性能优化的手段有哪些！\n在react中组件间过渡动画如何实现！\n你在React项目中是如何使用Redux的！ 项目结构是如何划分的！\nsuper() 和 super(props) 有什么区别！\nReact构建组件的方式有哪些！区别！\nReact事件绑定的方式有哪些！区别！\nReact中的key有什么作用！\nReact 中组件之间如何通信！\n\n版本控制系列\n\n说说对git pull 和 git fetch 的理解！有什么区别！\n说说你对版本管理的理解！常用的版本管理工具有哪些！\n说说你对git stash 的理解！应用场景！\n说说你对git reset 和 git revert 的理解！区别！\n说说你对git rebase 和 git merge的理解！区别！\n说说你对Git的理解！\n说说Git常用的命令有哪些！\n说说Git中 fork, clone,branch这三个概念，有什么区别！\n说说Git 中 HEAD、工作树和索引之间的区别！\n说说 git 发生冲突的场景！如何解决！\n\n操作系统系列\n\n说说你对输入输出重定向和管道的理解！应用场景！\n说说你对操作系统的理解！核心概念有哪些！\n说说你对 shell 的理解！常见的命令！\n说说你对 linux 用户管理的理解！相关的命令有哪些！\n说说什么是进程！什么是线程！区别！\n说说 linux系统下 文件操作常用的命令有哪些！\n说说 linux 系统下 文本编辑常用的命令有哪些！\n\nTypeScript 系列\n\n说说对 TypeScript 中命名空间与模块的理解！区别！\n说说如何在Vue项目中应用TypeScript！\n说说如何在 React 项目中应用 TypeScript！\n说说你对 TypeScript 装饰器的理解！应用场景！\n说说你对 TypeScript 的理解！与 JavaScript 的区别！\n说说你对 TypeScript 中高级类型的理解！有哪些！\n说说你对 TypeScript 中类的理解！应用场景！\n说说你对 TypeScript 中泛型的理解！应用场景！\n说说你对 TypeScript 中枚举类型的理解！应用场景！\n说说你对 TypeScript 中函数的理解！与 JavaScript 函数的区别！\n说说 typescript 的数据类型有哪些！\n\n算法系列\n\n说说常见的排序算法有哪些！区别！\n说说你对选择排序的理解！如何实现！应用场景！\n说说你对贪心算法、回溯算法的理解！应用场景！\n说说你对算法的理解！应用场景！\n说说你对算法中时间复杂度，空间复杂度的理解！如何计算！\n说说你对插入排序的理解！如何实现！应用场景！\n说说你对快速排序的理解！如何实现！应用场景！\n说说你对归并排序的理解！如何实现！应用场景！\n说说你对分而治之、动态规划的理解！区别！\n说说你对冒泡排序的理解！如何实现！应用场景！\n说说你对二分查找的理解！如何实现！应用场景！\n\n数据结构系列\n\n说说你对树的理解！相关的操作有哪些！\n说说你对集合的理解！常见的操作有哪些！\n说说你对链表的理解！常见的操作有哪些！\n说说你对栈、队列的理解！应用场景！\n说说你对数据结构的理解！有哪些！区别！\n说说你对堆的理解！如何实现！应用场景！\n说说你对图的理解！相关操作有哪些！\n\n小程序系列\n\n说说提高微信小程序的应用速度的手段有哪些！\n说说微信小程序的登录流程！\n说说微信小程序的生命周期函数有哪些！\n说说微信小程序的支付流程！\n说说微信小程序的实现原理！\n说说微信小程序的发布流程！\n说说微信小程序中路由跳转的方式有哪些！区别！\n说说你对微信小程序的理解！优缺点！\n\n设计模式系列\n\n说说对设计模式的理解！常见的设计模式有哪些！\n说说你对策略模式的理解！应用场景！\n说说你对工厂模式的理解！应用场景！\n说说你对发布订阅、观察者模式的理解！区别！\n说说你对单例模式的理解！如何实现！\n说说你对代理模式的理解！应用场景！\n"},"C-Knowledge/前端/技术书籍/从-0-到-1-落地前端工程化/从-0-到-1-落地前端工程化-模块化规范":{"title":"从 0 到 1 落地前端工程化-模块化规范","links":[],"tags":["编程/FE/工程化","编程/ES6/Module"],"content":"模块化的发展\n早期的模块化不是真正的模块化，只是通过一些“骚操作”实现看似是模块化的效果，例如立即调用函数表达式(简称IIFE)就是一个在定义时可立即执行的函数，至于它如何实现模块化，可查看MDN文档，在此不深入讲述了。后期的模块化才算是真正的模块化，它包括CJS、AMD、CMD、UMD和ESM，经过多年演变，目前Web开发倾向于ESM，Node开发倾向于CJS。\n模块化的核心包括以下特性，基本都是围绕如何处理文件(模块)。\n\n拆分：将代码根据功能拆分为多个可复用模块\n加载：通过指定方式加载模块并执行与输出模块\n注入：将一个模块的输出注入到另一个模块\n管理：因为工程模块数量众多需管理模块间的依赖关系\n\n模块化的作用\n\n模块方案\n使用多个&lt;script&gt;的问题：\n\n请求过多：每个&lt;script&gt;都有一个src必然会增加HTTP请求次数\n依赖模糊：每个&lt;script&gt;的摆放顺序都有可能影响前后脚本加载错误\n难以维护：每个&lt;script&gt;的变量命名与函数作用域都有可能互相影响\n\nJS模块化\n六种常见模块方案，分别是IIFE、CJS、AMD、CMD、UMD和ESM。\n\n每个模块方案的特性\n同步加载包括IIFE与CJS，异步加载包括AMD、CMD和ESM。浏览器可兼容IIFE与AMD，服务器可兼容CJS，浏览器与服务器都兼容CMD、UMD和ESM。\nCJSvsESM\n\n\n运行时加载指整体加载模块生成一个对象，再从对象中获取所需的属性方法去加载。最大特性是全部加载，只有运行时才能得到该对象，无法在编译时做静态优化。\n编译时加载指直接从模块中获取所需的属性方法去加载。最大特性是按需加载，在编译时就完成模块加载，效率比其他方案高，无法引用模块本身(本身不是对象)，但可拓展JS高级语法(宏与类型校验)。\n\n现状：ESM能否在Node环境中运行\n原生支持ESM\nv8.9.0\n命令中加上—experimental-modules，Node就可象征性地支持ESM。\nnode --experimental-modules index.js\nv13.2.0\n默认支持ESM。\n—experimental-modules特性包括以下方面。\n\n\n使用type指定模块方案\n\n\n在package.json中指定type为commonjs，则使用CJS\n\n\n在package.json中指定type为module，则使用ESM\n\n\n使用—input-type指定入口文件的模块方案，与type一样\n\n\n命令中加上—input-type=commonjs，则使用CJS\n\n\n命令中加上—input-type=module，则使用ESM\n\n\n支持新文件后缀.cjs\n\n\n文件后缀使用.cjs，则使用CJS\n\n\n使用—es-module-specifier-resolution指定文件名称引用方式\n\n\n命令中加上—es-module-specifier-resolution=explicit，则引用模块时必须使用文件后缀(默认)\n\n\n命令中加上—es-module-specifier-resolution=node，则引用模块时无需使用文件后缀\n\n\n使用main根据type指定模块方案加载文件\n\n\n在package.json中指定mian后会根据type指定模块方案加载文件\n\n\nCJS/ESM判断方式\nmjs文件使用ESM解析，cjs文件使用CJS解析，js文件使用基于package.json指定的type解析(type=commonjs使用CJS，type=module使用ESM)。\nNode会将以下情况视为ESM。\n\n文件后缀为.mjs\n文件后缀为.js且在package.json中指定type为module\n命令中加上—input-type=module\n命令中加上—eval cmd\n\n方案：部署Node的ESM开发环境\n将Node v13.2.0作为高低版本分界线，当版本&gt;=13.2.0则定为高版本，当版本&lt;13.2.0则定为低版本。高版本使用Node原生部署方案，低版本使用Node编译部署方案。\n在根目录中创建package.json并执行npm i安装项目依赖。\n{\n\t&quot;name&quot;: &quot;node-esm&quot;,\n\t&quot;version&quot;: &quot;1.0.0&quot;,\n\t&quot;main&quot;: &quot;src/index.js&quot;,\n\t&quot;scripts&quot;: {\n\t\t&quot;start&quot;: &quot;node src/index.js&quot;\n\t},\n\t&quot;dependencies&quot;: {\n\t\t&quot;@yangzw/bruce-us&quot;: &quot;1.0.3&quot;\n\t}\n}\n创建src/index.js文件，加入以下内容。示例引用我开源的@yangzw/bruce-us，其中NodeType()用于获取Node相关信息。\nimport { NodeType } from &quot;@yangzw/bruce-us/dist/node&quot;;\n \nconsole.log(NodeType());\nNode原生部署方案\n添加模块类型，并指定Node/Npm版本限\n\n为了让Node支持ESM，还需为其指定Node/Npm版本限制。这是为了避免预设与实际情况不同而报错，例如预设该项目在高版本运行，实际却在低版本运行。\nNode与Npm是成双成对地安装，可通过Node Releases查询到Node v13.2.0对应Npm v6.13.1。\n{\n\t&quot;type&quot;: &quot;module&quot;,\n\t&quot;engines&quot;: {\n\t\t&quot;node&quot;: &quot;&gt;=13.2.0&quot;,\n\t\t&quot;npm&quot;: &quot;&gt;=6.13.1&quot;\n\t}\n}\n解决显示文件名称\n\n在命令中加上—es-module-specifier-resolution=node就能解决显示文件名称的问题。\n{\n\t&quot;scripts&quot;: {\n\t\t&quot;start&quot;: &quot;node --es-module-specifier-resolution=node src/index.js&quot;\n\t}\n}\n解决特性无法使用问题\n\n__filename与__dirname可用import.meta对象重建\nrequire、module和exports可用import与export代替\njson文件的引用可用Fs模块的readFileSync与JSON.parse()代替\n\nimport { readFileSync } from &quot;fs&quot;;\nimport { dirname } from &quot;path&quot;;\nimport { fileURLToPath } from &quot;url&quot;;\n \nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconsole.log(__filename, __dirname);\n \nconst json = readFileSync(&quot;./info.json&quot;);\nconst info = JSON.parse(json);\nESM模块不会导出导入值而是引用值。\n\n导入引用模块可访问该引用但无法修改它。\n导出引用模块可为引用该模块的模块重新分配值且该值由导入引用模块使用\n\nNode编译部署方案\n用babel将代码从ESM转换为CJS\nnpm i @babel/cli @babel/core @babel/node @babel/preset-env -D\nbabel的四个核心子包：\n\n@babel/cli：提供支持@babel/core的命令运行环境\n@babel/core：提供转译函数\n@babel/node：提供支持ESM的命令运行环境\n@babel/preset-env：提供预设语法转换集成环境\n\n将start命令中的node替换为babel-node。\n{\n\t&quot;scripts&quot;: {\n\t\t&quot;start&quot;: &quot;babel-node src/index.js&quot;\n\t},\n\t&quot;babel&quot;: {\n\t\t&quot;presets&quot;: [\n\t\t\t&quot;@babel/preset-env&quot;\n\t\t]\n\t}\n}\n兼容更低版本Node，可在package.json中指定babel的targets。\n{\n\t&quot;babel&quot;: {\n\t\t&quot;presets&quot;: [\n\t\t\t[&quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;8.0.0&quot; } }]\n\t\t]\n\t}\n}\n监听脚本自动重启命令\nnodemon是一个自动检测项目文件发生变化就重启服务的Npm模块。\n执行npm i -D nodemon安装nodemon，在package.json中指定nodemonConfig相关配置，将start命令替换为nodemon -x babel-node src/index.js。\n{\n\t&quot;nodemonConfig&quot;: {\n\t\t&quot;env&quot;: {\n\t\t\t&quot;NODE_ENV&quot;: &quot;dev&quot;\n\t\t},\n\t\t&quot;execMap&quot;: {\n\t\t\t&quot;js&quot;: &quot;node --harmony&quot;\n\t\t},\n\t\t&quot;ext&quot;: &quot;js json&quot;,\n\t\t&quot;ignore&quot;: [\n\t\t\t&quot;dist/&quot;\n\t\t],\n\t\t&quot;watch&quot;: [\n\t\t\t&quot;src/&quot;\n\t\t]\n\t}\n}\nnodemon配置可查看Nodemon官网。\n扩展阅读\njuejin.cn/book/7034689774719860739/section/7034911744845676548"},"C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/从-0-打造音视频直播系统":{"title":"从 0 打造音视频直播系统","links":["C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/原来通过浏览器访问摄像头这么容易","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何通过WebRTC进行音视频设备检测呢！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何使用浏览器给自己拍照呢！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/可以把采集到的音视频数据录制下来吗！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/原来浏览器还能抓取桌面！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/WebRTC中的RTP及RTCP详解","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/你竟然不知道SDP！它可是WebRTC的驱动核心！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/有话好商量，论媒体协商","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/让我们揭开WebRTC建立连接的神秘面纱","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/WebRTC-NAT穿越原理","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何通过Node.js实现一套最简单的信令系统！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/RTCPeerConnection：音视频实时通讯的核心","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/在WebRTC中如何控制传输速率呢！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何打开-and-关闭音视频！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/WebRTC中的数据统计原来这么强大（上）","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/WebRTC中的数据统计原来这么强大（下）","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何使用Canvas绘制统计图表（上）！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何使用Canvas绘制统计图表（下）！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/WebRTC能不能进行文本聊天呢！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/原来WebRTC还可以实时传输文件！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何保证数据传输的安全（上）！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/如何保证数据传输的安全（下）！","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/实战演练：通过WebRTC实现一个1对1音视频实时直播系统"],"tags":["编程/FE/音视频"],"content":"WebRTC 1对1通话 (23讲)\n\n原来通过浏览器访问摄像头这么容易\n如何通过WebRTC进行音视频设备检测呢！\n如何使用浏览器给自己拍照呢！\n可以把采集到的音视频数据录制下来吗！\n原来浏览器还能抓取桌面！\nWebRTC中的RTP及RTCP详解\n你竟然不知道SDP！它可是WebRTC的驱动核心！\n有话好商量，论媒体协商\n让我们揭开WebRTC建立连接的神秘面纱\nWebRTC NAT穿越原理\n如何通过Node.js实现一套最简单的信令系统！\nRTCPeerConnection：音视频实时通讯的核心\n在WebRTC中如何控制传输速率呢！\n如何打开&amp;关闭音视频！\nWebRTC中的数据统计原来这么强大（上）\nWebRTC中的数据统计原来这么强大（下）\n如何使用Canvas绘制统计图表（上）！\n如何使用Canvas绘制统计图表（下）！\nWebRTC能不能进行文本聊天呢！\n原来WebRTC还可以实时传输文件！\n如何保证数据传输的安全（上）！\n如何保证数据传输的安全（下）！\n实战演练：通过WebRTC实现一个1对1音视频实时直播系统\n"},"C-Knowledge/前端/技术书籍/前端性能优化手册/Chrome-DevTools":{"title":"Chrome DevTools","links":[],"tags":["编程/性能"],"content":""},"C-Knowledge/前端/技术书籍/前端性能优化手册/PSI":{"title":"PSI","links":[],"tags":["编程/性能"],"content":"PageSpeed Insights (PSI) 是一项免费的 Google 服务，可报告网页在移动设备和桌面设备上的用户体验，并提供关于如何改进网页的建议。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/TTI":{"title":"TTI","links":[],"tags":["编程/性能"],"content":""},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--Canvas篇":{"title":"前端性能优化--Canvas篇","links":["前端性能优化——渲染篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化——卡顿篇"],"tags":["编程/性能"],"content":"Canvas 渲染在前端应用中的使用场景不算多，但在大多数用到的场景下，也常常需要考虑性能瓶颈。\nCanvas 的使用场景可能少一些（比如游戏、复杂图形、复杂排版等），本来想将 Canvas 渲染放在《前端性能优化——渲染篇》一起介绍。后来想了下，Canvas 本身有许多优化点，可以结合自己在项目中的一些经验再详细地做介绍。\n#Canvas 性能优化\n其实对于 Canvas 的优化，WDN (opens new window)上也有一些介绍。如果你在网上搜索相关内容，或许有许多的优化方向都和本文有些相像。\n这是当然的，因为我们在做 Canvas 优化的时候，也同样会去找业界的方案做调研，结合自身项目的情况再做方案设计。\n那么，这里整理下我了解到以及实践中的一些 Canvas 优化方案吧。\n#Canvas 上下文切换\nCanvas 绘制 API 都是在上下文context上进行调用，context不是一个普通的对象，当我们对其赋值的时候，性能开销远大于普通对象。我们可以尝试将每个赋值操作执行一百万次，来看看其耗时：\n\n可见，频繁对 Canvas 上下文属性修改赋值是有一定的性能开销的。这是因为当我们调用context.lineWidth = 2时，浏览器会需要立刻地做一些事情，这样在下一次绘制的时候才能以最新的状态绘制。这意味着，在绘制两段不同字体大小的文本的时候，需要设置两次不同的字体，也就是需要进行两次context上下文状态的切换。\n在大多数情况下，我们的 Canvas 绘制内容的样式不会太多。但是在绘制内容数量大、样式多的场景下，我们应该考虑如何减少上下文context的切换。\n可以考虑使用先将相同样式的绘制内容收集起来，结合享元的方式将其维护起来。在绘制的时候，则可以针对每种样式做切换，切换后批量绘制相同样式的所有内容。\n举个例子，我们绘制俄罗斯方块，可以考虑所有方块的信息收集起来，相同样式的放在一个数据中，切换上下文后遍历绘制。比如，边框信息放在一个数组中，背景色相同的放在一个数组中。\n#Canvas 拆分\n一般来说，我们在 Canvas 里绘制的内容，都可以根据变更频率来拆分，简称动静分离。\nCanvas 拆分的关键点在于：尽量避免进行不必要的渲染，减少频繁变更的渲染范围。\n比如在游戏中，状态栏（血条、当前关卡说明等）相对动作/动画内容来说，这部分内容的变更不会太频繁，可以将其拆出到一个单独的 Canvas 来做绘制。再假设该游戏有个静态的复杂背景，如果我们每次更新内容都需要重新将这个背景再绘制一遍，显然开销也是不小的，那么这个背景我们也可以用单独的 Canvas 来绘制。\nCanvas 拆分的前提是更新频率的内容分离，而在拆分的时候也有两个小技巧：\n\n根据绘制范围拆分。\n根据堆叠层次关系拆分。\n\n#绘制范围的拆分\n绘制范围的拆分要怎么理解呢？简单说就是将画布划分不同的区域，然后根据不同的区域更新频率，来进行 Canvas 拆分。\n举个例子，假设我们现在需要实现 Web 端 VsCode，而整个界面都是由 Canvas 绘制（当然这样不大合理，这里假设只是为了更好地举例）。\n我们可以简单地将 VsCode 拆分成几个区域：顶部栏、左侧栏、底部栏、编辑区。显然这个几个区域的变更频率、触发变更的前提都不一致，我们可以将其做拆分。\n#堆叠层次的拆分\n如果说绘制范围的拆分是二维角度，那么堆叠层次更像是三维的 y 轴方向的拆分。\n前面提到的游戏画布拆分，其实背景图片便是堆叠在其余内容的下面。我们可以考虑更复杂的场景，比如我们要实现 Web 版的 Excel/Word，那么我们也可考虑按照堆叠顺序来做拆分：背景色、文字、边框线等等。\n对于有堆叠顺序的绘制来说，Canvas 拆分的优化效果更好。因为如果是二维角度的内容，我们可以只擦除和重绘某个 x/y 轴范围的内容就可以。\n但是涉及到绘制内容的堆叠，如果不做 Canvas 的拆分，意味着我们其中任何一个层级的内容变更，都需要将所有层级的内容擦除并且重绘。比如在 Excel 场景下，某个区域的格子背景颜色变更，我们需要将该区域的格子全部擦除，再重新分别绘制背景色、文字、边框线、其他内容等等。\n实际上，结合前面提到的context上下文的性能开销可知，我们在绘制的时候，很可能并不是以单个格子为单位来进行顺序堆叠的绘制，而是整个画布所有格子一起做顺序绘制（意思是，先绘制所有格子的背景色，再绘制所有格子的文字和边框线等等）。\n在这样的情况下，如果没有做 Canvas 堆叠顺序的拆分，意味着每一个小的变更，我们都需要将整个表格的内容进行重绘。\n#Canvas 拆分的开销\n需要注意的是，Canvas 本身的维护也会存在一定的开销，并不是说我们拆的越多越好。\n可以根据项目的实际情况，结合 Canvas 拆离后的效果，确定 Canvas 拆分的最终方案。\n#离屏渲染\n对于离屏渲染的概念，大多数情况是指：使用一个不可见（或是屏幕外）的 Canvas 对即将渲染的内容的某部分进行提前绘制，然后频繁地将屏幕外图像渲染到主画布上，避免重复生成该部分内容的步骤。\n比如，提前绘制好某个图像，在画布更新的时候直接使用该图像：\n// 在离屏 canvas 上绘制\nvar canvasOffscreen = document.createElement(&quot;canvas&quot;);\ncanvasOffscreen.width = dw;\ncanvasOffscreen.height = dh;\ncanvasOffscreen\n  .getContext(&quot;2d&quot;)\n  .drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n \n// 在绘制每一帧的时候，绘制这个图形\ncontext.drawImage(canvasOffscreen, x, y);\n#各种离屏渲染场景\n关于离屏渲染，其实结合不同的使用场景，还可以达到不同的效果。比如：\n(1) 使用离屏 Canvas 提前绘制特定内容。\n这就是前面说到的提前绘制好需要的内容，避免每次重复生成的开销。\n(2) 使用双 Canvas 交替绘制。\n考虑 Canvas 滚动的场景，比如分页绘制，离屏 Canvas 可以提前绘制下一页/下一屏的内容，在切换的时候可以直接使用提前绘制好的内容。\n通过这样的方式，可以加快 Canvas 的绘制，可以理解为预渲染的效果。\n(3) 使用 OffscreenCanvas 达到真正的离屏。\n通过 OffscreenCanvas API，真正地将离屏 Canvas 完整地运行在 worker 线程，有效减少主线程的性能开销。\n#OffscreenCanvas API 能力\n要达到将 Canvas 运行在 web worker 线程中，需要依赖 OffscreenCanvas API (opens new window)提供的能力。\n\n需要注意的是，该 API 同样可以运行在主线程中。即使是在主线程中运行，其开销也比普通 Canvas 要小。\n\nOffscreenCanvas提供了一个可以脱离屏幕渲染的 Canvas 对象，可运行在在窗口环境和 web worker 环境。但是该 API 已知具有兼容性问题（比如 Safari 和 IE，以及部分安卓 Webview），需要考虑不兼容情况下的降级方案。关于此能力现有的技术方案和文档较少，可参考：\n\nOffscreenCanvas - 概念说明及使用解析(opens new window)\nOffscreenCanvas — Speed up Your Canvas Operations with a Web Worker(opens new window)\n\n对于该 API，核心的优势在于：当主线程繁忙时，依然可以通过 OffscreenCanvas 在 worker 中更新画布内容，避免给用户造成页面卡顿的体验。\n除此之外，还可以进一步考虑在兼容性支持的情况下，通过将局部计算运行在 worker 中，减少渲染层的计算耗时，提升渲染层的渲染性能。\n#其他 Canvas 优化方式\n上面介绍了几种较大的 Canvas 优化方案，实际上我们在项目中还需要考虑：\n\n做内容的增量更新渲染，避免频繁地绘制大范围的内容\n避免浮点数的坐标点，浏览器为了达到抗锯齿的效果会做额外的运算，建议用整数取而代之\n使用 CSS transform 代替 Canvas 计算缩放（CSS transforms 使用 GPU，因此速度更快）\n过于复杂的计算逻辑，可以考虑做任务的拆分，避免长时间计算造成页面卡顿\n\n这里简单提一下增量渲染。\n#增量渲染\n增量渲染需要对内容的变更做计算，将变更的内容局限在某个特定范围，从而避免频繁地绘制大范围的内容。\n举个例子，假设我们的画布内容支持向下滚动，那么我们在滚动的时候可以考虑：\n\n根据滚动的距离，将上一帧可复用的内容做裁剪保存\n在下一帧绘制中，先将上一帧中重复的内容在新的位置绘制\n原有内容绘制完成后，新增的部分内容再进行重新绘制\n\n通过这样的方式，可以节省掉一部分的内容绘制和生成过程，提升每次渲染的速度。\n#结束语\n使用 Canvas 绘制，我们则脱离了浏览器自身的绘制过程，因此更加要注意性能问题，避免卡顿和耗时较大的计算。\n至于耗时长的计算和卡顿的优化，我会在另外一篇文章中做详细的介绍（参见前端性能优化——卡顿篇）。\n\n我有一个游戏梦，Canvas 做游戏应该也很好玩吧。\n"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--SSR篇":{"title":"前端性能优化--SSR篇","links":[],"tags":["编程/性能"],"content":"SSR 也算是前端性能优化中最常用的技术方案了，能有效地缩短页面的可见时间，给用户带来很好的体验。\n我们常说的 SSR 指 Server-Side Rendering，即服务端渲染，属于首屏直出渲染的一种方案。\n#SSR 性能优化\n首先，我们来看一下 SSR 方案主要优化了哪些地方的性能。\n#SSR 渲染方案\n一般来说，我们页面加载会分为好几个步骤：\n\n请求域名，服务器返回 HTML 资源。\n浏览器加载 HTML 片段，识别到有 CSS/JavaScript 资源时，获取资源并加载。\n\n现在大多数前端页面都是单页面应用，使用了一些前端框架来渲染页面，因此还会有以下的流程：\n\n加载并初始化前端框架、路由库。\n根据当前页面路由配置，命中对应的页面组件并进行渲染。\n页面组件如果有依赖的资源，则发起请求获取数据后，再进行渲染。\n\n到这里，用户才完整地可见到当前页面的内容，并进行操作。可见，页面启动时的加载流程比较长，对应的耗时也都无法避免。\n使用 SSR 服务端渲染，可以在第 1 步中直接返回当前页面的内容，浏览器可以直接进行渲染，再加载剩余的其他资源，因此优化效果是十分明显的。除了性能上的优化，SSR 还可以带来更好的 SEO 效果，因为搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\n那一般来说 SSR 技术方案要怎么做呢？其实从上面的过程中，我们也可以推导出，需要根据页面路由和页面内容生成对应的 HTML 内容，用于首次获取 HTML 的时候直接返回。\n#框架自带 SSR 渲染\n现在我们大多数前端项目都会使用框架，而许多开源框架也提供了 SSR 能力。由于前端框架本身就负责动态拼接和渲染 HTML 的工作，因此实现 SSR 有天然的便利性。\n以 Vue 为例子，Vue 提供了 vue-server-renderer (opens new window)服务端能力，基本思想基本也是前面说过的：浏览器请求服务端时，服务端完成动态拼接 HTML 的能力，将拼接好的 HTML 直接返回给浏览器，浏览器可以直接渲染页面：\n// 省略，可直接查看官网例子：ssr.vuejs.org/zh/guide/#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81\n \n// 服务端收到请求时，生成 HTML 内容并返回\nserver.get(&quot;*&quot;, (req, res) =&gt; {\n  // 使用 Vue 实例\n  const app = new Vue({\n    data: {\n      url: req.url,\n    },\n    template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;`,\n  });\n \n  // 使用 vue-server-renderer 将 Vue 实例生成最终的 HTML 内容\n  renderer.renderToString(app, context, (err, html) =&gt; {\n    console.log(html);\n    if (err) {\n      res.status(500).end(&quot;Internal Server Error&quot;);\n      return;\n    }\n    res.end(html);\n  });\n});\n \nserver.listen(8080);\n当服务端收到请求时，生成 Vue 实例并依赖vue-server-renderer的能力，将 Vue 实例生成最终的 HTML 内容。该例子中，服务端直接使用现有资源就可以完成直出 HTML 的拼接.\n但是在更多的前端应用场景下，通常还需要服务端动态获取其他的数据，才能完整地拼接出首屏需要的内容。一般来说，我们可以在服务端接到浏览器请求时，同时获取对应的数据，使用这些数据完成 HTML 拼接后再返回给浏览器。\n在 Vue SSR 能力中，可以依赖createApp的能力，引入Vuex提前获取对应的数据并更新到 Store 中（参考数据预取和状态 (opens new window)），然后在服务端收到请求时，创建完整的 Vue 应用的能力：\nconst createApp = require(&quot;/path/to/built-server-bundle.js&quot;);\n \nserver.get(&quot;*&quot;, (req, res) =&gt; {\n  const context = { url: req.url };\n \n  createApp(context).then((app) =&gt; {\n    renderer.renderToString(app, (err, html) =&gt; {\n      if (err) {\n        if (err.code === 404) {\n          res.status(404).end(&quot;Page not found&quot;);\n        } else {\n          res.status(500).end(&quot;Internal Server Error&quot;);\n        }\n      } else {\n        res.end(html);\n      }\n    });\n  });\n});\n#同构 SSR 渲染\n前面我们讲到，Vue 提供了 SSR 的能力，这意味着我们可以使用 Vue 来完成客户端和服务端渲染，因此大部分的代码都可以复用。对于这种一份代码可分别在服务器和客户端上运行，我们成为“同构”。\n对比自行实现 SSR 渲染，依赖开源框架提供的同构能力，一套代码可以分别实现 CSR 和 SSR，可大大节省维护成本。\n还是以 Vue 为例，使用 Vue 框架实现同构，大概的逻辑如图：\n\n不管是路由能力，还是组件渲染的能力，要保持同一套代码能分别运行在浏览器和服务端环境（Node.js）中，对于代码的编写则有一定的要求，比如 DOM 操作、window/document 对象等都需要谨慎，这些 Vue 官方指引 (opens new window)也有介绍。\n除此之外，服务端的入口逻辑显然会和客户端有差异，比如资源的获取方式、依赖的公共资源有所不一样等等。因此，在打包构建时会区分出两端的入口文件，并对通用逻辑做整合打包。这些内容也都在上面的图中有所体现。\n#非同构 SSR 渲染\n如果我们并没有强依赖前端框架，或是我们的项目过于复杂，此时可能要实现同构需要的成本比较大（抽离通用模块、移除环境依赖代码等）。考虑到项目的确需要 SSR 来加速页面可见，此时我们可以针对首屏渲染内容，自行实现 SSR 渲染。\nSSR 核心思想前面也讲过好几遍了，因此要做的事情也比较明确：根据不同的路由，提供对于的页面首屏拼接的能力。由于不强依赖于同构，因此可以直接使用其他语言或是 ejs 来实现首屏 HTML 内容的拼接。\n显然，非同构的方案实现 SSR 的成本，比同构的方案成本要高不少，并且还存在代码一致性、可维护性等一系列问题。因此，即使首屏直出的内容无法使用框架同构，大多数情况下，我们也会考虑尽量复用现有的代码，抽离核心的通用代码，并提供 SSR 服务代码编译打包的能力。\n举个例子，假设我们的页面完全由 Canvas 进行渲染，显然 Canvas 是无法直出的。但正因为 Canvas 渲染前，需要加载的代码、计算渲染内容等各种流程过长，耗时较多，想要实现 SSR 渲染则可能只能考虑，针对首屏内容做一套 DOM/SVG 渲染用于 SSR。\n基于这样的情况下，我们需要尽量复用计算部分的能力，抽离出通用的 Canvas/DOM/SVG 渲染接口，以尽可能实现对接口编程而不是对实现编程。\n#SSR 利弊\n上面主要围绕 SSR 的实现思想，介绍了开源框架 SSR、同构/非同构等 SSR 方案。\n其实除了代码实现的部分以外，一个完整的 SSR 方案，还需要考虑：\n\n代码构建/部署：代码发布流程中，如何确保 SSR 部分代码的有效性，即不会因为非 SSR 部分代码的变更导致 SSR 服务异常\n是否使用 Serverless：是否使用 Serverless 来部署 SSR 服务\n是否使用缓存：是否可以将 SSR 部分或是最终生成的 HTML 结果进行缓存，节约服务端计算和拼接成本\n\n我们在选择一个技术方案的时候，不能只看它能带来什么收益，同时还需要评估一并带来的风险以及弊端。\n对于 SSR 来说，收益是显而易见的，前面也有提到：\n\n实现更快的内容到达时间 (time-to-content)\n更好的 SEO\n\n而其弊端也是客观存在的，包括：\n\n服务端资源消耗\n方案需要开发成本和维护成本\n可能会影响页面最终的完全可交互时间\n\n对于最后一点，有时候也会被我们忽略。因为 SSR 在最开始就提供了首屏完整的 HTML 内容，用户可见时间极大地提前了，我们常常会忘了关注页面所有功能加载完成、页面可交互的时间点。显然，由于浏览器需要在首屏时渲染完整的 HTML 内容，该过程也是需要一定的耗时的，所以后面的其他步骤完成的时间点都会有所延迟。如果首屏 HTML 内容很多/复杂的情况下，这种情况会更明显。\n#结束语\nSSR 的内容大概讲到这里，其实在更多的时候，SSR 方案的重点往往是文中一笔带过的弊端。实现一套同构渲染的代码，亦或是维护两套分别用于 CSR/SSR 的代码，这些方案的目的和方向都比较明确。\n而 SSR 部署在什么环境、使用服务端还是 Serverless 生成，是否结合缓存实现、缓存更新策略又该是怎样的，如何保证非同构代码的渲染一致性，这些问题才是我们在将 SSR 方案落地过程中，需要反复思考和琢磨的问题。\n我们在做方案调研的时候，也常常会过于关注开发成本和最终效果，从而忽略了整个项目和方案过程中的许多可能性。虽然目的的确很重要，但要记住过程也是很重要的。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--加载流程篇":{"title":"前端性能优化--加载流程篇","links":["C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--归纳篇"],"tags":["编程/性能"],"content":"对于前端应用的性能优化，大多数时候我们都是从加载流程开始优化起。\n前面我有给大家整体地讲过《前端性能优化—归纳篇》，其实里面已经囊括了大多数场景下的一些性能优化的方向。\n越是交互复杂、用户量大的业务，对性能的要求就越是严格。大多数的前端性能优化，都是从页面的启动和加载流程开始梳理和定位，对于功能复杂的业务来说，这样的梳理尤为重要。\n\n\n                  \n                  注意❗ \n                  \n                \n注意：前面说过性能优化分为时间和空间两个角度，本文中提及的性能优化更多是指时间角度（即耗时）的优化。\n\n#常见的页面加载流程\n其实我们在性能优化的归纳篇有简单说过，页面加载的过程其实跟我们常常提起的浏览器页面渲染流程几乎一致：\n\n网络请求，服务端返回 HTML 内容。\n浏览器一边解析 HTML，一边进行页面渲染。\n解析到外部资源，会发起 HTTP 请求获取，加载 Javascript 代码时会暂停页面渲染。\n根据业务代码加载过程，会分别进入页面开始渲染、渲染完成、用户可交互等阶段。\n页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。\n\n那么，我们可以针对其中的每个步骤做优化，主要包括：资源获取、资源加载、页面可见、页面可交互。\n#资源获取\n资源获取主要可以围绕两个角度做优化：\n\n资源大小\n资源缓存\n\n#资源大小\n一般来说，前端都会在打包的时候做资源大小的优化，资源类型包括 HTML、JavaScript、CSS、图片等。优化的方向包括：\n(1) 合理的对资源进行分包。\n首次渲染时只保留当前页面渲染需要的资源，将可以异步加载、延迟加载的资源拆离。通常我们会在代码编译打包的时候做处理，比如使用 Webpack 将代码拆到不同的 bundle 包中 (opens new window)。\n(2) 移除不需要的代码。\n我们项目中常常会引入许多开源代码，同时我们自己也会实现很多的工具方法，但是实际上并不是全部相关的代码都是最终需要执行的代码，所以我们可以在打包的时候移除不需要的代码。现在基本大多数的打包工具都提供了类似的能力，比如 Tree-shaking。\n除此之外，如果我们的项目较大，使用和依赖了多个不同的仓库。如果在不同的代码仓库里，都依赖了同样的 npm 代码包，那么我们可能会遇到打包时引入多次同样的 npm 包的情况。一般来说，我们在管理依赖包的时候，可以使用peerDependency来进行管理，避免多次安装依赖、以及版本不一致导致的多次打包和安装等情况。\n(3) 资源压缩和合并。\n代码压缩也常常是在打包阶段进行的，包括 JavaScript 和 CSS 等代码，在一些情况下也可以使用图片合并（雪碧图的生成）。通常也是使用的打包工具以及插件自带的压缩能力，开启压缩后的代码可能比较难定位，可以配合 Sorce Mapping 来进行问题定位。\n除了打包时的压缩，我们在页面加载的时候也可以启用 HTTP 的 gzip 压缩，可以减少资源 HTTP 请求的耗时。\n#资源缓存\n资源缓存的优化，其实更多时候跟我们的资源获取的链路有关，包括：\n\n减少 DNS 查询时间，比如使用浏览器 DNS 缓存、计算机 DNS 缓存、服务器 DNS 缓存\n合理地使用 CDN 资源，有效地减少网络请求耗时\n对请求资源进行缓存，包括但不限于使用浏览器缓存、HTTP 缓存、后台缓存，比如使用 Service Worker、PWA 等技术\n\n其实，我们观察资源获取的链路，获取除了大小和缓存的角度以外，还可以做更多的优化，比如：\n\n使用 HTTP/2、HTTP/3，提升资源请求速度\n对请求进行优化，比如对多个请求进行合并，减少通信次数\n对请求进行域名拆分，提升并发请求数量\n\n#资源加载\n资源加载步骤中，我们一般也有以下的优化角度：\n\n加载流程拆分\n资源懒加载\n资源预加载\n\n#加载流程拆分\n页面的加载过程，常常分为两个阶段：页面可见、页面可交互。\n前面我们讲了对资源做拆分，在页面启动加载的时候仅加需要的资源，拆分的过程则可以结合上述的两个阶段来做处理。\n(1) 页面可见。\n页面可见可以分为部分可见以及内容完全可见。\n对于部分可见，一般来说可以做 loading 的展示或是直出，让用户知道页面正在加载中，而非无响应。\n对于内容完全可见，则是用户可视区域内的内容完全渲染完毕。除此之外，当前可视范围以外的内容，则可以拆离出首屏的分包，通过预加载或是懒加载的方式进行异步加载。\n(2) 页面可交互。\n同样的，页面可交互也可以分为部分可交互以及完全可交互。\n一般来说，组件的样式渲染仅需要 HTML 和 CSS 加载完成即可，而组件的功能则可能需要加载具体的功能代码。对于复杂或是依赖资源较多的功能，加载的耗时可能相对较长。在这样的情况下，我们可以选择将该部分的资源做异步加载。\n在初始的内容加载完毕之后，剩下的资源需要延迟加载。对于页面功能完全可交互，同样依赖于分包资源延迟加载。加载流程的优化，不管是页面可见，还是页面可交互，都离不开延迟加载。\n延迟加载可分为两种方式进行加载：懒加载和预加载。因此，资源懒加载和预加载也是加载流程中很重要的一部分。\n#资源懒加载\n我们常说的懒加载其实又被称为按需加载，顾名思义就是需要用到的时候才会进行加载。通过将非必要功能进行懒加载的方式，可以有效地减少页面的初始加载速度，提升页面加载的性能。\n常见的场景比如某些组件在渲染时不具备完整的功能，当用户点击的时候，才进行对应逻辑的获取和加载。遇到点击时未加载完成的情况下，可以通过适当的方式提示用户功能正在加载中。\n资源懒加载常常也是跟资源分包一起进行，大多数前端框架（比如 Vue、React、Angular）也都提供了懒加载的能力，也可以配合 Webpack 打包 (opens new window)做处理。\n#资源预加载\n资源预加载也称为闲时加载，很多时候我们可以在页面空闲的时候，对一些用户可能会用到的资源做提前加载，以加快后续渲染或者操作的时间。\n仔细一看，资源预加载和资源懒加载都比较相似，都会通过将资源拆离的方式做成异步延迟的方式加载。两者的区别在于：\n\n懒加载的功能只会在需要的时候才进行加载，因为一些功能用户可能不会使用到，比如帮助中心、反馈功能等等\n预加载的功能则是在不阻塞核心功能的时候，尽可能利用空闲的资源提前加载，这部分的功能则是用户很可能会使用到，比如获取下一屏页面的内容数据\n\n#复杂场景下的加载流程\n在页面到达可交互状态之后，后续的加载流程也可以根据业务场景做后续的优化。对于一些复杂的业务，我们可以结合业务的特点做更进一步的性能优化。\n#复杂加载流程管理\n对于页面初始化流程过于复杂的应用来说，我们可以对加载流程做任务的拆分，分阶段地进行加载。\n举个例子，假设我们需要在 Web 端加载 VsCode，那么我们可能需要考虑以下各个功能的加载：\n- 整体页面框架\n- 顶部菜单栏\n- 左侧工具栏\n- 底部状态栏\n- 文件目录栏\n- 文件详情\n  - 内容展示\n  - 编辑功能\n  - 菜单功能\n- 搜索功能\n- 插件功能\n\n以上只是我按照自己想法粗略拆分的功能，我们可以简单分成几个加载阶段：\n\n页面整体框架加载完成。此时可以看到各个功能区域的分布，包括顶部菜单栏、左侧工具栏、底部状态栏、项目内容区域等等，但这些区域的内容未必都完全加载完成。\n通用功能加载完成。比如顶部菜单栏、左侧工具栏、底部状态栏等等，一些具体的菜单或是工具的功能可以做按需加载和预加载，比如搜索功能。\n项目内容相关框架加载完成。此时可以看到项目相关的内容区域，比如文件目录、当前文件的内容详情等等。\n插件功能。用户安装的插件，在核心功能都加载完成之后再获取和加载。\n\n当我们根据项目的具体加载过程做了阶段划分之后，则可以将我们的代码做任务拆分，可以拆分成串行和并行的任务。串行的任务比如按照阶段划分的大任务，并行的任务则可以是某个阶段内的小任务，其中也可以包括一些异步执行的任务，或是延迟加载的任务。\n#长耗时任务的拆离\n如果我们的应用中会有耗时较长的计算任务，比如拉取回来的数据需要计算处理后才能渲染，那么我们可以对这些耗时较长的任务做任务拆分。\n同样的，我们还是回到 Web 端加载 VsCode 的场景。假设我们在加载某个特别大的文件，则可以考虑分别对该文件的内容获取、数据转换做任务拆分，比如分片获取该文件的内容，根据分片的内容做渲染的计算，计算过程如果耗时较长，也可以做异步任务的拆分，甚至可以结合 Web Worker 和 WebAssembly 等技术做更多的优化。\n#读写分离\n对于交互复杂、需要加载的资源较多的情况下，如果用户的权限只是可读，那么对于编辑相关的功能可以做资源拆离，对于有权限的用户才进行编辑能力的加载。\n读写分离其实属于资源拆分的一种具体场景，我们可以结合业务的具体场景做具体的功能拆分，比如管理员权限相关的管理功能，也是类似的优化场景。\n#结束语\n我们做性能优化的场景，更多时候出现在我们的应用出现了性能瓶颈的时候。大多数情况下，前端应用都相对简单，也无需做过度的优化。\n对于复杂的应用，对加载流程和链路的梳理、划分，不管是对我们做架构设计来说，还是对于做性能优化来说，都有不小的帮助。只有理清楚整个应用的加载流程，结合对每个步骤和阶段的耗时统计，我们可以针对性地对耗时较长的地方做优化。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿的监控和定位":{"title":"前端性能优化--卡顿的监控和定位","links":["Web-Clip/@阿里面试：写一个倒计时功能刷掉了80-percent-的人","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿篇","C-Knowledge/前端/技术书籍/前端性能优化手册/TTI"],"tags":["编程/性能"],"content":"卡顿大概是前端遇到的问题的最棘手的一个，尤其是卡顿产生的时候常常无法进行其他操作，甚至控制台也打开不了。\n但是这活落到了咱们头上，老板说啥就得做啥。能本地复现的我们还能打开控制台，打个断点或者录制 Performance 来看看到底哪些地方占用较大的耗时。如果没法本地复现呢？\n#卡顿检测\n首先，我们来看看可以怎么主动检测卡顿的出现。\n卡顿，顾名思义则是代码执行产生长耗时，导致浏览器无法及时响应用户的操作。那么，我们可以基于不同的方案，来监测当前页面响应的延迟。\n#Worker 心跳方案\n对应浏览器来说，由于 JavaScript 是单线程的设计，当卡顿发生的时候，往往是由于 JavaScript 在执行过长的逻辑，常见于大量数据的遍历操作，甚至是进入死循环。\n利用这个特效，我们可以在页面打开的时候，就启动一个 Worker 线程，使用心跳的方式与主线程进行同步。假设我们希望能监测 1s 以上的卡顿，我们可以设置主线程每间隔 1s 向 Worker 发送心跳消息。（当然，线程通讯本身需要一些耗时，且 JavaScript 的计时器也未必是准时的，因此心跳需要给予一定的冗余范围）\n由于页面发生卡顿的时候，主线程往往是忙碌状态，我们可以通过 Worker 里丢失心跳的时候进行上报，就能及时发现卡顿的产生。\n但是其实 Worker 更多时候用于检测网页崩溃，用来检测卡顿的效果其实还不如使用window.requestAnimationFrame，因为线程通信的耗时和延迟导致该方案不大准确。\n#window.requestAnimationFrame 方案\n前面前端性能优化—卡顿篇有简单提到一些卡顿的检测方案，市面上大多数的方案也是基于window.requestAnimationFrame方法来检测是否有卡顿出现。\nwindow.requestAnimationFrame()会在浏览器下次重绘之前调用，常常用来更新动画。这是因为setTimeout/setInterval计时器只能保证将回调添加至浏览器的回调队列(宏任务)的时间，不能保证回调队列的运行时间，因此使用window.requestAnimationFrame会更合适。\n通常来说，大多数电脑显示器的刷新频率是 60Hz，也就是说每秒钟window.requestAnimationFrame会被执行 60 次。因此可以使用window.requestAnimationFrame来监控卡顿，具体的方案会依赖于我们项目的要求。\n比如，有些人会认为连续出现 3 个低于 20 的 FPS 即可认为网页存在卡顿 (opens new window)，这种情况下我们则针对这个数值进行上报。\n除此之外，假设我们认为页面中存在超过特定时间（比如 1s）的长耗时任务即存在明显卡顿，则我们可以判断两次window.requestAnimationFrame执行间超过一定时间，则发生了卡顿。\n\n\n                  \n                  注意❗ \n                  \n                \n使用window.requestAnimationFrame监测卡顿需要注意的是，他是一个被十分频繁执行的代码，不应该处理过多的逻辑。\n\n#Long Tasks API 方案\n熟悉前端性能优化的开发都知道，阻塞主线程达 50 毫秒或以上的任务会导致以下问题：\n\n可交互时间（TTI）延迟\n严重不稳定的交互行为 (轻击、单击、滚动、滚轮等) 延迟\n严重不稳定的事件回调延迟\n紊乱的动画和滚动\n\n因此，W3C 推出 Long Tasks API (opens new window)。长任务（Long task）定义了任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。比如以下常规场景：\n\n长耗时的事件回调\n代价高昂的回流和其他重绘\n浏览器在超过 50 毫秒的事件循环的相邻循环之间所做的工作\n\n\n参考 Long Tasks API — MDN(opens new window)\n\n我们可以使用PerformanceObserver这样简单地获取到长任务：\nvar observer = new PerformanceObserver(function (list) {\n  var perfEntries = list.getEntries();\n  for (var i = 0; i &lt; perfEntries.length; i++) {\n    // 分析和上报关键卡顿信息\n  }\n});\n// 注册长任务的观察\nobserver.observe({ entryTypes: [&quot;longtask&quot;] });\n相比requestAnimationFrame，使用 Long Tasks API 可避免调用过于频繁的问题，并且performance timeline的任务优先级较低，会尽可能在空闲时进行，可避免影响页面其他任务的执行。但需要注意的是，该 API 还处于实验性阶段，兼容性还有待完善，而我们卡顿常常发生在版本较落后、性能较差的机器上，因此兜底方案也是十分需要的。\n#PerformanceObserver 卡顿检测\n前面也提到，卡顿产生于用户操作后网页无法及时响应。根据这个原理，我们可以使用PerformanceObserver监听用户操作，检测是否产生卡顿：\nnew PerformanceObserver((list) =&gt; {\n  list.getEntries().forEach((entry) =&gt; {\n    const duration = entry.duration;\n \n    const delay = entry.processingStart - entry.startTime;\n    const eventHandlerTime = entry.processingEnd - entry.processingStart;\n \n    console.log(`Total duration: ${duration}`);\n    console.log(`Event delay: ${delay}`);\n    console.log(`Event handler duration: ${eventHandlerTime}`);\n  });\n}).observe({ type: &quot;event&quot; });\n这种方式的好处是避免频繁在requestAnimationFrame中执行任务，这也是官方鼓励开发者使用的方式，它避免了轮询，且被设计为低优先级任务，甚至可以从缓存中取出过往数据。\n但该方式仅能发现卡顿，至于具体的定位还是得配合埋点和心跳进行会更有效。\n#卡顿埋点上报\n不管是哪种卡顿监控方式，我们使用检测卡顿的方案发现了卡顿之后，需要将卡顿进行上报才能及时发现问题。但如果我们仅仅上报了卡顿的发生，是不足以定位和解决问题的。\n#卡顿打点\n那么，我们可以通过打点的方式来大概获取卡顿发生的位置。\n举个例子，假设我们一个网页中，关键的点和容易产生长耗时的操作包括：\n\n加载数据。\n计算。\n渲染。\n批量操作。\n数据提交。\n\n那么，我们可以在这些操作的地方进行打点。假设我们卡顿工具的能力主要有两个：\ninterface IJank {\n  _jankLogs: Array&lt;IJankLogInfo &amp; { logTime: number }&gt;;\n  // 打点\n  log(jankLogInfo: IJankLogInfo): void;\n  // 心跳\n  _heartbeat(): void;\n}\n那么，当我们在页面加载的时候分别进行打点，我们的堆栈可能是这样的：\n_jankLogs = [\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;加载数据&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;计算&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;渲染&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;批量操作计算&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;数据提交&quot;,\n    logTime: xxxxx,\n  },\n];\n当卡顿心跳发现卡顿产生时，我们可以拿到堆栈的数据，比如当用户在批量操作之后发生卡顿，假设此时我们拿到堆栈：\n_jankLogs = [\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;加载数据&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;计算&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;渲染&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;批量操作计算&quot;,\n    logTime: xxxxx,\n  },\n];\n这意味着卡顿发生时，最后一次操作是数据层--批量操作计算，则我们可以认为是该操作产生了卡顿。\n我们可以将module/action以及具体的卡顿耗时一起上报，这样就方便我们监控用户的大盘卡顿数据了，也较容易地定位到具体卡顿产生的位置。\n#心跳打点\n当然，上述方案如果能达到最优效果，则我们需要在代码中关键的位置进行打点，常见的比如数据加载、计算、事件触发、JavaScript 加载等。\n我们可以将打点方法做成装饰器，自动给class中的方法进行打点。如果埋点数据过少，可能会产生误报，那么我们可以增加心跳的打点：\nIJank._heartbeat = () =&gt; {\n  IJank.log({\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  });\n};\n当我们心跳产生的时候，会更新堆栈数据。假设发生卡顿的时候，我们拿到这样的堆栈信息：\n_jankLogs = [\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;加载数据&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;计算&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;渲染层&quot;,\n    action: &quot;渲染&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;数据层&quot;,\n    action: &quot;批量操作计算&quot;,\n    logTime: xxxxx,\n  },\n  {\n    module: &quot;Jank&quot;,\n    action: &quot;heartbeat&quot;,\n    logTime: xxxxx,\n  },\n];\n显然，卡顿发生时最后一次打点为Jank--heartbeat，这意味着卡顿并不是产生于数据层---批量操作计算，而是产生于该逻辑后的一个不知名逻辑。在这种情况下，我们可能还需要再在可疑的地方增加打点，再继续观察。\n#JavaScript 加载打点\n有一个用于监控一些懒加载的 JavaScript 代码的小技巧，我们可以使用PerformanceObserver获取到 JavaScript 代码资源拉取回来后的时机，然后进行打点：\nperformanceObserver = new PerformanceObserver((resource) =&gt; {\n  const entries = resource.getEntries();\n \n  entries.forEach((entry: PerformanceResourceTiming) =&gt; {\n    // 获取 JavaScript 资源\n    if (entry.initiatorType !== &quot;script&quot;) return;\n \n    // 打点\n    this.log({\n      moduleValue: &quot;compileScript&quot;,\n      actionValue: entry.name,\n    });\n  });\n});\n \n// 监测 resource 资源\nperformanceObserver.observe({ entryTypes: [&quot;resource&quot;] });\n当卡顿产生时，堆栈的最后一个日志如果为compileScript--bundle_xxxx之类的，则可以认为该 JavaScript 资源在加载的时候耗时较久，导致卡顿的产生。\n通过这样的方式，我们可以有效监控用户卡顿的发生，以及卡顿产生较多的逻辑，然后进行相应的问题定位和优化。\n#结束语\n对于计算逻辑较多、页面逻辑复杂的项目来说，卡顿常常是一个较大痛点。\n关于日常性能的数据监控和优化方案之前也有介绍不少，相比一般的性能优化，卡顿往往产生于不合理的逻辑中，比如死循环、过大数据的反复遍历等等，其监控和定位方式也与普通的性能优化不大一致。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿篇":{"title":"前端性能优化--卡顿篇","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/WebAssembly"],"tags":["编程/性能"],"content":"如果页面中存在耗时较长的计算任务，那么卡顿也是需要关注的一个性能优化点。\n前面我有给大家整体地讲过《前端性能优化—归纳篇》，其实里面已经囊括了大多数场景下的一些性能优化的方向。\n当我们开始讨论卡顿时，往往意味着页面中有较大的逻辑运算，该计算任务耗时太长，阻塞了浏览器的主线程，导致用户的一些操作无法及时响应。因此，我们今天卡顿优化的重点在于如何优化耗时较长的计算。\n#卡顿优化\n还是那句话，对于大多数的渲染场景，我们都可以使用浏览器的 Performance 来录制和分析性能问题，Performance 适用于针对某个具体、可复现的问题做分析。\n卡顿问题同样也是，我们可以在火焰图中看到一些长耗时的任务，然后再逐个分析具体的耗时问题出现在哪里，逐一解决。\n这里介绍一些耗时任务的优化方案。\n#赋值和取值\n其实大多数情况下，我们都很少会去在意一些变量的取值和赋值。\n但是在一些复杂的计算场景下，比如深层次的遍历中，需要考虑的点就很多很细，比如：\n\n尽量将不需要执行的逻辑前置，提前判断做return\n减少window对象或是深层次对象上的取值，可以将其保存为临时变量使用\n减少不必要的遍历，Array.filter()这种语法也是一次遍历，需要注意\n对复杂数据结构的数据查询，可以考虑优化数据结构\n\n一些简单的问题，在重复上百万次的计算之后，都会被无数放大。即使是从window对象上获取某个值，然后做计算生成 DOM 这样的操作，如果将它放在多层遍历的最里层去做，同样会造成性能问题。\n如果你的项目中有使用 Canvas，且重度依赖画布绘制，你会发现 ctx 的上下文切换开销也不低，后面也会单独对 Canvas 的一些性能问题做补充说明。\n这也告诉我们，平时的代码习惯也要好，比如副作用、全局对象等，都可以考虑做更好的设计。\n#优化计算性能/内存\n除了上面提到的一些基础场景（比如取值赋值），很多时候我们提升计算性能，还依赖于使用更好的算法和数据结构。\n其实大多数时候，前端都很少涉及到算法和数据结构相关的设计，但是在极端复杂的场景下，也需要考虑做一些优化。\n讲一个经典例子，在 VSCode 的 1.21 发布版本中包含了一项重大改进：全新的文本缓冲区实现 (opens new window)，在内存和速度方面都有大幅的性能提升。\n在这次优化中，VSCode 引入了红黑树的数据结构，替代了原有的线性阵列，优化了内存避免了内存爆炸，同时也优化了查询的时间复杂度。\n其实，除了计算耗时过长，如果出现内存占用过多的情况下，同样会造成浏览器频繁的 GC。如果你有仔细观察 Performance，便会发现浏览器的 GC 本身也需要不小的耗时。\n所以，我们还需要时常关注内存情况，考虑：\n\n使用享元的方式来优化数据存储，减少内存占用\n及时地清理不用的资源，比如定时器\n避免内存泄露等问题\n\n#大任务拆解\n对于一些计算耗时较长的任务，我们可以考虑将任务做拆解，分成一个个的小任务，做异步执行。\n比如，考虑将任务执行耗时控制在 50 ms 左右。每执行完一个任务，如果耗时超过 50 ms，将剩余任务设为异步，放到下一次执行，给到页面响应用户操作和更新渲染的时间。\n我们都知道 React 框架有使用虚拟 DOM 的设计。实际上，虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈：\n\n在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树\n在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费\n递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降\n\n对此，React 中还设计了协调器（Reconciler）与渲染器（Renderer）来优化页面的渲染性能。而在 React16 中，还新增了调度器（Scheduler）。\n调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。通过这样的方式，React 可在浏览器空闲的时候进行调度并执行任务。\n这便是将大任务做拆解方案中，很好的一个例子。\n#其他计算优化\n除了上述的一些优化方案，我们还可以考虑：\n(1) 使用 Web Worker。\n如今 Web Worker 已经是前端应用中比较常用的一个能力了，对于一些耗时较长、相对独立的计算任务，我们可以使用 Web Worker 来进行计算。\n当然，由于这些计算任务已经不在主线程了，那么通信的耗时、数据的同步、Worker 兼容性等问题也需要考虑，做好兜底和兼容方案，保证核心能力的使用。\n(2) 使用 WebAssembly。\nWebAssembly 的运行性能接近原生，因此在许多计算耗时的场景上会被使用来优化，比如文件上传、文件/视频内容识别等等。\n(3) 使用 AOT 技术。\n使用 AOT 技术，通过将计算过程提前，减少计算等待时长。\n举个例子，在 Angular 框架中，提供了**预编译（AOT）**能力，无须等待应用首次编译，以及通过预编译的方式移除不需要的库代码、减少体积，还可以提早检测模板错误。\n#卡顿的监控和定位\n出现卡顿问题的时候，往往难以定位，因为这个时候页面常常已经卡死，无法做更多的调试操作。\n#Performance\n定位一个页面的运行是否有卡顿，最简单又直接的方式是录制 Performance。Performance 会把耗时长的任务直接标记为红色，我们可以根据这些任务，查找和分析具体产生耗时的脚本是哪些，然后去做优化。\n但是，Performance 仅对开发者来说比较方便，在真实用户的使用场景里，未必有条件能提供 Performance 的录制。更多的时候，我们只能粗略地监控用户的卡顿情况，发现这样的场景，并尝试去解决。\n#requestAnimationFrame\n一般来说我们监控卡顿，可以考虑使用window.requestAnimationFrame方法。该方法会在绘制下一帧绘制前被调用，这意味着当前的同步计算任务即将结束。\n前面也有说到，卡顿大多数是因为长耗时的计算任务导致的。那么，我们就可以考虑在某个函数执行之前记下时间戳，而在window.requestAnimationFrame的时候再取其中的时间差，判断当前函数的执行耗时是否合理。\n当然，该方案并不是完全准确，因为我们常常会在一个函数中间调用另外一个函数，还可能会同步抛出事件通知，执行其他的计算任务。\n不过，考虑到真实的线上用户里无法直接使用 Performance，这也算是一个能做卡顿监控的方案。我们可以配合日志、其他不同的监控和上报等，来做更多的问题定位。\n#结束语\n大多数的卡顿场景，都是由于页面渲染掉帧导致的。因此针对页面的更新渲染，不管是 DOM 渲染还是 Canvas 渲染，需要注意将帧率保持在 50~60 FPS 的范围内，这样用户的体验会流程很多。\n当然，如果我们的代码里写了死循环，造成页面直接卡死了，也是卡顿的一种情况，但这就又是另外一个故事了。\n\n愿天下所有的开发同学不再遇到卡顿~\n"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--容器篇":{"title":"前端性能优化--容器篇","links":["C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--归纳篇"],"tags":["编程/性能"],"content":"前面我们讲了很多前端应用内部的性能优化，实际上除了前端自身，我们还可结合容纳 Web 页面本身的客户端一起做优化。\n首先，本文中提到的容器，基本上都是指 Web 页面的宿主，比如浏览器、APP 客户端、小程序，它们提供了 WebView 环境来运行 Web 应用。\n#容器性能优化\n由于 Web 应用本身只运行在 WebView 中，而 WebView 的能力又依赖于宿主容器，因此 Web 应用本身很多能力都比较局限。如果宿主容器能配合一起做一些优化，效果要远胜于我们自身做的很多优化效果。\n从性能优化的角度来说，宿主容器主要能提供的能力包括：\n\n加速页面打开\n加速页面切换\n\n#加速页面打开\n对前端项目来说，我们常常会对首屏打开做很多的优化，包括尽量减少首屏需要的代码、对首屏渲染的内容进行分片等等（参考《前端性能优化—归纳篇》）。\n即使前端本身优化到极致，对于资源获取、请求数据等这些耗时占比较大的部分，还是存在的。但是如果容器能提供类似的能力，我们就可以将这部分的耗时做优化了，比如：\n\n提前下载并缓存 Web 相关资源，页面打开时直接获取缓存，比如 HTML/JavaScript/CSS\n提前获取和缓存页面渲染相关的请求资源，页面请求时直接返回，或是直接从缓存中获取\n提前启动 WebView 页面，并加载基础资源\n\n#资源准备\n我们可以在客户端即将打开某个 WebView 页面之前，提前将该页面资源下载下来，由此加快 WebView 页面加载的速度。\n由于资源请求本身也会消耗一定的资源，一般来说会在比较明确使用的场景下才会使用。也就是说用户很可能会点进去该 WebView 页面，基于这样的前提来做资源准备，比如列表页进入详情页，比如底部 TAB 进入的页面等等。\n这些提前下载并临时缓存的资源，可以包括：\n\n页面加载资源，包括 HTML/CSS/JavaScript 等\n首屏页面内容的请求数据，比如分片数据的首片数据等\n\n资源预下载要做的时候相对简单，需要注意的是下载后的资源的管理问题，在使用完毕或是不需要的情况下需要及时的清理，如果过多的缓存会占用用户机器的资源。\n其实除了依赖客户端，前端本身也有相关的技术方案，比如说可以使用 PWA 提前请求和缓存页面需要的资源。\n#预加载\n在需要的资源已经准备好的前提下，容器还可以提供预加载的能力，包括：\n\n容器预热：提前准备好 WebView 资源\n资源加载：将已下载的 Web 资源进行加载，比如基础的 HTML/CSS/JavaScript 等资源\n\n举个例子，小程序中也有对资源预加载做处理。在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。\n小程序的启动过程也分了两个步骤：\n\n\n页面预渲染。这是准备 WebView 页面的过程，由于小程序里是双线程的设计，因此渲染层和逻辑层都会分别进行初始化以及公共库的注入。逻辑层和渲染层是并行进行的，并不会相互依赖和阻塞。\n小程序启动。当用户打开小程序后，小程序开始下载业务代码，同时会在本地创建基础 UI（内置组件）。准备完成后，就会开始注入业务代码，启动运行业务逻辑。\n\n显然，小程序基础库和环境初始化相关的资源，都被提前内置在 APP 中了，并提前准备好相关的资源，使得用户打开小程序的时候，可以快速地加载页面。除此之外，小程序还提供了预加载的能力，业务方只需要配置提前拉取的资源，微信则可以在启动的过程中，提前将相关的资源拉取回来。\n很多宿主预加载的方案也类似，比如对 WebView 页面做前置的资源下载和加载，当用户点击时尽快地给到用户体验。\n#加速页面切换\n除了首次打开页面的加速，在页面切换时我们也可以做很多提速的事情。\n#容器预热\n前面讲到，在打开小程序前，其实微信已经提前准备好了一个 WebView 层，由此减少小程序的加载耗时。\n而当这个预备的 WebView 层被使用之后，一个新的 WebView 层同样地会被提前准备好。这样当开发者跳转到新页面时，就可以快速渲染页面了。这个过程也可以理解为容器的前置预热。\n在这个例子中，小程序针对不同的页面使用了不同的 WebView 进行渲染，因此不管是首次打开，还是跳转/切换新页面，都会准备多一个 WebView 用来快速加载。\n但多准备一个 WebView 本身也是对客户端的一种资源消耗，所以其实我们还可以考虑另外一种方案：容器切换。\n#容器切换\n容器切换方案指当页面切换时复用同一个 WebView 资源，可以理解为前端单应用类似的方式在 APP 中做资源切换。\n由于需要复用同一个 WebView，因此该方案对资源的管理要求较高，包括：\n\n对页面应用的生命周期管理完善，自顶向下实现初始化、更新和销毁的能力\n页面切换时，需要及时清理原有逻辑和资源，比如定时器、页面遗留的 UI 和事件监听等\n资源占用、内存泄露等问题，会随着 WebView 复用次数而积累\n\n要达到不同页面和前端应用之间的资源复用，要求比直接准备一个新的 WebView 容器要高很多。即使是不同的页面，也需要有统一的生命周期管理，约定好页面的一些销毁行为，并能执行到每个模块和组件中。\n但如果项目架构和设计做得好，效果要远胜于容器预热，因为在进行页面切换的时候，很多资源可以直接复用，比如：\n\n通用的框架库，比如使用了 Vue/React 等前端框架、Antd 等组件库，就可以免去获取和加载这些资源的耗时\n公共库的复用，项目中自行封装的一些工具库，也可以直接复用\n模块复用，通用的模块比如顶部栏、底部栏、工具栏、菜单栏等功能，可以在页面切换时选择性保留，直接省略这部分模块的加载和页面渲染\n\n看到这里或许有些人会疑惑，如果是这样的话为什么不直接用单页面呢？要知道我们讨论的场景是客户端打开的场景，也就是说 WebView 页面的退出，大多数情况下是会先回到 APP 原生页面中。当用户进入到另外一个 WebView 页面时，才会重新打开 WebView，此时才考虑是用新预热的 WebView，还是直接复用刚才的 WebView。\n总的来说，容器切换是一个设计要求高、副作用强、但优化效果好的方案。\n#客户端直出渲染\n在有容器提供资源的基础上，我们还可以在 WebView 页面关闭前，对当前页面做截屏或是 HTML 保存处理。\n在下一次用户进入到相同的页面中时，可以先使用上一次浏览的图片或是页面片段先预览，当页面加载完成后，再将预览部分移除。这种预加载（预览）的方案，由于是客户端提供的直出渲染能力，因此也被称为客户端直出渲染。\n当然，相对于在页面关闭前保存，其实也可以直接实现直出渲染的能力，这样不管是否已经打开过某个页面，都可以通过容器预热时提前计算出直出渲染的内容，当页面打开时直接进行渲染。\n这种方案有一个比较麻烦的地方：当缓存的页面内容发生变化时，需要及时更新直出渲染的内容。\n因此，及时用户并不在页面内，也需要定期去获取最新的资源，并生成直出渲染的内容。当需要预渲染的页面多了，维护这些页面的实时性也需要消耗不少的资源，因此更适用于维护成本较低的页面。\n#结束语\n其实，容器的作用不只是加速页面打开速度，由于结合了原生 APP 的能力，我们甚至可以给 WebView 提供完整的离线加载能力。比如在网络离线的情况下，通过提前将资源下载并缓存，用户依然可以正常访问 APP 里的页面。\n当然，每一项技术方案都是有利有弊，容器提供了更优的能力，也需要消耗一定的资源，我们可以结合自己项目本身的情况来做取舍。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--归纳篇":{"title":"前端性能优化--归纳篇","links":["C-Knowledge/前端/技术书籍/前端性能优化手册/补齐Web前端性能分析的工具盲点"],"tags":["编程/性能"],"content":"对于前端开发来说，性能优化老生常谈了。不管是日常工作中，还是涉及到晋级答辩，性能都是频繁被我们提及的一个话题。\n性能优化不是一劳永逸的解决方案，项目在发展过程，代码不断地迭代和变更。我们在某个阶段优化过的代码，过段时间性能又会慢慢下降，这也是前端开发常把性能挂在嘴边的原因。\n当页面加载时间过长、交互操作不流畅时，会给用户带来很糟糕的体验。越是使用时间越长的产品，用户对体验的要求越高，如果出现卡顿或是加载缓慢，最坏的情况下会导致用户的流失。\n对于性能优化，其实解决方案也比较常见和通用了，但是基本上也只有指导思想，实施起来还得具体项目具体分析。\n#常见的性能优化方案\n对于前端应用来说，网络耗时、页面加载耗时、脚本执行耗时、渲染耗时等耗时情况会影响用户的等待时长，而 CPU 占用、内存占用、本地缓存占用等则可能会导致页面卡顿甚至卡死。\n因此，性能优化可以分别从耗时和资源占用两方面来解决，我个人也比较喜欢将其称为“时间”和“空间”两个维度。\n#时间角度优化：减少耗时\n我们知道浏览器在页面加载过程中，会进行以下的步骤：\n\n网络请求相关（发起 HTTP 请求从服务端获取页面资源，包括 HTML/CSS/JS/图片资源等）\n浏览器解析 HTML 和渲染页面\n加载 Javascript 代码时会暂停页面渲染（包括解析到外部资源，会发起 HTTP 请求获取并加载）\n\n在浏览器的首次加载和渲染完成之后，不代表用户就可以马上交互和操作。根据业务代码加载过程，页面还会分别进入页面开始渲染、渲染完成、用户可交互等阶段。除此之外，页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。\n\n题外话：为什么我们常常说要理解原理呢？性能优化便是个很好的例子，如果你不知道这个过程具体发生了什么，就很难找到地方下手去进行优化。\n\n根据这个过程，我们可以从四个方面进行耗时优化：\n\n网络请求优化。\n首屏加载优化。\n渲染过程优化。\n计算/逻辑运行提速。\n\n在前端性能优化实践中，网络请求优化和首屏加载优化方案使用频率最高，因为不管项目规模如何、各个模块和逻辑是否复杂，这两个方向的耗时优化方案都是比较通用的。相比之下，对于页面内容较多、交互逻辑/运算逻辑复杂的项目，才需要针对性地进行渲染过程优化和计算/逻辑运行提速。\n一起来看看~\n#1. 网络请求优化\n网络请求优化的目标在于减少网络资源的请求和加载耗时，如果考虑 HTTP 请求过程，显然我们可以从几个角度来进行优化：\n\n请求链路：DNS 查询、部署 CDN 节点、缓存等。\n数据大小：代码大小、图片资源等。\n\n对于请求链路，核心的方案常常包括使用缓存，比如 DNS 缓存、CDN 缓存、HTTP 缓存、后台缓存等等，前端的话还可以考虑使用 Service Worker、PWA 等技术。使用缓存并非万能药，很多使用由于缓存的存在，我们在功能更新修复的时候还需要考虑缓存的情况。除此之外，还可以考虑使用 HTTP/2、HTTP/3 等提升资源请求速度，以及对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。\n数据大小则主要考对请求资源进行合理的拆分（CSS、Javascript 脚本、图片/音频/视频等）和压缩，减少请求资源的体积，比如使用 Tree-shaking、代码分割、移除用不上的依赖项等。\n在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。\n#2. 首屏加载优化\n首屏加载优化核心点在于两部分：\n\n将页面内容尽快地展示给用户，减少页面白屏时间。\n将用户可操作的时间尽量提前，避免用户无法操作的卡顿体验。\n\n减少白屏时间除了我们常说的首屏加载耗时优化，还可以考虑使用一些过渡的动画，让用户感知到页面正在顺利加载，从而避免用户对于白屏页面或是静止页面产生烦躁和困惑。除了技术侧的优化，很多时候产品策略的调整，给用户带来的体验优化效果不低于技术手段优化，因此我们也需要重视。\n整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：\n\n对页面的内容进行分片/分屏加载\n仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源\n使用骨架屏进行预渲染\n使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块\n使用服务端直出渲染，减少页面二次请求和渲染的耗时\n\n有些时候，我们的页面也需要在客户端进行展示，此时可充分利用客户端的优势：\n\n配合客户端进行资源预请求和预加载，比如使用预热 Web 容器\n配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染\n使用秒看技术，通过生成预览图片的方式提前将页面内容提供给用户\n\n除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。\n#3. 渲染过程优化\n渲染过程的优化要怎么定义呢？我们可以将其理解为首屏加载完成后，用户的操作交互触发的二次渲染。\n主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：\n\n使用资源预加载，提升空闲时间的资源利用率\n减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时\n使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 离屏渲染）\n通过合理使用浏览器 GPU 能力，提升浏览器渲染效率（比如使用 css transform 代替 Canvas 缩放绘制）\n\n以上这些，是对常见的 Web 页面渲染优化方案。对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算/逻辑运行的提速。\n#4. 计算/逻辑运行提速\n计算/逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：\n\n通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况\n将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker\n通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly\n通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术\n通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算\n通过将计算结果缓存的方式，减少运算次数\n\n以上便是时间维度的性能优化思路，还有空间维度的资源优化情况。\n#空间角度优化：降低资源占用\n提到性能优化，大多数我们都在针对页面加载耗时进行优化，对资源占用的优化会更少，因为资源占用常常会直接受到用户设备性能和适应场景的影响，大多数情况下优化效果会比耗时优化局限，因此这里也只能说一些大概的思路。\n资源占用常见的优化方式包括：\n\n合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理\n避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等\n避免复杂/异常的递归调用，导致调用栈的溢出\n通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用\n\n说到底，我们在做性能优化的时候，其实很多情况下会依赖时间换空间、空间换时间等方式。性能优化没有银弹，只能根据自己项目的实际情况做出取舍，选择相对合适的一种方案去进行优化。\n对于页面耗时和资源占用的性能优化分析，大部分情况都可以使用 Chrome 开发者工具进行针对性的分析和优化。\n#结束语\n实际上，除了遇到问题的时候进行优化，更优的方案是在工作流中搭建一个监控性能指标的步骤，每次变更发布前都跑一遍，发现性能下降之后进行及时的告警，推动开发者解决。对于这块，之前我也有简单描述过，可以参考《补齐 Web 前端性能分析的工具盲点》一文。\n对于性能优化，其实本文只整理和归纳了一些常见的思路，至于实际上在项目中要怎么处理和使用，等有空的时候我再来跟大家讲一下~~"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--数据指标体系":{"title":"前端性能优化--数据指标体系","links":["C-Knowledge/前端/技术书籍/前端性能优化手册/补齐Web前端性能分析的工具盲点","C-Knowledge/前端/开发技术/web-vitals","C-Knowledge/前端/技术书籍/前端性能优化手册/PSI"],"tags":["编程/性能"],"content":"常常进行前端性能优化的小伙伴们会发现，实际开发中性能优化总是阶段性的：页面加载很慢/卡顿 → 性能优化 → 堆叠需求 → 加载慢/卡顿 → 性能优化。\n这是因为我们的项目往往也是阶段性的：快速功能开发 → 出现性能问题 → 优化性能 → 快速功能开发。\n建立一个完善的性能指标体系，便可以在需求开发阶段发现页面性能的下降，及时进行修复。\n#前端性能指标体系\n为什么需要进行性能优化呢？这是因为一个快速响应的网页可以有效降低用户访问的跳出率，提升网页的留存率，从而收获更多的用户。参考《经济时报》如何超越核心网页指标阈值，并使跳出率总体提高了 43% (opens new window)，这个例子中主要优化了两个指标：Largest Contentful Paint (LCP) 和 Cumulative Layout Shift (CLS)。\n除此之外，页面速度是一个重要的搜索引擎排名因素，它影响到你的网页是否能被更多用户访问。\n#常见的前端性能指标\n我们来看下常见的前端性能指标，由于网页的响应速度往往包含很多方面（页面内容出现、用户可操作、流畅度等等），因此性能数据也由不同角度的指标组成：\n\nFirst Contentful Paint (FCP) (opens new window)：首次内容绘制，衡量从网页开始加载到网页任何部分呈现在屏幕上所用的时间\nLargest Contentful Paint (LCP) (opens new window)：最大内容绘制，衡量从网页开始加载到屏幕上渲染最大的文本块或图片元素所用的时间\nFirst Input Delay (FID) (opens new window)：首次输入延迟，衡量从用户首次与您的网站互动（点击链接、点按按钮或使用由 JavaScript 提供支持的自定义控件）到浏览器实际能够响应该互动的时间\nInteraction to Next Paint (INP) (opens new window)：衡量与网页进行每次点按、点击或键盘交互的延迟时间，并根据互动次数选择该网页最差的互动延迟时间（或接近最高延迟时间）作为单个代表性值，以描述网页的整体响应速度\nTime to Interactive (TTI) (opens new window)：可交互时间，衡量的是从网页开始加载到视觉呈现、其初始脚本（若有）已加载且能够快速可靠地响应用户输入的时间\nTotal Blocking Time (TBT) (opens new window)：总阻塞时间，测量 FCP 和 TTI 之间的总时间，在此期间，主线程处于屏蔽状态的时间够长，足以阻止输入响应\nCumulative Layout Shift (CLS) (opens new window)：衡量从页面开始加载到其生命周期状态更改为隐藏之间发生的所有意外布局偏移的累计得分\nTime to First Byte (TTFB) (opens new window)：首字节时间，测量网络使用资源的第一个字节响应用户请求所需的时间\n\n这些是 User-centric performance metrics (opens new window)中介绍到的指标，其中 FCP、LCP、FID、INP/TTI 在我们常见的前端开发中会比较经常用到。\n最简单的，一般前端应用都会关心以下几个指标：\n\nFCP/LCP，该指标影响内容呈现给用户的体验，对页面跳出率影响最大。\nFID/INP，该指标影响用户与网页交互的体验，对功能转化率和网页留存率影响较大。\nTTI，该指标也为前端网页常用指标，页面可交互即用户可进行操作了。\n\n除了这些简单的指标外，我们要如何建立起对网页完整的性能指标呢？一套成熟又完善的解决方案为 Google 的 PageSpeed Insights (PSI)  (opens new window)。\n#PageSpeed Insights (PSI)\nPageSpeed Insights (PSI) 是一项免费的 Google 服务，可报告网页在移动设备和桌面设备上的用户体验，并提供关于如何改进网页的建议。\n前面在《补齐Web前端性能分析的工具盲点》 (opens new window)一文中，我们简单介绍过 Google 的另外一个服务—Lighthouse (opens new window)。\nPageSpeed Insights 和 Lighthouse 的区别主要为：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特征PageSpeed InsightsLighthouse如何访问pagespeed.web.dev/ (opens new window)（浏览器访问；无需登录）Google Chrome 浏览器扩展 (opens new window)（推荐非开发人员使用）  Chrome DevTools(opens new window)  Node CLI 工具(opens new window)  Lighthouse CI(opens new window)数据来源Chrome 用户体验报告（真实数据）  Lighthouse API（模拟实验室数据）Lighthouse API评估一次一页一次一页或一次多页指标核心网络生命、页面速度性能指标（首次内容绘制、速度指数、最大内容绘制、交互时间、总阻塞时间、累积布局偏移）性能（包括页面速度指标）、可访问性、最佳实践、SEO、渐进式 Web 应用程序（如果适用）建议标有Opportunities and Diagnostics的部分提供了提高页面速度的具体建议。标有Opportunities and Diagnostics的部分提供了提高页面速度的具体建议。堆栈包可用于定制改进建议。\n简单来说，PageSpeed Insights 可同时获取实验室性能数据和用户实测数据，而 Lighthouse 则可获取实验室性能数据以及网页整体优化建议（包括但不限于性能建议）。\n我们之前提到过，前端性能监控包括两种方式：合成监控（Synthetic Monitoring，SYN）、真实用户监控（Real User Monitoring，RUM）。这两种监控的性能数据，便是分别对应着实验室数据和用户实测数据。\n实测数据是通过监控访问网页的所有用户，并针对其中每个用户的各自的体验，衡量一组给定的性能指标来确定的。和实验室数据不同，由于现场数据基于真实用户访问数据，因此它反映了用户的实际设备、网络条件和用户的地理位置。\n当然，实测数据也可以由用户真实访问页面时进行上报收集，稍微大一点的前端应用都会这么做。但在此之前，如果你的前端网页没有做数据上报监控，也可以使用 PageSpeed Insights 工具进行简单的测试。但考虑到 PageSpeed Insights 收集的用户皆基于 Chrome 浏览器（CrUX），且需要登录的应用无法有效地获取真实数据，那么自行搭建一套性能指标体系则是最好的。\n虽然实际上 PageSpeed Insights 服务并不能解决我们所有的问题，但是我们可以参考它的性能指标，来搭建自己的性能体系呀。\n#核心网页指标\n参考 Google 的 PageSpeed Insights (opens new window)，我们知道 PSI 会报告真实用户在上一个 28 天收集期内的 First Contentful Paint (FCP)、First Input Delay (FID)、Largest Contentful Paint (LCP)、Cumulative Layout Shift (CLS) 和 Interaction to Next Paint (INP) 体验，同时 PSI 还报告了实验性指标首字节时间 (TTFB) 的体验。\n其中，核心网页指标包括 FID/INP、LCP 和 CLS。\n#FID\nFirst Input Delay (FID) (opens new window)衡量的是从用户首次与网页互动（即，点击链接、点按按钮或使用由 JavaScript 提供支持的自定义控件）到浏览器能够实际开始处理事件处理脚本以响应该互动的时间。\n我们可以使用 Event Timing API (opens new window)在 JavaScript 中衡量 FID：\nnew PerformanceObserver((entryList) =&gt; {\n  for (const entry of entryList.getEntries()) {\n    const delay = entry.processingStart - entry.startTime;\n    console.log(&#039;FID candidate:&#039;, delay, entry);\n  }\n}).observe({type: &#039;first-input&#039;, buffered: true});\n实际上，从 2024 年 3 月开始，FID 将替换为 Interaction to Next Paint (INP)，后面我们会着重介绍。\n#LCP\nLargest Contentful Paint (LCP) (opens new window)指标会报告视口内可见的最大图片或文本块的呈现时间（相对于用户首次导航到页面的时间）。\n我们可以使用 Largest Contentful Paint API (opens new window)在 JavaScript 中测量 LCP:\nnew PerformanceObserver((entryList) =&gt; {\n  for (const entry of entryList.getEntries()) {\n    console.log(&#039;LCP candidate:&#039;, entry.startTime, entry);\n  }\n}).observe({type: &#039;largest-contentful-paint&#039;, buffered: true});\n#CLS\n许多网站都面临布局不稳定的问题：DOM 元素由于内容异步加载而发生移动。\nCumulative Layout Shift (CLS) (opens new window)指标便是用来衡量在网页的整个生命周期内发生的每次意外布局偏移的最大突发布局偏移分数。我们可以从Layout Instability方法中获得布局偏移：\naddEventListener(&quot;load&quot;, () =&gt; {\n    let DCLS = 0;\n    new PerformanceObserver((list) =&gt; {\n        list.getEntries().forEach((entry) =&gt; {\n            if (entry.hadRecentInput)\n                return;  // Ignore shifts after recent input.\n            DCLS += entry.value;\n        });\n    }).observe({type: &quot;layout-shift&quot;, buffered: true});\n});\n布局偏移分数是该移动两个测量的乘积：影响比例和距离比例。\nlayout shift score = impact fraction * distance fraction\n#Interaction to Next Paint (INP)\nFID 仅在用户首次与网页互动时报告响应情况。尽管第一印象很重要，但首次互动不一定代表网页生命周期内的所有互动。此外，FID 仅测量首次互动的“输入延迟”部分，即浏览器在开始处理互动之前必须等待的时间（由于主线程繁忙）。\nInteraction to Next Paint (INP) (opens new window)用于通过观察用户在访问网页期间发生的所有符合条件的互动的延迟时间，评估网页对用户互动的总体响应情况。\nINP 不仅会衡量首次互动，还会考虑所有互动，并报告网页整个生命周期内最慢的互动。此外，INP 不仅会测量延迟部分，还会测量从互动开始，一直到事件处理脚本，再到浏览器能够绘制下一帧的完整时长。因此是 Interaction to Next Paint。这些实现细节使得 INP 能够比 FID 更全面地衡量用户感知的响应能力。\n从 2024 年 3 月开始，INP 将替代 FID 加入 Largest Contentful Paint (LCP) 和 Cumulative Layout Shift (CLS)，作为三项稳定的核心网页指标。\nINP 的计算方法是观察用户与网页进行的所有互动，而互动是指在同一逻辑用户手势触发的一组事件处理脚本。例如，触摸屏设备上的“点按”互动包括多个事件，如pointerup、pointerdown和click。互动可由 JavaScript、CSS、内置浏览器控件（例如表单元素）或由以上各项驱动。\n我们同样可以使用 Event Timing API (opens new window)在 JavaScript 中衡量 FID：\nnew PerformanceObserver((entryList) =&gt; {\n  for (const entry of entryList.getEntries()) {\n    const delay = entry.processingStart - entry.startTime;\n  }\n}).observe({type: &#039;event&#039;, buffered: true});\n关于 INP 的优化，可以参考 Optimize Interaction to Next Paint (opens new window)。\n#web-vitals JavaScript 库\nweb-vitals JavaScript 库使用PerformanceObserver，用于测量真实用户的所有 Web Vitals 指标，其方式准确匹配 Chrome 的测量方式，提供了上述提到的各种指标数据：CLS、FID、LCP、INP、FCP、TTFB。\n我们可以使用 web-vitals 库来收集到所需的数据。\n#评估体验质量\nPSI根据网页指标计划设置了阈值，将用户体验质量分为三类：良好、需要改进或较差，具体可参考 PageSpeed Insights 简介 (opens new window)。\n值得注意的是，PSI 报告所有指标的第 75 百分位。\n为便于开发者了解其网站上最令人沮丧的用户体验，选择第 75 百分位。通过应用上述相同阈值，这些字段指标值被归类为良好/需要改进/欠佳。\n这与我们常见的前端性能指标监控不大一样，因为一般来说大家会取平均值来评估指标。而取 75 百分位这种方式，值得我们去好好思考哪种计算方式更能真实反应用户的体验。\n当然，上述 PSI 的性能指标体系，也未必完全适合我们网页使用，我们还可以针对网页的实际情况做出调整。举个例子，网页的 FCP/LCP 虽然十分影响用户的留存，但如果是对于专注服务于老用户、操作频繁、使用时长长的应用来说，网页运行过程中的流畅性更值得关注。\n#参考\n\nWhy lab and field data can be different (and what to do about it)(opens new window)\nAdvancing Interaction to Next Paint(opens new window)\n在 PageSpeed Insights 中针对网站进行移动设备浏览体验分析(opens new window)\nLong Animation Frames (LoAF)(opens new window)\n以用户为中心的效果指标(opens new window)\nTowards an animation smoothness metric(opens new window)\n\n#结束语\n性能优化的事项很多，事情也往往很杂。当我们去针对我们网页进行性能优化事项的时候，如何评估我们的成果也是一个永恒不变的话题。\n建立起有效的性能指标体系，就能更直观地展示出网页存在的性能问题，以及优化后的效果。\n但需要注意的是，一味地追求指标数据并不都是一件好事情，因为为了指标好看往往我们会牺牲掉一些其他的体验。最终在平衡取舍下，呈现给用户最合适的体验才是开发的责任所在。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--渲染篇":{"title":"前端性能优化--渲染篇","links":["前端性能优化--方案归纳篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--加载流程篇","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-17-对事件处理做了哪些改进！"],"tags":["编程/性能"],"content":"对于内容复杂和变更频繁的前端应用，页面渲染也常常是性能优化的核心场景。\n前面我有给大家整体地讲过《前端性能优化—方案归纳篇》，其实里面已经囊括了大多数场景下的一些性能优化的方向。关于加载流程相关的优化，也有在《前端性能优化—加载流程篇》一文中进行详细的介绍。\n本文主要围绕页面渲染相关的内容，来进行性能优化分析。\n#首屏渲染\n说到页面渲染，首屏的渲染显然是最首要的。其实前面在归纳篇也有介绍，首屏加载优化核心点在于：将页面内容尽快展示给用户，减少页面白屏时间。\n首屏渲染包括了首屏内容的加载和渲染两个过程。\n#首屏内容加载\n对于首屏加载过程，我们可以通过以下方式进行优化：\n\n使用骨架屏进行预渲染\n对页面进行分片/分屏加载，将页面可见/可交互时间提前\n优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源\n使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块\n使用服务端直出渲染，减少页面二次请求和渲染的耗时\n使用秒看技术，通过预览的方式（比如图片）提前将页面内容提供给用户\n配合客户端进行资源预请求和预加载，比如使用预热 Web 容器\n配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染\n\n这里提到了很多的方向，但是否每个优化点都适用于自身的项目中，需要结合项目本身做调研和验证。举个简单的例子，最后两条优化点明显是基于有自研客户端的前提下，需要配合客户端一起做优化才可以实现。\n实际上，对于首屏内容的优化，前端开发在项目中更常用的点是骨架屏、数据分片/分屏加载、SSR DOM 直出渲染这几种，因为这几个优化点相对来说方向明确、效果明确、实现相对简单。如果是想要对项目做差异化服务、做资源的拆分和优化，则可能随着项目的复杂度增加，方案难度提升、实现成本也增长。\n#首屏内容渲染\n对于首屏内容渲染的过程，更多时候我们是指浏览器渲染 HTML 的过程。该过程可以优化的点也是我们常常提及的，浏览器渲染页面的优化过程，比如：\n\n将 CSS 放在&lt;head&gt;里，可用来避免浏览器渲染的重复计算\n将 JavaScript 脚本放在&lt;body&gt;的最后面，避免资源阻塞页面渲染\n减少 DOM 数量，减少浏览器渲染过程中的计算耗时\n通过合理使用浏览器 GPU 合成，提升浏览器渲染效率\n\n以上这些，是我们在做首屏渲染时考虑渲染过程的优化点。虽然这些优化点属于前端基础和共识，也常常会出现在基础面试中。\n很多时候我们为了准备面试而学习了很多的知识和原理，却容易在将知识和实践结合的过程中忘记。越是基础和简单的点，反而往往会在实际写代码的时候被忽略，直到性能出现了问题，这些基础的优化点才会被注意到。\n当然，首屏性能的提升，除了渲染相关的，也还有上一篇我们提到的加载流程相关的优化。\n#页面更新\n除了首屏内容需要尽快加载和渲染以外，当页面内容需要更新的时候，我们也需要尽可能地减少更新内容渲染的耗时。\n一般来说，页面更新场景我们常常会关注用户操作和页面渲染。\n#用户操作\n页面内容的更新，一般有两种情况：\n\n用户自身操作（点击、输入、拖拽等）的页面响应。\n实时内容的变更（比如聊天室的消息提醒、弹幕等等）。\n\n如果是用户自身的操作，则我们需要及时地更新页面内容，让用户感受到操作生效了。该过程应该是优先级最高的，一般需要同步进行。因为如果有别的任务在执行而导致主线程阻塞，就容易造成页面卡顿的体验。关于卡顿相关的，我会另外再起一篇文章介绍，这里就不过多展开啦。\n至于实时内容的变更，优先级更多会比用户操作稍微低一些，也基本上都是异步进行的。我们还可以考虑对变更内容做合并、批量更新，也可以考虑定时拉取最新内容更新的方式。\n#事件委托\n对于用户交互频繁的场景，我们还得注意事件的绑定。相信很多人都了解过**事件委托** ，如果在列表数量内容较大的时候，对成千上万节点进行事件监听，也是不小的性能消耗。使用事件委托的方式，通过将事件绑定在父元素上，我们可以大量减少浏览器对元素的监听，也是在前端性能优化中比较简单和基础的一个做法。\n事件委托是很常见的优化方式，需要注意的是，如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。\n如果我们在document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。此时可以使用passive: true选项来解决。\n#页面渲染\n我们在页面内容更新的时候，一般也可以考虑以下优化点：\n\n减少/合并 DOM 操作，减少页面更新的内容范围，减少浏览器渲染过程中的计算耗时\n对于页面动画，可以使用 CSS transition 能力，减少 DOM 属性的修改\n使用资源预加载，在空闲时间，提前将用户可能需要用到的资源进行获取并加载（比如下一页的内容）\n\n#DOM 操作合并\n说到 DOM 操作的合并和减少，目前大多数前端框架都提供了虚拟 DOM 的能力（比如 Vue 和 React）。虚拟 DOM 本身就有对 DOM 操作和更新做优化，通过使用 JavaScript 对象模拟 DOM 元素，并在页面需要更新时对更新的部分做 DOM Diff，尽可能地减少内容的更新频率和范围。\n虽然现在大多数前端项目都离不开前端框架，也正因为这些框架本身已经做了很多的优化，所以我们常常会忘记和忽略掉这些注意事项。\n但也从侧面论证了，即使是很基础的优化点也需要重视，即使是简单的优化点也可以做出很棒的设计。\n#页面滚动渲染\n考虑到页面滚动的场景，可能会出现性能问题的地方常常是长列表/页面的渲染。\n由于页面内容过多，页面的 DOM 元素数量也很多，容易造成页面渲染的卡顿。在这样的情况下，我们可以考虑仅渲染可见区域的部分，比如页面内容超出滚动范围之外，就可以进行销毁，将页面的 DOM 数量保持在一定范围内。\n#结束语\n本文主要围绕页面渲染和更新的过程，介绍了一些性能优化的方向。其实如果你有注意到，就会发现本文的内容大多数还是基础和简单的前端知识点。\n还是那句话，前端基础和原理知识基本上大多数开发都掌握了，但是要怎么将这些知识在项目中发挥到最佳的作用呢？这才是我们工作中在不断探索和学习，获得经验和成长的关键点。\n纸上得来终觉浅，了解一些知识很简单，但是要深入理解、熟练掌握后，再结合自身经验将它发挥出来，才是其价值的完整体现。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--用户卡顿检测":{"title":"前端性能优化--用户卡顿检测","links":[],"tags":["编程/性能"],"content":""},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--项目管理篇":{"title":"前端性能优化--项目管理篇","links":[],"tags":["编程/性能"],"content":"知晓要如何解决问题，只是真正解决问题的第一步。在工作里，我们更多时候遇到的问题不只是如何解决，而是如何有效落地。\n《前端性能优化—归纳篇》中，我给大家介绍了很多常见的前端性能优化思路和方案，核心优化思想为时间上减少耗时、空间上降低资源占用。其中耗时优化在前端性能优化中更常见，优化方案包括网络请求优化、首屏加载优化、渲染过程优化、计算/逻辑运行提速四个方面。\n性能优化通常需要投入不少的人力和成本来完成，因此更多的时候我们可以将其当作是一个项目的方式来进行管理。从项目管理的角度来讲，我们的性能优化工作会拆解为以下部分内容：\n\n确定优化的目标和预期。\n确定技术方案。\n项目排期和执行。\n进行项目复盘。\n\n#1. 确定优化的目标和预期\n性能优化的第一步，就是要确定优化的目标和预期。在给出具体的数据之前，我们首先需要对一些性能数据进行定义，常见包括：\n\n网络资源请求时间\nTime To Start Render(TTSR)：浏览器开始渲染的时间\nDom Ready：页面解析完成的时间\nTime To Interact(TTI))：页面可交互时间\nTotal Blocking Time (TBT)：总阻塞时间，代表页面处于不可交互状态的耗时\nFirst Input Delay(FID)：从用户首次交互，到浏览器响应的时间\n\n要选择合适有效的指标进行定义，比如由于前端框架的出现，Page Load 耗时（window.onload事件触发的时间）已经难以用来作为页面可见时间的关键点，因此可以使用框架提供的生命周期，或者是使用 Largest Contentful Paint (LCP，关键内容加载的时间点)更为合适。\n对需要关注的性能数据进行定义完成后，可以对它们进行目标和预期的确定，一般来说有两种方式：\n\n对比原先数据优化一定比例，比如 TTI 耗时减少 30%。\n通过对竞品进行分析确定目标，比如比竞品耗时减少 20%。\n\n在确定了目标和预期之后，我们便可以根据预期来确定优化的方向、技术方案。\n#2. 确定技术方案\n根据确定的目标和预期，我们就可以选择合适的优化方案。\n为什么不能将前面提到的全部技术方案都做一遍呢？显然这是不合理的。主要原因有两个：\n\n性价比。项目开发最看重的便是投入产出比，对于不同的项目来说，不同的技术优化方案需要投入人力不一样，很可能需要的投入较多但是优化效果可能不明显。\n不适用，比如有些业务并不具备差异化服务。\n\n举个例子，阿猪的预期目标是客户端内打开应用 TTI 耗时减少 30%，因此他可以选择的优化方案包括：\n\n对首页数据进行分片/分屏加载。\n首屏仅加载需要的资源，通过异步加载方式加载剩余资源。\n使用服务端直出渲染。\n使用 Tree-shaking 移除代码中无用的部分。\n配合客户端进行资源预请求和预加载，比如使用预热 Web 容器。\n配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。\n\n其中，5-6 需要客户端小伙伴进行支持，那么阿猪可以根据对方可以投入人力进行配合，来确定这两个优化点是否在本次方案中。\n为了达成目标，对合适的技术优化点进行罗列之后，需要对每个优化点进行简单的调研，确定它们的优化效果。比如针对对首页数据进行分屏加载，可以通过简单的模拟测试，对比完整数据的 TTI 耗时，与首屏数据的 TTI 耗时，预估该技术点的优化效果如何。\n最后，根据每个优化点的优化效果，以及相应的工作量评估，以预期为目标，选择性价比最优的技术方案。\n在技术方案确定后，则需要对工作内容进行排期，并按计划执行。优化完成后，还需要结合目标和预期，对优化效果进行复盘，同时还可以提出未来优化的规划。\n#3. 项目排期和执行\n这个步骤主要是排期实现，耗时最多。一般来说，需要注意的有两点：\n\n进行合理的分工排期。\n对项目风险进行把控。\n\n#进行合理的分工排期\n进行工作量评估的过程可以分为三步：\n\n确认技术方案，以及分工合作方式。\n拆分具体功能模块，分别进行工作量评估，输出具体的排期时间表。\n标注资源依赖情况和协作存在的风险，进行延期风险评估。\n\n当我们确认好技术方案之后，可以针对实现细节拆分具体的功能模块，分别进行工作量的预估和分工排期。具体的分工排期在多人协作的时候是必不可少的，否则可能面临分工不明确、接口协议未对齐就匆忙开工、最终因为各种问题而返工这些问题。\n进行工作量评估的时候，可以精确到半天的工作量预期。对独自开发的项目来说，同样可以通过拆解功能模块这个过程，来思考具体的实现方式，也能提前发现一些可能存在的问题，并相应地进行规避。\n提供完整的工作量评估和排期计划表（精确到具体的日期），可以帮助我们有计划地推进项目。在开发过程中，我们可以及时更新计划的执行情况，团队的其他人也可以了解我们的工作情况。\n工作量评估和排期计划表的另外一个重要作用，是通过时间线去严格约束我们的工作效率、及时发现问题，并在项目结束后可针对时间维度进行项目复盘。\n#对项目风险进行把控\n我们在项目开发过程中，经常会遇到这样的情况：\n\n因为方案设计考虑不周，部分工作需要返工，导致项目延期\n在项目进行过程中，常常会遇到依赖资源无法及时给到、依赖方因为种种原因无法按时支援等问题，导致项目无法按计划进行\n团队协作方式未对齐，开发过程中出现矛盾，反复的争执和调整协作方式导致项目延期\n\n一个项目能按照预期计划进行，技术方案设计、分工和协作方式、依赖资源是否确定等，任何一各环节出现问题都可能导致整体的计划出现延误，这是我们不想出现的结果。\n因此，我们需要主动把控各个环节的情况，及时推动和解决出现的一些多方协作的问题。\n#4. 进行项目复盘\n很多开发习惯了当代码开发完成、发布上线之后就结束了这个项目，其实他们遗漏了一个很重要的环节：复盘。\n我换过好多个团队，发现大多数团队和个人，都没有养成复盘的习惯。复盘是一个特别好的习惯，对于我们个人的成长也好，项目的优化和发展也好，都有很好的作用。\n当然，也有一些人会把复盘当做背锅和甩锅，这是不对的。当我们在项目过程中，常常因为有 Deadline 而不断地赶节奏，大多数情况下都只能发现一个问题解决一个问题。而在项目结束之后，我们才可以跳出项目，做更加广视角下的回顾和思考。\n有效的复盘，可以达到以下的效果：\n\n及时发现自己的问题并改进，避免掉进同一个坑。\n让团队成员知道每个人都在做什么，团队管理不混乱。\n整理沉淀和分享项目经验，让整个团队都得到成长。\n\n对于大多数开发来说，很多时候都不屑于主动邀功，觉得自己做了些什么老板肯定都看在眼里，写什么总结和复盘都是刷存在感的表现。实际上老板们每天的事情很多，根本没法关注到每一个人，我以前也曾经跟老板们问过这样一个问题：做和说到底哪个重要？\n答案是两个都重要。把一件事做好是必须的，但将这件事分享出来，可以同样给团队带来更多的成长。\n通过对项目进行复盘，除了可以让团队其他人和老板知道我们做了些什么，更重要的是，我们可以及时发现自身的一些问题并改进。\n项目复盘最好可以结合数据来说话，性能优化的工作可以用具体的耗时和 CPU 资源占用这些指标来做总结，工具的开发可以用接入使用的用户数量来说明效果。甚至是普普通通的项目上线，也都可以使用对比排期和实际开发，复盘各个环节的耗时和质量。\n#结束语\n对于大部分前端开发来说，接触工具和框架开发、参与开源项目的机会比较少，很多时候我们写的都是“枯燥无聊”的业务代码。我们总认为只有做工具才会比较有意思、有技术挑战，很多时候会先入为主，认为业务代码写得再好也没用，也渐渐放弃了去思考要怎么把事情做好。\n其实不只是工作中，我们生活里也可以常常进行反思和总结，这样我们的步伐才可以越跑越快。成长的过程中总会遇到各式各样的问题，有些问题被我们视而不见，有些问题我们选择了躲开，但其实我们还可以通过迎面应战、解决并反思的方式，在这样一次次战斗中快速地成长。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化手册":{"title":"前端性能优化手册","links":["C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--用户卡顿检测","C-Knowledge/前端/技术书籍/前端性能优化手册/让你的长任务在-50-毫秒内结束","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--归纳篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--加载流程篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--渲染篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--Canvas篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--容器篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--SSR篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--项目管理篇","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿的监控和定位","C-Knowledge/前端/技术书籍/前端性能优化手册/补齐Web前端性能分析的工具盲点","C-Knowledge/前端/技术书籍/前端性能优化手册/有趣的-PerformanceObserver","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--数据指标体系"],"tags":["编程/性能"],"content":"\n前端性能优化—用户卡顿检测\n让你的长任务在 50 毫秒内结束\n前端性能优化—归纳篇\n前端性能优化—加载流程篇\n前端性能优化—渲染篇\n前端性能优化—卡顿篇\n前端性能优化—Canvas篇\n前端性能优化—容器篇\n前端性能优化—SSR篇\n前端性能优化—项目管理篇\n前端性能优化—卡顿的监控和定位\n补齐Web前端性能分析的工具盲点\n有趣的 PerformanceObserver\n前端性能优化—数据指标体系\n"},"C-Knowledge/前端/技术书籍/前端性能优化手册/有趣的-PerformanceObserver":{"title":"有趣的 PerformanceObserver","links":["C-Knowledge/前端/开发技术/web-vitals","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化--卡顿的监控和定位"],"tags":["编程/性能"],"content":"之前在研究小伙伴遗留代码的时候，发现了PerformanceObserver这玩意，不看不知道，越看越有意思。\n其实这个 API 出了挺久了，机缘巧合下一直没有接触到，直到最近开始深入研究前端性能情况。\n#PerformanceObserver\n其实单看PerformanceObserver的官方描述 (opens new window)，好像没什么特别的：\n\nPerformanceObserver()构造函数使用给定的观察者callback生成一个新的PerformanceObserver对象。当通过observe()方法注册的条目类型的性能条目事件被记录下来时，调用该观察者回调。\n\n乍一看，好像跟我们网页开发和性能数据没什么太大关系。\n#常见的性能指标数据获取\n在很早的时候，前端开发的性能数据很多都是从Performance (opens new window)里获取：\n\nPerformance接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、User Timing API 和 Resource Timing API。\n\n提到页面加载耗时，还是得祭出这张熟悉的图（来自PerformanceNavigationTiming API (opens new window)）：\n\n上述图中的数据都可以从window.performance中获取到。\n一般来说，我们可以在页面加载的某个结点（比如onload）的时候获取，并进行上报。\n但这仅包含页面打开过程的性能数据，而近年来除了网页打开，网页使用过程中的用户体验也逐渐开始被重视了起来。\n2024 年 3 月起，INP (Interaction to Next Paint) 将替代 First Input Delay (FID) 加入 Largest Contentful Paint (LCP) 和 Cumulative Layout Shift (CLS)，作为三项稳定的核心网页指标。尽管第一印象很重要，但首次互动（FID）不一定代表网页生命周期内的所有互动（INP）。\n这意味着我们还需要关注整个网页生命周期内的用户体验，PerformanceObserver的设计正是为了提供用户体验相关性能数据，它鼓励开发人员尽可能使用。\n#PerformanceObserver 对象\nPerformanceObserver 对象为性能监测对象，用于监测性能度量事件，在浏览器的性能时间轴记录新的 performance entry 的时候将会被通知。\n研究过前端性能的人，或许还有些对PerformanceObserver不大熟悉（比如我），但是所有大概都知道 Chrome 浏览器的 Performance 性能时间轴：\n\n作为 Performance 面板的老用户，我们常常会从时间轴上捞取出存在性能问题的操作，然后细细分析和研究对应的代码执行情况。而这个时间轴上记录下 performance entry 时，我们可以当通过observe()方法获取到对应的内容和数据。\n前面提到，如果我们需要关注网页在整个生命周期中的性能情况，意味着需要定期轮询、埋点等方式做上报。通过使用PerformanceObserver接口，我们可以：\n\n避免轮询时间线来检测新指标\n避免新增删除重复数据逻辑来识别新指标\n避免与其他可能想要操纵缓冲区的消费者的竞争条件\n\n#PageSpeed Insights (PSI) 前端性能指标\n之前给大家讲过前端性能数据指标体系，我们能看到核心网页指标包括 FID、LCP 和 CLS，他们都可以从使用PerformanceObserver直接拿到：\n// FID\nnew PerformanceObserver((entryList) =&gt; {\n  for (const entry of entryList.getEntries()) {\n    const delay = entry.processingStart - entry.startTime;\n    console.log(&quot;FID candidate:&quot;, delay, entry);\n  }\n}).observe({ type: &quot;first-input&quot;, buffered: true });\n// LCP\nnew PerformanceObserver((entryList) =&gt; {\n  for (const entry of entryList.getEntries()) {\n    console.log(&quot;LCP candidate:&quot;, entry.startTime, entry);\n  }\n}).observe({ type: &quot;largest-contentful-paint&quot;, buffered: true });\n此外，web-vitals JavaScript 库 (opens new window)可用来测量真实用户的所有 Web Vitals 指标，其方式准确匹配 Chrome 的测量方式。他提供了 PSI 中的各种指标数据：CLS、FID、LCP、INP、FCP、TTFB，如果你仔细研究它的实现，便是使用PerformanceObserver的能力。\n比如，INP 需要监控整个网页生命周期中的交互体验，我们可以看到web-vitals实现基于PerformanceEventTiming的监测实现：\nnew PerformanceObserver((list) =&gt; {\n  list.getEntries().forEach((entry) =&gt; {\n    // Full duration\n    const duration = entry.duration;\n \n    // Input delay (before processing event)\n    const delay = entry.processingStart - entry.startTime;\n \n    // Synchronous event processing time\n    // (between start and end dispatch)\n    const eventHandlerTime = entry.processingEnd - entry.processingStart;\n    console.log(`Total duration: ${duration}`);\n    console.log(`Event delay: ${delay}`);\n    console.log(`Event handler duration: ${eventHandlerTime}`);\n  });\n}).observe({ type: &quot;event&quot; });\n而Event Timing API中包括的用户交互事件几乎是很全的，但该方式可用于检测用户交互的流畅性，并不能作为出现卡顿时的定位方案。具体卡顿的定位，可参考《前端性能卡顿的监控和定位方案》一文。\n#resource observe 获取资源加载时机\n在《前端性能卡顿的监控和定位方案》这篇文章中，我们还发现一个有意思的使用方式：\nnew PerformanceObserver((resource) =&gt; {\n  const entries = resource.getEntries();\n \n  entries.forEach((entry: PerformanceResourceTiming) =&gt; {\n    // 获取 JavaScript 资源\n    if (entry.initiatorType !== &quot;script&quot;) return;\n    const startTime = new Date().getTime();\n \n    window.requestAnimationFrame(() =&gt; {\n      // JavaScript 资源加载完成\n      const endTime = new Date().getTime();\n    });\n  });\n}).observe({ entryTypes: [&quot;resource&quot;] });\n除了使用performanceObserver监测resource资源获取性能数据，我们还可以在回调触发时开始计数，以此计算该 JavaScript 资源加载耗时，从而考虑是否需要对资源进行更合理的分包。\n#自定义性能指标\n配合PerformanceObserver，我们还可以使用User Timing API (opens new window)进行自定义打点：\n// Record the time immediately before running a task.\nperformance.mark(&quot;myTask:start&quot;);\nawait doMyTask();\n// Record the time immediately after running a task.\nperformance.mark(&quot;myTask:end&quot;);\n \n// Measure the delta between the start and end of the task\nperformance.measure(&quot;myTask&quot;, &quot;myTask:start&quot;, &quot;myTask:end&quot;);\n然后使用PerformanceObserver获取相关指标数据：\n// 有兼容性，需要处理异常\ntry {\n  const po = new PerformanceObserver((list) =&gt; {\n    for (const entry of list.getEntries()) {\n      console.log(entry.toJSON());\n    }\n  });\n  // 监测 measure entry\n  po.observe({ type: &quot;measure&quot;, buffered: true });\n} catch (e) {}\n更多的使用方式，可以参考自定义指标 (opens new window)一文。\n#参考\n\nUser Timing Level 3(opens new window)\nPerformance Timeline(opens new window)\nPerformanceEventTiming(opens new window)\nPerformance: measure() method(opens new window)\nPerformanceEntry.entryType(opens new window)\nTimeline event reference(opens new window)\n\n#结束语\n由于PerformanceObserver 对象与浏览器的性能时间轴紧紧相关，基于此我们可以做很多性能监测的事情。\n如果想偷懒，使用 web-vitals JavaScript 库并对 PSI 定义的核心指标进行上报，我们就能大概掌握了网页的核心性能指标数据，并以此进行分析和优化。\n前端性能在前端领域中，也算是个亘古不变的难题，每次研究总能学到新的知识，这也是挺有趣的一件事呢。"},"C-Knowledge/前端/技术书籍/前端性能优化手册/补齐Web前端性能分析的工具盲点":{"title":"补齐Web前端性能分析的工具盲点","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/帧率","C-Knowledge/前端/技术书籍/前端性能优化手册/Chrome-DevTools"],"tags":["编程/性能"],"content":"最近依然在研究大型项目，而大型项目最容易遇到的问题便是性能问题。一般来说，当我们遇到性能瓶颈的时候，才会开始去进行相应的分析。分析的方向除了业务本身的特点相关之外，常见的我们还可以借助一些工具来发现问题。本文一起来研究下，前端性能分析可以怎么走~\n#前端性能分析工具（Chrome DevTools）\n一般来说，前端的性能分析通常可以从时间和空间两个角度来进行：\n\n时间：常见耗时，如页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等\n空间：资源占用，包括 CPU 占用、内存占用、本地缓存占用等\n\n那么，下面来看看有哪些常见的工具可以借来用用。由于我们的网页基本上跑在浏览器中，所以基本上大多数的工具都来源于浏览器自身提供，首当其冲的当然是 Chrome DevTools (opens new window)。本文我们也主要围绕 Chrome DevTools 来进行说明。\n#Lighthouse\nLighthouse (opens new window)的前身是 Chrome DevTools 面板中的 Audits。在 Chrome 60 之前的版本中, 这个面板只包含网络使用率和页面性能两个测量类别，从 Chrome 60 版本开始， Audits 面板已经被 Lighthouse 的集成版取代。而在最新版本的 Chrome 中，则需要单独安装 Lighthouse 拓展程序来使用，也可以通过脚本来使用。\n#架构\n\n下面是 Lighthouse 的组成部分：\n\n驱动（Driver）：和 Chrome Debugging Protocol (opens new window)进行交互的接口\n收集器（Gatherers）：使用驱动程序收集页面的信息，收集器的输出结果被称为 Artifact\n审查器（Audits）：将 Artifact 作为输入，审查器会对其运行测试，然后分配通过/失败/得分的结果\n报告（Report）：将审查的结果分组到面向用户的报告中（如最佳实践），对该部分应用加权和总体然后得出评分\n\n#主要功能\nLighthouse 会在一系列的测试下运行网页，比如不同尺寸的设备和不同的网络速度。它还会检查页面对辅助功能指南的一致性，例如颜色对比度和 ARIA 最佳实践。\n在比较短的时间内，Lighthouse 可以给出这样一份报告（可将报告生成为 JSON 或 HTML）：\n\n这份报告从 5 个方面来分析页面： 性能、辅助功能、最佳实践、搜索引擎优化和 PWA。像性能方面，会给出一些常见的耗时统计。除此以外，还会给到一些详细的优化方向。\n如果你希望短时间内对你的网站进行较全面的评估，可以使用 Lighthouse 来跑一下分数，确定大致的优化方向。\n#Performance 面板\nPerformance (opens new window)面板同样有个前身，叫 Timeline (opens new window)。该面板用于记录和分析运行时性能，运行时性能是页面运行时（而不是加载）的性能。\n#使用步骤\nPerformance 面板功能特别多，具体的分析也可以单独讲一篇了。这里我们简单说一下使用的步骤：\n\n在隐身模式下打开 Chrome。隐身模式可确保 Chrome 以干净状态运行，例如浏览器的扩展可能会在性能评估中产生影响。\n在 DevTools 中，单击“Performance”选项卡，并进行一些基础配置（更多参考官方说明 (opens new window)）。\n按照提示单击记录，开始记录。进行完相应的操作之后，点击停止。\n当页面运行时，DevTools 捕获性能指标。停止记录后，DevTools 处理数据，然后在 Performance 面板上显示结果。\n\n#主要功能\n关于 Performance 怎么使用的文章特别多，大家网上随便搜一下就能搜到。一般来说，主要使用以下功能：\n\n\n查看 FPS 图表：当在 FPS 上方看到红色条形时，表示帧速率下降得太低，以至于可能损害用户体验。通常，绿色条越高，FPS 越高\n查看 CPU 图表：CPU 图表在 FPS 图表下方。CPU 图表的颜色对应于性能板的底部的 Summary 选项卡\n查看 火焰图：火焰图直观地表示出了内部的 CPU 分析，横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方。启用 JS 分析器后，火焰图会显示调用的每个 JavaScript 函数，可用于分析具体函数\n查看 Buttom-up：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的调用路径\n\n具体要怎么定位某些性能瓶颈，可以参考官方文档系列文章 (opens new window)，这里就不详细介绍啦。\n#Performance Monitor\n打开 Chrome 控制台后，按组合键ctrl + p(Mac 快捷键为command + p)，输入&gt; Show Performance Monitor，就可以打开 Performance Monitor 性能监视器。主要的监控指标包括：\n\nCPU usage：CPU 占用率\nJS head size：JS 内存使用大小\nDOM Nodes：内存中挂载的 DOM 节点个数\nJS event listeners：事件监听数\n…：其他等等\n\n大多数情况下，我们在进行性能优化的时候，使用上面一些工具也足以确定大致的优化方向。更多的细节和案例，就不在这里详述了。\n#前端性能监控\n除了具体的性能分析和定位，我们也经常需要对业务进行性能监控。前端性能监控包括两种方式：合成监控（Synthetic Monitoring，SYN）、真实用户监控（Real User Monitoring，RUM）。\n#合成监控\n合成监控就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。例如上面介绍的 Lighthouse 就是合成监控。\n合成监控的使用场景不多，一般可能出现在开发和测试的过程中，例如结合流水线跑性能报告、定位性能问题时本地跑的一些简单任务分析等。该方式的优点显而易见：\n\n可采集更丰富的数据指标，例如结合 Chrome Debugging Protocol (opens new window)获取到的数据\n较成熟的解决方案和工具，实现成本低\n不影响真实用户的性能体验\n\n#真实用户监控\n真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标。我们在用户访问结束的时候，把这些性能指标上传到我们的日志服务器上，进行数据的提取清洗加工，最后在我们的监控平台上进行展示的一个过程。\n我们提及前端监控的时候，大多数都包括了真实用户监控。常见的一些性能监控包括加载耗时、DOM 渲染耗时、接口耗时统计等，而对于页面加载过程，可以看到它被定义成了很多个阶段：\n\n而我们要做的，则是在力所能及的地方进行打点、计算、采集、上报，该过程常常需要借助 Performance Timeline API。将需要的数据发送到服务端，然后再对这些数据进行处理，最终通过可视化等方式进行监控。因此，真实用户监控往往需要结合业务本身的前后端架构设计来建设，其优点也比较容易理解：\n\n完全还原真实场景，减去模拟成本\n数据样本足够抹平个体的差异\n采集数据可用于更多场景的分析和优化\n\n对比合成监控，真实用户监控在有些场景下无法拿到更多的性能分析数据（例如具体哪里 CPU 占用、内存占用高），因此更多情况下作为优化效果来参考。这些情况下，具体的分析和定位可能还是得依赖合成监控。\n但真实用户监控也有自身的优势，例如 TCP、DNS 连接耗时过高，在各种环境下的一些运行耗时问题，合成监控是很难发现的。\n#性能分析自动化\n我们在开发过程中，也常常需要进行性能分析。而前端的性能分析上手成本也不低，除了基本的页面加载耗时、网络耗时，更具体的定位往往需要结合前面介绍的 Performance 面板、FPS、CPU、火焰图等一点点来分析。\n如果这一块想要往自动化方向发展，我们可以怎么做呢？\n#使用 Lighthouse\n前面也有介绍 Lighthouse，它提供了脚本的方式使用。因此，我们可以通过自动化任务跑脚本的方式，使用 Lighthouse 跑分析报告，通过对比以往的数据来进行功能变更、性能优化等场景的性能回归。\n使用 Lighthouse 的优势在于开发成本低，只需要按照官方提供的配置 (opens new window)来调整、获取自己需要的一些数据，就可以快速接入较全面的 Lighthouse 拥有的性能分析能力。\n不过由于 Lighthouse 同样基于 CDP(Chrome DevTools Protocol)，因此除了实现成本降低了，CDP 缺失的一些能力它也一样会缺失。\n#Chrome DevTools Protocol\nChrome DevTools Protocol (opens new window)允许第三方对基于 Chrome 的 Web 应用程序进行检测、检查、调试、分析等。有了这个协议，我们就可以自己开发工具获取 Chrome 的数据了。\n#认识 Chrome DevTools 协议\nChrome DevTools协议基于 WebSocket，利用 WebSocket 建立连接 DevTools 和浏览器内核的快速数据通道。\n我们使用的 Chrome DevTools 其实也是一个 Web 应用。我们使用 DevTools 的时候，浏览器内核 Chromium 本身会作为一个服务端，我们看到的浏览器调试工具界面，通过 Websocket 和 Chromium 进行通信。建立过程如下：\n\nDevTools 将作为 Web 应用程序，Chromium 作为服务端提供连接。\n通过 HTTP 提取 HTML、JavaScript 和 CSS 文件。\n资源加载后，DevTools 会建立与浏览器的 Websocket 连接，并开始交换 JSON 消息。\n\n同样的，当我们通过 DevTools 从 Windows、Mac 或 Linux 计算机远程调试 Android 设备上的实时内容时，使用的也是该协议。当 Chromium 以一个--remote-debugging-port=0标志启动时，它将启动 Chrome DevTools 协议服务器。\n#Chrome DevTools 协议域划分\nChrome DevTools协议具有与浏览器的许多不同部分（例如页面、Service Worker 和扩展程序）进行交互的 API。该协议把不同的操作划分为了不同的域（domain），每个域负责不同的功能模块。比如DOM、Debugger、Network、Console和Performance等，可以理解为 DevTools 中的不同功能模块。\n使用该协议我们可以：\n\n获取 JS 的 Runtime 数据，常用的如window.performance和window.chrome.loadTimes()等\n获取Network及Performance数据，进行自动性能分析\n使用 Puppeteer (opens new window)的 CDPSession (opens new window)，与浏览器的协议通信会变得更加简单\n\n#与性能相关的域\n本文讲性能分析相关，因此这里我们只关注和性能相关的域。\n1. Performance。 从Performance域中Performance.getMetrics()可以拿到获取运行时性能指标包括：\n\nTimestamp: 采取度量样本的时间戳\nDocuments: 页面中的文档数\nFrames: 页面中的帧数\nJSEventListeners: 页面中的事件数\nNodes: 页面中的 DOM 节点数\nLayoutCount: 全部或部分页面布局的总数\nRecalcStyleCount: 页面样式重新计算的总数\nLayoutDuration: 所有页面布局的合并持续时间\nRecalcStyleDuration: 所有页面样式重新计算的总持续时间\nScriptDuration: JavaScript 执行的持续时间\nTaskDuration: 浏览器执行的所有任务的合并持续时间\nJSHeapUsedSize: 使用的 JavaScript 栈大小\nJSHeapTotalSize: JavaScript 栈总大小\n\n2. Tracing。 Tracing域可获取页面加载的 DevTools 性能跟踪。可以使用Tracing.start和Tracing.stop创建可在 Chrome DevTools 或时间轴查看器中打开的跟踪文件。\n我们能看到生成的 JSON 文件长这样： \n这样的 JSON 文件，我们可以丢到 DevTools Timeline Viewer (opens new window)中，可以看到对应的时间轴和火焰图：\n\n3. Runtime。 Runtime域通过远程评估和镜像对象暴露 JavaScript 的运行时。可以通过Runtime.getHeapUsage获取 JavaScript 栈的使用情况，通过Runtime.evaluate计算全局对象的表达式，通过Runtime.queryObjects迭代 JavaScript 栈并查找具有给定原型的所有对象（可用于计算原型链中某处具有相同原型的所有对象，衡量 JavaScript 内存泄漏）。\n除了上面介绍的这些，还有Network可以分析网络相关的性能，以及其他可能涉及 DOM 节点、JS 执行等各种各样的数据分析，更多的可能需要大家自己去研究了。\n#自动化性能分析\n通过使用 Chrome DevTools 协议，我们可以获取 DevTools 提供的很多数据，包括网络数据、性能数据、运行时数据。\n对于如何使用该协议，其实已经有很多大神针对这个协议封装出不同语言的库，包括 Node.js、Python、Java等，可以根据需要在 awesome-chrome-devtools (opens new window)这个项目中找到。\n至于我们到底能拿到怎样的数据，可以做到怎样的自动化程度，就不在本文里讲述啦，后面有机会再开篇文章详细讲讲。\n#参考\n\n你一定要知道的 Chrome DevTool 新功能(opens new window)\n前端性能分析利器-Chrome性能分析&amp;性能监视器(opens new window)\n蚂蚁金服如何把前端性能监控做到极致?(opens new window)\nchrome devtools protocol——Web 性能自动化实践介绍(opens new window)\nChrome DevTools Protocol(opens new window)\nWeb Performance Recipes With Puppeteer(opens new window)\n\n#结束语\n前端性能分析相关的文章不算多，而由于性能分析本身的场景就跟业务特性结合比较紧密，可以用来借鉴的内容、较统一的解决方案也不多。而性能的监控、自动化等方向的介绍比较少，也希望这篇文章能给到你们一些方向吧~"},"C-Knowledge/前端/技术书籍/前端性能优化手册/让你的长任务在-50-毫秒内结束":{"title":"让你的长任务在 50 毫秒内结束","links":[],"tags":["编程/性能"],"content":"虽然之前有跟大家分享过不少卡顿相关的内容，实际上网页里卡顿的产生基本上都是由于长任务导致的。当然，能阻塞用户操作的，我们说的便是主线程上的长任务。\n浏览器中的长任务可能是 JavaScript 的编译、解析 HTML 和 CSS、渲染页面，或者是我们编写的 JavaScript 中产生了长任务导致。\n#让你的长任务保持在 50 ms 内\n之前在介绍前端性能优化—卡顿篇时，提到可以将大任务进行拆解：\n\n考虑将任务执行耗时控制在 50 ms 左右。每执行完一个任务，如果耗时超过 50 ms，将剩余任务设为异步，放到下一次执行，给到页面响应用户操作和更新渲染的时间。\n\n为什么是 50 毫秒呢？\n这个数值并不是随便写的，主要来自于 Google 员工开发的 RAIL 模型 (opens new window)。\n#RAIL 模型\nRAIL 表示 Web 应用生命周期的四个不同方面：响应（Response）、动画（Animation）、空闲（Idel）和加载（Load）。由于用户对每种情境有不同的性能预期，因此，系统会根据情境以及关于用户如何看待延迟的用户体验调研来确定效果目标。\n人机交互学术研究由来已久，在 Jakob Nielsen’s work on response time limits (opens new window)中提出三个阈值：\n\n100 毫秒：大概是让用户感觉系统立即做出反应的极限，这意味着除了显示结果之外不需要特殊的反馈\n1 秒：大概是用户思想流保持不间断的极限，即使用户会注意到延迟。一般情况下，大于 0.1 秒小于 1.0 秒的延迟不需要特殊反馈，但用户确实失去了直接操作数据的感觉\n10 秒：大概是让用户的注意力集中在对话上的极限。对于较长的延迟，用户会希望在等待计算机完成的同时执行其他任务，因此应该向他们提供反馈，指示计算机预计何时完成。如果响应时间可能变化很大，则延迟期间的反馈尤其重要，因为用户将不知道会发生什么。\n\n在此基础上，如今机器性能都有大幅度的提升，因此基于用户的体验，RAIL 增加了一项：\n\n0-16 ms：大概是用户感受到流畅的动画体验的数值。只要每秒渲染 60 帧，这类动画就会感觉很流畅，也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），让应用生成一帧大约 10 毫秒\n\n由于这篇文章我们讨论的是长任务相关，因此主要考虑生命周期中的响应（Response），目标便是要求 100 毫秒内获得可见响应。\n#在 50 毫秒内处理事件\nRAIL 的目标是在 100 毫秒内完成由用户输入发起的转换，让用户感觉互动是瞬时完成的。\n目标是 100 毫秒，但是页面运行时除了输入处理之外，通常还会执行其他工作，并且这些工作会占用可用于获得可接受输入响应的部分时间。\n因此，为确保在 100 毫秒内获得可见响应，RAIL 的准则是在 50 毫秒内处理用户输入事件：\n\n为确保在 100 毫秒内获得可见响应，请在 50 毫秒内处理用户输入事件。这适用于大多数输入，例如点击按钮、切换表单控件或启动动画。这不适用于轻触拖动或滚动。\n\n除了响应之外，RAIL 对其他的生命周期也提出了对应的准则，总体为：\n\n响应（Response）：在 50 毫秒内处理事件\n动画（Animation）：在 10 毫秒内生成一帧\n空闲（Idel）：最大限度地延长空闲时间\n加载（Load）：提交内容并在 5 秒内实现互动\n\n具体每个行为的目标和准则是如何考虑和确定的，大家可以自行学习，这里不再赘述。\n#长任务优化\n网页加载时，长时间任务可能会占用主线程，使页面无法响应用户输入（即使页面看起来已就绪）。点击和点按通常不起作用，因为尚未附加事件监听器、点击处理程序等。\n基于前面介绍的 RAIL 模型，我们可以将超过 50 毫秒的任务称之为长任务，即：任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。\n实际上，Chrome 浏览器中的 Performance 面板也是如此定义的，我们录制一段 Performance，当主线程同步执行的任务超过 50 毫秒时，该任务块会被标记为红色。\n\n#识别长任务\n一般来说，在前端网页中容易出现的长任务包括：\n\n大型的 JavaScript 代码加载\n解析 HTML 和 CSS\nDOM 查询/DOM 操作\n运算量较大的 JavaScript 脚本的执行\n\n#使用 Chrome Devtools\n我们可以在 Chrome 开发者工具中，通过录制 Performance 的方式，手动查找时长超过 50 毫秒的脚本的“长红/黄色块”，然后分析这些任务块的执行内容，来识别出长任务。\n我们可以选择 Bottom-Up 和 Group by Activity 面板来分析这些长任务（关于如何使用 Performance 面板，可以参考分析运行时性能 (opens new window)一文）：\n\n比如在上图中，导致任务耗时较长的原因是一组成本高昂的 DOM 查询。\n#使用 Long Tasks API\n我们还可以使用 Long Tasks API (opens new window)来确定哪些任务导致互动延迟：\nnew PerformanceObserver(function (list) {\n  const perfEntries = list.getEntries();\n  for (let i = 0; i &lt; perfEntries.length; i++) {\n    // 分析长任务\n  }\n}).observe({ entryTypes: [&quot;longtask&quot;] });\n#识别大型脚本\n大型脚本通常是导致耗时较长的任务的主要原因，我们可以想办法来识别。\n除了使用上述的方法，我们还可以使用PerformanceObserver识别：\nnew PerformanceObserver((resource) =&gt; {\n  const entries = resource.getEntries();\n \n  entries.forEach((entry: PerformanceResourceTiming) =&gt; {\n    // 获取 JavaScript 资源\n    if (entry.initiatorType !== &quot;script&quot;) return;\n    const startTime = new Date().getTime();\n \n    window.requestAnimationFrame(() =&gt; {\n      // JavaScript 资源加载完成\n      const endTime = new Date().getTime();\n      // 如果此时耗时大于 50 ms，则可任务出现了长任务\n      const isLongTask = endTime - startTime &gt; 50;\n    });\n  });\n}).observe({ entryTypes: [&quot;resource&quot;] });\n这种方式我们还可以通过entry.name拿到对应的加载资源，针对性地进行处理。\n#自定义性能指标\n除此之外，我们还可以通过在代码中埋点，自行计算执行耗时，从而针对可预见的场景识别出长任务：\n// 可预见的大任务执行前打点\nperformance.mark(&quot;bigTask:start&quot;);\nawait doBigTask();\n// 执行后打点\nperformance.mark(&quot;bigTask:end&quot;);\n \n// 测量该任务\nperformance.measure(&quot;bigTask&quot;, &quot;bigTask:start&quot;, &quot;bigTask:end&quot;);\n再配合PerformanceObserver获取对应的性能数据，大于 50 毫秒则可以判断为长任务、\n#优化长任务\n发现长任务之后，我们就可以进行对应的长任务优化。\n#过大的 JavaScript 脚本\n大型脚本通常是导致耗时较长的任务的主要原因，尤其是首屏加载时尽量避免加载不必要的代码。\n我们可以考虑拆分这些脚本：\n\n首屏加载，仅加载必要的最小 JavaScript 代码。\n其他 JavaScript 代码进行模块化，进行分包加载。\n通过预加载、闲时加载等方式，完成剩余所需模块的代码加载。\n\n拆分 JavaScript 脚本，使得用户打开页面时，只发送初始路由所需的代码。这样可以最大限度地减少需要解析和编译的脚本量，从而缩短网页加载时，也有助于提高 First Input Delay (FID) 和 Interaction to Next Paint (INP) 时间。\n有很多工具可以帮助我们完成这项工作：\n\nwebpack(opens new window)\nParcel(opens new window)\nRollup(opens new window)\n\n这些热门的模块打包器，都支持动态加载的方式来拆分 JavaScript 脚本。我们甚至可以限制每个构建模块的大小，来防止某个模块的 JavaScript 脚本过大，具体的使用方式大家可以自行搜索。\n#过长的 JavaScript 执行任务\n主线程一次只能处理一个任务。如果任务的延时时间超过某一点（确切来说是 50 毫秒），则会被归类为耗时较长的任务。\n对于这种过长的执行任务，优化方案也十分直接：任务拆分，直观来看就是这样：\n\n一般来说，任务拆分可以分为两种：\n\n串行执行的不同执行任务。\n单个超大的执行任务。\n\n#串行任务的拆分\n对于串行执行的不同任务，可以将不同任务的调用从同步改成异步即可，比如 Optimize long tasks (opens new window)这篇文章中详细介绍的：\nsaveSettings()的函数，该函数会调用五个函数来完成某些工作：\nfunction saveSettings() {\n  validateForm();\n  showSpinner();\n  saveToDatabase();\n  updateUI();\n  sendAnalytics();\n}\n\n对这些串行任务进行拆分有很多种方式，比如：\n\n使用setTimeOut()/postTask()实现异步\n自行实现任务管理器，管理串行任务执行，每执行一个任务后释放主线程，再执行下一个任务（还需考虑优先级执行任务）\n\n具体的代码可以参考 Optimize long tasks (opens new window)该文章，理想的优化效果为：\n\n#单个超大任务的拆分\n有时候我们的应用中需要做大量的运算，比如对上百万个数据做一系列的计算，此时我们可以考虑进行分批拆分。\n拆分的时候需要注意几个事情：\n\n尽量将每个小任务拆成 50 毫秒左右的执行时间。\n大任务分批执行，会由同步执行变为异步执行，需要考虑中间态（是否有新的任务插入，是否会重复执行）。\n\n之前在介绍复杂渲染引擎的时候，有详细讲解使用分批计算的方法进行性能优化，具体可以参考《复杂渲染引擎架构与设计—5.分片计算》 (opens new window)一文。\n#参考\n\nMeasure performance with the RAIL model(opens new window)\nReduce JavaScript payloads with code splitting(opens new window)\nPreload critical assets to improve loading speed(opens new window)\nAre long JavaScript tasks delaying your Time to Interactive?(opens new window)\nOptimize long tasks(opens new window)\n\n#结束语\n对于大型复杂的前端应用来说，卡顿和长任务都是家常便饭。\n性能优化没有捷径，有的都是一步步定位，一点点分析，一处处解决。每一个问题都是独立的问题，但我们还可以识别它们的共性，提供更高效的解决路径。"},"C-Knowledge/前端/技术书籍/前端面试之道/前端面试之道":{"title":"前端面试之道","links":["C-Knowledge/前端/技术书籍/前端面试之道/1、前端面试之道-JS-基础知识点及常考面试题（一）","C-Knowledge/前端/技术书籍/前端面试之道/2、前端面试之道-JS-基础知识点及常考面试题（二）","C-Knowledge/前端/技术书籍/前端面试之道/3、前端面试之道-ES6-知识点及常考面试题","C-Knowledge/前端/技术书籍/前端面试之道/4、前端面试之道-JS-异步编程及常考面试题","C-Knowledge/前端/技术书籍/前端面试之道/5、前端面试之道-手写-Promise","C-Knowledge/前端/技术书籍/前端面试之道/6、前端面试之道-Event-Loop","C-Knowledge/前端/技术书籍/前端面试之道/7、前端面试之道-JS-进阶知识点及常考面试题","C-Knowledge/前端/技术书籍/前端面试之道/8、前端面试之道-JS-思考题","C-Knowledge/前端/技术书籍/前端面试之道/9、前端面试之道-DevTools-Tips","C-Knowledge/前端/技术书籍/前端面试之道/10、前端面试之道-浏览器基础知识点及常考面试题","C-Knowledge/前端/技术书籍/前端面试之道/11、前端面试之道-浏览器缓存机制","C-Knowledge/前端/技术书籍/前端面试之道/12、前端面试之道-浏览器渲染原理","C-Knowledge/前端/技术书籍/前端面试之道/13、前端面试之道-安全防范知识点","C-Knowledge/前端/技术书籍/前端面试之道/14、前端面试之道-从-V8-中看-JS-性能优化","C-Knowledge/前端/技术书籍/前端面试之道/15、前端面试之道-性能优化琐碎事","C-Knowledge/前端/技术书籍/前端面试之道/16、前端面试之道-Webpack-性能优化","C-Knowledge/前端/技术书籍/前端面试之道/17、前端面试之道-实现小型打包工具","C-Knowledge/前端/技术书籍/前端面试之道/18、前端面试之道-React-和-Vue-两大框架之间的相爱相杀","C-Knowledge/前端/技术书籍/前端面试之道/19、前端面试之道-Vue-常考基础知识点","C-Knowledge/前端/技术书籍/前端面试之道/20、前端面试之道-Vue-常考进阶知识点","C-Knowledge/前端/技术书籍/前端面试之道/21、前端面试之道-React-常考基础知识点","C-Knowledge/前端/技术书籍/前端面试之道/22、前端面试之道-React-常考进阶知识点","C-Knowledge/前端/技术书籍/前端面试之道/23、前端面试之道-监控","C-Knowledge/前端/技术书籍/前端面试之道/24、前端面试之道-UDP","C-Knowledge/前端/技术书籍/前端面试之道/25、前端面试之道-TCP","C-Knowledge/前端/技术书籍/前端面试之道/26、前端面试之道-HTTP-及-TLS","C-Knowledge/前端/技术书籍/前端面试之道/27、前端面试之道-HTTP2及-HTTP3","C-Knowledge/前端/技术书籍/前端面试之道/28、前端面试之道-输入-URL-到页面渲染的整个流程","C-Knowledge/前端/技术书籍/前端面试之道/29、前端面试之道-设计模式","C-Knowledge/前端/技术书籍/前端面试之道/30、前端面试之道-常见数据结构","C-Knowledge/前端/技术书籍/前端面试之道/31、前端面试之道-常考算法题解析","C-Knowledge/前端/技术书籍/前端面试之道/32、前端面试之道-如何写好一封简历","C-Knowledge/前端/技术书籍/前端面试之道/33、前端面试之道-面试常用技巧","C-Knowledge/前端/技术书籍/前端面试之道/34、前端面试之道-前方的路，让我们结伴同行"],"tags":["场景/面试","编程/书籍"],"content":"\n1、前端面试之道-JS 基础知识点及常考面试题（一）\n2、前端面试之道-JS 基础知识点及常考面试题（二）\n3、前端面试之道-ES6 知识点及常考面试题\n4、前端面试之道-JS 异步编程及常考面试题\n5、前端面试之道-手写 Promise\n6、前端面试之道-Event Loop\n7、前端面试之道-JS 进阶知识点及常考面试题\n8、前端面试之道-JS 思考题\n9、前端面试之道-DevTools Tips\n10、前端面试之道-浏览器基础知识点及常考面试题\n11、前端面试之道-浏览器缓存机制\n12、前端面试之道-浏览器渲染原理\n13、前端面试之道-安全防范知识点\n14、前端面试之道-从 V8 中看 JS 性能优化\n15、前端面试之道-性能优化琐碎事\n16、前端面试之道-Webpack 性能优化\n17、前端面试之道-实现小型打包工具\n18、前端面试之道-React 和 Vue 两大框架之间的相爱相杀\n19、前端面试之道-Vue 常考基础知识点\n20、前端面试之道-Vue 常考进阶知识点\n21、前端面试之道-React 常考基础知识点\n22、前端面试之道-React 常考进阶知识点\n23、前端面试之道-监控\n24、前端面试之道-UDP\n25、前端面试之道-TCP\n26、前端面试之道-HTTP 及 TLS\n27、前端面试之道-HTTP2及 HTTP3\n28、前端面试之道-输入 URL 到页面渲染的整个流程\n29、前端面试之道-设计模式\n30、前端面试之道-常见数据结构\n31、前端面试之道-常考算法题解析\n32、前端面试之道-如何写好一封简历\n33、前端面试之道-面试常用技巧\n34、前端面试之道-前方的路，让我们结伴同行\n"},"C-Knowledge/前端/技术书籍/前端面试之道/手写题：深拷贝":{"title":"手写题：深拷贝","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/深拷贝浅拷贝的区别！如何实现一个深拷贝！","D-Unsorted/对象的深拷贝"],"tags":["编程/JavaScript"],"content":"// 利用 WeakMap 解决循环引用\nlet map = new WeakMap()\nfunction deepClone(obj) {\n  if (obj instanceof Object) {\n    if (map.has(obj)) {\n      return map.get(obj)\n    }\n    let newObj\n    if (obj instanceof Array) {\n      newObj = []     \n    } else if (obj instanceof Function) {\n      newObj = function() {\n        return obj.apply(this, arguments)\n      }\n    } else if (obj instanceof RegExp) {\n      // 拼接正则\n      newobj = new RegExp(obj.source, obj.flags)\n    } else if (obj instanceof Date) {\n      newobj = new Date(obj)\n    } else {\n      newObj = {}\n    }\n    // 克隆一份对象出来\n    let desc = Object.getOwnPropertyDescriptors(obj)\n    let clone = Object.create(Object.getPrototypeOf(obj), desc)\n    map.set(obj, clone)\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = deepClone(obj[key])\n      }\n    }\n    return newObj\n  }\n  return obj\n}\n\n\n深拷贝浅拷贝的区别！如何实现一个深拷贝！\n对象的深拷贝\n"},"C-Knowledge/前端/技术书籍/前端面试必备/前端面试必备":{"title":"前端面试必备","links":[],"tags":["场景/面试"],"content":""},"C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LC":{"title":"AAC-LC","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LD"],"tags":["编程/FE/音视频"],"content":"简介\nMPEG AAC Low Complexity (AAC-LC)，\nMPEG AAC 低复杂度编码解码器（AAC-LC — 低复杂度高级音频编码）是低比特率、优质音频 的高性能音频编码解码器。由Fraunhofer集成电路研究所IIS等共同发明，AAC广泛地用于如iPod和移动电话之类的移动音乐播放器中。\n\n浏览器支持情况\n\n本文所讲的AAC-LC和下一篇AAC-LD都属于AAC编码格式的范畴，AAC 音频编码格式在浏览器中支持良好。\n下一步\n接下来让我们来了解下容器格式AAC-LD"},"C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LD":{"title":"AAC-LD","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/FLAC"],"tags":["编程/FE/音视频"],"content":"简介\nAAC-LD（又名AAC低延迟或MPEG-4低延迟音频编码器），为电话会议和OTT服务量身打造的低延迟音频编解码器\nAAC Low Delay 已经被广泛应用于专业和民用通信领域，是最先进的 MPEG-4音频编解码方式，可在极低编码延迟的条件下实现最佳语音和音频质量。\nAAC Low Delay 支持20 kHz 全音频带宽，能够为 IP 通信应用软件和设备带来 Full-HD Voice 音频质量。\n此类编解码器可以被看作相互之间的扩展集因为它们共享相同的编码核心，并且都会添加新的编码工具。AAC-ELD编解码器系列的软件可全面向下兼容。\n\n特征\n\n完全符合ISO MPEG-4低延迟编解码器标准\n支持的配置文件：LD\n每帧512或480个样本\n低CPU使用率和内存占用\n采样率从22.05到48 kHz\n单声道的比特率从8 Kbps到288 Kbps，立体声信号的比特率从16 Kbps到576 Kbps\nTI C6xx版本完全符合XDAIS（包括对分页表的父/子支持）\n代码可重入，支持多线程和动态内存分配\n\n延伸概念\nAAC-ELD是一款品质一流的编解码器，对于要求在低比特率和低延迟条件下保持卓越音频质量的通信解决方案而言，AAC-ELD编解码器是理想之选。\nAAC-LD对比AAC-ELD\n\n不同编码对应的比特率\n\nAAC-LD 和 AAC-ELD 随比特率变化对应的质量\n\n不同编码随比特率变化对应的算法延迟\n下一步\n接下来让我们来了解下容器格式FLAC"},"C-Knowledge/前端/技术书籍/多媒体前端手册/AIFF":{"title":"AIFF","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AMR"],"tags":["编程/FE/音视频"],"content":"简介\n\nAIFF是Audio Interchange File Format（音频交换文件格式）的缩写\n它是Apple Computer最初创建的一种音频格式，用于存储和传输高质量的采样音频数据。\n它支持各种位分辨率，采样率和音频通道。这种格式在Apple平台上非常流行，并且通常在处理数字音频波形的专业程序中采用。\nAIFF文件是未压缩的，与无处不在的MP3格式相比，这些文件非常大。AIFF文件可与Microsoft的wave文件媲美，因为它们的质量很高，非常适合刻录到CD。\n还有一种AIFF的压缩变体，称为AIFF-C或AIFC，具有各种定义的压缩编解码器。尽管AIFF文件在Macintosh用户和音频专业人员中很流行，但PC用户倾向于使用wave文件。\n标准AIFF格式的文件扩展名是.aiff或.aif。对于压缩的变体，应假定为.aifc，但支持该格式的音频应用程序也接受.aiff或.aif。\n下一步\n接下来让我们来了解下容器格式AMR"},"C-Knowledge/前端/技术书籍/多媒体前端手册/AMR":{"title":"AMR","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/MP3"],"tags":["编程/FE/音视频"],"content":"简介\n\nAMR（Adaptive Multi-Rate）自适应多速率，是一种音频编码文件格式，专用于有效地压缩语音频率。\nAMR音频主要用于移动设备的音频压缩，压缩比非常高，但是音质比较差，主要用于语音类的音频压缩，不适合对音质要求较高的音乐类音频的压缩。\n下一步\n接下来让我们来了解下容器格式MP3"},"C-Knowledge/前端/技术书籍/多媒体前端手册/AV1":{"title":"AV1","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/VP9"],"tags":["编程/FE/音视频"],"content":"简介\n\nAV1（Alliance for Open Media Video 1）是由AOM（Alliance for Open Media，开放媒体联盟）制定的一个开源、免版权费的视频编码格式，目标是解决H265昂贵的专利费用和复杂的专利授权问题并成为新一代领先的免版权费的编码标准。此外，AV1是google制定的VP9标准的继任者，也是H265强有力的竞争者。\n历史演进\n\n\n2015年，AOM成立，由半导体生产商、流媒体服务商和浏览器等公司组成。\n\n\n2016年4月7号，AV1的第一版参考编解码器0.1.0发布。\n\n\n2018年3月28号，AV1码流参考手册和参考编解码器软件发布。\n\n\n浏览器支持情况\n\n下一步\n接下来让我们来了解下容器格式VP9"},"C-Knowledge/前端/技术书籍/多媒体前端手册/AVI":{"title":"AVI","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/FLV"],"tags":["编程/FE/音视频"],"content":"简介\n\nAVI（Audio Video Interleaved）音频视频交错格式，由微软在1992年11月推出的一种多媒体文件格式，用于对抗苹果Quicktime的技术。\nAVI文件将音频（语音）和视频（影像）数据包含在一个文件容器中，允许音视频同步回放。类似DVD视频格式，AVI文件支持多个音视频流。\n优点\n\n可以跨多个平台使用\n\n缺点\n\n体积过于庞大，而且更加糟糕的是压缩标准不统一\n\n历史演进\n\n1992年被Microsoft公司推出，随Windows 3.1一起被人们所认识和熟知。\n\n容器格式解析\nAVI 文件是目前使用的最复杂的RIFF文件，它能同时存储同步表现的音频视频数据。AVI的 RIFF 块的形式类型是AVI，它包含3个子块：信息块、数据块、索引块\n\n信息块，ID为 “hdrl” 的LIST块，定义AVI文件的数据格式。\n数据块，ID为 “movi” 的LIST块，包含AVI的音视频序列数据。\n索引块，ID为 “idxl” 的子块，定义 “movi”LIST块的索引数据，是可选块。\n\n\n下一步\n接下来让我们来了解下容器格式FLV"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Architectures":{"title":"Architectures","links":[],"tags":["编程/FE/音视频","编程/WebRTC"],"content":"虽然WebRTC的特点是PeerConnection，即点对点传输，只需要服务器做信令交换。但是随着场景增大，比如多人会议等，就会面临一个问题：客户端需要对N个客户端发送流数据且需要管理之间的状态。这对于客户端的消耗是十分巨大且后续无法扩展会议规模的。\n这时候就需要引入流媒体服务器的概念，通过一个中转站帮助客户端转发流数据。客户端仅需要和服务器对接即可。通过这样的结构可以节省上行/下行带宽，成本由服务运营商承担。其中流媒体服务器也分为多种结构（MFU/SFU）。下图为上述三种形式的对比：\n\n可以看到在没有中转服务的Mesh结构中，各个客户端的上下行都是4Mbps，而在MCU（Multipoint Conferencing Unit，多点会议单元）架构中，由于MCU具备合流、编码以及转发功能，可以将多个客户端的数据合并打包转发，虽然会带来CPU的消耗，但是带宽成本降低了。而在SFU（**Selective Forwarding Unit，**选择性转发单位）架构中，由于SFU不具备流处理的功能，仅单纯做转发，所以下行带宽维持不变。总结就是：\n\nMesh结构适合简单场景，小型应用\nMCU结构-服务器计算成本巨大\nSFU结构-服务器带宽成本巨大\n\n可根据自己的业务场景选择合适的链接结构。\n参考：techbrood.com/zh/news/webrtc/2019%E5%B9%B4%E5%BC%80%E6%BA%90webrtc%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83.html"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Canvas-怎么实现播放视频！":{"title":"Canvas 怎么实现播放视频！","links":[],"tags":["编程/FE/音视频"],"content":"在使用网页播放视屏是常常会有写原生视频标签无法做到的事，比如在手机播放时可能会被手机播放器接管播放，或者加些弹幕，或者自定义些控件。\n \nclass Video2Canvas {\nstatic PLAY_STATUC = { PLAY: 1, PAUSE: 0 };\n \nconstructor(video, canvas) {\n  this.statuc = Video2Canvas.PLAY_STATUC.PAUSE;\n  this.video = video;\n  // 自动创建Canvas\n  if (!(this.canvas = canvas)) {\n\tthis.canvas = document.createElement(&quot;canvas&quot;);\n\tthis.canvas.width = video.clientWidth;\n\tthis.canvas.height = video.clientHeight;\n\tthis.canvas.className = video.className;\n\tvideo.style.display = &quot;none&quot;;\n\tvideo.parentNode.appendChild(this.canvas);\n  }\n  this.c2d = this.canvas.getContext(&quot;2d&quot;);\n  this.video.addEventListener(&quot;play&quot;, this.play.bind(this));\n  this.video.addEventListener(&quot;pause&quot;, this.pause.bind(this));\n}\n \nrender() {\n  if (this.statuc == Video2Canvas.PLAY_STATUC.PLAY) {\n\tthis.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\tthis.c2d.drawImage(\n\t  this.video,\n\t  0,\n\t  0,\n\t  this.canvas.width,\n\t  this.canvas.height\n\t);\n\trequestAnimationFrame(this.render.bind(this)); // 渲染视频帧\n  }\n}\n \nplay() {\n  console.log(&quot;播放&quot;);\n  if (this.video.paused) this.video.play();\n  this.statuc = Video2Canvas.PLAY_STATUC.PLAY;\n  this.render();\n  return this;\n}\n \npause() {\n  console.log(&quot;暂停&quot;);\n  if (this.video.played) this.video.pause();\n  this.statuc = Video2Canvas.PLAY_STATUC.PAUSE;\n  return this;\n}\n}\n \n// 使用方法：1\nconst video = document.querySelector(&quot;video&quot;); // 获取到视频标签\n// 实例化 Canvas 对象并播放，该操作会自动创建一个 Canvas 标签放到 video 标签同级并隐鲹原有的 video 标签\nconst v2c = new Video2Canvas(video).play();\n \n// 使用方法：2\n// const video = document.querySelector(&quot;video&quot;); // 获取到视频标签\n// const canvas = document.querySelector(&quot;canvas&quot;); // 获取到自己准备好的canvas标签\n// 实例化 Canvas 对象并播放\n// const v2c = new Video2Canvas(video, canvas).play();\n扩展阅读\n\n使用 canvas 处理视频\n使用原生 Canvas 播放视频‘\ncanvas_video.js： 一个用canvas来播放视频的小插件，主要应用于移动端微信。\ncanvas绘制video\n用canvas实现视频播放与弹幕功能\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/DASH":{"title":"DASH","links":[],"tags":["编程/FE/音视频"],"content":"\n基于HTTP的动态自适应流（英语：Dynamic Adaptive Streaming over HTTP，缩写DASH，也称MPEG-DASH）是一种自适应比特率流技术，使高质量流媒体可以通过传统的HTTP网络服务器以互联网传递。类似苹果公司的HTTP Live Streaming（HLS）方案，MPEG-DASH会将内容分解成一系列小型的基于HTTP的文件片段，每个片段包含很短长度的可播放内容，而内容总长度可能长达数小时（例如电影或体育赛事直播）。内容将被制成多种比特率的备选片段，以提供多种比特率的版本供选用。当内容被MPEG-DASH客户端回放时，客户端将根据当前网络条件自动选择下载和播放哪一个备选方案。客户端将选择可及时下载的最高比特率片段进行播放，从而避免播放卡顿或重新缓冲事件。也因如此，MPEG-DASH客户端可以无缝适应不断变化的网络条件并提供高质量的播放体验，拥有更少的卡顿与重新缓冲发生率。\nDASH为一项自适性流技术，其将多媒体文件分割为一个或多个片段，并使用超文本传输协议传递给客户端。媒体演示描述（MPD）描述片段信息（计时、统一资源定位符，以及媒体特征，例如视频分辨率和比特率），并且可以根据使用环境以不同的方式组织，例如SegmentList, SegmentTemplate, SegmentBase和SegmentTimeline。片段可以包含任何媒体数据，但是规范提供了与两种容器类型一起使用的特定指导和格式：ISO基础媒体文件格式（例如MP4文件格式）或MPEG-2传输流。\nDASH不关心音频/视频的编解码器。多媒体文件通常有一种或多种表示（即不同分辨率或比特率版本），并可基于不同的网络条件、设备功能和用户偏好进行选择，达到自适性流和QoE (Quality of Experience) fairness。DASH也与底层的应用层协议无关，因此可以配合任何协议中使用。例如，基于CCN的DASH。\n优势\n\n允许客户端根据网络带宽情况可以自动选择合适的码流进行播放，便于适应网络带宽抖动，同时最大程度上为终端用户提供最好的服务质量\n允许进行一次编码后安全地分发到通用平台的所有设备中（包括移动设备，OTT设备，通过插件方式到桌面设备或者 HTML5设备），便于实现面向多终端的流媒体内容传送\n支持多种编码格式，包括H.265、H.264、VP9等\n支持多种DRM，支持PlayReady、Widewine，采用通用加密技术，支持终端自带DRM，可以大幅度降低DRM投资成本\n支持多种文件封装，支持MPEG-4、MPEG-2 TS（Transport Stream）\n支持异构终端，浏览器原生不用插件就可以支持，Android/iOS/Windows/Flash可以通过JITP将DASH转换为HLS、HDS、HSS等，已支持Legacy终端类型，支持一份存储，大幅度减少文件存储量；\n支持直播、点播、录制、时移等丰富的视频特性；\n支持动态码率适配，支持多码率平滑切换；\n支持客户端和服务端的广告插入；\n是事实上的国际标准，被行业内产业链的众多企业所支持，具有更长久的生命力\n的实现方式更适合通过CDN进行内容分发，从而有效降低大规模内容分发的成本\n\n封装格式\nDash生成的片段可以选择不同格式封装，但相对于.ts（MPEG-TS），大多人更推荐.mp4（MPEG-4）\n\n.ts文件一般用于m3u8中, 或者提供了流媒体基础信息的前提下使用\n.mp4文件因为其头部记录moov信息(moov box 中包含编码、分辨率、码率、帧率、时长、音频采样率等等媒体信息)，可以在不下载完全媒体文件的前提下进行seek操作，而在ts文件里则不行\n\nfMP4\n\n全称（Fragmented mp4），可以理解为基于 mp4 的流媒体格式。mp4 可以参考前面的文章，fmp4相对mp4的特点主要是以下两点：\n\nmoof box 中存放的是该 Fragment 中 mdat 的视频分片的描述信息，读取 moof box 即可对该 Fragment 进行解码播放。\nFragmented MP4 中的 moov box 只存储文件级别的媒体信息，因此 moov box 的体积比传统的 MP4 中的 moov box 体积要小很多。\n\n下图为两种结构的详细对比和解释\n\n\nMPD\nMPEG-DASH 使用 XML格式的 **MPD（Media Presentation Description）**文件来描述码流的详细信息，类似于 HLS 的 m3u8 文件。\n\n白皮书翻译：juejin.im/post/5c8b6352518825106a62c682"},"C-Knowledge/前端/技术书籍/多媒体前端手册/FFmpeg":{"title":"FFmpeg","links":[],"tags":["编程/FE/音视频"],"content":"\nFFmpeg怎么念\nFFmpeg念作ef ef em peg，其全称为 Fast Forward Moving Picture Expert Group\nFFmpeg是什么\nFFmpeg是一套领先的多媒体框架，是一套开源且跨平台的多媒体解决方案，提供了音视频的编码、解码、转码、封装、解封装、流媒体、滤镜、播放等功能，官网地址为 ffmpeg.org\nFFmpeg可以用来干嘛\n\n视频播放器：很多视频播放器使用FFmpeg作为播放器内核，实现拉流、解封装、解码等功能，如射手播放器、暴风影音、QQ影音、KMPlayer、ijkplayer、MPlayer、VLC等，连Chrome浏览器的视频播放也使用了FFmpeg代码\n视频转换工具：基本上市面上做视频格式转换、视频压制的软件都基于FFmpeg来实现，比如格式工厂、小丸工具箱等\n\n除了播放和转换，其他如音视频录制、直播推流、滤镜应用等很多场景都可以使用FFmpeg\nFFmpeg的组成\n使用FFmpeg有两种方式：\n\n\n命令行工具：FFmpeg提供了三个命令行工具直接进行多媒体处理\n\nffmpeg 转换多媒体文件格式\nffplay 基于SDL和FFmpeg库的简单媒体播放器\nffprobe 简单的多媒体流信息分析工具\n\n\n\n模块库：FFmpeg提供了一些模块库，供开发者进行二次开发\n\nlibavutil 提供一些基础的工具函数，比如随机数生成、基础数据结构、文件操作、MD5 SHA加密方法等\nlibavcodec 提供音视频的编码器、解码器，支持目前多媒体领域中绝大多数常用的编解码格式。除了自带的编码格式外，还支持第三方的编解码器，比如使用x264编解码器支持H.264/AVC编解码，使用x265编解码器支持H.265/HEVC编解码\nlibavformat 提供媒体格式的解封装和封装，支持目前多媒体领域中绝大多数媒体封装格式，包括RTMP、RTSP、HLS等流媒体协议封装和MP3、MP4、FLV、TS等媒体文件封装。还支持媒体封装格式扩展，增加自己定制的封装处理模块\nlibavdevice 提供音视频采集和渲染相关的输入/输出设备接口，兼容大部分通用多媒体输入/输出软件框架，比如Video4Linux、Video4Linux2、VfW、ALSA等\nlibavfilter 提供通用的音频、视频、字幕等滤镜处理框架\nlibswscale 提供深度优化的视频图像转换API，比如图像缩放（1080p转换成720p）、像素格式转换（yuv转rgb）等\nlibswresample 提供深度优化的音频重采样API，比如采样频率转换（44100Hz转换到8000Hz）、声道格式转换（立体声转换为单声道）、样本格式转换（s16的PCM数据转换为f32的PCM数据）等\n\n\n\nFFmpeg基础使用示例\n\n视频格式转换：比如将avi文件转成mp4格式\nffmpeg -i input.avi output.mp4\n视频剪切：比如从时间为00:00:15开始，截取5秒钟的视频 (-ss表示开始切割的时间，-t表示要切多少)\nffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4\n提取音频：比如将一个MV变成音频文件 (-vn 不处理视频)\nffmpeg -i 千千阙歌现场版.mp4 -acodec copy -vn output.aac\n提取视频：比如将一个视频去除音频 (-an 不处理音频)\nffmpeg -i input.mp4 -vcodec copy -an output.mp4\n视频加水印：比如给视频右上角加上淘宝直播图片水印\nffmpeg -i input.mp4 -i 淘宝直播_logo.png -filter_complex overlay output.mp4\n视频缩放：比如将1920x1080分辨率的视频缩小到960x540\nffmpeg -i input.mp4 -vf scale=960:540 output.mp4\n\n前端和FFmpeg有什么关联\n\nJS播放器：可以基于FFmpeg和WebAssembly实现浏览器端的JS播放器，或扩展浏览器端其他的音视频能力，更多详情可参考 《Web端H.265播放器研发解密》\nNode模块 fluent-ffmpeg：node.js中非常实用的模块，该模块简化了ffmpeg复杂的命令操作，且配合文件上传以及视频流的处理等非常实用，更多详情可参考 fluent-ffmpeg\n\n参考文档\n\nffmpeg基础使用\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/FLAC":{"title":"FLAC","links":[],"tags":["编程/FE/音视频"],"content":"简介\n\nFLAC（Free Lossless Audio Codec）免费无损音频编解码器。是一套著名的自由音频压缩编码，其特点是无损压缩。 2012年以来它已被很多软件及硬件音频产品（如CD等）所支持。\nFLAC可以将原始源文件压缩多达60％，不同于其他有损压缩编码如AAC，它不会破坏任何原有的音频信息，所以可以还原音乐光盘音质 ，而不会丢失任何数据。更好的是FLAC是一种开源且免版税的音频文件格式，因此它没有施加任何知识产权约束。\n大多数主要程序和设备都支持FLAC，并且FLAC是 MP3音乐的主要替代方案。\n浏览器兼容情况\n\n下一步\n恭喜你～音视频基础章节已经到此结束了。\n具备了基础知识后，对于本册下面介绍的直播技术、播放器、web媒体技术理解起来都会简单许多！\n当然，还有开源产品和框架程序中的一些名词看起来也会游刃有余啦～"},"C-Knowledge/前端/技术书籍/多媒体前端手册/FLV":{"title":"FLV","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8"],"tags":["编程/FE/音视频"],"content":"简介\n\nFLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，现各视频网站大多使用的是FLV格式。\n优点\n\n文件小、加载速度极快。\n\n缺点\n\n导出的SWF文件体积庞大等。\n\n容器格式解析\nFLV 容器格式包括文件头（File Header）和文件体（File Body）两部分，其中文件体由一系列的 Tag 及 Tag Size 对组成。\n\n\n下一步\n接下来让我们来了解下容器格式TS, M3U8"},"C-Knowledge/前端/技术书籍/多媒体前端手册/H.264":{"title":"H.264","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AV1"],"tags":["编程/FE/音视频"],"content":"简介\n\nH.264是由国际电信联盟和国际标准化组织/国际电工委员会运动图像专家组联合开发的视频压缩技术或编解码器\n(如MPEG-4 Part 10，高级视频编码或AVC)。因此，术语H.264和AVC表示同一事物，并且可以互换。\nH.264是在MPEG-4技术的基础之上建立起来的，其编解码流程主要包括5个部分：帧间和帧内预测(Estimation)、 变换(Transform)和反变换、量化(Quantization)和反量化、环路滤波(Loop Filter)、熵编码(Entropy Coding)。\n浏览器支持情况\n\n下一步\n接下来让我们来了解下容器格式 AV1"},"C-Knowledge/前端/技术书籍/多媒体前端手册/H.265":{"title":"H.265","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/H.264"],"tags":["编程/FE/音视频"],"content":"简介\n\nHEVC代表高效视频编码。用来以替代H.264/AVC编码标准。\n这种新的视频编解码器也称为 H.265，它使用当前最有效的编码格式 MPEG-4（又名H.264）将视频文件压缩到可能的一半大小。这将是大多数有线电视公司仍在使用的MPEG-2编解码器压缩的文件大小的四分之一。更重要的是，HEVC 用于压缩4K分辨率（将来甚至可能达到8K分辨率）的视频，因此可以有效地进行传输。\n与现有协议相比，HEVC/H.265 能显著降低比特率——与 H.264 相比拥有高达 50% 的比特率改进——为 4K 和更高的视频分辨率提供了优化的传输解决方案，并且支持最高 7680 x 4320 的图像。HEVC 可以适用于任何传输协议，并且是高效传输 4K 和更高分辨率流媒体视频的领先技术。\n同一个视频，采用不同编码方式流量对比:\n\n由图可知：相同视频文件使用H.265编码方式编码后的文件体积大约是MPEG-4编码后文件的1/3\n视频性能\n\n与 H.264/MPEG-4 AVC HP 相比，平均比特率减少\n静态图像性能\n\n基于相等 PSNR 和 MOS 的静态图像压缩标准比较。\n与 JPEG 2000 和 JPEG 相比，平均比特率减少。\nHEVC/H.265 的优势\n\n浏览器支持程度\n\n浏览器支持比较差, 如何在浏览器上支持播放h.265编码格式的视频？业界方案参考： libde265.js, FFMpeg + WebAssembly\n下一步\n接下来让我们来了解下容器格式H.264"},"C-Knowledge/前端/技术书籍/多媒体前端手册/HLS":{"title":"HLS","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/hls.js","C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8"],"tags":["编程/FE/音视频"],"content":"HLS 是什么\nHLS (HTTP Live Streaming) 是 Apple 提出的直播流协议，它诞生于2009年，一个意在颠覆流媒体产业的新协议。它的工作原理是把一段视频流切分成一个个的小块，并基于 HTTP 的文件来下载。当媒体流正在播放时，客户端可以根据当前网络环境，方便地在不同的码率流中做切换，以实现更好的观影体验。下图是苹果官方给出的大体流程图：\n\nHLS 如何播放\nHLS提供一个m3u8地址，可以很方便地实现播放：\n\nSafari 浏览器直接能打开 m3u8地址，譬如： livenging.alicdn.com/mediaplatform/f80a98ee-c9d2-4e2d-b81e-fa80dd7ccd08_merge.m3u8\nAndroid 不能直接打开，需要使用 H5 的 video 标签，然后在浏览器中打开这个页面即可，譬如：\n\n&lt;video controls autoplay&gt;\n\t&lt;source\n\tsrc=&quot;livenging.alicdn.com/mediaplatform/f80a98ee-c9d2-4e2d-b81e-fa80dd7ccd08_merge.m3u8&quot;\n\ttype=&quot;application/vnd.apple.mpegurl&quot;\n\t/&gt;\n\t&lt;p class=&quot;warning&quot;&gt;Your browser does not support HTML5 video.&lt;/p&gt;\n&lt;/video&gt;\n\n其他不兼容的浏览器里想播放 HLS，可以使用开源的 hls.js，更多详细信息可以参考本手册的章节《hls.js》\n\nHLS协议\nHLS 由两部分构成：\n\n.m3u8 文件：以 UTF-8 编码的 m3u 文件，这个文件本身不能播放，只是存放了播放信息的文本文件\n.ts 视频文件：每一个 m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据\n\nm3u8 文件只是存放了一些 ts 文件的配置信息和相关路径，当视频播放时，m3u8 是动态改变的，video 标签会解析这个文件，并找到对应的 ts 文件来播放，所以一般为了加快速度，m3u8 放在 Web 服务器上，ts 文件放在 CDN 上。视频的编码格式为 H264，音频编码格式为 MP3、AAC 或者 AC-3。\n更多关于 m3u8 和 ts 格式的介绍，可以参考本手册的章节《TS, M3U8》\nHLS和RTMP对比\n\n\nRTMP 可以用在推流和拉流，但 HLS 只能用在拉流端。比如以RTMP协议推流、HLS协议拉流的方案大致流程如下\n\n\n\nHLS 延时比 RTMP 高\n\n\nRTMP 延时在1-3s，而 HLS 延时在5-20s，主要依赖切片的情况。HLS 的延时包含了 TCP 握手、ffmpeg 切片及磁盘写入、m3u8 文件下载与解析、ts 文件下载与解析等多个步骤。其中最长的耗时在于媒体服务等待数据进行切片，比如单个 ts 文件时长为10s，那么在直播的环境里媒体服务器要等到这 10 秒的数据推上来，才可以切片，即使切片处理及网络耗时不计，拉流端看到的数据也是10秒之前的内容。\n可以缩短列表的长度和单个 ts 文件的大小来降低延迟，极致来说可以缩减列表长度为 1，并且 ts 的时长为 1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时会造成更多的缓冲。因为延时较高，生产环境里一般用HLS来做直播时移和回放"},"C-Knowledge/前端/技术书籍/多媒体前端手册/HTTP-FLV":{"title":"HTTP-FLV","links":[],"tags":["编程/FE/音视频"],"content":"简介\nFLV是Adobe公司提出一种视频格式，由于协议简单、传输体积小而被广泛采用，而常见的HTTP-FLV流媒体协议是通过HTTP协议将FLV封装过的视频内容、音频内容流式传输到端上，从而实现直播播放诉求。个人理解HTTP-FLV不算是一个标准协议，而是借助了HTTP的流传输能力将FLV格式协议的媒体内容流示传输到客户端，而了解FLV协议格式内容，对于理解整个HTTP-FLV流媒体协议来说是非常有必要的。\nFLV协议内容\n简单来说，FLV格式主要由FLV header和FLV body两部分构成，而FLV body里包含了多个FLV tags，大体的组合公式可以概括为：\nFLV = FLV header + FLV body\nFLV body = PreviousTagSize0 + Tag1 + … + PreviousTagSizeN-1 + TagN\n\n1、FLV header\nheader部分长度为9个字节，前面3个字节为固定”FLV”拼写，第4个字节为版本号，通常为01；第5个字节里，第6位表示audio tag，第8位表示video tag；最后4个字节代表header长度，版本1下的长度为9；在常见的flv转封装库，如flv.js，都是通过检测FLV header来确定当前字节流是不是一个标准FLV格式的流\n\n2、FLV body\nflv body是由PreviousTagSize和FLV tags叠加构成\n2.2、FLV tags\nFLV tags 由 tags header + tags data 构成，header部分包含TagType、DataSize、Timestamp、Timestamp Extend、StreamId构成，其中TagType标明了data的类型，结构图如下：\n\n2.2.1、FLV tags header\n\n2.2.2、FLV tags data\n\nAudio tags，用于描述音频信息\nVideo tags，主要用于描述视频信息\nScript Data tags，一种amf的格式实现，拥有各种类型，用于存放媒体onMetaData（元数据）信息，如时长、长度、宽度等\n\n3、FLV tags data\n3.1、Audio tags\n图解如下：\n\n定义如下：\n\n特别需要关注的是，当SoundFormat=10的时候，SoundData的内容为AACAUDIODATA，AACAUDIODATA的协议内容为：\n\n3.2、Video tags\n图解如下：\n\n定义如下：\n\n特别需要关注的是，当CodecID为7的时候，也就是说VideoData的实际媒体内容为AVCVIDEOPACKET，AVCVIDEOPACKET的协议内容如下：\n\n3.3、Scripts Data tags\n图解如下：\n\n定义如下：\n\nSCRIPTDATAOBJECT的协议字段为：\n\nSCRIPTDATAVALUE的协议字段为：\n\n总协议图\n基于上面的协议拆分，做了下协议的整合大图\n\n附录\n官方协议详解：www.adobe.com/content/dam/acom/en/devnet/flv/video_file_format_spec_v10.pdf"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Hls.js-加载-m3u8主流程源码解析":{"title":"Hls.js 加载 m3u8主流程源码解析","links":[],"tags":["编程/FE/音视频"],"content":"hls.js的使用非常简单，以下为其官方的demo：\n&lt;script src=&quot;cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;\n&lt;video id=&quot;video&quot;&gt;&lt;/video&gt;\n&lt;script&gt;\n  var video = document.getElementById(&#039;video&#039;);\n  var videoSrc = &#039;test-streams.mux.dev/x36xhzz/x36xhzz.m3u8&#039;;\n  if (Hls.isSupported()) {\n    var hls = new Hls();\n    hls.loadSource(videoSrc);\n    hls.attachMedia(video);\n  }\n&lt;/script&gt;\n该框架的配置多大几十项，一般情况下使用默认配置即能满足绝大部分场景。但是如果针对一些特殊场景需要更改配置，对一般开发者来说并非易事。所以，如果精准控制，还得搞懂每一项的具体是怎么执行的。\nhls.js库是基于eventemitter3用于事件的监听和派发，这样处理逻辑松耦合，虽然当事件多起来后维护需要一定成本，但是基于hls.js在加载视频流到播放过程中，存在很多多个事件监听一个事件的场景，所以采用eventemitter也是十分合适的，而且也方便业务方增加监听事件。\nhls.js库根据功能划分为多个controller，如abr-controller、buffer-controller、stream-controller等，每个controller任务明确，通过事件监听派发的方式完成视频流的拉取、解析、播放等。\nhls.js从初始化到加载m3u8，到选择不同码率加载对应ts文件，再解码ts转为mp4最终在浏览器播放，整个过程非常复杂，作者整理了一个流程图如下：\n\n其中，几个关键环节对应的含义如下所示：\nMANIFEST_LOADING: 开始加载playlist m3u8资源\nMANIFEST_LOADED: playlist m3u8文件加载完成\nMANIFEST_PARSED：playlist m3u8解析完成\nLEVEL_LOADING: 加载特定码率的m3u8文件\nLEVEL_LOADED: 特定码率的m3u8文件解析完成，拿到该码率对应的ts列表\nFRAG_LOADING: 开始加载某个ts分片文件，开始根据ts片下载时间预估带宽\nFRAG_LOADED: ts分片文件加载成功，开始转码\nBUFFER_APPENDING: 视频流赋给video标签\n主流程中有两个关键的定时器，第一个为StreamController启动用来轮询ts文件列表是否更新结束；第二个为在ts片加载过程中，用来轮询监听当前ts下载速率以动态调节不同的码率，hls.js初始默认码率为playlist的中间码率，如当前码率列表为360p、480p、720p，则初始默认取480p。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/IBP帧":{"title":"IBP帧","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是GOP！","C-Knowledge/前端/技术书籍/多媒体前端手册/压缩率","C-Knowledge/前端/技术书籍/多媒体前端手册/SEI","C-Knowledge/前端/技术书籍/多媒体前端手册/复用(remux)"],"tags":["编程/FE/音视频"],"content":"帧指的是视频中的单幅画面,多个帧连起来就构成了视频。而在编码视频压缩过程中，为了节省存储空间，并不会将每一帧的信息都会完完全全保留下来，会采用各种方法来减少视频数据大小,其中生成I、B、P帧就是一种编码器常采用的办法。\n帧作为NAL层中的基本数据，存储在NALU当中，存储着视频的真正数据。\nIBP帧是什么\n\n如图从左到右依次解码。\n第一帧是I帧，它是关键帧。I帧进行帧内预测，可以单独解码本帧的数据。\n第二帧是 B 帧，它是向前预编码帧。它要使用一个前面的 I 帧或 P 帧和一个后面的 I 帧或 P 帧进行预测。不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。\n第四帧是 P 帧，它是向前预测编码帧。P 帧在解码过程中使用一个前面的 I 帧或 P 帧作为参考图像进行运动补偿。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。\nI 帧：帧内编码帧（intra picture）,I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一帧，经过适度地压缩，作为随机访问的参考点可以当成静态图像。I 帧可以看做一个图像经过压缩后觉得产物，I 帧压缩可以得6：1的压缩比而不会产生任何可觉察的模糊现象。I 帧压缩可去掉视频的空间冗余信息，下面即将介绍 P 帧和 B 帧是为了去掉 时间冗余信息。\nP帧：前向预测编码在帧(predictive-frame),通过将图像序列中前面已编码帧的时间冗余信息去充分去除压缩传输数据量的编码图像，也成为预测帧。\nB帧：双向预测内插编码帧（bi-directionalinterpolated prediction frame）,既考虑源图像序列前面的已编码帧，又估计源图像序列后面的已编码帧之间的时间冗余信息，来压缩传输数据量的编码图像，也成为双向预测帧。\nGOP是什么\n两个 I 帧之间形成一组图片，就是 GOP（Group Of Picture）。通常在为编码器设置为参数的时候，必须设置为 gop_size 的值，其代表的两个 I 帧之间的帧数目。一个 GOP 中容量最大的就是 I 帧，所以相对来讲，gop_size 设置的越大，整个画面就会越好，但是在解码端必须从接收接收到一个 I 帧的第一个 I 帧开始 I 才可以正确解码出原始图像，否者无法正常解码（这也是前面提到的 I 帧可以作为随机访问的帧。在提高视频质量的技巧中，还有个技巧是多使用 B 帧，一般来说，I 帧的压缩率是7（与 JPG 差不多），P 是20，B 可以达到50，可见使用 B 帧能节省大量的空间，节省出来的空间可以用来更多的保存 I 帧，这样就能在相同的码率下提供更好的画质。所以我们要根据不同的业务场景，适当的设置 gop_size 的大小，已得到更高质量的视频。\n\n帧的作用\n由于连续的帧之间相似性极高，为便于储存传输，我们需要对原始的视频进行编码压缩，以去除空间、时间维度的冗余。帧的压缩技术，极大的节约了网络带宽，提高了传输效率。\n重要的NAL流基本数据介绍完了，如果想了解SEI帧的相关信息，请查看后面章节SEI\n想了解播放器复用(remux)的相关知识，请学习下一章复用(remux)"},"C-Knowledge/前端/技术书籍/多媒体前端手册/MLT":{"title":"MLT","links":[],"tags":["编程/FE/音视频"],"content":"MLT是什么\n\nMLT的英文全称为MLT Multimedia Framework。\n官网地址、github\nThe engine of a non-linear video editor that can be used in all sorts of apps, not just desktop video editors.\n翻译：它是一个够用于多种类型app非线性视频编辑器引擎，且不局限于桌面领域(同样适用于Android、iOS等平台，功能十分强大)。\n非线性剪辑\n首先要理解什么是非线性视频剪辑，简而言之，就是意味着能存取视频片段中的任意一帧。它的概念类似于最初使用在电影剪接中 “剪”和“接”的手段。\n非线性剪辑的优势：\n非线性编辑是相对传统上以时间顺序进行线性编辑而言，非线性剪辑提供了更灵活的视频编辑方式和简单项目管理等诸多的优点，特别是理论上素材质量不会损失的优点受到欢迎。另外，非线性编辑借助计算机来进行数字化制作，几乎所有的工作都在计算机里完成，不再需要那么多的外部设备，对素材的调用也是瞬间实现，不用反反复复在磁带上寻找，突破单一的时间顺序编辑限制，可以按各种顺序排列，具有快捷简便、随机的特性。[from wikipedia]。\n类似Pr(Premiere)，Final Cut Pro等 均为非线性编辑软件。\n至此，那么我们再“翻译”一下MLT的功能：\nMLT功能\n这个框架可以用来对音视频做剪辑、合并、增加一些滤镜特效等；\n并且它提供一个html页面覆盖在视频上操作的功能也非常实用。\nMLT的基本设计模型\nMLT由C编写，它遵循基本的面向对象设计范式，主要采用的是生产者（producer）和消费者（consumer）模型。\n  +--------+   +--------+\n\t|Producer|--&gt;|Consumer|\n\t+--------+   +--------+\n\n\n\n                  \n                  注意❗ \n                  \n                \nps：实际上，MLT 底层功能是通过多个第三方库, 如: ffmpeg、freiOr 和 ladspa 等。类似「滤镜」就使用了 ffmpeg 的功能。\n\nMLT的优势\n\n小巧，干净的API，具有最小的依赖性\n模块化设计，便于添加新组件\n与其他多媒体库和应用程序轻松集成\n支持基于时间的媒体的创作和操作，包括播放列表，多个轨道，过滤器和过渡\n创作项目的序列化和反序列化\n基于Doxygen风格的API文档\nC++，C＃，Java，Lua，Perl，PHP，Python，Ruby和TCL的高级语言绑定\n多核和GPU处理\n跨平台：支持Linux，BSD，Mac OS X MacPorts，Windows MinGW\nLGPLv2.1 许可的 License\n\nMLT使用\nmelt命令行\nMLT提供了的命令行工具执行视频操作。\n如：\n按时间剪辑视频\nmelt test.mp4 in=&quot;00:01:10:00&quot; out=&quot;00:01:30:00&quot; -consumer avformat:o.mp3 acodec=libmp3lame\n\n添加滤镜：\nmelt test.mp4 -filter greyscale -consumer avformat:o.avi acodec=libmp3lame vcodec=libx264\n\n依赖MLT框架的视频软件：Kdenlive"},"C-Knowledge/前端/技术书籍/多媒体前端手册/MOV":{"title":"MOV","links":[],"tags":["编程/FE/音视频"],"content":"简介\n\nMOV视频容器是Apple Quicktime中经常使用的一种常见的多媒体格式，它使用Apple Computer开发的专有压缩算法来保存电影和其他视频文件，该算法与Macintosh和Windows平台都兼容。MOV容器可以存储不同的视频数据格式，例如MPEG-4和OGG。\n下一步\n本章对于视频的基础概念已经叙述完毕，你可以选择阅读编码格式"},"C-Knowledge/前端/技术书籍/多媒体前端手册/MP3":{"title":"MP3","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/Ogg"],"tags":["编程/FE/音视频"],"content":"简介\n\nMP3的全称是Moving Picture Experts Group Audio Layer III(动态影像专家压缩标准音频层面3), 是一种高效的计算机音频编码方案,它以较大的压缩比将音频文件转换成较小的扩展名为.mp3的文件,基本保持原文件的音质。\n浏览器支持情况\n\n下一步\n接下来让我们来了解下容器格式Ogg"},"C-Knowledge/前端/技术书籍/多媒体前端手册/MP4":{"title":"MP4","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AVI"],"tags":["编程/FE/音视频"],"content":"简介\n\nMP4 或称 MPEG-4 第14部分（MPEG-4 Part 14）是一种标准的数字多媒体容器格式。由国际标准化组织（ISO）和国际电工委员会（IEC）下属的”动态图像专家组“（Moving Picture Experts Group，即MPEG）制定。\nMP4 文件格式是一个十分开放的容器，几乎可以用来描述所有的媒体结构，MP4 文件中的媒体描述与媒体数据是分开的，并且媒体数据的组织也很自由，不一定要按照时间顺序排列，甚至媒体数据可以直接引用其他文件。MP4 也支持流媒体。MP4目前被广泛用于封装 h.264/h.265 视频和 AAC 音频，是高清视频的代表。\n\n历史演进\n\n2001年，Apple 的 QuickTime 格式，.qt和.mov后缀名。\n2001年，MPEG-4 Part1，把基于 QuickTime 的 box 布局的容器格式添加到了 MPEG-4 标准。\n2004年，标准文档把编码和容器格式的说明分开了。\n\nMPEG-4 Part12，定义了容器格式通用的 box 结构，即 ISO 媒体文件格式(ISO base media file format)。\nMPEG-4 Part14，基于 Part12 进行了细化，定义了用于存储 MPEG-4 内容的容器格式，即.mp4格式。\n容器格式解析\n下图是从在线解析 MP4 工具基于H.265 编码的 MP4 文件生成的 Tree View，基于下图来解释 MP4 容器内部结构(以下简称容器)。\n\n\n容器中所有数据是由若干个 box（QuickTime 中为atom）组成的。可以将 box 理解为一个数据对象块。\n容器首先会有且只有一个ftyp类型的 box，作为 MP4 格式的标志，并包含一些文件的信息。之后会有且只有一个moov（Movie box）类型的 box，子容器中包含了媒体的 metadata 信息。\n容器中的媒体数据包含在mdat（Midia data box）类型的 box 中，可以没有（媒体数据全部引用其他文件时）或有多个。\n\n\nftyp 包括32位的 major_brand，一个32位的 minor_version 和一个以32位为单位的 compatible_brands，这些用来指示文件应用级别信息。\nmoov 包含了文件媒体的 metadata 信息，“moov”中会包含1个“mvhd”和若干个“trak”。其中“mvhd”为header box，一般作为“moov”的第一个子 box 出现（对于其他 container box 来说，header box 都应作为首个子 box 出现）。“trak”包含了一个 track 的相关信息，是一个 container box。下图为部分“moov”的字节实例，其中红色部分为 box header，绿色为“mvhd”，黄色为一部分“trak”。\n\nmoov 字节实例\n\n\nmvhd结构表\n\n\n\ntrak 表示一些 sample 的集合，对于媒体数据来说表示一个视频或音频序列。\ntkhd(Track Header Box) track 数据信息\nmdia(Media Box) 媒体数据信息，mdia 定义了 track 媒体类型以及 sample 数据，描述 sample 信息。一般 mdia 包含一个 mdhd（Media Header Box），一个 hdlr（Handler Reference Box）和一个 minf（Media Information Box）\nminf中的文件解析：vmhd（Video Media Header Box），dinf（Data Information Box）解释如何定位媒体信息。stbl（Sample Table Box）sample 是媒体数据存储的单位，存储在 media 的 chunk 中，chunk 和sample 的长度均可互不相同，如下图所示。\n\n \n包含了关于 track 中 sample 所有时间和位置的信息，以及 sample 的编解码等信息。\n\nfree 无关紧要的内容，删除后不会产生任何影响\n\nMP4容器格式脑图:\n\n下一步\n接下来让我们来了解下容器格式AVI"},"C-Knowledge/前端/技术书籍/多媒体前端手册/OBS":{"title":"OBS","links":[],"tags":["编程/FE/音视频"],"content":"API\n简介\nOBS（Open Broadcaster Software）是一个用于录制和进行网络直播的自由开源软件包。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。[6]\n在视频编码方面，OBS可以使用X264自由软件程序库、Intel Quick Sync Video、Nvidia NVENC和AMD视频编码引擎将视频流编码为H.264/MPEG-4 AVC和H.265/HEVC格式。[7]音频可以使用MP3或AAC编解码器进行编码。进阶用户可以选择使用Libavcodec/libavformat中的任何编解码器和容器，也可以将流输出到自定义FFmpeg URL。\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/OGV":{"title":"OGV","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/MOV"],"tags":["编程/FE/音视频"],"content":"简介\n\n\nOGV文件格式是以Xiph.Org开源Ogg容器格式保存的视频文件。它包含可能使用一种或多种不同编解码器的视频流，例如Theora，Dirac或Daala。可以使用各种媒体播放器来播放OGV文件。\nOGV文件通常用于使用HTML5 &lt;video&gt;标签播放网页视频内容。但是，即使文件包含视频内容，它们也通常在HTML源代码中使用 “.ogg” 扩展名进行引用。\nXiph.Org 是 OGV 格式的开发者，提供了 DirectShow 编解码器包，使软件开发人员能够在开源和商业应用程序中包括对 OGV 文件的支持。\n下一步\n接下来让我们来了解下容器格式MOV"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Ogg":{"title":"Ogg","links":[],"tags":["编程/FE/音视频"],"content":"简介\n\nOGG文件是一种压缩的音频文件，它使用免费的未经专利的Ogg Vorbis音频压缩。它类似于.MP3文件，但听起来比相同大小的MP3文件更好，并且可能包含歌曲元数据，例如艺术家信息和曲目数据。许多软件音乐播放器和某些便携式音乐播放器都支持OGG文件。\nOgg格式是用于存储音频数据的容器。术语“ Vorbis”是指由Ogg的开发商Xiph.Org提供的特定编码方案。OGG文件还可以包括其他类型的音频压缩，包括FLAC和Speex。但是，由于这些文件使用不同的压缩方案，因此它们不能正式称为“ Vorbis”文件。\n浏览器支持情况\n\n下一步\n本章对于视频的基础概念已经叙述完毕，你可以选择阅读编码格式"},"C-Knowledge/前端/技术书籍/多媒体前端手册/PCM":{"title":"PCM","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LC"],"tags":["编程/FE/音视频"],"content":"简介\nPCM编码：脉冲编码调制(Pulse Code Modulation,PCM)，PCM是数字通信的编码方式之一。\n主要过程是将话音、图像等模拟信号每隔一定时间进行取样，使其离散化，同时将抽样值按分层单位四舍五入取整量化，同时将抽样值按一组二进制码来表示抽样脉冲的幅值。\nPCM格式\nPCM音频数据是未经压缩的音频采样数据裸流，是无法直接通过播放器进行播放的，因为pcm中只存储了音频采样数据裸流，采样频率、位深度、通道数等信息都没有进行存储，所以播放器不知道以什么方式来播放pcm数据。\n因此我们需要将pcm存储为wav格式或编码成其他音频格式进行存储及播放。\nPCM俗称无损编码，因为PCM代表了数字音频中最佳的保真水准，并不意味着PCM就能够确保信号绝对保真，PCM也只能做到最大程度的无限接近。\nPCM波形样本存储格式：\n\n下一步\n接下来让我们来了解下容器格式AAC-LC"},"C-Knowledge/前端/技术书籍/多媒体前端手册/PTS和DTS":{"title":"PTS和DTS","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/Web端H.265播放器研发解密"],"tags":["编程/FE/音视频"],"content":"DTS、PTS 的概念\nDTS、PTS 的概念如下所述：\n\nDTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\nPTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\n\n需要注意的是：虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。\n音画同步\n在一个媒体流中，除了视频以外，通常还有音频，音频也有 DTS、PTS 的概念，但是音频没有类似于视频中 B 帧，不需要双向预测，所以音频帧的 DTS、PTS 顺序是一致的。\n音频视频混合在一起播放，就呈现了我们常常看到的广义的视频。\n用户对于音画不同步的感知程度：\n\n如何同步音画同步\nPTS是实现 音画同步的关键。PTS从SPS中获取，事实上SPS中并没有直接关于PTS的值，是需要通过帧率计算的，前面我们了解到SPS中是可以获取 FPS 的数据，这里不展开叙述获取 PTS 的过程。\n要实现音视频同步，通常需要选择一个参考时钟，参考时钟上的时间是线性递增的，编码音视频流时依据参考时钟上的时间给每帧数据打上时间戳。在播放时，读取数据帧上的时间戳，同时参考当前参考时钟上的时间来安排播放。这里的说的时间戳就是我们前面说的 PTS。实践中，我们可以选择：同步视频到音频、同步音频到视频、同步音频和视频到外部时钟。\n总结\n关于解码的章节，你已经学习完毕了相信你对解码的整个过程有了一个初步的认知，实际上 NALU 中存储的信息十分复杂，手册也仅仅只是列举出重要的几项加以解析，如果想学习更多，欢迎和我们小组同学多多沟通。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/RTMP":{"title":"RTMP","links":[],"tags":["编程/FE/音视频"],"content":"\n简介\nRTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写，在合适的传输协议（如TCP）的基础上设计用于多路复用和包装多媒体传输流（如音频、视频和交互式内容）的应用层协议，主要用于Flash。\nRTMP协议有许多变种：\n\n默认使用TCP端口1935的纯粹（plain）协议。\nRTMPS，通过一个TLS/SSL连接传输RTMP。\nRTMPE，使用Adobe自有安全机制加密的RTMP。虽然实现的细节为专有，但该机制使用行业标准的密码学原函数。\nRTMPT，用HTTP封装以穿透防火墙。RTMPT通常在TCP通讯埠80和443上使用明文请求来绕过大多数的公司流量过滤。封装的会话中可能携带纯粹的RTMP、RTMPS或RTMPE数据包。\nRTMFP， 使用UDP而非TCP的RTMP，取代RTMP Chunk Stream。Adobe Systems开发了安全的实时媒体流协议套件，可以让最终用户直接地相互连接（P2P）。\n\n虽然RTMP的主要动机是成为一个播放Flash视频的协议，但它也用于其他一些应用程序，如Adobe LiveCycle Data Services ES。\n结构\n\n结构介绍可以参考此文章：cloud.tencent.com/developer/article/1038381\n英文不错的可以直接看wiki：en.wikipedia.org/wiki/Real-Time_Messaging_Protocol\n流程\n\n官方文档:wwwimages2.adobe.com/content/dam/acom/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf"},"C-Knowledge/前端/技术书籍/多媒体前端手册/RTP-and-RTCP-and-RTSP":{"title":"RTP&RTCP&RTSP","links":[],"tags":["编程/FE/音视频"],"content":"\n从上图可以看出的一些特点：\n\nRTP和RTCP都是基于UDP，且属于传输层协议，用作数据传输\nRTSP是基于TCP的，属于应用层协议\n\n以下为具体协议的详细介绍\nRTP\n实时传输协议（Real-time Transport Protocol或简写RTP）是一个网络传输协议，它是由IETF的多媒体传输工作小组1996年在RFC 1889中公布的，RTP协议详细说明了在互联网上传递音频和视频的标准数据包格式。它一开始被设计为一个多播协议，但后来被用在很多单播应用中。RTP协议常用于流媒体系统（配合RTSP协议），视频会议和一键通（Push to Talk）系统（配合H.323或SIP），使它成为IP电话产业的技术基础。RTP协议和RTP控制协议RTCP一起使用，而且它是创建在UDP协议上的。\nRTCP\n实时传输控制协议（Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP由RFC 3550定义（取代作废的RFC 1889）。RTP 使用一个 偶数 UDP port ；而RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。\nRTCP为RTP媒体流提供信道外（out-of-band）控制。RTCP本身并不传输数据，但和RTP一起协作将多媒体数据打包和发送。RTCP定期在流多媒体会话参加者之间传输控制数据。RTCP的主要功能是为RTP所提供的服务质量（Quality of Service）提供反馈。\nRTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等，网络应用程序即可利用RTCP的统计信息来控制传输的品质，比如当网络带宽高负载时限制信息流量或改用压缩比较小的编解码器。\nRTCP本身不提供数据加密或身份认证。SRTCP可以用于此类用途。\nRTSP\n实时流协议（Real Time Streaming Protocol，RTSP）是一种网络应用协议，专为娱乐和通信系统的使用，以控制流媒体服务器。该协议用于创建和控制终端之间的媒体会话。媒体服务器的客户端发布VCR命令，例如播放，录制和暂停，以便于实时控制从服务器到客户端（视频点播）或从客户端到服务器（语音录音）的媒体流。\n流数据本身的传输不是RTSP的任务。大多数RTSP服务器使用实时传输协议（RTP）和实时传输控制协议（RTCP）结合媒体流传输。然而，一些供应商实现专有传输协议。例如，RealNetworks公司的RTSP服务器软件也使用RealNetworks的专有实时数据传输（RDT）。\n虽然在某些方面与HTTP类似，RTSP定义了控制多媒体播放控制顺序。虽然HTTP是无状态的，但RTSP具有状态; 当需要跟踪并发会话时使用标识符。像HTTP一样，RTSP使用TCP来维护端到端连接，而大多数RTSP控制消息由客户端发送到服务器，一些命令沿着另一个方向（即从服务器到客户端）传播。\n图解区别\n网上找到一张图片很形象的解释了三者之间的关系\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/SEI":{"title":"SEI","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/PTS和DTS"],"tags":["编程/FE/音视频"],"content":"码流中有时不止图像信息，它可能“夹带私货”，其中可能就有SEI。\nSEI是什么\nSEI即补充增强信息(Supplemental Enhancement Information)。\nSEI的基本特征如下：\n1， 并非解码过程的必须选项\n2，可能对解码过程（容错、纠错）有帮助\n3，集成在视频码流中\n视频编码器在输出视频码流的时候，可以不提供SEI信息。在视频的传输过程、解封装、解码这些环节，都可能因为某种原因丢弃SEI内容，同时在视频内容的生成端和传输过程中，也是可以插入SEI信息的。这些插入的信息，和其他视频内容一同经过传输链路到达观看者端。\nSEI中可以添加参数信息：\n\n传递编码器参数\n传递视频版权信息\n传递摄像头参数\n传递内容生成过程中的剪辑事件（引发场景切换）\n…\n\nSEI在码流中的存储位置\nH.264/AVC\n针对NAL unit type，标准一共预留了32种类型，值为6时，表示SEI内容。\n附常见 H.264/AVC NAL unit type：\n\nH.265/HEVC\nH.265/HEVC 的 NAL unit type 标准共有64 种，其中39和40都表示 SEI 内容。\nSEI的用法示例\n以直播问答模式为例，通过SEI传递较多和答题业务相关的信息，并通过SEI承载的信息，优化题目显示和观众音视频观看的同步性。\n至此，SEI章节学习完毕，请学习下一章节 PTS和DTS。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/SPS和PPS":{"title":"SPS和PPS","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/视频播放-Seek-的基本原理","C-Knowledge/前端/技术书籍/多媒体前端手册/IBP帧","C-Knowledge/前端/职业规划/前端面试宝典/八股文/sps和pps的区别！"],"tags":["编程/FE/音视频"],"content":"学习了前面关于码流中的NAL，VAL的知识，相对于H.264中的解码应该也有了一些了解。也知道了解码实际上是通过解析NALU获取到对应需要的数据。那么 NALU 中究竟有什么？\n我们知道NALU是 NAL 层中传输数据的基本单位，里面包含了各式各样的数据，其中就有SPS 和 PPS。\nSPS( Sequence Paramater Set)\nSPS是什么\nSPS 即 Sequence Paramater Set，SPS中保存了一组编码视频序列（coded video sequence，即为原始视频的一帧一帧的数据经过编码之后的结构组成的序列）的全局参数。\n由此可见，SPS中的信息至关重要。如果其中的数据丢失或出现错误，解码过程很可能会失败。\nSPS在NALU类型\n在H.264标准协议中规定了多种不同的NAL Unit类型，其中type 7表示该NAL Unit内保存的数据为SPS。一般情况SPS的NAL Unit通常位于整个码流的起始位置。\nSPS包含的参数及作用\n参数包含了必要的配置解码器的信息，比如标识各档次的profile，标识当前码流的level，resolution，标识seq_parameter_set_id，代表为帧编码或场编码编码的标识frame_mbs_only_flag。\n具体了解可查看底部附件编码7.3.2.1章节。\n挑选几个重要的参数来说：\n\n\nprofile_idc，表明档次，基本分为三种\n\nbaseline profile（profile_idc = 66）\nmian profile（profile_idc = 77）\nextended profile（profile_idc = 88）\n\n\n\nprofile_idc的作用：规定了不同的编码方式，需要根据对应的profile对sps进行解码。\n\nlevel_idc，表明当前码流的Level\n\n主要作用：定义了在对应的Level_idc情况下，最大视频分辨率及帧率等参数。\n\nseq_parameter_set_id，\n\nPPS(Picture Paramater Set)\nPPS 是什么\nPPS 即 Picture Paramater Set。包含一幅图像所用的公共参数，即一幅图像中所有片段SS（Slice Segment）引用同一个PPS。\nPPS中存在一些与SPS中相同的参数，PPS中的这些数值将会覆盖SPS中他们的取值，即SS使用PPS中的这些参数进行解码。解码开始时，PPS全部处于非活动状态，当一幅图像解码时引用了某个PPS时，该PPS被激活，同一时刻只能有一个PPS被激活，直到该图像编码结束。\nPPS在MALU类型\n通常情况下，PPS在H.264的码流中单独保存在一个NALU中，NALU的NALU type为8；而在封装格式中，PPS通常与SPS一起，保存在码流的起始位置。\nPPS包含的参数机器作用\nPPS对应的是一个序列中某一幅图像或者某几幅图像，包括一个图像的slice的所有相关信息，如图像类型、序列号、标识符 pic_parameter_set_id、可选的 seq_parameter_set_id、熵编码模式选择标识、片组数目(slice groups)、初始量化参数和去方块滤波系数调整标识等等，解码时某些序列号的丢失可用来校验信息包的丢失与否。\n具体了解可查看底部附件中7.3.2.2章节\nSPS和PPS在码流中的图解\n正常情况下，在H.264码流中\n第一个 NALU 是 SPS\n第二个 NALU 是 PPS\n第三个 NALU 是 IDR（即时解码器刷新，其实就是第一个 I 帧，后续介绍 I 帧时会介绍）\n一般情况下，如下图所示：\n\n是不是清晰了许多\nSPS 与 PPS 后面跟随 IDR 帧(IDR 帧一般为视频开始解码的第一个帧)，SPS 为后续所有的 SS(Slice Segment)提供了公共参数。从图中同样可以看出 SPS 及 PPS 的重要性，事实上，SPS 与 PPS 中提供的公共参数，为整个解码流程提供了十分重要的数据比如(分辨率，图像序列等等)，如果一个码流中丢失了 SPS 及 PPS 参数信息，那么该码流中的 NALU 是无法被解码的。\n附件\n📎ITU-T H.264建议书.pdf\n下一章节将会带你学习关于 IBP帧的信息，了解真正的视频数据是以什么样的形式存在。\n\n\nsps和pps的区别！\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/STUN--and--TURN":{"title":"STUN & TURN","links":[],"tags":["编程/FE/音视频"],"content":"背景\nWebRTC中PeerConnect的第一步是建立连接，而互联网中的用户大多隐藏在各种防火墙之下，属于局域网或者明面上是广域网但实际还是大型局域网的范畴内（如中国移动宽带用户）。这时候就需要一种技术帮我们获悉真实的网络地址从而建立连接。\n简介\nNAT （Network Address Translation，网络地址转换）由于当前使用的IPV4地址的长度限制只有32位，大多数终端都没有一个可以在互联网上可见的唯一IPV4地址。NAT是作为一种解决IPv4地址短缺以避免保留IP地址困难的方案，在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址。\nSTUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。\nTURN（Traversal Using Relays around NAT，中继型NAT遍历服务），是一种数据传输协议（data-transfer protocol），用于转发数据包给对端浏览器，当2个对等端因为NAT类型而无法建立连接时(当遇到对称型NAT会导致打洞失败)。允许在TCP或UDP的连在线跨越NAT或防火墙。[注]\n简单的说，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。\n图解\n\n简介\nICE（Interactive Connectivity Establishment**，互动式连接建立），由 IETF 的 MMUSIC 工作组开发出来的，它所提供的是一种框架，使各种 NAT 穿透技术可以实现统一。ICE 跟 STUN 和 TURN 不一样，ICE 不是一种协议，而是一个框架（Framework），它整合了 STUN 和 TURN。\n\n如上图所示，如果A想与B通信，那么其过程如下：\n\nA收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；\nA向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；\nB向启动信息中的每一个地址发送一条STUN请求；\nA将第一条接收到的STUN请求的回复信息发送给B；\nB接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；\n利用列表中的排序列最高的地址进一步的设备间通信。\n\n由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。\n部分资料来源：www.52im.net/thread-557-1-1.html"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Security":{"title":"Security","links":[],"tags":["编程/FE/音视频","编程/WebRTC"],"content":"背景\n鉴于 Web 对于数据安全越来越重视，所以 WebRTC 中的数据传输环节肯定也少不了加密过程。本章将介绍对数据、媒体源、信令等进行加密的一些流程。\n名词解释\nSRTP（Secure Real-time Transport Protocol，安全实时传输协议）是在RTP（Real-time Transport Protocol，实时传输协议）基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。\nDTLS（Datagram Transport Layer Security，数据包传输层安全 ），是一种通信协议，提供数据包协议在传输层的发送安全。它依靠于传输层安全协议（TLS），能够提供与TLS同等级的安全保护。\n图解\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Signaling":{"title":"Signaling","links":[],"tags":["编程/FE/音视频","编程/WebRTC"],"content":"WebRTC 使用 RTCPeerConnection 在浏览器间传递数据流，需要一个服务器协调沟通并发送控制信息，这个过程被称为 Signaling。实际上 WebRTC 不关心你使用什么手段进行 Signaling，你可以选择任何你偏爱的手段。Signaling 过程主要交换以下信息：\n\n用于p2p的网络信息\n浏览器支持的媒体编码格式以及通信协议\n\n\n其中用于描述这些信息的协议格式叫SDP (Session Description Protocol)。一个典型的SDP结构如下：\nv=0\no=- 7614219274584779017 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\nm=audio 1 RTP/SAVPF 111 103 104 0 8 107 106 105 13 126\nc=IN IP4 0.0.0.0\na=rtcp:1 IN IP4 0.0.0.0\na=ice-ufrag:W2TGCZw2NZHuwlnf\na=ice-pwd:xdQEccP40E+P0L5qTyzDgfmW\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=mid:audio\na=rtcp-mux\na=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:9c1AHz27dZ9xPI91YNfSlI67/EMkjHHIHORiClQe\na=rtpmap:111 opus/48000/2\n...\n\nSDP一般不单独使用，而是配合RTP/RTSP等协议进行通信"},"C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8":{"title":"TS, M3U8","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/WebM"],"tags":["编程/FE/音视频"],"content":"简介\nHLS协议（可以先阅读HLS协议章节）包括两个重要的构建块。一种是视频文件的存储方式 (ts)，另一种是M3U8索引文件，每一个 .m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据，m3u8 文件存放了一些 ts 文件的配置信息和相关路径，当视频播放时，.m3u8 是动态改变的，video 标签会解析这个文件，并找到对应的 ts 文件来播放。一般为了加快速度，.m3u8 放在 web 服务器上，ts 文件放在 CDN 上。\nHLS 协议视频支持 H.264 格式的编码，支持的音频编码方式是 AAC 编码。\n从视频文件开始。HLS协议期望将视频文件存储在相等长度的较小块中，通常每个长度为10秒。\n最初，这些文件必须存储在TS文件（.ts）中，并以H.264格式编码，并带有AAC音频。\n\n上图表示了一个video中存在m3u8（一般不止一个）文件指向了多个.ts文件，一般来说每个 .ts 文件的长度约为10s，即上图中含有4个ts文件，所以视频长度为40s\n请注意，最新版本的HLS也允许使用片段化的.mp4文件。由于这仍然是新事物，并且某些视频播放器仍需要实现它，因此本文中的示例将使用.ts文件。\nM3U8文件\n简介\nm3u8 文件，就是以 UTF-8 编码的 m3u（最初创建为组织MP3文件集合的纯文本文件格式）文件，这个文件本身不能播放，只是存放了播放信息的文本文件。\n容器格式解析\nM3U8文件简版包含URL列表或带有一些其他元数据的本地文件路径。元数据行以＃开头。\n#EXTM3U                 m3u文件头\n#EXT-X-MEDIA-SEQUENCE   第一个TS分片的序列号\n#EXT-X-TARGETDURATION   每个分片TS的最大的时长\n#EXT-X-ALLOW-CACHE      是否允许cache\n#EXT-X-ENDLIST          m3u8文件结束符\n#EXTINF                 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效\nstream-1.ts\n\n在HLS 详细版的内容比上面的简版多了一个 playlist或称master。\n在 master 中，会根据网络段实现设置好不同的 m3u8 文件，比如，3G/4G/wifi 网速等。一个 master 文件中为：\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=3615600,CODECS=&quot;avc1.4d001f,mp4a.40.2&quot;,RESOLUTION=1280x720\nlive/high.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=5605600,CODECS=&quot;avc1.640028,mp4a.40.2&quot;,RESOLUTION=960x540\nlive/medium.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1755600,CODECS=&quot;avc1.42001f,mp4a.40.2&quot;,RESOLUTION=640x360\nlive/low.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=545600,CODECS=&quot;avc1.42001e,mp4a.40.2&quot;,RESOLUTION=416x234\nlive/cellular.m3u8\n\n所以说live/high.m3u8（wifi环境，高清）文件里的结构为：\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:26\n#EXTINF:9.901,\ntaobaolive.taobao.com/wifi/segment1.ts\n#EXTINF:9.901,\ntaobaolive.taobao.com/wifi/segment2.ts\n#EXTINF:9.501,\ntaobaolive.taobao.com/wifi/segment3.ts\n\nTS文件\n简介\nTS文件为传输流文件，在HLS协议中m3u8文件和ts文件，ts文件主要是存放视频的数据。\n容器格式解析\nTS文件分为三层:\n\nts层 (Transport Stream) 在pes层加入数据流的识别和传输必须的信息\npes层 (Packet Elemental Stream) 在音视频数据上加了时间戳等对数据帧的说明信息\nes层 (Elementary Stream) 音视频数据\n\nTS层\nts包大小固定为188字节，ts层分为三个部分\n\nts header：固定4个字节\nadaptation field：可能存在也可能不存在，主要作用是给不足188字节的数据做填充\npayload：pes数据\n\nts header\n\nts层的内容是通过PID值来标识的，主要内容包括：PAT表、PMT表、音频流、视频流。解析ts流要先找到PAT表，只要找到PAT就可以找到PMT，然后就可以找到音视频流了。\nPAT表的PID值固定为0。PAT表和PMT表需要定期插入ts流，因为用户随时可能加入ts流，这个间隔比较小，通常每隔几个视频帧就要加入PAT和PMT。\nPAT和PMT表是必须的，还可以加入其它表如SDT（业务描述表）等，不过hls流只要有PAT和PMT就可以播放了。\n\nPAT表：他主要的作用就是指明了PMT表的PID值。\nPMT表：他主要的作用就是指明了音视频流的PID值。\n音频流/视频流：承载音视频内容。\n\nadaption\n\n自适应区的长度要包含传输错误指示符标识的一个字节。\npcr是节目时钟参考，pcr、dts、pts都是对同一个系统时钟的采样值，pcr是递增的，因此可以将其设置为dts值，音频数据不需要pcr。如果没有字段，ipad是可以播放的，但vlc无法播放。打包ts流时PAT和PMT表是没有adaptation field的，不够的长度直接补0xff即可。\n视频流和音频流都需要加adaptation field，通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。\n\nPAT格式\n\nPMT 格式\n\nPES层\npes层是在每一个视频/音频帧上加入了时间戳等信息，pes包内容很多，我们只留下最常用的。\n\nPes Header 6B\nOptional Pes Header 3-259B\nPayload 最大65526B\n\n\nPTS是显示时间戳、DTS是解码时间戳。概念如下所述\n\n PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\nDTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\n\n为什么HLS延时相对较高？\nHLS 的延时包含了 TCP 握手、m3u8 文件下载与解析、ts 文件下载与解析等多个步骤\n可以缩短列表的长度和单个 ts 文件的大小来降低延迟，极致情况下可以缩减列表长度为 1，并且 ts 的时长为 1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲。\n苹果官方推荐的 ts 时长时 10s，所以这样就会大概有 30s 的延迟。\n下一步\n接下来让我们来了解下容器格式WebM"},"C-Knowledge/前端/技术书籍/多媒体前端手册/VP9":{"title":"VP9","links":[],"tags":["编程/FE/音视频"],"content":"简介\n\nVP9是WebM Project开发的下一代视频编码格式 。VP9支持从低比特率压缩到高质量超高清的所有Web和移动用例，并额外支持10/12位编码和HDR。\n与其他已知的编解码器相比，VP9可以将视频比特率降低多达50％。YouTube 以及其他领先的网络视频提供商均支持自适应流传输。\n超过20亿个端点支持VP9解码，包括Chrome，Opera，Edge，Firefox和Android设备以及数百万台智能电视。\nH265, VP9性能对比\n编码质量\n\n数值越小，编码质量越高，从编码质量上看出两者差异较小\n\n\n                  \n                  注意❗ \n                  \n                \n备注：x 265 是一个用于编码符合高效率视频编码（HEVC / H.265）标准的视频的开源自由软件及函数库。\n\n编码时间\n\nVP9在无论是4K还是1920、1208都完胜H.265\n下一步\n恭喜你～视频的章节已经到此结束了，接下来是音频的基础知识"},"C-Knowledge/前端/技术书籍/多媒体前端手册/WAV":{"title":"WAV","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/AIFF"],"tags":["编程/FE/音视频"],"content":"简介\n\nWAVE (Waveform Audio File Format)，是由微软和IBM公司共同开发的音频编码格式，广泛应用于Windows平台。又因为文件后缀名为.wav而被称为WAV。\n通常用来保存PCM格式的原始音频数据，所以通常被称为无损音频。但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。\n容器格式解析\n常见的wav容器格式\n\nWAV文件遵循RIFF规则，其内容以区块（chunk）为最小单位进行存储。\nWAV文件一般由3个区块组成：RIFF chunk、Format chunk和Data chunk。\nRIFF CHUNK\n\n\nSize是整个文件的长度减去ID和Size的长度\nType是WAVE表示后面需要两个子块：Format区块和Data区块\n\nFORMAT CHUNK\n\n\nSize表示区块数据的长度。\nAudioFormat表示Data区块存储的音频数据的格式。\nNumChannels表示音频数据的声道数，1：单声道，2：双声道\nSampleRate表示音频数据的采样率\nByteRate每秒数据字节数\nBlockAlign每个采样所需的字节数\nBitsPerSample每个采样存储的bit数\n\nDATA CHUNK\n\n\n以&#039;data&#039;为标识\nSize表示音频数据的长度，N = ByteRate * seconds\nData音频数据\n\n浏览器支持情况\n\n下一步\n接下来让我们来了解下容器格式AIFF"},"C-Knowledge/前端/技术书籍/多媒体前端手册/WebAssembly":{"title":"WebAssembly","links":["C-Knowledge/前端/开发技术/Node/Node.js"],"tags":["编程/FE/音视频"],"content":"WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式，是由主流浏览器厂商组成的 W3C 社区团体制定的一个新的规范。\nWebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行，它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C/C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。简而言之，WebAssembly 是一种二进制指令格式，运行在概念虚拟机之上：\n\n特性\n\n高效：WebAssembly 有一套完整的语义，实际上 wasm 是体积小且加载快的二进制格式， 其目标就是充分发挥硬件能力以达到原生执行效率\n安全：WebAssembly 运行在一个沙箱化的执行环境中，甚至可以在现有的 JavaScript 虚拟机中实现。在web环境中，WebAssembly将会严格遵守同源策略以及浏览器安全策略。\n开放：WebAssembly 设计了一个非常规整的文本格式用来、调试、测试、实验、优化、学习、教学或者编写程序。可以以这种文本格式在web页面上查看wasm模块的源码。\n标准：WebAssembly 在 web 中被设计成无版本、特性可测试、向后兼容的。WebAssembly 可以被 JavaScript 调用，进入 JavaScript 上下文，也可以像 Web API 一样调用浏览器的功能。当然，WebAssembly 不仅可以运行在浏览器上，也可以运行在非web环境下。\n\n起源\n起初，Mozilla 通过 asm.js 项目来提升浏览器运行 web 应用的性能，可以把 C/C++ 等语言编译为在浏览器端可被 JS 调用的格式，但随着 pthreads 和 SIMD 引入到 JS 中，Mozilla 联合 Microsoft、Google、Apple 等公司开发了 WebAssembly 来解决 asm.js 的局限性。\n对于网络平台而言，WebAssembly 具有巨大的意义，它提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在 Web 中运行。在这种情况下，以前无法以此方式运行的客户端软件都将可以运行在 Web 中。 而且，更棒的是，这是通过 W3C WebAssembly Community Group 开发的一项网络标准，并得到了来自各大主要浏览器厂商的积极参与。\n从最初面向浏览器提升前端 web 应用的性能，到开发者开始尝试在服务端运行 WebAssembly 程序，再到区块链、AI、动态插件等尝试，WebAssembly 受到的关注度越来越高，发展速度也越来越快。\n编译运行\n编译器通常用来把高级语言翻译到机器码，每一种目标汇编语言（x86、ARM）都依赖于特定的机器结构。而 WebAssembly 与其他的汇编语言不一样，它不依赖于具体的物理机器，它可以理解为概念机的汇编语言，正因为如此，WebAssembly 指令有时也被称为虚拟指令。\n     \n\n目前对于 WebAssembly 支持情况最好的编译器工具链是 LLVM，有很多不同的前端和后端插件可以用在 LLVM 上，Emscripten 是最常用的 C/C++ 编译成 wasm 的工具。\n\n在支持 wasm 的浏览器中可以在 javascript 中加载运行 wasm 文件：\nfunction fetchAndInstantiate(url, importObject) {\n  return fetch(url).then(response =&gt;\n    response.arrayBuffer()\n  ).then(bytes =&gt;\n    WebAssembly.instantiate(bytes, importObject)\n  ).then(results =&gt;\n    results.instance\n  );\n}\nWASI\nWebAssembly 是概念机的汇编语言，所以 WebAssembly 需要一个概念操作系统的系统接口，而不是任何单一操作系统的系统接口，这样它就可以在所有不同操作系统中运行，这就是 WASI——WebAssembly 平台的系统接口。\nWebAssembly 系统接口需要满足两大原则：可移植性和安全性。\n\n可移植性: POSIX 提供了源代码级的可移植性，相同源代码可以与不同版本 libc 一起编译生成适用于不同操作系统的产物。但是 WebAssembly 编译并不依赖操作系统，需要编译成可移植的二进制文件。例如，Node 的原生模块如果是用 WebAssembly 编写，那么用户安装原生模块应用时就不需要运行 node-gyp 重新编译了。\n安全性：当应用请求操作系统执行某些输入或输出时，操作系统需要确定该代码所请求的操作是否安全，操作系统通常使用基于所有权与组的访问控制来处理这个问题。WebAssembly 采用沙箱来保证安全性，应用无法直接访问操作系统。宿主机（浏览器或者其他 wasm 运行时）可以自定义沙箱系统能力，将应用在安全沙箱中执行。只是拥有沙箱机制并不会使系统本身变安全（宿主机仍然可以将所有能力都放入到沙箱中），不过它至少让宿主机能够选择创建更安全的系统。\n\n// wasi-demo\n(module\n    ;; Import the required fd_write WASI function which will write the given io vectors to stdout\n    ;; The function signature for fd_write is:\n    ;; (File Descriptor, *iovs, iovs_len, nwritten) -&gt; Returns number of bytes written\n    (import &quot;wasi_unstable&quot; &quot;fd_write&quot; (func $fd_write (param i32 i32 i32 i32) (result i32)))\n)\nWebAssembly 会将这些 WASI 函数作为 import 函数，然后由 runtime 提供这些函数对应的绑定。比如，在 Node.js 环境中，Node.js 在运行 Webassembly 前，需要适配这些 WASI 函数，提供对应的 JavaScript 函数绑定，调用 WASI 就是调用 runtime 提供的对应 WASI 函数适配。\nWASI 就是定义一堆标准系统操作标准 API，然后交由 Runtime 和 WebAssembly编译器去实现，在托管环境下我们可以对 WASI 进行裁剪，从而确保安全。\n近况\n\nWebAssembly 被 W3C 作为标准规范，HTML, CSS, JavaScript, WebAssembly将成为 Web 开发四剑客\n图形化应用开始向 WebAssembly转变，如 PhotoShop、AutoCAD、Google Earth、QT 等\nWebAssembly 逐渐也被应用到服务端后端，主要是隔离性、安全、性能高等特性，在 FaaS 场景上可以说是最佳匹配\nWASI 已经包含 Socket 支持，WebAssembly 可以像独立应用一样进行网络通讯\nNode.js 13.5.0 添加对 WASI 的支持\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/WebM":{"title":"WebM","links":["E-Day-planner/2024/四月/开源协议","C-Knowledge/前端/技术书籍/多媒体前端手册/OGV"],"tags":["编程/FE/音视频"],"content":"简介\n\nWebM是一种专为Web设计的开放，免版税的媒体文件格式。\nWebM定义文件容器结构，视频和音频格式。WebM文件包含使用VP8或VP9视频编解码器压缩的视频流和使用Vorbis或 Opus音频编解码器压缩的音频流。\nWebM 影片格式其实是以 Matroska（即 MKV）容器格式为基础开发的新容器格式，里面包括了VP8影片轨和 Ogg Vorbis 音轨。\n\n优势\n\n\n开放与创新\nWeb 成功的关键因素是它的核心技术（例如 HTML，HTTP 和 TCP / IP）可供任何人实施和改进。由于视频是 Web 体验的核心，因此需要高质量，开放的视频格式选择。WebM 是100％免费的，并根据 BSD-style 的 许可证开源。\n\n\n针对网络进行了优化\n在网络上提供视频服务不同于传统的广播和离线媒体。现有的视频格式旨在满足这些媒体的需求，并且做得很好。WebM 致力于满足在网络上提供视频的独特需求。\n\n\n低计算空间，可在任何设备上播放，包括低功耗上网本，手持设备，平板电脑等。\n\n\n简单的容器格式\n\n\n最高质量的实时视频交付\n\n\n单击并编码。最小的编解码器配置文件和子选项。如果可能，让编码器做出艰难的选择。\n\n\n官网：www.webmproject.org/\n下一步\n接下来让我们来了解下容器格式OGV"},"C-Knowledge/前端/技术书籍/多媒体前端手册/WebRTC-Web-API":{"title":"WebRTC Web API","links":[],"tags":["编程/FE/音视频","编程/WebRTC"],"content":"\nMediaStream (aka getUserMedia)\nRTCPeerConnection\nRTCDataChannel\n\nMediaStream\n特性\n\n表示一段包含了视频/音频的媒体流\n拥有多个媒体轨道\n可通过navigator.getUserMedia()获取\n\n图解\n\n代码示例\nnavigator\n  .mediaDevices\n  .getUserMedia({\n    audio: true,\n    video: true,\n  })\n  .then((stream) =&gt; {\n    videoEl.srcObject = stream\n  })\n  .catch((err) =&gt; console.error(err.message))\nRTCPeerConnection\n建立p2p连接管道，用作传输媒体数据\n特性\n\n信令处理\n编解码\np2p通信\n安全\n带宽管理\n…\n\n图解\n\n代码示例\npc = new RTCPeerConnection(null);\npc.ontrack = gotRemoteStream;\npc.addStream(localStream);\npc.createOffer(gotOffer);\n \nfunction gotOffer(desc) {\n  pc.setLocalDescription(desc);\n  sendOffer(desc);\n}\n \nfunction gotAnswer(desc) {\n  pc.setRemoteDescription(desc);\n}\n \nfunction gotRemoteStream(e) {\n  attachMediaStream(remoteVideo, e.streams[0);\n}\nRTCDataChannel\n可以让您在两个对等体之间打开一个通道，您可以通过该通道发送和接收任意数据。\n特性\n\n类似WebSockets\n超低延迟\n加密\n\n代码示例\nvar pc = new RTCPeerConnection();\n \npc.ondatachannel = function(event) {\n  receiveChannel = event.channel;\n  receiveChannel.onmessage = function(event){\n    document.querySelector(&quot;div#receive&quot;).innerHTML = event.data;\n  };\n};\n \nsendChannel = pc.createDataChannel(&quot;sendDataChannel&quot;, {reliable: false});\n \ndocument.querySelector(&quot;button#send&quot;).onclick = function (){\n  var data = document.querySelector(&quot;textarea#send&quot;).value;\n  sendChannel.send(data);\n};"},"C-Knowledge/前端/技术书籍/多媒体前端手册/WebXR":{"title":"WebXR","links":[],"tags":["编程/FE/音视频"],"content":"XR 是 Extended Reality (扩展现实) 的简写，包括了 VR (虚拟现实)，AR (增强现实)，MR (Mixed reality，混合现实)，WebXR 支持各种 XX 现实的设备。WebXR 允许开发人员创建在所有VR/AR设备都可运行的沉浸式内容，以实现基于 Web 的 VR/AR 体验。\nVR\n虚拟现实就是虚拟和现实相互结合。从理论上来讲，虚拟现实技术（VR）是一种可以创建和体验虚拟世界的计算机仿真系统，它利用计算机生成一种模拟环境，使用户沉浸到该环境中。虚拟现实技术就是利用现实生活中的数据，通过计算机技术产生的电子信号，将其与各种输出设备结合使其转化为能够让人们感受到的现象，这些现象可以是现实中真真切切的物体，也可以是我们肉眼所看不到的物质，通过三维模型表现出来。因为这些现象不是我们直接所能看到的，而是通过计算机技术模拟出来的现实中的世界，故称为虚拟现实。\nAR\n增强现实（Augmented Reality，简称AR），增强现实技术也被称为扩增现实，AR增强现实技术是促使真实世界信息和虚拟世界信息内容之间综合在一起的较新的技术内容，其将原本在现实世界的空间范围中比较难以进行体验的实体信息在电脑等科学技术的基础上，实施模拟仿真处理，叠加将虚拟信息内容在真实世界中加以有效应用，并且在这一过程中能够被人类感官所感知，从而实现超越现实的感官体验。真实环境和虚拟物体之间重叠之后，能够在同一个画面以及空间中同时存在。\nMR\n混合现实技术（MR）是虚拟现实技术的进一步发展，该技术通过在虚拟环境中引入现实场景信息，在虚拟世界、现实世界和用户之间搭起一个交互反馈的信息回路，以增强用户体验的真实感。\n混合现实是一组技术组合，不仅提供新的观看方法，还提供新的输入方法，而且所有方法相互结合，从而推动创新 。输入和输出的结合对中小型企业而言是关键的差异化优势。这样，混合现实就可以直接影响您的工作流程，帮助您和您的员工提高工作效率和创新能力。\nWebXR API\nWebXR API 将 WebVR API 扩展到包括混合现实的设备的更广泛的范围（AR / VR，沉浸式/手持式）。沉浸式 Web 社区希望使 Web 应用程序通过在一个 API 中支持所有混合现实设备，根据用户设备能力呈现出 AR，VR 或传统 2D 效果，实现渐进式体验。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/Web端H.265播放器研发解密":{"title":"Web端H.265播放器研发解密","links":["C-Knowledge/前端/技术书籍/JavaScript教程/video-标签谷歌实现原理"],"tags":["编程/FE/音视频"],"content":"音视频编解码对于前端工程师是一个比较少涉足的领域，涉及到流媒体技术中的文本、图形、图像、音频和视频多种理论知识的学习，才能够应用到具体实践中，我们自研web播放器并支持h.265解码，在码率优化的大背景下（保持画质不变情况下，应用图像增强、roi区域检测、智能场景分类和h265编解码等多种技术能力，将码流降低50%。达到减少带宽成本，提升视频服务QoE的目的），真正做到了h265解码播放的全域覆盖。本文主要分享了我们基于WebAssembly实现H.265格式的解封装、解码和播放。\n背景\nH.265又称HEVC(全称High Efficiency Video Coding，高效率视频编码)，是ITU-T H.264/MPEG-4 AVC标准的继任者。相比H.264，H.265拥有更高的压缩率，也就意味着同样码率（又称比特率是指每秒传送的比特(bit)数。单位为bps(Bit Per Second)，比特率越高，每秒传送数据就越多，画质就越清晰），H.265的画质会更清晰，更高的压缩率就能使用更低的存储和传输成本。\n\n\n带宽成本：在有限带宽下H.265能传输更高质量的网络视频，理论上，H.265最高只需H.264编码的一半带宽即可传输相同质量视频。更低的带宽可以更好的降低存储及传输成本，并为未来基于短视频及直播领域更多更复杂好玩的互动玩法做铺垫。\n\n\n转码成本：但是当前主流浏览器均不支持H.265原生视频播放，因此通常视频生产端需要针对浏览器做一次H.264视频的转码来适配浏览器端如PC场景的播放，而增加了转码成本。如在淘宝直播中，假设以每天5万场直播计算，每场直播转码成本20元，一天就是100万的转码成本。\n为此，我们团队对浏览器端H.265视频播放的可行性及兼容性进行了一次探索，为移动端及PC端全量H.265做准备，也对浏览器端视音频处理、WebAssembly实践进行一次深入的尝试。\n\n\nH.264 vs H.265\nH.264是当下用的最为广泛的视频编码格式，H.265标准围绕着现有的视频编码标准H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。H.265和H.264都是基于块的视频编码技术，主要的差别在于编码单元的大小以及一些编码算法细节，H.265将图像划分为“编码树单元(coding tree Unit, CTU)”，而不是像H.264那样的16×16的宏块。根据不同的编码设置，编码树单元的尺寸可以被设置为64×64或有限的32×32或16×16。一般来说区块尺寸越大，压缩效率就越好。具体的算法及相关细节这里不具体展开了，还有一些其他的压缩算法如因为H.265专利限制而生的开放编码格式如AV1等，读者可以参考其他相关文章。\n\n如下图，可以看到同样主观画面质量，H.265(500K)仅需H.264(800K)一半左右的带宽码率。\n\n浏览器现状\n如下图，因为H.265专利及硬解支持情况不完善的原因，主流现代浏览器均不兼容H.265编码的视频播放（Edge 新版本以插件方式支持），但是因为 Apple 对H.265的支持（这里作者认为这可能是一个很重要的标志，因为技术的发展很多时候不光是这个技术本身所决定的，而是很多因素共同作用的结果，商业也是其中很重要的一个因素），移动端 ios safari 在11.0版本以上支持原生播放。\n\n想要在浏览器端播放H.265视频原生的 &lt;video /&gt; 标签没有办法支持，但是因为视频格式本身是连续图像画面和音频的集合，参考了chromium的源码及video标签内部的实现原理，可以通过 &lt;canvas /&gt; + Web Audio API 的结合来模拟实现一个虚拟的video标签来实现播放器功能。\ndemo\n因为直播流时效性的缘故，发布了一个播放H.265 mp4视频（该视频地址直接在浏览器中播放只有声音而没有画面）的在线demo，读者可以有一个直观感受。\n地址：g.alicdn.com/videox/mp4-h265/1.0.2/index.html\n效果：\n\n前期调研\n播放器整体架构\n基于传统播放器的架构，我们设计的播放器架构如下：\n\n视音频基础\n因为前端领域对视频领域的涉及场景不多，一个 &lt;video /&gt; 标签就可以满足大部分场景，但是经历了这几年直播和短视频的爆发，视频的需求和功能也变得越来越复杂，开发之前阅读了很多视音频领域相关的书籍和文章，在此先对视音频基础进行一个简单的介绍。\n视频中我们通常说的视频的格式，比如 .mp4, .mov, .wmv, .m3u8, .flv 等等被称为 container。在一个视频文件中音频、视频数据是分开存储的，使用的压缩算法也不一样。其中container作为容器主要包含了video数据、audio数据、metadata（用于检索视音频payload格式等信息）。每个格式的封装格式不一样，比如FLV格式的基本单元是Tag，而MP4格式的基本单元是Box，辅助的meta信息用于检索找到对应的原始数据。\n而平时听到的H.264, H.265等视频编码标准被称为 codec (COmpress and DECompress )。一个视频格式比如mp4可以使用任何标准化的压缩算法，这些信息都会被包含在一个视频文件的meta信息中来告诉播放器该用什么编解码算法来播放。\n客户端播放器\n一个传统的客户端播放器播放一个视频流经过了如下各个环节：\n拉取数据 ⇒ 解封装 ⇒ 音视频解码 ⇒ 采样/像素数据发送到设备进行渲染。\n\n对于流媒体，播放器客户端通过拉流以数据源（音视频流）为中心，进行管道式的传输。在此期间，对视频流的读取，转换，分类，复制等一系列操作处理，以封装的 mp4流为例，需要对流进行解封装、解码、渲染等步骤：\n\n浏览器video标签\n在探究的过程中，为了了解主流浏览器不支持H.265视频播放的原因，以及浏览器端实现播放器原理的了解，通过对 Chromium 浏览器官方文档及 video 标签实现源码的阅读，整理了一个流程图。\n\n可以看到浏览器内部对视频流播放的实现，在经过了PipelineController等数据传输管道的处理后利用FFmpeg软解或者Gpu硬解之后交给视频设备及音频设备进行同步及渲染。其中H.265的视频因为硬解支持情况不完善，软解可能有性能风险，所以在chrome中被关闭了不支持，在chromium中可以通过参数打开。我们就依照这个思路，利用浏览器提供的接口来实现一个模拟的video标签。\n设计过程\n开发思路\n开发思路按照从简单到复杂的过程，对任务进行拆分，来完成H.265视频点播及直播等各个场景的覆盖，以mp4短视频出发完成播放流程，再覆盖直播场景，考虑如网络抖动、内存控制等复杂因素，再针对直播m3u8等回放文件进行播放并开发视频seek、倍速等功能。\nmp4播放⇒flv播放⇒hls播放⇒加入seek、倍速等功能\n可行性分析\n\n\n思路：在最开始进行可行性分析时，参考结合了已有工具videoconverter.js和libde265.js对H.265视频ffmpeg的编译提取了hevc文件及mp3音频文件在浏览器端进行了播放。\n\n\ndemo地址：sparkmorry.github.io/mse-learning/h265/\n\n\n表现：将720P 的 mp4视频进行视频和音频的分离，[[Canvas 怎么实现播放视频！|通过 &lt;canvas /&gt; 绘制图像，通过 &lt;audio /&gt; 标签播放音频]]，画面在 Macbook Pro 上 Chrome 浏览器下在23fps 左右。\n\n\n问题：\n\n不能达到解码性能标准: 720P的视频在Macbook Pro上仅在23fps左右，而原视频是25fps，不能达到解码性能标准，无法流畅播放。\n无法做到音画同步: 该方案因为直接提取了hevc裸流文件，无法获取视频和音频每帧的pts时间戳，无法做到严格的音画同步。\n\n\n\n解决方案：\n\n性能：因为libde265.js是asm.js，通过对libde265.js开源库的改造，打包WebAssembly测试性能情况\n音画同步：参考flv.js、hls.js等开源视频库的方案，根据曾经的实践经历，js在解封装方面的性能能够完成视频流文件解封装，获取每帧视频、音频播放的pts及原始数据交给解码器进行解码再渲染。\n\n\n\n方案调整：\n\n\n\nMP4点播流播放\n\n\n思路：根据上一过程调整的解决方案，通过js对mp4流进行解封装，因为音频解码的复杂度不高，也先用js进行解码，仅将视频解码模块用已有的三方模块libde265并替换为wasm解决性能问题，音视频解码模块都自身维护一段缓存区，负责存储解封装模块传过来的packet数据，解决音画同步的问题。\n\n\n表现：通过开源libde265实现的视频解码模块，针对于720p的视频流，平均解码时间是45ms，不能满足每一帧音频播放时间间隔（40ms）。\n\n\n问题：视频解码性能仍然不够。\n\n\n解决方案：\n\n\n丢帧：保证了音频同步，丢掉部分非参考帧，但损失了部分体验。所以提升解码性能和改善播放策略才能有可能满足当前方案的可行性。提升解码性能和改善播放策略。\n\n\n提升解码性能：用解码性能更好的ffmpeg替换掉libde265。\n\n\n改善播放流程：因为每个requestAnimationFrame循环任务都是同步的，边解码边播放。引入用WebWorker线程。通过改善视频解码模块，解码器内部开启循环解码，当外部的视频播放设备需要播放下一帧时，直接从解码器解码完的帧缓存中读取下一帧数据。实现了worker和主线程并行执行。\n\n\n方案调整：\n\n\ndemo地址：static-assets.cyt-rain.cn/h265/index.html\n\n\n设计流程\n\n\n\nFLV直播流播放\n\n\n思路：mp4视频流畅播放，但在直播场景（如FLV视频流）中，客户端需要和服务端建立长链接，不断接收流消息，借用FFmpeg本身对流媒体的支持，对视频数据进行解封装及解码。\n\n\n表现：无法编译FFmpeg网络库，TCP无法建立连接。\n\n\n问题：\n无法编译FFmpeg网络库：TCP建立连接创建Socket时报错，Emscripten工具无法编译TCP连接相关配置\ncodec不支持：FLV官方协议不支持H.265。\n\n\n解决方案：\n\n\n无法编译FFmpeg网络库：主线程利用fetch方法进行拉流，放到FFmpeg自定义缓冲区进行解封装及解码。因为直播流长时间播放需要不停的开辟、释放内存空间，采用环形的数据缓冲区。\n\n\nFLV官方协议不支持H.265：对FFmpeg及编码端对H.265进行扩展，因为FFmpeg内部数据结构嵌套较深，替换js解封装函数直接用FFmpeg的解封装函数。\n\n\n方案调整：\n\n\n设计流程\n\n\n\n当前方案\n播放流程\n\n\n\n因为FFmpeg支持多种格式解封装，只需要在在主线程中通过浏览器API（通常是fetch方法）拉取原始流数据并放到缓存中，等初始缓存到一个阈值时开启Worker进行解封装及解码；\n\n\n在子线程（Worker）中通过主线程fetch方法触发的数据回调接收数据存入环形缓冲区（内存环）中；\n\n\n子线程将读取到的音频帧输送到主线程中，通过Web Audio API缓存音频数据，根据已解码的视频帧缓存队列循环解码保证缓存中一直缓存10帧rgba图像数据；\n\n\n主线程中canvas根据音频播放回调的pts消费并渲染视频图像；\n\n\n循环以上操作直到fetch接口返回流已结束。\n\n\n解码器编译\n通过Emscripten工具可以把C语言编写的FFmpeg库编译成wasm并在浏览器中应用到视音频解码中。\n我们的视频解码场景和通常的播放器一样，通过依赖 FFmpeg 的通用接口来实现解封装和解码的工作。先通过 emscripten 编译 ffmpeg 库，再通过静态库的方式依赖到解封装和解码入口程序中。\n\n测试表现\n性能测试\n测试视频\n因为flv直播视频受时效性影响较大，拿720P高清的H.265 mp4视频作为稳定输入测试\n\n\n地址：gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4\n\n\n视频参数：\n\n\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from &#039;gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4#039;:\n  Metadata:\n    major_brand     : isom\n    minor_version   : 512\n    compatible_brands: isomiso2mp41\n    encoder         : www.aliyun.com - Media Transcoding\n  Duration: 00:01:00.10, start: 0.000000, bitrate: 907 kb/s\n    Stream #0:0(und): Video: hevc (Main) (hvc1 / 0x31637668), yuv420p(tv, bt709, progressive), 1280x720, 854 kb/s, 25 fps, 25 tbr, 12800 tbn, 25 tbc (default)\n    Metadata:\n      handler_name    : VideoHandler\n    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 48 kb/s (default)\n    Metadata:\n      handler_name    : SoundHandler\n\n测试机器\n\n\nlenovo ThinkPad T430\n\nCPU: Intel(R) Core(TM) i5-3230M CPU@2.60GHz  x64处理器\n内存: 8 GB\n系统: windows 10\n\n\n\nMacBook Pro (Retina, 15-inch, Mid 2015)\n\nCPU: 2.2 GHz Intel Core i7\n内存: 16 GB\n系统: macOS 10.14.2\n\n\n\n性能情况\n\nMBP下表现\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndecoder.wasm大小decoder.js大小平均每帧解码时长内存占用cpu占用1.4M168K26.79ms27M17～25%\n\n针对两个pc笔记本进行了测试，平均每帧解码（包含yuv420转rgba）时长在各个浏览器的表现情况如下：\n注：此处Native（原生）表示针对mac系统原生编译的FFmpeg作为依赖的解码器（相对不考虑具体如x86、arm等计算机架构的WebAssembly的跨平台方案而言）。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n设备ChromeSafariFireFoxEdgeNativeMacOS(i7)26.79ms22.19ms24.77ms-5.08mswindows(i5)33.51ms-36.74ms86.72ms未测试\n意味着最高能提供720P高清视频如下帧率视频流畅播放的能力：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n设备ChromeSafariFireFoxEdge视频基准NativeMacOS(i7)37fps45fps40fps-25fps196fpswindows(i5)30fps-27fps12fps25fps未测试\n可以看到这两台机器中，在非高速运动等普通的如电商场景25fps帧率的高清720p视频已经能达到生产环境的标准，但是距离原生的速度还有一定距离。\n浏览器兼容性\n主要用到了WebAssembly及WebWorker的支持，实际测试中主流浏览器Chrome、Safari、Firefox、Edge均能通过兼容性测试。\n\nWebAssembly\n\n\n\nWebWorker\n\n\nTODO\n当前的技术方案已经能在大部分机器的主流浏览器上流畅的播放720P的高清直播流，但是在Edge浏览器及性能稍差的机器上还是存在高清视频解码性能不能满足流畅播放的风险，针对WebAssembly达到native速度的目标还有一定距离，尤其是汇编并行计算的支持，在视音频及大规模数据处理中是很常见的性能优化策略，作者整理了几个优化的方向，在未来还有更多探索的空间：\n\n\n汇编\nFFmpeg中解码有较多利用汇编进行并行计算的优化，但是汇编指令是cpu specific的（比如x86指令和arm指令），而wasm是跨平台的基于栈的虚拟机。Emscripten不支持汇编的编译，考虑用clang等llvm前端将FFmpeg的.c和汇编.asm文件编译成LLVM IR（LLVM Intermediate Representation），然后通过fastcomp或者其他后端来编译测试。\n\n\n硬解\nFFmpeg3.3以上开始支持自动硬解探测，支持的硬件设备根据不同操作系统及硬件会有不同的支持，具体参考：trac.ffmpeg.org/wiki/HWAccelIntro 。因为wasm是跨平台的虚拟指令集，支持程度还要待进一步探究。\n\n\n多线程\nFFmpeg内部解码有多线程来提高解码性能，通过pthread可以支持跨平台的多线程支持的，但是如果不支持共享内存，则线程之间的数据传输会有很多性能消耗（深拷贝或者Transfered Object）。浏览器端共享内存通过SharedArrayBuffer来实现，因为有安全隐患，大部分主流浏览器关闭了SharedArrayBuffer、Chrome67+开始恢复。考虑到兼容性多线程的支持还要再进行尝试。\n\n\nWebGL渲染\n解码平均时长中有4ms左右(15%)在yuv转rgba上，通过WebGL可以用gpu加速图像的计算，但是同时与WebGL的数据交换又会产生一定的性能损耗，需要再测试查看性能结果\n\n\n未来展望\n通过H.265视频播放将开源视音频库FFmpeg的能力及WebAssembly性能的优势在浏览器端视音频处理上有了一次深入的尝试。视频作为一种多媒体形式，相比现有的文字、图像、音频都能有更生动及更丰富信息的表现。尤其经过了直播和短视频的爆发增长后，成为了一种基础的多媒体形式，也是网络及移动端手机性能等技术发展的体现。未来随着5G及更高性能的硬件设备的发展会被更广泛的应用到各个领域。浏览器在这场视频革命中也是不可或缺的一个环节，通过这次的探索，为未来浏览器端扩展视音频处理的通用能力提供了想象的空间，同时也在浏览器端通过WebAssembly向native性能及能力靠近的路上做了一个落地的尝试，虽然从测试情况看现在的表现还不如native，但是随着标准及技术的演进，为未来对性能要求比较高的图形图像及人工智能等相关方向在浏览器端处理一定会渐渐被广泛的应用起来，比如如下几个方向：\n\n\n扩展浏览器端视频播放能力\n借助FFmpeg强大的编解码能力，除了H.265视频的播放，未来还可以在浏览器端兼容各种格式及编码类型的视频播放。如不同的编码格式AV1、不同的容器格式mov格式等等。\n\n\n扩展浏览器端视音频处理能力\n借助FFmpeg及其他语言框架的现有能力，还可以在视音频领域做更多复杂的操作如视频滤镜、视频剪切、视频格式转换等功能，减少网络传输及存储的成本。\n\n\n基于WebAssembly的高性能web应用\n借助WebAssembly的跨平台优势，可以将传统的其他语言的开源框架如图形相关开源库OpenGL、SDL等的能力移植到浏览器上来。借助性能上的优势也可以将传统的图像、3D等运算能力要求较高的应用扩展到浏览器端。\n\n\n参考\n\n\nChromium媒体元素源码: github.com/chromium/chromium/tree/master/media\n\n\nWebAssembly: webassembly.org/\n\n\n优秀的开源视音频处理框架FFmpeg: www.ffmpeg.org/\n\n\n基于LLVM编译的WebAssembly打包工具集Emscripten：emscripten.org/index.html\n\n\n基于WebAssembly的ogg播放器：github.com/brion/ogv.js\n\n\n基于FFmpeg的简单播放器：github.com/leixiaohua1020/simplest_ffmpeg_player\n\n\n后言\n本文介绍了我们在Web端H.265播放器上研发的过程和进展，后续还有很多继续优化和深入的点。对相关知识感兴趣的同学欢迎沟通交流，附上我们前端团队的介绍：\n淘宝技术部内容与开放平台前端团队是淘系核心的商业变革阵地，相对于横向资源前端团队，我们更深入在内容电商、音视频技术领域，探寻创新商业模式及业界领先技术。\n本团队目前正火热招聘20届优秀毕业生，欢迎有志之士加入！\n有意向者可直接联系团队负责人： 灵玉 lingyu.csh@taobao.com"},"C-Knowledge/前端/技术书籍/多媒体前端手册/flv.js":{"title":"flv.js","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/HTTP-FLV","C-Knowledge/前端/技术书籍/多媒体前端手册/解封装(demux)"],"tags":["编程/FE/音视频"],"content":"概述\nflv.js是Bilibili网站开源的HTML5 flv播放器，基于HTTP-FLV流媒体协议，通过纯js实现FLV转封装，使flv格式文件能在web上进行播放。\n但是flv.js也不是所有的flv格式视频都能播放，并且对浏览器环境也有一定的要求，以下是flv.js的使用限制:\n\n视频必须是AVC（H.264） 编码，音频必须为 AAC 或者 MP3编码\n浏览器环境必须支持MSE，查看支持列表：caniuse.com/#feat=mediasource，值得注意的是，ie浏览器中，ie11以上才能正常使用，而ie11浏览器必须在win8系统以上才能运行；移动端上，ios仅支持在iPadOS 13以上系统，ios手机端完全不可运行；android则要求4.4以上系统\n浏览器必须支持video，fetch api、xhr和websocket支持其一便可\n\n原理概述\n\n\nIOController由fetch api、xhr或者websocket构成，负责流式从服务端读取flv格式文件内容，并且以片段的方式传送到Demuxer中\nDemuxer接收到flv格式流媒体内容，根据flv协议进行格式拆分，分化出视频流、音频流，更多flv协议内容参考本手册HTTP-FLV\nRemuxer接收视频流、音频流，按照mp4格式要求进行合流，这个过程被称为remuxer\nMSEController收到remuxer后的流，将流内容源源不断通过mediaSource生成的blob地址输出给video标签进行播放\n\n使用指南\n官方GitHub：github.com/bilibili/flv.js\n快速开始：\n&lt;script src=&quot;flv.min.js&quot;&gt;&lt;/script&gt;\n&lt;video id=&quot;videoElement&quot;&gt;&lt;/video&gt;\n&lt;script&gt;\n    if (flvjs.isSupported()) {\n        var videoElement = document.getElementById(&#039;videoElement&#039;);\n        var flvPlayer = flvjs.createPlayer({\n            type: &#039;flv&#039;,\n            url: &#039;example.com/flv/video.flv&#039;\n        });\n        flvPlayer.attachMediaElement(videoElement);\n        flvPlayer.load();\n        flvPlayer.play();\n    }\n&lt;/script&gt;\n详细API：github.com/bilibili/flv.js/blob/master/docs/api.md\n源码解读\n文件结构\n\nsrc——源码目录\ncore/——负责转封装核心控制\n\nfeatures.js——转封装mp4编码支持、网络环境支持\nmedia-info.js——获取保存在scripts tags data里视频流的基础信息，如时长、宽高、fps、是否有音轨等\nmedia-segment-info.js——自定义的媒体片段字段封装类\nmse-controller.js——控制播放和mse的模块\nmse-events.js——基于mse封装的自定义事件\ntransmuxer.js——转封装连接模块，位于主线程中，负责于worker中的transmuxer-worker进行调度控制通信\ntransmuxer-controller.js——转封装主控制逻辑\ntransmuxer-events.js——转封装事件\ntransmuxer-worker.js——运行在WebWorker中，将transmuxer-controller.js的调用/返回转化成postMessage指令与主线程（transmuxer.js）进行通信\n\n\ndemux/——负责flv协议解封装\nio/——网络库相关\nplayer/——播放控制\nremux/——mp4转封装逻辑\nutils/——工具函数库\nconfig.js——配置文件\nflv.js——主入口，整合各个模块，被index.js直接引用\nindex.js——入口文件\n\n框架结构\n\n调用分析\n1、创建部分\n\n\n调用createPlayer，会初始化FlvPlayer，返回FlvPlayer的实例\n挂载video标签，通过调用attachElment接口去完成，此时MSEController被初始化\n调用load接口开始拉流，依次初始化Transmuxer、TransmuxingWorker、TransmuxingController、IOController，其中TransmuxingWorker和TransmuxingController运行在worker里，具体代码（transmuxer.js#L33）：\n\nif (config.enableWorker &amp;&amp; typeof (Worker) !== &#039;undefined&#039;) {\n  try {\n    let work = require(&#039;webworkify&#039;);\n    this._worker = work(TransmuxingWorker);\n    ...\n  } catch (error) {\n    Log.e(this.TAG, &#039;Error while initialize transmuxing worker, fallback to inline transmuxing&#039;);\n    this._worker = null;\n    this._controller = new TransmuxingController(mediaDataSource, config);\n  }\n} else {\n  this._controller = new TransmuxingController(mediaDataSource, config);\n}\n\n并且，创建IOController时，根据当前环境支持情况选择使用Fetch loader或者是XHR loader（io-controller.js#L239）：\n\n_selectLoader() {\n    if (this._config.customLoader != null) {\n        this._loaderClass = this._config.customLoader;\n    } else if (this._isWebSocketURL) {\n        this._loaderClass = WebSocketLoader;\n    } else if (FetchStreamLoader.isSupported()) {\n        this._loaderClass = FetchStreamLoader;\n    } else if (MozChunkedLoader.isSupported()) {\n        this._loaderClass = MozChunkedLoader;\n    } else if (RangeLoader.isSupported()) {\n        this._loaderClass = RangeLoader;\n    } else {\n        throw new RuntimeException(&#039;Your browser doesn\\&#039;t support xhr with arraybuffer responseType!&#039;);\n    }\n}\n\n创建loader（io-controller.js#L255）：\n\n_createLoader() {\n  this._loader = new this._loaderClass(this._seekHandler, this._config);\n  ...\n}\n2、网络部分\nloader的开始拉流时，会向服务器发送一个http请求，此时http为下载模式长连接，会以二进制的方式将flv格式媒体内容返回给浏览器，浏览器去实现loader的时候，需要做一些差异化处理：\n\nfetch方式，通过response对象里的body，获取ReadableStream对象进行流读取（fetch-stream-loader.js#L121）：\n\nself.fetch(seekConfig.url, params).then((res) =&gt; {\n    if (this._requestAbort) {\n        this._requestAbort = false;\n        this._status = LoaderStatus.kIdle;\n        return;\n    }\n    if (res.ok &amp;&amp; (res.status &gt;= 200 &amp;&amp; res.status &lt;= 299)) {\n        ...\n        return this._pump.call(this, res.body.getReader());\n    } else {\n        ...\n    }\n})\n\nXHR方式，主要通过ajax的方式获取流数据，在标准、moz、ms上实现各有差异，差异点在responseType的设置，以及接收方式上，差异如下：\n\n标准：responseType=arraybuffer，load事件接收流数据\nmoz：responseType=moz-chunked-arraybuffer，类似arraybuffer，但是接收方式需要通过progress事件接收，而且仅包含第一次progress事件之后的事件\nms：responseType=ms-stream，同样在progress事件中获取流数据，并且仅支持下载请求，在ie浏览器中支持\n\n\n\n3、解封装（demux）部分\n解封装的概念便是将特定格式的视频流进行拆分，拆分出视频数据、音频数据、附加数据，以便进一步的进行格式处理或者编解码处理，更多概念参考本手册的解封装(demux)\n\nTransmuxing-controller.js首先将flv-demuxer.js与io-controller.js进行绑定，让flv-demuxer.js可以源源不断接收流数据（transmuxing-controller.js#L235）：\n\n_loadSegment(segmentIndex, optionalFrom) {\n  this._currentSegmentIndex = segmentIndex;\n  let dataSource = this._mediaDataSource.segments[segmentIndex];\n \n  let ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n  \n  ...\n \n  if (optionalFrom) {\n    this._demuxer.bindDataSource(this._ioctl);\n  } else {\n    ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n  }\n \n  ioctl.open(optionalFrom);\n}\n\n此时，flv-demuxer.js根据协议逻辑，不断执行parseChunks（flv-demuxer.js#L159）\n\nbindDataSource(loader) {\n  loader.onDataArrival = this.parseChunks.bind(this);\n  return this;\n}\n\nparseChunks方法里主要包含了flv文件格式协议的解析内容，如拆分FLV header、FLV body，并且对audio tags、video tags、script data tags进行解析，最后挂载到this._audioTrack、this._videoTrack上，这里不对FLV文件格式协议进行展开，感兴趣的可以阅读本手册http-flv\ndemuxer完成后，remuxer如何获取解封装过的this._videoTrack和this._audioTrack呢，答案在flv-demuxer.js里，flv-demuxer.js在首次初始化的时候，还会对mp4-remuxer.js进行绑定（transmuxing-controller.js#L235）：\n\n_onInitChunkArrival(data, byteStart) {\n  let probeData = null;\n  let consumed = 0;\n \n  if (byteStart &gt; 0) {\n    // IOController seeked immediately after opened, byteStart &gt; 0 callback may received\n    ...\n    this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl));\n    ...\n  } else {\n    ...  \n  }\n \n  return consumed;\n}\n\nbindDataSource的具体实现（mp4-remuxer.js#L83）：\n\nbindDataSource(producer) {\n  producer.onDataAvailable = this.remux.bind(this);\n  producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n  return this;\n}\n\nflv-deumxer触发onDataAvailable时，自动执行mp4-remuxer里的remux接口，将videoTrack和audioTrack数据提取出来，按照mp4格式进行封装。\n\n4、复用（remux）部分\n了解复用之前，我们需要简单了解一下mp4的文件格式：\n- ftype 不是捷豹的跑车ftype，这个字段用于确定文件的类型，包括32位的 major_brand，一个32位的 minor_version 和一个以32位为单位的 compatible_brands，用来指示文件应用级别信息\n- moov 涵盖了movie header（mvhd）和多个trak，主要保存了媒体的时间信息、trak信息和媒体索引等\n\t- mvhd\n\t- trak\n\t- trak\n\t...\n- mdat 媒体的主要内容\n- free 不重要，有没有都行\n好了，更多的mp4格式内容欢迎了解本手册的mp4格式，这里不作展开，而remux的过程，分为两步：\n\n第一步，构造mp4格式文件\nvideoRemux过程，提取出Flv video tag里的data内容，获取NALU大小、NALU内容，构造到mp4里的mdat、moof中（mp4-remuxer.js#L538）：\n\n_remuxVideo() {\n  ... \n  // allocate mdatbox\n  mdatbox = new Uint8Array(mdatBytes);\n  mdatbox[0] = (mdatBytes &gt;&gt;&gt; 24) &amp; 0xFF;\n  mdatbox[1] = (mdatBytes &gt;&gt;&gt; 16) &amp; 0xFF;\n  mdatbox[2] = (mdatBytes &gt;&gt;&gt;  8) &amp; 0xFF;\n  mdatbox[3] = (mdatBytes) &amp; 0xFF;\n  mdatbox.set(MP4.types.mdat, 4);\n  // Write samples into mdatbox\n  for (let i = 0; i &lt; mp4Samples.length; i++) {\n    let units = mp4Samples[i].units;\n    while (units.length) {\n      let unit = units.shift();\n      let data = unit.data;\n      mdatbox.set(data, offset);\n      offset += data.byteLength;\n    }\n  }\n  ...\n  track.samples = mp4Samples;\n  track.sequenceNumber++;\n \n  // workaround for chrome &lt; 50: force first sample as a random access point\n  // see bugs.chromium.org/p/chromium/issues/detail\n  if (this._forceFirstIDR) {\n    let flags = mp4Samples[0].flags;\n    flags.dependsOn = 2;\n    flags.isNonSync = 0;\n  }\n \n  let moofbox = MP4.moof(track, firstDts);\n  ...\n}\n调用了remux方法的同时，还会触发onTrackMetadata回调，将获取到的scripts data tags里的meta data，构造出由ftype、moov构成的metabox\n_onTrackMetadataReceived(type, metadata) {\n    let metabox = null;\n \n    let container = &#039;mp4&#039;;\n    let codec = metadata.codec;\n \n    if (type === &#039;audio&#039;) {\n        ...\n    } else if (type === &#039;video&#039;) {\n        this._videoMeta = metadata;\n        metabox = MP4.generateInitSegment(metadata);\n    } else {\n        return;\n    }\n \n    // dispatch metabox (Initialization Segment)\n    if (!this._onInitSegment) {\n        throw new IllegalStateException(&#039;MP4Remuxer: onInitSegment callback must be specified!&#039;);\n    }\n    this._onInitSegment(type, {\n        type: type,\n        data: metabox.buffer,\n        codec: codec,\n        container: `${type}/${container}`,\n        mediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\n    });\n}\n\n\naudioRemux过程和videoRemux过程类似\n\n\n第二步，append媒体流\n\n\n可以看到，每次remux结束后，mp4-remuxer.js都会发送TransmuxingEvents.MEDIA_SEGMENT事件，而接收处则为flv-player.js#L214，转而调用mse-controller.js的appendMediaSegment方法，最后调用mse的appendSource方法，将mp4数据进行输入\nthis._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) =&gt; {\n  this._msectl.appendMediaSegment(ms);\n \n  // lazyLoad check\n  if (this._config.lazyLoad &amp;&amp; !this._config.isLive) {\n    let currentTime = this._mediaElement.currentTime;\n    if (ms.info.endDts &gt;= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\n      if (this._progressChecker == null) {\n        Log.v(this.TAG, &#039;Maximum buffering duration exceeded, suspend transmuxing task&#039;);\n        this._suspendTransmuxer();\n      }\n    }\n  }\n});\n这里值得注意的是，appendSource 的 mp4内容，有时候是 video 类型的，有时候是 audio 类型的，flv.js 并没有让 video 自行处理 mp4的音画同步，而是自行在 remux 过程中进行了 pts 的对齐，最终实现音画同步\n扩展阅读\n\nflv.js核心思路解读\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/hls.js":{"title":"hls.js","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8","C-Knowledge/前端/技术书籍/多媒体前端手册/Hls.js-加载-m3u8主流程源码解析"],"tags":["编程/FE/音视频"],"content":"概述\nhls.js 是基于Http Live Stream 协议开发，利用 Media Source Extension，用于实现 HLS 在 web 上播放的一款js 播放库。\n由于HLS协议由苹果提出，并且在移动端设备上广泛支持，因此可以被广泛应用与直播场景。而hls.js在pc端只需要支持mse便可以应用，移动端使用原生video标签设置src便可完成播放，因此hls.js的支持环境是：\n\nChrome for Android 34+\nChrome for Desktop 34+\nFirefox for Android 41+\nFirefox for Desktop 42+\nIE11+ for Windows 8.1+\nEdge for Windows 10+\nOpera for Desktop\nVivaldi for Desktop\nSafari for Mac 8+ (beta)\n\n\n原理概述\n\n\nhls.js会先通过loader去拉取.m3u8文件，通过文本正则匹配获取子m3u8文件或者ts地址\n获取到ts地址后，然后再进行二进制读取，将ts格式中的视频流、音频流进行分流（demuxing）\n分流后封装成mp4格式设置到Media Source Extension，最后通过挂载到video标签进行播放\n\n更多ts,m3u8格式参考本手册TS, M3U8\n使用指南\n官方GitHub：github.com/video-dev/hls.js/\n快速开始：\n&lt;script src=&quot;cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;\n&lt;!-- Or if you want a more recent canary version --&gt;\n&lt;!-- &lt;script src=&quot;cdn.jsdelivr.net/npm/hls.js@canary&quot;&gt;&lt;/script&gt; --&gt;\n&lt;video id=&quot;video&quot;&gt;&lt;/video&gt;\n&lt;script&gt;\n  var video = document.getElementById(&#039;video&#039;);\n  if(Hls.isSupported()) {\n    var hls = new Hls();\n    hls.loadSource(&#039;video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8&#039;);\n    hls.attachMedia(video);\n    hls.on(Hls.Events.MANIFEST_PARSED,function() {\n      video.play();\n  });\n }\n // hls.js is not supported on platforms that do not have Media Source Extensions (MSE) enabled.\n // When the browser has built-in HLS support (check using `canPlayType`), we can provide an HLS manifest (i.e. .m3u8 URL) directly to the video element through the `src` property.\n // This is using the built-in support of the plain video element, without using hls.js.\n // Note: it would be more normal to wait on the &#039;canplay&#039; event below however on Safari (where you are most likely to find built-in HLS support) the video.src URL must be on the user-driven\n // white-list before a &#039;canplay&#039; event will be emitted; the last video event that can be reliably listened-for when the URL is not on the white-list is &#039;loadedmetadata&#039;.\n  else if (video.canPlayType(&#039;application/vnd.apple.mpegurl&#039;)) {\n    video.src = &#039;video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8&#039;;\n    video.addEventListener(&#039;loadedmetadata&#039;,function() {\n      video.play();\n    });\n  }\n&lt;/script&gt;\n详细 api：github.com/video-dev/hls.js/blob/master/docs/API.md\n扩展阅读\n\nHls.js 加载 m3u8主流程源码解析\nhls.js 源码解读【1】\nhls.js 源码解读【2】\nhls.js 源码解读【3】\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/mediaElement.js":{"title":"mediaElement.js","links":[],"tags":["编程/FE/音视频"],"content":""},"C-Knowledge/前端/技术书籍/多媒体前端手册/video.js":{"title":"video.js","links":[],"tags":["编程/FE/音视频"],"content":"概述\nvideo.js是一款基于html5的播放器，同时支持h5和flash播放，并且拥有超过100个插件可进行使用，可满足hls、dash格式播放，支持定制主题，字幕扩展等不同层次的诉求，在世界范围拥有大量的应用场景。\n\n使用指南\n官方GitHub：github.com/videojs/video.js\n官方文档：videojs.com/\n快速开始：\n引入资源文件\n&lt;link href=&quot;//vjs.zencdn.net/7.3.0/video-js.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;script src=&quot;//vjs.zencdn.net/7.3.0/video.min.js&quot;&gt;&lt;/script&gt;\n增加video节点\n&lt;video\n    id=&quot;my-player&quot;\n    class=&quot;video-js&quot;\n    controls\n    preload=&quot;auto&quot;\n    poster=&quot;//vjs.zencdn.net/v/oceans.png&quot;\n    data-setup=&#039;{}&#039;&gt;\n  &lt;source src=&quot;//vjs.zencdn.net/v/oceans.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/source&gt;\n  &lt;source src=&quot;//vjs.zencdn.net/v/oceans.webm&quot; type=&quot;video/webm&quot;&gt;&lt;/source&gt;\n  &lt;source src=&quot;//vjs.zencdn.net/v/oceans.ogv&quot; type=&quot;video/ogg&quot;&gt;&lt;/source&gt;\n  &lt;p class=&quot;vjs-no-js&quot;&gt;\n    To view this video please enable JavaScript, and consider upgrading to a\n    web browser that\n    &lt;a href=&quot;videojs.com/html5-video-support/&quot; target=&quot;_blank&quot;&gt;\n      supports HTML5 video\n    &lt;/a&gt;\n  &lt;/p&gt;\n&lt;/video&gt;\n初始化播放器\nvar options = {};\n \nvar player = videojs(&#039;my-player&#039;, options, function onPlayerReady() {\n  videojs.log(&#039;Your player is ready!&#039;);\n \n  // In this context, `this` is the player that was created by Video.js.\n  this.play();\n \n  // How about an event listener?\n  this.on(&#039;ended&#039;, function() {\n    videojs.log(&#039;Awww...over so soon?!&#039;);\n  });\n});\n详细api：docs.videojs.com/"},"C-Knowledge/前端/技术书籍/多媒体前端手册/下载文件":{"title":"下载文件","links":[],"tags":["编程/JavaScript/DOM"],"content":"/**\n * 下载文件\n * @param {String} path - 请求的地址\n * @param {String} fileName - 文件名\n */\nfunction downloadFile (downloadUrl, fileName) {\n    // 创建表单\n    const formObj = document.createElement(&#039;form&#039;);\n    formObj.action = downloadUrl;\n    formObj.method = &#039;get&#039;;\n    formObj.style.display = &#039;none&#039;;\n    // 创建input，主要是起传参作用\n    const formItem = document.createElement(&#039;input&#039;);\n    formItem.value = fileName; // 传参的值\n    formItem.name = &#039;fileName&#039;; // 传参的字段名\n    // 插入到网页中\n    formObj.appendChild(formItem);\n    document.body.appendChild(formObj);\n    formObj.submit(); // 发送请求\n    document.body.removeChild(formObj); // 发送完清除掉\n}\n/**\n * 下载文件\n * @param {*} url\n * @param {*} fileName\n */\nexport const download = (url, fileName = url) =&gt; {\n  const a = document.createElement(&quot;a&quot;);\n  a.download = fileName;\n  a.href = url;\n  a.target = &quot;_blank&quot;;\n  a.style.display = &quot;none&quot;;\n  document.body.appendChild(a);\n  a.click();\n};"},"C-Knowledge/前端/技术书籍/多媒体前端手册/关于视频你需要知道的基本概念：码率（Bitrate）、帧率（FPS）、分辨率和清晰度":{"title":"关于视频你需要知道的基本概念：码率（Bitrate）、帧率（FPS）、分辨率和清晰度","links":[],"tags":["编程/FE/音视频"],"content":"前言\n想通过一篇文章的科普，让你在使用视频的时候知道如何选择合适的视频参数。\n\n一般涉及到的视频参数就是：封装格式、编码格式、码率、帧率和分辨率。\n对用户表现的体感就是：流畅度和清晰度。\n开发者需要关心的是：内存、CPU 和 GPU 的消耗、体积大小和带宽。\n\n本篇文章会尝试把这些概念都联系起来，对视频相关的概念有整体的认知。\n结论先行\n用户视角：\n\n清晰度 = 码率 / 分辨率\n流畅度 = 帧率\n\n开发者视角：\n\n影响内存的：主要是分辨率\n影响 CPU 的：码率和编码格式\n影响 GPU 的：分辨率和编码格式。\n影响体积大小和带宽：码率\n\n封装格式\n就是把视频数据和音频数据打包成一个文件的规范。 一个完整的视频文件，包括音频、视频和基础元信息，我们常见的视频文件如 mp4、mov、flv、avi、rmvb 等视频文件，就是一个容器的封装，里面包含了音频和视频两部分。\n封装格式是不会影响视频的画质，封装成什么格式就看在使用的时候解码器是否支持这个封装格式即可。\n\n\n                  \n                  提示💡 \n                  \n                \n封装，也叫多路复用(mux)。封装的目的一般为了在一个文件（流）中能同时存储视频（video）、音频（audio）、字幕（subtitle）等内容——这也正是“复用”的含义所在（分时复用）。封装还有另一个作用是在网络环境下确保数据的可靠快速传输。\n\n编码格式\n我们知道，其实视频就是一帧一帧的图片。计算一下，一部 25 帧每秒，90 分钟，分辨率为 1024*768，24 位(rgb 每个 8 位)真彩色的视频，没有经过压缩，大小为 ：\n\n1Byte（字节） = 8bit（位）\n一帧大小 = 1024 _ 768 _ 24 = 18874368（bit） = 2359296（Byte）\n总帧数 = 90 _ 60 _ 25 = 135000\n总大小 = 一帧大小 _ 总帧数 = 2359296 _ 135000 = 318504960000（Byte）= 303750（MB）≈ 296（GB）\n\n从上面的计算可以看出，我们储存一部 90 分钟没压缩的电影需要 296GB 的。所以我们需要对视频进行压缩，这种视频压缩技术就是我们所说的编码。\n视频编码方式：H.26X（H.261、H.262、…、H.264（目前最常用）、H.265）\n音频编码方式：MP3、AAC 等\n通过视频压缩算法，减少了视频文件的大小。压缩比越大，解压缩还原后播放的视频越失真，这是因为压缩的同时不可避免的丢失了视频中原来图像的数据信息。\n\n\n                  \n                  注意❗ \n                  \n                \n注意编码格式要跟封装格式做区分，两者没有任何关系。\n\n一般我们只需要关注 H.264 和 H.265 即可，H.264 是使用最广泛，除了 H.265 之外压缩率最高的，也就是说在相同码率下除了 H.265 之外 体积最小的。\n而 H.265 相比于 H.264 相同码率下体积还降低了 50% 。\n那是不是就可以无脑使用 H.265 了呢？先说说使用 H.265 有什么问题，我认为最大的两点就是：\n\n计算复杂性。H.265 的编码和解码过程比之前的标准（如 H.264）更复杂，压缩率更高，解码需要更多的计算资源。这意味着在一些低端设备上可能会面临性能问题。\n兼容性。 尽管 H.265 已经得到广泛支持，但仍然存在一些老旧设备不支持 H.265 的硬件解码，这就会导致播放器只能使用软解，会增加 CPU 的消耗。\n\n\n\n                  \n                  提示💡 \n                  \n                \n硬件解码：顾名思义就是通过硬件进行解码的计算，通常是 GPU。软件解码：顾名思义就是通过软件计算解码，软件计算主要依靠的是 CPU。CPU 的计算能力相比 GPU 来说弱很多，就会导致 CPU 占用率高，导致设备发热发烫。\n\n所以在设备相对较好的情况下，无脑使用 H.265 是没有问题的，如果对于低端设备使用 H.265 可能会带来性能问题，导致视频播放卡顿，需要用空间来换时间了。\n视频分辨率\n视频分辨率跟我们平时说的图像分辨率差不多，主要是指单位英寸中所包含的像素点数。 可以用长 x *宽的形式表示比如 1280 ** 720 的分辨率，也可以以像素点总数的形式表示，比如 200 万像素(1920 * 1080)。\n常见的分辨率：\n\n720 P(1280 * 720)\n1080 P(1920 * 1080)\n2K(2560 * 1440)\n4K(4096 * 2160)\n\n\n\n\n视频的分辨率与像素不可分，比如一个视频的分辨率为 1280 * 720,就代表了这个视频的水平方向有 1280 个像素，垂直方向有 720 个像素。\n\n\n另外需要知道的：\n\n720P 是指视频有 720 行像素， P 是 Progressive 逐行扫描 。\n2K 是指视频像素的总列数 。\nMP 是像素总数，指像素的行数(P)与列数(K)乘积的结果（百万像素） -\n1080P 分辨率为 1920 *1080，总像素 2073600，通常将 1080P 叫做 200 万像素分辨率\n\n\n\n通常视频在同样视窗的情况下，分辨率越高，所包含的像素就越多，视频画面就越细腻、越清晰。\n\n\n\n\n                  \n                  注意❗ \n                  \n                \n另外需要注意分辨率越大在解析到内存之后占用的内存也会更大，这个原理跟图片的分辨率对内存的影响是一致的。对于内存优化，通常降低分辨率是一个有效的方式。\n\n视频帧率\n\n帧率的单位是：FPS 是指每秒帧数（Frames Per Second）简写：P，“如 30 fps 和 30 p 指的都是每秒钟播放 30 张图片的意思” 。\n高低帧率：低帧率会伴随模糊、卡顿、镜头移动时不顺畅等问题，但也不是越高越好，会造成眩晕的感觉。\n不同帧率的视频在不同设备上播放：① 若一个播放设备最高支持 60fps，在此设备上播放 120fps 的影片，则播放设备会每隔一张删除 120fps 的影片，被删除的图片成为无效帧。这就导致高帧率的影片在低帧率的设备上播放时，会降低播放流畅度。② 若一个播放设备最高支持 120fps，在此设备上播放 60fps 的影片，则播放设备会每将每张图片复制一张，以填补空缺的帧。但是效果和 60fps 的设备上播放一样，对播放流畅度没有提升。\n\n帧率是直接影响流畅度的指标，视频一般 24FPS/25FPS 已经足够，低于 24 将会感到卡顿。\n视频码率（视频比特率）\n\n非常非常重要的一个参数。\n\n码率就是数据传输时单位时间(1s)传送的数据位数，一般我们用的单位是 kbps 即千位每秒。\n码率与体积的关系：\n\n在相同的时间下，码率越大，体积就越大。\n存储体积 = **码率 *** 时间。\n\n码率与画质的关系：\n\n同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越高，精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。\n编码模式码率取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来 cbr（固定码率）、vbr（可变码率）、abr（平均码率）；\n\nCBR: constant bitrate(固定码率)\nVBR：variable bitrate(动态码率)\nQVBR（Quality Variable Bit rate）质量码流\nABR：average bitrate(平均码率，是 VBR 的一种插值参数)\nCVBR：Constrained VariableBit Rate(有限码流)\n\n是 VBR 的一种改进方法，对应的 Maximum bitRate 恒定或者 Average BitRate 恒定。兼顾了 CBR 和 VBR 的优点：在图像内容静止时，节省带宽，有运动发生时，利用前期节省的带宽来尽可能的提高图像质量，达到同时兼顾带宽和图像质量的目的。这种方法通常会让用户输入最大码率和最小码率，静止时，码率稳定在最小码率，运动时，码率大于最小码率，但是又不超过最大码率。\n是在 CBR 和 VBR 两者之间的一种权衡，即设定一段时间的平均码率，在此时间内，对简单，静态的图像分配低于平均码率的码率，对于复杂的，大量运动的图像分配高于平均码率的码流；\n适合网络传输；\nQVBR 在 VBR 的基础上，增加了自适应动态质量控制功能。编码器会根据图像质量目标和帧率等因素自适应调节码率，以确保图像质量。这种编码方式减少了码率的小部分波动对图像质量的影响，进一步提高了图像的清晰度和稳定性。\n优点：能够在保证画面质量的前提下减少码流的波动\n缺点：相比 VBR 需要更高的码率带宽比。\n比特分配根据图像内容的复杂度进行。如果图像细节较丰富或者含有大量的运动，则给其分配大一点的码流，若图像比较平坦，就给其分配较少的码流， 这样既保证了质量，又兼顾带宽限制。\n这种算法适合图像内容变化幅度较大的情况；\n适合的应用场景是媒体存储，不适合网络传输；\n以恒定比特率方式进行编码，有运动发生时，由于码率恒定，只能通过增大 QP 来减少码字大小，图像质量变差，当场景静止时，图像质量又变好，因此图像质量不稳定。\n这种算法优先考虑码率(带宽)。适合在流式播放中应用。\nCBR 编码的缺点在于编码内容的质量不稳定,容易产生马赛克。因为对于某些较复杂的图像比较难压缩，所以 CBR 流的某些部分质量就比其他部分差。\n\n联系\n帧率相关\n\n对视频画质的影响：画面流畅度，不卡顿。\n与码率的联系：帧率越大，画面越流畅；每秒展示的画面（图片越多），需要的解码能力越强；若解码能力跟不上，则编码器就必须加大对单帧画面的压缩比，也就是通过降低画质来承载足够多的帧数，画面容易出现跳跃，不连贯，即丢帧；反之亦然。\n\n码率\n\n影响体积，与体积成正比：码率越大，体积越大；码率越小，体积越小。\n\n分辨率：\n\n影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小\n如果限定一个码率，比如 800kbps，那么分辨率越高就会让编码器越“为难”，可以想象，它必须拆东墙补西墙，通过减少色彩信息或者引入马赛克这种“鱼目混珠”的手段来承载足够多的像素点。所以，同样的是 2G 的一个电影文件，1080p 画质的版本可能不如 720p 画质的版本看起来更清晰。\n\n清晰度：\n\n码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。\n在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。\n\n总结\n没有完美的算法，无非是时间和空间的平衡，二者不可兼得。\n作为一个开发者，我们需要在用户的终端性能、网络、成本等各方面权衡，在不同的场景使用不同的参数的视频，可以提升用户的使用体验，降低公司的成本。\n在了解各个参数之后，在对视频做优化的时候就会游刃有余：\n\n当需要优化视频传输成本，降低视频的体积，最有效的就是降低码率，这样可能会降低清晰度，也可从视频编码格式入手，能否将 H.264 升级成 H.265.\n当终端设备内存受限，页面需要播放多个视频导致内存不够，首要考虑降低视频分辨率从而降低内存消耗。\n\n参考文章：\n\n视频封装格式\nH264---码率控制---CBR、VBR、ABR、CVBR四种编码方式\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/分辨率":{"title":"分辨率","links":[],"tags":["编程/FE/音视频"],"content":"简介\n常见分辨率：\n\n\n\n                  \n                  提示💡 \n                  \n                \n备注：SD 标准清晰度：Standard Definition，FHD 全高清：Full High Definition，UHD 超高清：Ultra High Definition\n\n定义\n视频分辨率：是用于度量图像内数据量多少的一个参数，通常表示成 ppi。\n单位\n描述分辨率的单位有：dpi（点每英寸）、lpi（线每英寸）、ppi（像素每英寸）和PPD（PPPixels Per Degree 角分辨率，像素每度）。\n下一步\n本章对于视频的基础概念已经叙述完毕，你可以选择阅读容器格式、编码格式，这两者并没有顺序限制～"},"C-Knowledge/前端/技术书籍/多媒体前端手册/判断是否为-DOM-元素":{"title":"判断是否为 DOM 元素","links":[],"tags":["编程/JavaScript/DOM"],"content":"function isElement(obj) {\n  try {\n    //Using W3 DOM2 (works for FF, Opera and Chrome)\n    return obj instanceof HTMLElement;\n  }\n  catch(e){\n    //Browsers not supporting W3 DOM2 don&#039;t have HTMLElement and\n    //an exception is thrown and we end up here. Testing some\n    //properties that all elements have (works on IE7)\n    return (typeof obj===&quot;object&quot;) &amp;&amp;\n      (obj.nodeType === 1) &amp;&amp; (typeof obj.style === &quot;object&quot;) &amp;&amp;\n      (typeof obj.ownerDocument ===&quot;object&quot;);\n  }\n}\n//Returns true if it is a DOM node\nfunction isNode(o){\n  return (\n    typeof Node === &quot;object&quot; ? o instanceof Node : \n    o &amp;&amp; typeof o === &quot;object&quot; &amp;&amp; typeof o.nodeType === &quot;number&quot; &amp;&amp; typeof \n    o.nodeName===&quot;string&quot;\n  );\n}\n \n//Returns true if it is a DOM element    \nfunction isElement(o){\n  return (\n    typeof HTMLElement === &quot;object&quot; ? o instanceof HTMLElement : //DOM2\n    o &amp;&amp; typeof o === &quot;object&quot; &amp;&amp; o !== null &amp;&amp; o.nodeType === 1 &amp;&amp; typeof \n    o.nodeName===&quot;string&quot;\n  );\n}"},"C-Knowledge/前端/技术书籍/多媒体前端手册/压缩率":{"title":"压缩率","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/分辨率"],"tags":["编程/FE/音视频"],"content":"简介\n经过压缩后文件的大小 / 原始文件的大小 * 100% = 压缩率\n压缩率一般是越小越好，但是压得越小，解压时间越长。\n压缩编码\n原始视频压缩的目的是去除冗余信息，可以去除的冗余包括：\n\n空间冗余：图像相邻像素之间有较强的相关性\n时间冗余：视频序列的相邻图像之间内容相似\n编码冗余：不同像素值出现的概率不同\n视觉冗余：人的视觉系统对某些细节不敏感\n知识冗余：规律性的结构可由先验知识和背景知识得到\n\n视频压缩编码的方法：\n\n变换编码\n熵编码\n运动估计和运动补偿\n混合编码\n\n常见编码格式压缩率\n\n\n                  \n                  举例 \n                  \n                \n举例：视频文件 3840 x 2160.yuv (大小：3.6 GB，分辨率：3840 x 2160 4 k 帧率 25 fps，码率：10 Mbps），使用H.265 编码方式压缩后文件大小 15 MB\n\nH.265编码方式下，压缩文件：15MB，压缩率为: 15 / 3600 * 100% ≈ 0.42%\nH.264编码方式下，压缩率是H.265的 1/2\n下一步\n接下来让我们来了解下分辨率的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/复用(remux)":{"title":"复用(remux)","links":[],"tags":["编程/FE/音视频"],"content":"引言\n前面章节讲完了demux及解码，对于整个码流从解封装到解码都有了一个初步认识。\n事实上，对一个多媒体文件，不仅仅可以demuxer解封装，同样也有逆操作通过remuxer复用。\n什么是remux\n把基本的音频ES、视频ES、字幕ES等组合成一个完整的多媒体就是Remux(复用)。\n对一个视频来说，改变封装格式，改变视频编码，需要remux和demux的配合。\n举个例子，当前有一个封装格式为mkv的视频，你想转成mp4，则需要经历：\n\nremux后得到产物\n一般而言，重封装后，得到的产物是一个完整封装格式的多媒体文件(.mp4、.flv、.ts等)。\nremux的使用\n比如，在针对一个电影做中文字幕时，需要先将其解封装后得到音视频资源，而后单独对字幕进行制作，封装幕成为基本流，然后再复用(Remux)成一份文件。\n对于目前市面上的视频转码软件或库来说，demux和remux是必不可少的操作。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/多媒体前端手册":{"title":"多媒体前端手册","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/视频","C-Knowledge/前端/技术书籍/多媒体前端手册/码率","C-Knowledge/前端/技术书籍/多媒体前端手册/帧率","C-Knowledge/前端/技术书籍/多媒体前端手册/压缩率","C-Knowledge/前端/技术书籍/多媒体前端手册/分辨率","C-Knowledge/前端/技术书籍/多媒体前端手册/MP4","C-Knowledge/前端/技术书籍/多媒体前端手册/AVI","C-Knowledge/前端/技术书籍/多媒体前端手册/FLV","C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8","C-Knowledge/前端/技术书籍/多媒体前端手册/WebM","C-Knowledge/前端/技术书籍/多媒体前端手册/OGV","C-Knowledge/前端/技术书籍/多媒体前端手册/MOV","C-Knowledge/前端/技术书籍/多媒体前端手册/H.265","C-Knowledge/前端/技术书籍/多媒体前端手册/H.264","C-Knowledge/前端/技术书籍/多媒体前端手册/AV1","C-Knowledge/前端/技术书籍/多媒体前端手册/VP9","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/YUV-格式","RGB","C-Knowledge/前端/技术书籍/多媒体前端手册/音频","C-Knowledge/前端/技术书籍/多媒体前端手册/采样率","C-Knowledge/前端/技术书籍/多媒体前端手册/采样大小","C-Knowledge/前端/技术书籍/多媒体前端手册/比特率","C-Knowledge/前端/技术书籍/多媒体前端手册/音频压缩率","C-Knowledge/前端/技术书籍/多媒体前端手册/WAV","C-Knowledge/前端/技术书籍/多媒体前端手册/AIFF","C-Knowledge/前端/技术书籍/多媒体前端手册/AMR","C-Knowledge/前端/技术书籍/多媒体前端手册/MP3","C-Knowledge/前端/技术书籍/多媒体前端手册/Ogg","C-Knowledge/前端/技术书籍/多媒体前端手册/PCM","C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LC","C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LD","C-Knowledge/前端/技术书籍/多媒体前端手册/FLAC","C-Knowledge/前端/技术书籍/多媒体前端手册/推拉流","C-Knowledge/前端/技术书籍/多媒体前端手册/流媒体协议","C-Knowledge/前端/技术书籍/多媒体前端手册/RTMP","C-Knowledge/前端/技术书籍/多媒体前端手册/RTP-and-RTCP-and-RTSP","C-Knowledge/前端/技术书籍/多媒体前端手册/HTTP-FLV","C-Knowledge/前端/技术书籍/多媒体前端手册/HLS","C-Knowledge/前端/技术书籍/多媒体前端手册/DASH","C-Knowledge/前端/技术书籍/多媒体前端手册/流媒体服务","C-Knowledge/前端/技术书籍/多媒体前端手册/播放器","C-Knowledge/前端/技术书籍/多媒体前端手册/拉流","C-Knowledge/前端/技术书籍/多媒体前端手册/解封装(demux)","C-Knowledge/前端/技术书籍/多媒体前端手册/解码","C-Knowledge/前端/技术书籍/多媒体前端手册/SPS和PPS","C-Knowledge/前端/技术书籍/多媒体前端手册/IBP帧","C-Knowledge/前端/技术书籍/多媒体前端手册/SEI","C-Knowledge/前端/技术书籍/多媒体前端手册/PTS和DTS","C-Knowledge/前端/技术书籍/多媒体前端手册/复用(remux)","C-Knowledge/前端/技术书籍/多媒体前端手册/播放器渲染","C-Knowledge/前端/技术书籍/多媒体前端手册/流操作基础","C-Knowledge/前端/技术书籍/多媒体前端手册/多媒体技术WebRTC","C-Knowledge/前端/技术书籍/多媒体前端手册/WebRTC-Web-API","C-Knowledge/前端/技术书籍/多媒体前端手册/Signaling","C-Knowledge/前端/技术书籍/多媒体前端手册/STUN--and--TURN","C-Knowledge/前端/技术书籍/多媒体前端手册/Security","C-Knowledge/前端/技术书籍/多媒体前端手册/Architectures","C-Knowledge/前端/开发技术/音视频/MSE","C-Knowledge/前端/技术书籍/多媒体前端手册/WebXR","D-Unsorted/WebGL","C-Knowledge/前端/技术书籍/多媒体前端手册/WebAssembly","C-Knowledge/前端/技术书籍/多媒体前端手册/flv.js","C-Knowledge/前端/技术书籍/多媒体前端手册/hls.js","C-Knowledge/前端/技术书籍/多媒体前端手册/video.js","C-Knowledge/前端/技术书籍/多媒体前端手册/mediaElement.js","C-Knowledge/前端/技术书籍/多媒体前端手册/西瓜播放器","C-Knowledge/前端/技术书籍/多媒体前端手册/FFmpeg","C-Knowledge/前端/技术书籍/多媒体前端手册/OBS","C-Knowledge/前端/技术书籍/多媒体前端手册/MLT","C-Knowledge/前端/技术书籍/多媒体前端手册/Web端H.265播放器研发解密","C-Knowledge/前端/技术书籍/多媒体前端手册/关于视频你需要知道的基本概念：码率（Bitrate）、帧率（FPS）、分辨率和清晰度"],"tags":["编程/FE/音视频"],"content":"\n音视频基础\n视频\n\n\n基础概念\n\n码率\n帧率\n压缩率\n分辨率\n\n\n\n容器格式\n\nMP4\nAVI\nFLV\nTS, M3U8\nWebM\nOGV\nMOV\n\n\n\n编码格式\n\nH.265\nH.264\nAV1\nVP9\n\n\n\n原始数据\n\nYUV\nRGB\n\n\n\n音频\n\n\n基础概念\n\n采样率\n采样大小\n比特率\n音频压缩率\n\n\n\n容器格式\n\nWAV\nAIFF\nAMR\nMP3\nOgg\n\n\n\n编码格式\n\nPCM: 原始数据\nAAC-LC\nAAC-LD\nFLAC\n\n\n\n直播技术\n\n\n推拉流\n\n\n流媒体协议\n\nRTMP\nRTP&amp;RTCP&amp;RTSP\nHTTP-FLV\nHLS\nDASH\n\n\n\n流媒体服务\n\n\n播放器\n\n拉流\n解封装(demux)\n解码\n\n****SPS和PPS\nIBP帧\nSEI\nPTS和DTS\n\n\n复用(remux)\n渲染\n\n多媒体技术\n\n流操作基础\nWebRTC\n\nWeb API\nSignaling\nSTUN &amp; TURN\nSecurity\nArchitectures\n\n\nMSE\nWebXR\nWebGL\nWebAssembly\n\n开源产品和框架\n\nflv.js\nhls.js\nvideo.js\nmediaElement.js\n西瓜播放器\nFFmpeg\nOBS\nMLT\n\n扩展阅读\n\nALive：助力阿里经济体，开启直播新纪元\nWeb端H.265播放器研发解密\nffmpeg基础使用\n关于视频你需要知道的基本概念：码率（Bitrate）、帧率（FPS）、分辨率和清晰度\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/多媒体技术WebRTC":{"title":"多媒体技术WebRTC","links":["C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/从-0-打造音视频直播系统"],"tags":["编程/FE/音视频"],"content":"简介\n网页即时通信（英语：Web Real-Time Communication），它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建**点对点（Peer-to-Peer）**的数据分享和电话会议成为可能。\n组成\n\n视频引擎（VideoEngine）\n音效引擎（VoiceEngine）\n会议管理（Session Management）\niSAC：音效压缩\nVP8：Google自家的WebM项目的视频编解码器\nAPIs（Native C++ API, Web API）\n\n\n流程图解\n简单的通话流程\n\n\n\n从 0 打造音视频直播系统\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/帧率":{"title":"帧率","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/压缩率"],"tags":["编程/FE/音视频"],"content":"简介\n\n备注：帧率越高，流畅度越高，低帧率会造成视觉卡顿，上图中到达顶部和到达底部时间是一致的\n越高的帧速率可以得到更流畅、更逼真的动画。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。\n定义\n视频帧率（Frame rate）：用于测量显示帧数的量度，也可以理解为图形处理器每秒钟能够刷新几次。\n单位\n测量单位为每秒显示的帧数(Frames per Second，FPS）或赫兹（Hz）。\n下一步\n接下来让我们来了解下压缩率的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/拉流":{"title":"拉流","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/H.264","C-Knowledge/前端/技术书籍/多媒体前端手册/MP4","C-Knowledge/前端/技术书籍/多媒体前端手册/WebM","C-Knowledge/前端/技术书籍/多媒体前端手册/Ogg"],"tags":["编程/FE/音视频"],"content":"video 元素本身支持 H.264 编码的 MP4、vp8编码的 WebM、theora 编码的 Ogg 视频格式。浏览器内部处理拉流逻辑。\n对于像flv格式的视频流数据，我们需要自行拉取数据。\n浏览器依赖 HTTP FLV 或者 WebSocket 中的一种协议来传输FLV。其中HTTP FLV需通过流式IO去拉取数据，支持流式IO的有fetch或者stream。\n相关用法如下：\nFetch API \nFetch API 会在发起请求后得到的 Promise 对象中返回一个 Response 对象，而 Response 对象除了提供 headers、redirect() 等参数和方法外，还实现了 Body 这个 mixin 类，而在 Body 上我们才看到我们常用的那些 res.json()、res.text()、res.arrayBuffer() 等方法。在 Body 上还有一个 body 参数，这个 body 参数就是一个 ReadableStream。\nfetch(this.url, {\n  method: &quot;GET&quot;\n}).then(resp =&gt; {\n  const { status, statusText } = resp;\n  resp.body.getReader().then(result =&gt; {\n    let { value, done } = result;\n    value = new Uint8Array(value ? value : 0);\n    this.data = concat(this.data, value);\n    if (done) {\n      this.done = true;\n    } else if (this.data.length &lt; this.chunkSize) {\n      // ...,\n    }\n  });\n});\nStreams API \nStreams API 赋予了网络请求以片段处理数据的能力，过去我们使用 XMLHttpRequest 获取一个文件时，我们必须等待浏览器下载完整的文件，等待浏览器处理成我们需要的格式，收到所有的数据后才能处理它。现在有了流，我们可以以 TypedArray 片段的形式接收一部分二进制数据，然后直接对数据进行处理，这就有点像是浏览器内部接收并处理数据的逻辑。甚至我们可以将一些操作以流的形式封装，再用管道把多个流连接起来，管道的另一端就是最终处理好的数据。\nthis.xhr = new XMLHttpRequest();\nthis.xhr.open(&quot;GET&quot;, this.url);\nthis.xhr.responseType = &quot;arraybuffer&quot;;\nthis.xhr.setRequestHeader(&quot;Range&quot;, `bytes=${startIndex}-${endIndex}`);\n \nthis.xhr.onload = () =&gt; {\n  if (this.xhr.readyState == 4) {\n    if (this.xhr.status &gt;= 200 &amp;&amp; this.xhr.status &lt;= 299) {\n      if (!this.emitted) {\n        this.emitted = true;\n      }\n      this.startIndex = endIndex + 1;\n      resolve(new Uint8Array(this.xhr.response));\n    }\n  }\n};\n \nthis.xhr.send();"},"C-Knowledge/前端/技术书籍/多媒体前端手册/推拉流":{"title":"推拉流","links":[],"tags":["编程/FE/音视频"],"content":"概述\n将实况场景信息实时编码压缩后进行网络输出发布，用户播放分发后的流媒体数据的过程。\n过程\n\n\n经过输出设备得到原始的采样数据—视频数据和音频数据\n使用硬编码（对应系统的API）或软编码（FFMpeg等）来编码压缩音视频数据\n然后根据不同的封装格式（如FLV、TS、MPEG-TS）进行封装打包\n通过不同的传输协议（如RTMP、RTP等）将流上传到服务器\n服务器进行节点分发（CDN）\n用户侧通过不同的传输协议（如RTMP、HLS、HTTP-FLV等）获取流数据\n同步骤3、2反向解封装和解码音视频数据\n进行渲染播放\n\n从过程中可以看出，每一步对推流效果的影响都是很大的，比如选取好的采集设备获取更优质的原始数据。用高配置的电脑并采用最先进的编码策略（如HEVC，当然播放端也需要配合支持），推流协议选取延迟相对较低的（如RTMP、HTTP-FLV）\n鉴于大部分内容属于多媒体领域通用的技术，本章节仅对直播部分（直播协议、服务等）做详细介绍，其它内容可参考其它大章。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/播放器":{"title":"播放器","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/RTMP","C-Knowledge/前端/技术书籍/多媒体前端手册/H.264","C-Knowledge/前端/技术书籍/多媒体前端手册/AAC-LD","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/YUV-格式","C-Knowledge/前端/技术书籍/多媒体前端手册/PCM","C-Knowledge/前端/技术书籍/多媒体前端手册/拉流"],"tags":["编程/FE/音视频"],"content":"引言\n对于音视频播放器，你肯定不陌生，日常听歌曲或者看视频，基本都使用到了播放器。将一份mp4(也可能是mkv，或者其他容器格式)的文件使用播放器打开，播放器就能输出图片、声音等媒体元素。\n对于普通用户而言，播放器是一个黑盒，完全不清楚为什么一个文件输入，就有如此多丰富的信息展示出来。\n本章节将带你走入播放器世界，探究播放器的谜底。\n\n\n                  \n                  注意❗ \n                  \n                \n注：这里的播放器是指能播放以数字信号形式存储的音视频的软件。例如播放器：暴风影音、windows media player、迅雷影音等。\n\n播放器做哪些事情\n图解播放器\n\n可以看到播放器的几个基本流程：\n1 ，解协议\n从原始的流媒体协议数据中只保留下来音视频数据，列入采用RTMP协议传输的数据，经过解协议后输出flv(ts等)格式的数据。\n2，解封装\n解封装音频和视频压缩编码数据，常见的封装格式mp4，mkv，rmvb，flv，avi这些格式，然后将已经压缩编码的视频、音频数据放到一起。例如 FLV 格式的数据经过解封装后输出 H.264 编码的视频码流和 AAC 编码的音频码流。\n3，解码\n视频，音频压缩编码数据，还原成非压缩的视频，音频原始数据，音频的压缩编码标准包括 AAC，MP3，AC-3等，视频压缩编码标准包含H.264，MPEG2，VC-1等经过解码得到非压缩的视频颜色数据如 YUV420P，RGB 和非压缩的音频数据如 PCM 等。\n4，音视频播放\n将同步解码出来的音频和视频数据(中间可能经过同步)分别送至系统声卡和显卡播放。\n下一章节\n以上是对播放器的一个基本介绍，现在你对播放器应该有了一个初步的认知。可以继续学习下个章节：拉流。\n后面章节，我们将按照上述播放器顺序，对播放器的各个流程详细介绍。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/播放器渲染":{"title":"播放器渲染","links":["C-Knowledge/前端/开发技术/音视频/MSE","C-Knowledge/前端/技术书籍/多媒体前端手册/Web端H.265播放器研发解密","C-Knowledge/前端/技术书籍/多媒体前端手册/Canvas-怎么实现播放视频！"],"tags":["编程/FE/音视频"],"content":"渲染，指的是将解码后的数据，在 pc 硬件上（显示器、扬声器）进行播放。负责渲染的模块我们称之为渲染器(Render)，视频渲染器主流有EVR（Enhanced Video Render）以及 madVR (madshi Video Render)，Web 播放器一般使用 video 标签来嵌入。\nvideo 标签\nHTML &lt;video&gt; 元素用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 &lt;video&gt;  标签用于音频内容，但是 &lt;audio&gt; 元素可能在用户体验上更合适。使用 MSE 可以通过 JavaScript  生成媒体流，这可以用于自适应流（adaptive streaming）及随时间变化的视频直播流（live streaming）等应用场景。\n自定义渲染\n但是主流浏览器不支持 H.265 视频播放，我们需要自己实现播放器渲染器。\n通过对 Chromium 浏览器官方文档及 video 标签实现源码的阅读，整理了一个流程图：\n\n可以看到浏览器内部对视频流播放的实现，在经过了 PipelineController 等数据传输管道的处理后利用 FFmpeg 软解或者 GPU 硬解之后交给视频设备及音频设备进行同步及渲染。其中 H.265 的视频因为硬解支持情况不完善，软解可能有性能风险，所以在 chrome 中被关闭了不支持，在 chromium 中可以通过参数打开。对于 H.265 视频可以依照这个思路，利用浏览器提供的接口来实现一个模拟的 video 标签，大体是 通过 canvas 和 audio 来实现。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/比特率":{"title":"比特率","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/音频压缩率"],"tags":["编程/FE/音视频"],"content":"\n简介\n比特率（bit rate）又称“二进制位速率”，俗称“码率”。指每秒传送的比特(bit)数，又称数据信号速率。单位为比特/秒(bit/s或bps)、千比特/秒（kbit/s或kbps，k=1000）或兆比特/秒（Mbit/s 或 Mbps，1Mbps = 1000kbit/s）。比特率越高，表示单位时间传送的数据就越多。\n单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。一般我们用的单位是kbps即千位每秒\n音频中比特率计算公式\n比特率(kbps)=量化采样点(kHz)×位深(bit/采样点)×声道数量(一般为2)\n比特率对应音频质量\n\n32 kbps — MW(AM) 质量\n96 kbps — FM 质量\n128 ~ 160 kbps — 相当好的质量，有时有明显差别\n192 kbps — 优良质量，偶尔有差别\n224 ~ 320 kbps — 高质量\n800 bps — 能够分辨的语音所需最低码率（需使用专用的 FS-1015 语音编解码器）\n8 kbps — 电话质量（使用语音编码）\n8 ~ 500 kbps — Ogg Vorbis 和MPEG1 Player1/2/3 中使用的有损音频模式\n500 kbps ~ 1.4 Mbps —44.1KHz 的无损音频，解码器为 FLAC Audio, WavPack 或 Monkey’s Audio\n1411.2 ~ 2822.4 Kbps —脉冲编码调制(PCM)声音格式 CD 光碟的数字音频\n5644.8 kbps — SACD使用的 Direct Stream Digital 格式\n\n下一步\n接下来让我们来了解下压缩率的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/流媒体协议":{"title":"流媒体协议","links":[],"tags":["编程/FE/音视频"],"content":"概述\n每一个你在网络上观看的视频或音频媒体都是依靠特定的网络协议进行数据传输，基本分布在会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。\n\n大部分底层协议内容前端无需感知，直播场景下接触较多的上层协议有RTMP、RTP、HLS、DASH等。\n现在的上层协议分为流媒体专用协议（RTMP、RTSP/RTP）和基于HTTP改造协议（HLS、MPEG-DASH、MSS、HDS等）两种，像RTMP是用在流服务的专用实时消息传输协议，其它HTTP-Based协议的优势则是在传统服务上优化观看体验和快速扩展。\n常用协议对比\n下面两张图可以体现各个协议的特性对比\n\n\n可以看出流媒体专用协议对比大多数HTTP改造协议，低延时的优点特别明显。但是缺点也存在，RTMP为Adobe公司的提案，依托Flash技术，没有成为行业标准，所以存在兼容性的问题，故Web上HTTP-FLV应用更为广泛。当然WebRTC作为一种更新的解决方案也不失为一种选择。\n不同协议详细的对比可参考此文章：www.wowza.com/blog/streaming-protocols"},"C-Knowledge/前端/技术书籍/多媒体前端手册/流媒体服务":{"title":"流媒体服务","links":[],"tags":["编程/FE/音视频"],"content":"简介\n流媒体服务器是流媒体应用的核心系统，是运营商向用户提供视频服务的关键平台。流媒体服务器的主要功能是对流媒体内容进行采集、缓存、调度和传输播放。流媒体应用系统的主要性能体现都取决于媒体服务器的性能和服务质量。因此，流媒体服务器是流媒体应用系统的基础，也是最主要的组成部分。\n\n常用\n\nAdobe Flash Media Server —Adobe\nWindows Media Server — Microsoft\nQuicktime Media Server - Apple\nMultimedia Solutions - 阿里云\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/流操作基础":{"title":"流操作基础","links":["C-Knowledge/前端/技术书籍/ES6-入门教程/ArrayBuffer","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Buffer-的理解！应用场景！","C-Knowledge/前端/技术书籍/JavaScript教程/ArrayBuffer-对象，Blob-对象"],"tags":["编程/FE/音视频"],"content":"前端对于 ArrayBuffer 操作有两种方式，TypeArray 和 DataView。对于各个字节序的读取没有 Node 原生的 Buffer 对象方便。\n常用的操作有：\n\n对bit单元的操作\n对字节/ 字节序的操作\n\n对字节/ 字节序的操作\n读取字节、字节序\n/**\n * 读取32位大端字节序\n */\nfunction readUInt32BE(buffer: ArrayBuffer, offset: number) {\n  return new DataView(buffer, offset).getInt32(0, false);\n}\n \n/**\n * 读取24位大端字节序\n */\nfunction readUInt24BE(buffer: ArrayBuffer, offset: number) {\n  const arr = new Uint8Array(buffer);\n  return (arr[offset] &lt;&lt; 16) | (arr[offset + 1] &lt;&lt; 8) | arr[offset + 2];\n}\n \n/**\n * 读取16位大端字节序\n */\nfunction readUInt16BE(buffer: ArrayBuffer, offset: number) {\n  return new DataView(buffer, offset).getInt16(0, false);\n}\n \n/**\n * 读取8位大端字节序\n */\nfunction readUInt8(buffer: ArrayBuffer, offset: number) {\n  const arr = new Uint8Array(buffer);\n  return arr[offset];\n}\n写入字节流\n// 申请一个byteLength长度arraybuffer空间\nconst typeArray = new Uint8Array(byteLength);\n// 将newBuffer插入到arraybuffer空间中的offset位置\ntypeArray.set(new Uint8Array(newBuffer), offset);\n复制字节流\nlet a = new Uint8Array([1,2,3,4,5,6]);\nlet c = a.slice(0, 5);\n共享字节流\nlet a = new Uint8Array([1,2,3,4,5,6]);\nlet b = a.subarray(0, 5);\n对 bit 的操作\n// 获取一个字节的前4个bit\nreadUInt8(buffer, 0) &amp; 240) &gt;&gt; 4;\n// 获取一个字节的后4个bit\nreadUInt8(buffer, 0) &amp; 15;\n\n\nArrayBuffer\nArrayBuffer 对象，Blob 对象\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/码率":{"title":"码率","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/帧率"],"tags":["编程/FE/音视频"],"content":"\n简介\n单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。一般我们用的单位是kbps即千位每秒\n定义\n比特率(bit rate)又称“二进制位速率”，俗称“码率”，每秒传送的比特(bit)数，又称数据信号速率。\n单位\n比特/秒(bit/s或bps)、千比特/秒（kbit/s或kbps，k=1000）或兆比特/秒（Mbit/s 或 Mbps，1Mbps = 1000kbit/s）。比特率越高，表示单位时间传送的数据就越多。\n视频码率计算公式\n\n\n\n                  \n                  举例 \n                  \n                \n举例：D 5 碟，容量 4.3 G，其中考虑到音频的不同格式，算为 600 M（故剩余容量为 4.3 * 1024 - 600 = 3803.2 M)，所以视频文件应不大于 3.7 G，本例中取视频文件的容量为 3.446 G，视频长度 100 分钟（6000 秒），计算结果：码率约等于 4818 kbps (3.446 * 1024 * 1024 * 8 / 6000 = 4817.857)。\n\n码率与编码方式的关系\n分辨率固定的情况下清晰度和码率的关系：\n\nH.265与H.264编码下不同分辨率对应的推荐码率上限：\n\n码率对应视频质量\n\n16 kbps — 可视电话质量（使用者可以接受的”说话的头”照片的最低要求）\n128 ~ 384 kbps — 商业导向的视频会议系统质量\n1 Mbps — VHS质量\n1.25 Mbps — VCD质量（使用 MPEG1 压缩）\n5 Mbps — DVD质量（使用 MPEG2 压缩）\n8 ~ 15 Mbps — 高清晰度电视（HDTV） 质量（使用 H.264 压缩）\n29.4 Mbps — HD DVD 质量\n40 Mbps — 蓝光光碟（Blu-ray Disc） 质量（使用 MPEG2、H.264 或 VC-1 压缩）\n440/880 Mbps – Sony HDCAM SR质量（SQ/HQ）\n\n下一步\n接下来让我们来了解下帧率 的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/细品西瓜播放器功能分析":{"title":"细品西瓜播放器功能分析","links":["D-Unsorted/Location-对象，URL-对象，URLSearchParams-对象","前端本地图片预览的实现方式","D-Unsorted/File-对象，FileList-对象，FileReader-对象","C-Knowledge/前端/技术书籍/多媒体前端手册/判断是否为-DOM-元素","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas-怎么实现截图！","C-Knowledge/前端/技术书籍/JavaScript教程/video，audio","C-Knowledge/前端/技术书籍/多媒体前端手册/下载文件"],"tags":["编程/FE/音视频"],"content":"简介\n西瓜视频播放器（HTML5）一款带解析器、能节省流量的 HTML5 视频播放器。它从底层解析 MP4、HLS、FLV 探索更大的视频播放可控空间。它具有以下功能特色：\n\n易扩展：灵活的插件体系、PC/移动端自动切换、安全的白名单机制；\n更丰富：强大的 MP4 控制、点播的无缝切换、有效的带宽节省；\n较完整：完整的产品机制、错误的监控上报、自动的降级处理。\n\n背景\n字节跳动的视频业务大多数是短视频，早期的时候我们在 video.js 基础上做二次开发。**后来发现很多功能达不到我们的要求，比如自定义 UI 的成本、视频的清晰度无缝切换、视频流量的节省。考虑到当前点播依旧是 mp4 居多，我们做了个大胆的假设：在播放器端加载视频、解析视频、转换格式，让不支持分段播放的 mp4 动态支持，这样就无须转换源视频的格式，服务器端也无其他开销。**在这个动力下，我们在 2017 年年底完成了这项开发任务，并与2018 年年初测试了稳定性和经济收益。\n在这个背景下，我们一次解析了 hls、flv 等视频，这样我们不再简单的依赖第三方的视频库，只有掌握了底层技术才有优化的可能性。在不断攻克 hls、flv 解析的背景下，我们增强了产品体验，比如交互效果、进场动画等。直到最近，我们想完善文档并把播放器源代码开源出来给更多的视频从业者一个参考，我们一起交流学习，共同进步。\n一、西瓜播放器架构\n\n1.1 功能分析思维导图\n\n二、西瓜播放器 UML\n\n三、内置插件功能分析\n西瓜视频播放器主张一切设计都是插件，小到一个播放按钮大到一项直播功能支持。想更好的自定义播放器完成自己业务的契合，理解插件机制是非常重要的，播放器本身有很多内置插件，比如报错、loading、重播等，如果大家想自定义效果可以关闭内置插件，自己开发即可。\n3.1 本地预览功能\n播放器预览本地视频功能，不建议改动。源码\n地址：\ngithub.com/bytedance/xgplayer/blob/master/packages/xgplayer/src/control/localPreview.js\n使用方式\nnew Player({\n  el:document.querySelector(&#039;#mse&#039;),\n  url: &#039;video_url&#039;,\n  preview: {\n    uploadEl: uploadDom\n  }\n});\n\n配置项：uploadEl\n含义：Dom 元素，用于放置上传视频文件的相关控件\n\n源码实现\nlet localPreview = function() {\n  let player = this;\n  let util = Player.util;\n  // util.createDom = function (el = &#039;div&#039;, tpl = &#039;&#039;, attrs = {}, cname = &#039;&#039;)\n  let preview = util.createDom(\n    &quot;xg-preview&quot;,\n    &#039;&lt;input type=&quot;file&quot;&gt;&#039;,\n    {},\n    &quot;xgplayer-preview&quot;\n  );\n  let upload = preview.querySelector(&quot;input&quot;);\n  if (player.config.preview &amp;&amp; player.config.preview.uploadEl) {\n    player.config.preview.uploadEl.appendChild(preview);\n    upload.onchange = function() {\n      // developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input/file\n      // 选中文件通过 HTMLInputElement.files 属性返回 — 返回值是一个 FileList 对象,\n      // 这个对象是一个包含了许多 File 文件的列表\n      player.uploadFile = upload.files[0];\n      // objectURL = URL.createObjectURL(object);\n      // 参数 object：用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。\n      // URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL()\n      // 创建的 URL 对象。\n      // 当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件\n      // 的引用了。比如 window.URL.revokeObjectURL(objectURL);\n      let url = URL.createObjectURL(player.uploadFile);\n      if (util.hasClass(player.root, &quot;xgplayer-nostart&quot;)) {\n        player.config.url = url;\n        player.start();\n      } else {\n        player.src = url;\n        player.play();\n      }\n    };\n  }\n};\n \nPlayer.install(&quot;localPreview&quot;, localPreview);\n原理分析\n视频本地预览的功能主要利用 URL.createObjectURL() API 来实现。URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。 这个新的 URL 对象表示指定的 File 对象或 Blob 对象。\n\n\n                  \n                  注意❗ \n                  \n                \n注意： 此特性在 Web Worker 中可用。\n**注意：**此特性在 Service Worker 中不可用，因为它有可能导致内存泄漏。\n\n\ninput file 获取本地 File 对象\n把 File 对象转换为 ObjectURL\n设置 Video 元素的 src 为视频本地的 ObjectURL 地址\n\n扩展分析\n1、前端本地图片预览的实现方式\n前端本地图片预览，可以通过 FileReader.readAsDataURL 或 URL.createObjectURL 的方式来实现。\n2、FileReader vs URL.createObjectURL\n2.1 是否同步\n\ncreateObjectURL 是同步执行\nFileReader.readAsDataURL 是异步执行的\n\n2.2 内存使用\n\ncreateObjectURL 方法会返回一个本地的 URL 地址，对象会一直保存在内存中，直到文档触发 unload 事件（比如 document close）或者手动调用 revokeObjectURL。\nFileReader.readAsDataURL 会返回 base64 格式的字符串，比 Blob URL 的方式会占用更多的内存空间，当你不需要使用它的时候，可以通过系统的垃圾回收机制来自动进行回收。\n\n2.3 兼容性\n\ncreateObjectURL：支持 IE 10 以上的主流浏览器，详细的兼容性，可以查看 caniuse - createObjectURL。\nFileReader.readAsDataURL：支持 IE 10 以上的主流浏览器，详细兼容性，可以查看 caniuse - readAsDataURL\n\n\n\n                  \n                  引用 \n                  \n                \n参考资源 ——\nfilereader-vs-window-url-createobjecturl\n地址：\nstackoverflow.com/questions/31742072/filereader-vs-window-url-createobjecturl/31743665#31743665\n\n3、createObjectURL 特性检测\nfunction createObjectURL (file) { \n    if (window.webkitURL) { \n      return window.webkitURL.createObjectURL(file); \n    } else if (window.URL &amp;&amp; window.URL.createObjectURL) { \n      return window.URL.createObjectURL(file); \n    } else { \n      return null; \n    } \n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 ——\nhow-to-choose-between-window-url-createobjecturl-and-window-webkiturl-create\n地址：\nstackoverflow.com/questions/11277677/how-to-choose-between-window-url-createobjecturl-and-window-webkiturl-creat\n\n4、插件优化项\n\n为了避免大的视频通过 createObjectURL 方式进行预览会造成大量的内存占用，是否提供一套智能的回收方案，比如在特定时机点调用 revokeObjectURL 方法。\n源码中 player.config.preview.uploadEl.appendChild(preview) 只是保证对象是否存在，并没有保证传入的对象一定是 DOM 元素。判断是否为 DOM 元素，可以使用以下的方法来判断：\n\nfunction isElement(obj) {\n  try {\n    //Using W3 DOM2 (works for FF, Opera and Chrome)\n    return obj instanceof HTMLElement;\n  }\n  catch(e){\n    //Browsers not supporting W3 DOM2 don&#039;t have HTMLElement and\n    //an exception is thrown and we end up here. Testing some\n    //properties that all elements have (works on IE7)\n    return (typeof obj===&quot;object&quot;) &amp;&amp;\n      (obj.nodeType === 1) &amp;&amp; (typeof obj.style === &quot;object&quot;) &amp;&amp;\n      (typeof obj.ownerDocument ===&quot;object&quot;);\n  }\n}\nUpdate 2\n//Returns true if it is a DOM node\nfunction isNode(o){\n  return (\n    typeof Node === &quot;object&quot; ? o instanceof Node : \n    o &amp;&amp; typeof o === &quot;object&quot; &amp;&amp; typeof o.nodeType === &quot;number&quot; &amp;&amp; typeof \n    o.nodeName===&quot;string&quot;\n  );\n}\n \n//Returns true if it is a DOM element    \nfunction isElement(o){\n  return (\n    typeof HTMLElement === &quot;object&quot; ? o instanceof HTMLElement : //DOM2\n    o &amp;&amp; typeof o === &quot;object&quot; &amp;&amp; o !== null &amp;&amp; o.nodeType === 1 &amp;&amp; typeof \n    o.nodeName===&quot;string&quot;\n  );\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 ——\nhow-do-you-check-if-a-javascript-object-is-a-dom-object\n地址：\nstackoverflow.com/questions/384286/how-do-you-check-if-a-javascript-object-is-a-dom-object\n\n3.2 播放器截图\n播放器内部截图，截图格式可以自定义。源码\n地址：\ngithub.com/bytedance/xgplayer/blob/master/packages/xgplayer/src/control/screenShot.js\n截图功能支持用户对当前视频播放窗口进行即时截屏，截图尺寸即为当前视频播放窗口的尺寸，截图默认为 .png 格式。\n使用方式\nnew Player({\n  el:document.querySelector(&#039;#mse&#039;),\n  url: &#039;video_url&#039;,\n  screenShot: true\n})\n\n配置项：screenShot\n默认值：false\n参考值：true | false\n\n源码实现\nlet screenShot = function () {\n  let player = this\n  let util = Player.util\n  if (!player.config.screenShot) {\n    return\n  }\n  let btn = util.createDom(\n    &#039;xg-screenShot&#039;, \n    &#039;&lt;p class=&quot;name&quot;&gt;&lt;span&gt;截图&lt;/span&gt;&lt;/p&gt;&#039;, \n    {tabindex: 11}, \n    &#039;xgplayer-screenShot&#039;\n  );\n  let canvas = document.createElement(&#039;canvas&#039;)\n  let canvasCtx = canvas.getContext(&#039;2d&#039;)\n  let img = new Image()\n  // 截图尺寸即为当前视频播放窗口的尺寸\n  canvas.width = this.config.width || 600\n  canvas.height = this.config.height || 337.5\n  // 添加截图按钮到播放器控件上\n  let root = player.controls\n  root.appendChild(btn) \n  let array = [&#039;click&#039;, &#039;touchstart&#039;]\n  array.forEach(item =&gt; {\n    btn.addEventListener(item, function (e) {\n      e.preventDefault()\n      e.stopPropagation()\n      img.onload = (function () {\n        // developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage\n        // 例如：CSSImageValue，HTMLImageElement，SVGImageElement，HTMLVideoElement，\n        // HTMLCanvasElement，ImageBitmap 或者OffscreenCanvas。\n        canvasCtx.drawImage(player.video, 0, 0, canvas.width, canvas.height)\n        // developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image\n        // developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes\n        // anonymous：对此元素的 CORS 请求将不设置凭据标志。\n        // use-credentials：对此元素的CORS请求将设置凭证标志；这意味着请求将提供凭据。\n        // &quot;&quot;：设置一个空的值，如 crossorigin 或 crossorigin=&quot;&quot;，和设置 anonymous 的效果一样。\n        img.setAttribute(&#039;crossOrigin&#039;, &#039;anonymous&#039;)\n        img.src = canvas.toDataURL(&#039;image/png&#039;).replace(&#039;image/png&#039;, &#039;image/octet-stream&#039;)\n        let screenShotImg = img.src.replace(/^data:image\\/[^;]+/, \n          &#039;data:application/octet-stream&#039;)；\n        saveScreenShot(screenShotImg, &#039;截图.png&#039;)\n      })()\n    })\n  })\n}\n \nPlayer.install(&#039;screenShot&#039;, screenShot)\n原理分析\n播放器截图功能主要利用\nCanvasRenderingContext2D.drawImage() API 来实现。Canvas 2D API 中的 CanvasRenderingContext2D.drawImage() 方法提供了多种方式在 Canvas 上绘制图像。drawImage API 的语法如下：\n\nvoid ctx.drawImage(image, dx, dy);\nvoid ctx.drawImage(image, dx, dy, dWidth, dHeight);\nvoid ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n\n其中 image 参数表示绘制到上下文的元素。允许任何的 canvas 图像源(CanvasImageSource)，例如：CSSImageValue，HTMLImageElement，SVGImageElement，HTMLVideoElement，HTMLCanvasElement，ImageBitmap 或者 OffscreenCanvas。\n\n创建截屏按钮并添加到播放器控制条上\n创建 Canvas 元素和一个 Image 实例\n为截屏按钮绑定事件监听，如 click 和 touchstart 事件\n用户点击截屏时，触发对应的回调函数并通过 drawImage() 获取当前视频帧\n\n扩展分析\n1、Image 元素的 crossOrigin 属性\n在 HTML5 中，一些 HTML 元素提供了对 CORS 的支持，例如 audio、image、link、script 和 video 均有一个跨域属性（crossOrigin property），它允许你配置元素获取数据的 CORS 请求。\n\n默认情况下（即未指定 crossOrigin 属性时），CORS 根本不会使用。如 Terminology section of the CORS specification 中的描述，在非同源情况下，设置 “anonymous” 关键字将不会通过 cookies，客户端 SSL 证书或 HTTP 认证交换用户凭据。即使是无效的关键字和空字符串也会被当作 anonymous 关键字使用。\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— CORS_settings_attributes\n地址：\ndeveloper.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes\n\n2、  HTMLCanvasElement.toDataURL()\nHTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为 96dpi。\n\n如果画布的高度或宽度是 0，那么会返回字符串 “data:,。“\n如果传入的类型非 “image/png”，但是返回的值以 “data:image/png” 开头，那么该传入的类型是不支持的。\nChrome 支持 “image/webp” 类型。\n\nHTMLCanvasElement.toDataURL() 语法如下：\ncanvas.toDataURL(type, encoderOptions);\n\ntype 可选，图片格式，默认为 image/png\nencoderOptions 可选\n\n在指定图片格式为 image/jpeg 或image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。\nconst canvas = document.getElementById(&quot;canvas&quot;);\nconst dataURL = canvas.toDataURL();\nconsole.log(dataURL);\n// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby\n// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;\n3、前端文件下载\n方案一：\nlet saveScreenShot = function (data, filename) {\n  let saveLink = document.createElement(&#039;a&#039;)\n  saveLink.href = data\n  saveLink.download = filename\n  let event = document.createEvent(&#039;MouseEvents&#039;)\n  event.initMouseEvent(&#039;click&#039;, true, false, window, 0, 0, 0, 0, 0, false, false,\n    false, false, 0, null)\n  saveLink.dispatchEvent(event)\n}\n方案二：\nconst a = document.createElement(&#039;a&#039;);\nconst url = window.URL.createObjectURL(blob);\nconst filename = &#039;what-you-want.txt&#039;;\na.href = url;\na.download = filename;\na.click();\nwindow.URL.revokeObjectURL(url);\nDataURL 与 createObjectURL 方式的区别，可以阅读本地预览功能 &gt; 扩展分析部分。\n\n参考资源 —— 这应该是你见过的最全前端下载总结\n地址：\nzhuanlan.zhihu.com/p/55224397\n\n4、自定义事件\nlet event = document.createEvent(&#039;MouseEvents&#039;)\nevent.initMouseEvent(&#039;click&#039;, true, false, window, 0, 0, 0, 0, 0, false, false,\n    false, false, 0, null)\nsaveLink.dispatchEvent(event)\n5、插件优化项\n\nlet array = [‘click’, ‘touchstart’] 变量命名规范化，建议 array 命名为 events。\nsaveScreenShot(screenShotImg, ‘截图.png’) 插件支持定义图片的格式和截图的名称，截图名称可以考虑使用 时间戳 + 固定后缀 的格式。\n在播放器卸载的时候，执行相关的清理操作。比如回收 let img = new Image() 插件内创建的 Image 元素并解除该元素上已绑定的事件。\n\n3.3 下载功能\n播放器下载控件，可以自定义。源码\n地址：\ngithub.com/bytedance/xgplayer/blob/dev/packages/xgplayer/src/control/download.js\n使用方式\n视频下载控件，点击后下载视频。\nlet player = new Player({\n    download: true //设置download控件显示\n});\n\n配置项：download\n默认值：false\n参考值：true | false\n\n源码实现\nimport downloadUtil from &quot;downloadjs&quot;;\n \nconst download = function() {\n  const player = this;\n  if (!this.config.download) {\n    return;\n  }\n  let container = player.root;\n  let util = Player.util;\n  // util.createDom = function (el = &#039;div&#039;, tpl = &#039;&#039;, attrs = {}, cname = &#039;&#039;)\n  let downloadEl = util.createDom(\n    &quot;xgplayer-download&quot;,\n    `&lt;xg-icon class=&quot;xgplayer-download-img&quot;&gt;&lt;/xg-icon&gt;`,\n    {},\n    &quot;xgplayer-download&quot;\n  );\n \n  let root = player.controls;\n  root.appendChild(downloadEl);\n \n  let tipsDownload =\n    player.config.lang &amp;&amp; player.config.lang === &quot;zh-cn&quot; ? &quot;下载&quot; : &quot;Download&quot;;\n  // util.createDom = function (el = &#039;div&#039;, tpl = &#039;&#039;, attrs = {}, cname = &#039;&#039;)\n  let tips = util.createDom(&quot;xg-tips&quot;, tipsDownload, {}, &quot;xgplayer-tips&quot;);\n  downloadEl.appendChild(tips);\n \n  player.download = function() {\n    const url = getAbsoluteURL(player.config.url);\n    downloadUtil(url);\n  };\n  \n  downloadEl.addEventListener(&quot;click&quot;, e =&gt; {\n    e.stopPropagation();\n    // must pass an absolute url for download\n    player.download();\n  });\n \n  downloadEl.addEventListener(&quot;mouseenter&quot;, e =&gt; {\n    e.preventDefault();\n    e.stopPropagation();\n    tips.style.left = &quot;50%&quot;;\n    let rect = tips.getBoundingClientRect();\n    let rootRect = container.getBoundingClientRect();\n    if (rect.right &gt; rootRect.right) {\n      tips.style.left = `${-rect.right + rootRect.right + 16}px`;\n    }\n  });\n};\n \nPlayer.install(&quot;download&quot;, download);\n原理分析\n下载功能主要是通过动态创建下载按钮并为该按钮绑定 click 事件，当用户触发 click 事件时，在相应的回调函数中使用 downloadjs 这个库实现下载功能。\n扩展分析\n1、获取绝对路径\nexport const getAbsoluteURL = function (url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    const div = document.createElement(&#039;div&#039;)\n    div.innerHTML = `&lt;a href=&quot;${url}&quot;&gt;x&lt;/a&gt;`\n    url = div.firstChild.href\n  }\n  return url\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— 前端下载文件 的6种方法的对比\n地址：\njuejin.im/post/5e50fa23518825494b3cccd7\n\n3.4 播放器贴图\n播放器贴图，不建议改动。源码\n地址：\ngithub.com/bytedance/xgplayer/blob/master/packages/xgplayer/src/control/poster.js\n使用方式\n封面图是当播放器初始化后在用户点击播放按钮前显示的图像。\nnew Player({\n  el:document.querySelector(&#039;#mse&#039;),\n  url: &#039;video_url&#039;,\n  poster: &#039;//abc.com/**/*.png&#039;\n});\n\n配置项：poster\n默认值：”\n参考值：‘i.ytimg.com/vi/lK2ZbbQSHww/hqdefault.jpg’\n\n源码实现\nlet poster = function() {\n  let player = this;\n  let util = Player.util;\n  // util.createDom = function (el = &#039;div&#039;, tpl = &#039;&#039;, attrs = {}, cname = &#039;&#039;)\n  let poster = util.createDom(&quot;xg-poster&quot;, &quot;&quot;, {}, &quot;xgplayer-poster&quot;);\n  let root = player.root;\n  // 是否使用默认的封面图\n  if (player.config.poster) {\n    poster.style.backgroundImage = `url(${player.config.poster})`;\n    root.appendChild(poster);\n  }\n \n  // 监听播放事件，播放时隐藏封面图\n  function playFunc() {\n    poster.style.display = &quot;none&quot;;\n  }\n \n  player.on(&quot;play&quot;, playFunc);\n \n  // 监听销毁事件，执行清理操作\n  function destroyFunc() {\n    player.off(&quot;play&quot;, playFunc);\n    player.off(&quot;destroy&quot;, destroyFunc);\n  }\n \n  player.once(&quot;destroy&quot;, destroyFunc);\n};\n \nPlayer.install(&quot;poster&quot;, poster);\n原理分析\nxgplayer 的插件基于 EventEmitter 事件系统，通过监听播放器的 play 事件来隐藏 poster 海报。此外通过监听播放器的 destory 事件来实现清理操作，比如移除 play 事件的监听器和 destroy 事件。\n扩展分析\n1、  poster.style.backgroundImage = url(${player.config.poster}) 未判断是否为有效 URL 地址\n考虑到代码的健壮性，最好判断一下 player.config.poster 的属性值是否为合法的 URL 地址或 DataURL。另外为了避免用户设置的图片出现问题，导致页面出现异常，可以考虑降级处理，即设置 Fallback 图片。\ndiv {   \n  background-image: url(&#039;placehold.it/1000x1000&#039;), \n    url(&#039;placehold.it/500x500&#039;);\n    background-repeat:no-repeat;\n    background-size: 100%;\n    height:200px;\n    width:200px;\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 ——\nfallback-background-image-if-default-doesnt-exist\n地址：\nstackoverflow.com/questions/37588017/fallback-background-image-if-default-doesnt-exist\n\n3.5 画中画\n播放器画中画功能，不建议改动。源码\n地址：\ngithub.com/bytedance/xgplayer/blob/master/packages/xgplayer/src/control/pip.js\n画中画功能支持用户在浏览网页其它内容时继续以小窗的形式观看视频，同时可以拖拽改变小窗在页面中的 fix 位置。\n使用方式\nnew Player({\n  el:document.querySelector(&#039;#mse&#039;),\n  url: &#039;video_url&#039;,\n  pip: true\n});\n\n配置项：pip\n默认值：false\n参考值：true | false\n\n源码实现\nPiP 插件\nexitPIP () {\n    util.removeClass(this.root, &#039;xgplayer-pip-active&#039;)\n    this.root.style.right = &#039;&#039;\n    this.root.style.bottom = &#039;&#039;\n    this.root.style.top = &#039;&#039;\n    this.root.style.left = &#039;&#039;\n    if (this.config.fluid) {\n      this.root.style[&#039;padding-top&#039;] = `${this.config.height * 100 / this.config.width}%`\n    }\n}\nplayer.getPIP\ngetPIP () {\n    let ro = this.root.getBoundingClientRect()\n    let Top = ro.top\n    let Left = ro.left\n    let dragLay = util.createDom(&#039;xg-pip-lay&#039;, &#039;&lt;div&gt;&lt;/div&gt;&#039;, {}, &#039;xgplayer-pip-lay&#039;)\n    this.root.appendChild(dragLay)\n    let dragHandle = util.createDom(\n      &#039;xg-pip-drag&#039;,\n      &#039;&lt;div class=&quot;drag-handle&quot;&gt;&lt;span&gt;点击按住可拖动视频&lt;/span&gt;&lt;/div&gt;&#039;, {tabindex: 9},    \n      &#039;xgplayer-pip-drag&#039;)\n    this.root.appendChild(dragHandle)\n    let draggie = new Draggabilly(&#039;.xgplayer&#039;, {\n      handle: &#039;.drag-handle&#039;\n    })\n    util.addClass(this.root, &#039;xgplayer-pip-active&#039;)\n    this.root.style.right = 0\n    this.root.style.bottom = &#039;200px&#039;\n    this.root.style.top = &#039;&#039;\n    this.root.style.left = &#039;&#039;\n    if (this.config.fluid) {\n      this.root.style[&#039;padding-top&#039;] = &#039;&#039;\n    }\n    let player = this;\n    [&#039;click&#039;, &#039;touchstart&#039;].forEach(item =&gt; {\n      dragLay.addEventListener(item, function (e) {\n        e.preventDefault()\n        e.stopPropagation()\n        player.exitPIP()\n        player.root.style.top = `${Top}px`\n        player.root.style.left = `${Left}px`\n      })\n    })\n}\nplayer.exitPIP\nexitPIP () {\n    util.removeClass(this.root, &#039;xgplayer-pip-active&#039;)\n    this.root.style.right = &#039;&#039;\n    this.root.style.bottom = &#039;&#039;\n    this.root.style.top = &#039;&#039;\n    this.root.style.left = &#039;&#039;\n    if (this.config.fluid) {\n      this.root.style[&#039;padding-top&#039;] = `${this.config.height * 100 / this.config.width}%`\n    }\n}\n原理分析\n画中画插件通过动态设置播放器根容器的定位信息来实现小窗播放，在进入小窗模式之后，会使用 draggabilly 第三方库，实现在视图区拖拽小窗的功能。\n扩展分析\n1、requestPictureInPicture API\n请求让该 video 元素进入画中画模式，返回一个 promise，如果没有异常，这个 promise 的值会是一个 PictureInPictureWindow 对象，这个对象就代表弹出的那个 PiP 窗口。\nasync function openPiP(video) {\n  try {\n    // 进入画中画模式\n    const pipWindow = await video.requestPictureInPicture() \n    ...\n  } catch (e) {\n    console.error(e) // 处理异常\n  }\n})\n哪一些情况下进入画中画模式会失败？一共有 5 种情况：\n\n操作系统不支持、或者用户通过浏览器选项禁用了此功能，此时 document.pictureInPictureEnabled 属性会返回 false；\n视频文件错误、或者没有视频流只有音频流；\n此次请求不是由用户操作触发的，比如用户没有点击任何按钮，页面自动执行该方法，会被当做恶意行为拦截掉；\n当前页面通过 feature-policy 禁用了画中画特性，此时 document.pictureInPictureEnabled 属性也会返回 false；\n当前 video 元素通过 disablePictureInPicture 属性（HTML 属性和 DOM 属性均可）禁用了画中画特性。\n\n2、video 元素新增的属性 disablePictureInPicture\n通过该属性可以禁用 video 元素的画中画特性，右键菜单中的“画中画”选项会被禁用。\n通过 HTML 属性：\n&lt;video src=&quot;...&quot; disablePictureInPicture&gt;\n通过 DOM 属性：\nvideo.disablePictureInPicture = true。\n3、video 元素新增的事件 enterpictureinpicture 和 leavepictureinpicture\nvideo.addEventListener(&#039;enterpictureinpicture&#039;, function(pipWindow) {\n  // 进入了画中画模式，可以拿到 pipWindow 对象\n});\n \nvideo.addEventListener(&#039;leavepictureinpicture&#039;, function() {\n  // 退出了画中画模式\n});\n4、document 上新增的方法 exitPictureInPicture()\n因为一个页面只能打开一个 PiP 窗口，所以让 video 元素退出画中画模式的方法不在 video 元素自己身上，而在 document 上。这个方法也返回一个 promise，不过 promise 包的值是个 undefined。\n5、document 上新增的属性 pictureInPictureElement 和 pictureInPictureEnabled\n类似于\ndocument.pointerLockElement 和 document.fullscreenElement， document.pictureInPictureElement 会返回当前页面中处于画中画模式的 video 元素，如果没有的话，返回 null。document.pictureInPictureEnabled 上面已经提到过了，在当前页面不支持或被禁用画中画模式的情况下会返回 false，否则返回 true。\n6、PictureInPictureWindow 对象的 API\n从 requestPictureInPicture() 方法的返回值和 enterpictureinpicture 事件的回调参数中可以拿到 pipWindow 对象，该对象有两个属性 width 和 height，还支持一个 resize 事件，在用户改变 PiP 窗口大小时会触发。\nasync function openPiP(video) {\n  const pipWindow = await video.requestPictureInPicture()\n  console.log(pipWindow.width, pipWindow.height) // 打印了默认的窗口大小\n \n  pipWindow.addEventListener(&#039;resize&#039;, function() {\n    console.log(pipWindow.width, pipWindow.height) // 用户改变 PiP 窗口大小时触发\n  })\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— 浏览器中的画中画（Picture-in-Picture）模式及其 API\n地址：\nzhuanlan.zhihu.com/p/38251413\n\n3.6 自定义插件\n开发插件\n// pluginName.js\nimport Player from &#039;xgplayer&#039;;\nlet pluginName=function(player){\n  // 插件逻辑\n}\nPlayer.install(&#039;pluginName&#039;,pluginName);\n使用插件\nimport Player from &#039;xgplayer&#039;;\nlet player = new Player({\n  id: &#039;xg&#039;,\n  url: &#039;//abc.com/**/*.mp4&#039;\n})\n四、其它功能分析\n4.1 获取 HTMLMediaElement 元素网络状态\nHTMLMediaElement.networkState 属性表示在网络上获取媒体的当前状态。其语法如下：\nconst networkState = audioOrVideo.networkState;\n\n使用示例\nget networkState () {\n    let status = [{\n      en: &#039;NETWORK_EMPTY&#039;,\n      cn: &#039;音频/视频尚未初始化&#039;\n    }, {\n      en: &#039;NETWORK_IDLE&#039;,\n      cn: &#039;音频/视频是活动的且已选取资源，但并未使用网络&#039;\n    }, {\n      en: &#039;NETWORK_LOADING&#039;,\n      cn: &#039;浏览器正在下载数据&#039;\n    }, {\n      en: &#039;NETWORK_NO_SOURCE&#039;,\n      cn: &#039;未找到音频/视频来源&#039;\n    }]\n    return this.lang ? this.lang[status[this.video.networkState].en] : \n      status[this.video.networkState].en\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— MDN - networkState\n\n4.2 获取 HTMLMediaElement 元素就绪状态\nHTMLMediaElement.readyState 属性返回音频/视频的当前就绪状态。其语法如下：\n\n\n                  \n                  引用 \n                  \n                \nconst readyState = audioOrVideo. readyState;\n\n\n使用示例\nget readyState () {\n    let status = [{\n      en: &#039;HAVE_NOTHING&#039;,\n      cn: &#039;没有关于音频/视频是否就绪的信息&#039;\n    }, {\n      en: &#039;HAVE_METADATA&#039;,\n      cn: &#039;关于音频/视频就绪的元数据&#039;\n    }, {\n      en: &#039;HAVE_CURRENT_DATA&#039;,\n      cn: &#039;关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒&#039;\n    }, {\n      en: &#039;HAVE_FUTURE_DATA&#039;,\n      cn: &#039;当前及至少下一帧的数据是可用的&#039;\n    }, {\n      en: &#039;HAVE_ENOUGH_DATA&#039;,\n      cn: &#039;可用数据足以开始播放&#039;\n    }]\n    return this.lang ? this.lang[status[this.video.readyState].en] : \n      status[this.video.readyState]\n}\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— MDN - readyState\n\n4.3 X5 内核 H5 同层播放器\n同层页面内播放是标准的视频播放形态，在 video 标签中添加 x5-video-player-type：h5-page 属性来控制网页内部同层播放，可以在视频上方显示 html 元素。\nx5-video-player-fullscreen 全屏方式\n视频播放时将会进入到全屏模式\n如果不申明此属性，页面得到视口区域为原始视口大小(视频未播放前)，比如在微信里，会有一个常驻的标题栏，如果不声明此属性，这个标题栏高度不会给页面，播放时会平均分为两块（上下黑块）\n注： 声明此属性，需要页面自己重新适配新的视口大小变化。可以通过监听resize 事件来实现\n&lt;video id=&quot;test_video&quot; src=&quot;xxx&quot; x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot;/&gt;\n需要监听窗口大小变化（resize）实现全屏\nwindow.onresize = function(){\n test_video.style.width = window.innerWidth + &quot;px&quot;;\n test_video.style.height = window.innerHeight + &quot;px&quot;;\n}\n\n\n                  \n                  注意❗ \n                  \n                \n为了让视频真正铺满全屏，可以适当让 video 的显示区域大于视口区域，这样在显示时在视口外的部截掉后，不会出四周黑边的情况。\n\nx5-video-orientation 控制横竖屏\n功能：声明播放器支持的方向\n可选值： landscape 横屏，portraint 竖屏，默认值：portraint。\n\n\n                  \n                  引用 \n                  \n                \n参考资源 —— H5同层播放器接入规范\n\n4.4 批量导入指定目录下的文件\n在 xgplayer 项目的 index.js 文件中，会使用 import * as Controls from ‘./control/*.js’ 语句来批量导入播放器的所有内置插件：\n// xgplayer/packages/xgplayer/src/index.js\nimport Player from &#039;./player&#039;\nimport * as Controls from &#039;./control/*.js&#039;\nimport &#039;./style/index.scss&#039;\nexport default Player\n批量导入某个目录下的所有文件，这个功能是借助 babel-plugin-bulk-import 这个插件来实现的。除了使用上述插件之外，还可以借助 Webpack context API 来实现，具体如下：\n/**\n * Require Editor modules places in components/modules dir\n * 一个webpack的api，通过执行require.context函数获取一个特定的上下文，主要用来实现自动化导入模块，\n * 在前端工程中，如果遇到从一个文件夹引入很多模块的情况，可以使用这个api，它会遍历文件夹中的指定文件，\n * 然后自动导入使得不需要每次显式的调用import导入模块。\n */\nconst contextRequire = require.context(&quot;./modules&quot;, true);\n \nconst modules = [];\n \ncontextRequire.keys().forEach((filename) =&gt; {\n  /**\n   * Include files if:\n   * - extension is .js or .ts\n   * - does not starts with _\n   */\n  if (filename.match(/^\\.\\/[^_][\\w/]*\\.([tj])s$/)) {\n    modules.push(contextRequire(filename));\n  }\n});"},"C-Knowledge/前端/技术书籍/多媒体前端手册/西瓜播放器":{"title":"西瓜播放器","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/细品西瓜播放器功能分析"],"tags":["编程/FE/音视频"],"content":"扩展阅读\n\n细品西瓜播放器功能分析\n"},"C-Knowledge/前端/技术书籍/多媒体前端手册/视频":{"title":"视频","links":[],"tags":["编程/FE/音视频"],"content":"概览\n视频的基础从概念、容器格式、编码格式展开来讲\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n基本概念码率、帧率、压缩率、分辨率容器格式MP4、AVI、FLV、TS, M3U8、WebM、OGV、MOV编码格式H.265、H.264、AV1、VP9\n视频编码概览\n这幅图从时间顺序来表示了不同厂商对应的编码标准的发展：\n\n常见视频容器格式对应编码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n容器格式视频编码音频编码mp4mpeg4或h.264或h.265mpeg4 aacavimpeg4mp3或pcm_s161eflvXvidmp3wmvwmv3xwma7x\n下一步\n接下来进入视频具体章节，你可以选择阅读基础概念、容器格式、编码格式，这三者并没有顺序限制～"},"C-Knowledge/前端/技术书籍/多媒体前端手册/解封装(demux)":{"title":"解封装(demux)","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/解码"],"tags":["编程/FE/音视频"],"content":"引言\n解封装是整个播放器当中的重要环节，它起到的承上启下的关键作用。当拿到一个封装格式的文件时，播放器要如何解析并识别？后续文章将为你揭晓答案！\nmux 及 demux 基本介绍\nmux 为 Multiplex 的缩写，封装之意，而 demux 即为解封。\n通过 muxing（混流），可以将视频流、音频流甚至是字幕流合并到一个单独的文件中，作为一个信号进行传输。等传输完毕，就可以通过 demux（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。\n在理解demux之前，需要知道一些基本知识：\nES(Elementary Stream)：单独的一路视频、一条音频、一个字幕或者单个的附加数据。一般来说，多媒体文件有一个视频 ES、一个音频 ES 和一个字幕 ES(字幕并不是所有视频都有)。一般 ES 流是以 NAL 的（想了解 NAL 不要着急，后续解码章节将为你解释）形式存在的。\n为什么要demux\ndemux是视频播放中的重要流程。\n多媒体（Multimedia）是多种媒体的综合，一般包括文本，声音和图像等多种媒体形式。同样多媒体文件是一个将多种媒体封装在一起的复杂文件，在多媒体文件开始播放的时候，需要把图像、声音、字幕(可能不存在)等基本流分离出来，这个分离的行为和过程就是解封装(demux)。\n而分离出来的各个基本流（ES）分别送给视频解码器、音频解码器等解码后才能得到图像声音。\nDemux发生的过程：\n\ndemux的使用\n宏观角度上说，解封装之后获得图像、声音、字幕(可能不存在)等基本流，而后基本流可以通过解码器进行解码。\ndemux图解：\n\ndemux的使用\n无论是何种播放器，需要播放多媒体文件时，必须先对容器封装格式进行解封装(demux)，解封后解码才可播放。\n想了解更多关于解码的知识，可以学习下一章解码，下一章将带你进入解码世界"},"C-Knowledge/前端/技术书籍/多媒体前端手册/解码":{"title":"解码","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/视频播放-Seek-的基本原理","C-Knowledge/前端/技术书籍/多媒体前端手册/SPS和PPS","C-Knowledge/前端/技术书籍/多媒体前端手册/PCM","C-Knowledge/前端/职业规划/前端面试宝典/八股文/平时说的软解和硬解，具体是什么！","C-Knowledge/前端/技术书籍/多媒体前端手册/IBP帧"],"tags":["编程/FE/音视频"],"content":"引言\n通过前面的学习，你大致已经知道了关于demux的播放器行为，对于demux(解封装)之后基本流的解码相信已经也有了宏观上的认知。\n本章节将会带你进入解码的世界。\n想知道多媒体文件中有什么？视频是如何一帧一帧串起来的？播放器如何播放一个多媒体文件，在播放之前播放器内核到底做了哪些事情？\n带着这些问题，阅读后面章节，将为你一一解开视频解码的神秘面纱。\n但在此之前，你需要对目前主流的H.264编码的网络传输数据有一个大致了解，这样有助于对后续章节的理解。\nH.264 分层概念\n了解编码的基本一些概念之前，需要了解一些知识。\n以H.264/AVC这一视频编码标准，系统框架分为两层：视频编码层面（Video Coding Layer，简称VCL）和网络抽象层面（Network Abstraction Layer，简称NAL）。\nVCL\n\nVCL负责表示有效视频数据的内容。\nVCL层是对核心算法引擎、块、宏块及片的语法级别的定义，最终输出压缩编码后的数据 SODB。NAL层将SODB打包成RBSP然后加上NAL头，组成一个NALU（NAL单元）。\n\nNAL\n\nNAL 负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。\n\n\n\n                  \n                  提示💡 \n                  \n                \n附：\nSODB(String ofData Bits，即数据比特串)：VCL 最原始的编码数据。RBSP(Raw ByteSequence Payload，即原始字节序列载荷)：对 SODB 的重新添加封装。\n\nNALU是什么\nNAL unit(NALU)是NAL层单元流的基本语法结构，它包含一个字节的头信息（NALU header）和一系列来自VCL的原始数据字节流（RBSP）。每个NALU是一个一定字语法元素的可变长字节字符串，包括1Byte的头信息（标识后面的RBSP数据类型），以及若干个整数字节的原始字节序列负荷（RBSP）。\n\nNALU header:\nNALU header 主要标识后面的RBSP是什么类型的数据。\n长度为1 Byte，包含：\n\nforbidden_bit(1bit)\nnal_reference_bit(2bit)\nnal_unit_type(5bit)\n\nRBSP数据\n一个NALU可以携带一个SEI或一个序列****参数集或一个图像参数集(后面都会具体介绍这些东西是什么)。\nH.264采用NALU接入可适用多种网络，提高了容错能力，比如说根据NALU header可发现丢失的是哪一个VCL单元，冗余编码图像使得基本编码图像丢失仍可得到较“粗糙”的图像。\n附：H.264 nal_unit_type****表：\n0      Unspecified                                                    non-VCL\n1      Coded slice of a non-IDR picture                               VCL\n2      Coded slice data partition A                                   VCL\n3      Coded slice data partition B                                   VCL\n4      Coded slice data partition C                                   VCL\n5      Coded slice of an IDR picture                                  VCL\n6      Supplemental enhancement information (SEI)                     non-VCL\n7      Sequence parameter set                                         non-VCL\n8      Picture parameter set                                          non-VCL\n9      Access unit delimiter                                          non-VCL\n10     End of sequence                                                non-VCL\n11     End of stream                                                  non-VCL\n12     Filler data                                                    non-VCL\n13     Sequence parameter set extension                               non-VCL\n14     Prefix NAL unit                                                non-VCL\n15     Subset sequence parameter set                                  non-VCL\n16     Depth parameter set                                            non-VCL\n17..18 Reserved                                                       non-VCL\n19     Coded slice of an auxiliary coded picture without partitioning non-VCL\n20     Coded slice extension                                          non-VCL\n21     Coded slice extension for depth view components                non-VCL\n22..23 Reserved                                                       non-VCL\n24..31 Unspecified                                                    non-VCL\n\nNALU类型\nNALU 类型有很多，其中重要的有 SPS、PPS 和帧。\n\n解码是什么？主要做了些什么？\n通过前面的学习，我们已经了解到，NALU作为基本的NAL层传输单位，在码流中无处不在，并且不同的NALU有着不同的功能，解码就是对基本流中的NALU中的各项类型进行拆分解析，并生成对应可播放产物。\n\n音频视频播放器没有办法直接使用基本码流播放，必须将基本码流解码成细化图像及数据(对应产物)才能输送到对应的播放器播放。\n解码产物\n\n音频解码获得的数据是PCM采样数据，称为: sample\n视频解码获得的数据是一幅YUV或RGB图像数据，称为: picture\n\n附：\n目前中比较常见的音频编码方式：AAC、MP3等视频常见编码方式：H.264、H.265等\n得到对应数据后，就可以输送给对应的音视频处理器播放处理。\n解码方式：硬解和软解\n硬解：通过硬件实现的解码称为硬解码。\n\n优点：播放流畅、低功耗、效率高\n缺点：受视频格式限制、效果可能没有软解好\n\n软解：通过软件实现的解码称为软解码。\n\n优点：不受视频格式限制、画质略好于硬解\n缺点：占用过高CPU的资源、功耗略高、对高清视频可能没有硬解流畅\n\n总结\n关于解码，相信你现在有了一定的了解，实际上解码就是将demux后得到基本码流进行再次以对应的编码格式进行解码的行为。\n现在你可以去学习下一个小章节关于NALU中包含的信息：SPS和PPS，IBP帧等。"},"C-Knowledge/前端/技术书籍/多媒体前端手册/采样大小":{"title":"采样大小","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/比特率"],"tags":["编程/FE/音视频"],"content":"简介\n一秒钟所采的样本数为比特率，每个样本中信息的比特数就是位深，即采样精度，单位为Bit\n用来衡量声音波动变化的参数，是指声卡在采集和播放声音文件时所使用数字声音信号的二进制位数，有8位，16位，24位等。这个数值越大，解析度就越高，录制和回放的声音就越真实。\n\n计算公式\n\n应用场景\n\n16Bit：动态范围大概是96dB，适用于普通流行歌曲。\n24Bit：动态范围大概是144dB，一般用于电影配乐，交响乐团等等大动态的音频信号。\n\n下一步\n接下来让我们来了解下比特率的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/采样率":{"title":"采样率","links":["C-Knowledge/前端/技术书籍/多媒体前端手册/采样大小"],"tags":["编程/FE/音视频"],"content":"简介\n音频采样率是指录音设备在一秒钟内对声音信号的采样次数，采样频率越高声音的还原就越真实越自然。\n\n常用的采样率\n\n8,000 Hz - 电话所用采样率\n11,025 Hz-AM调幅广播所用采样率\n22,050 Hz和24,000 Hz- FM调频广播所用采样率\n32,000 Hz - miniDV 数码视频 camcorder、DAT (LP mode)所用采样率\n44,100 Hz - 音频 CD, 也常用于 MPEG-1 音频（VCD, SVCD, MP3）所用采样率\n47,250 Hz - 商用 PCM 录音机所用采样率\n48,000 Hz - miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率\n50,000 Hz - 商用数字录音机所用采样率\n96,000 或者 192,000 Hz - DVD-Audio、一些 LPCM DVD 音轨、BD-ROM（蓝光盘）音轨、和 HD-DVD （高清晰度 DVD）音轨所用所用采样率\n2.8224 MHz - Direct Stream Digital 的 1 位 sigma-delta modulation 过程所用采样率。\n\n下一步\n接下来让我们来了解下采样大小的概念"},"C-Knowledge/前端/技术书籍/多媒体前端手册/音频":{"title":"音频","links":[],"tags":["编程/FE/音视频"],"content":"\n概览\n音频的基础从概念、容器格式、编码格式展开来讲\n\n音频容器格式对应编码\n\n下一步\n接下来进入音频具体章节，你可以选择阅读基础概念、容器格式、编码格式，这三者并没有顺序限制～"},"C-Knowledge/前端/技术书籍/多媒体前端手册/音频压缩率":{"title":"音频压缩率","links":[],"tags":["编程/FE/音视频"],"content":"简介\n音频压缩率：原始音频数据与通过PCM等压缩编码技术压缩后的数据大小的比率\n压缩率一般用10:1来表示，这种表示也称为压缩系数。10代表未压缩的数据大小\n常见容器格式压缩率\n\n\n\n                  \n                  注意❗ \n                  \n                \n注：压缩率为 1 的为无损压缩，越接近 0 压缩后的文件越小\n\n下一步\n本章对于音频的基础概念已经叙述完毕，你可以选择阅读容器格式、编码格式，这两者并没有顺序限制～"},"C-Knowledge/前端/技术书籍/技术书籍📚":{"title":"技术书籍📚","links":["C-Knowledge/前端/技术书籍/ES6-入门教程/ES6-入门教程","C-Knowledge/前端/技术书籍/前端面试之道/前端面试之道","C-Knowledge/前端/技术书籍/JavaScript教程/JavaScript-教程","C-Knowledge/前端/技术书籍/HTML-教程/HTML-教程","C-Knowledge/前端/技术书籍/CSS世界/CSS世界","C-Knowledge/前端/技术书籍/CSS-新世界/CSS-新世界","C-Knowledge/前端/技术书籍/TypeScript教程/TypeScript-教程","C-Knowledge/前端/技术书籍/Web-API-教程/Web-API-教程","C-Knowledge/前端/技术书籍/从-0-打造音视频直播系统/从-0-打造音视频直播系统","C-Knowledge/前端/技术书籍/探索three.js/探索three.js","C-Knowledge/前端/技术书籍/多媒体前端手册/多媒体前端手册","C-Knowledge/前端/技术书籍/前端性能优化手册/前端性能优化手册","C-Knowledge/前端/技术书籍/数据结构手册/数据结构手册","C-Knowledge/前端/技术书籍/算法手册/算法手册","C-Knowledge/读书笔记/《人生元编程》","C-Knowledge/读书笔记/《黑客与画家》Paul-Graham·著-阮一峰·译"],"tags":["编程/书籍"],"content":"大前端\n\nES6 入门教程\n前端面试之道\nJavaScript 教程\nHTML 教程\nCSS世界\nCSS 新世界\nTypeScript 教程\nWeb API 教程\n从 0 打造音视频直播系统\n探索three.js\n多媒体前端手册\n前端性能优化手册\n\n计算机基础\n\n数据结构手册\n算法手册\n\n互联网\n\n《人生元编程》\n《黑客与画家》Paul Graham·著 阮一峰·译\n"},"C-Knowledge/前端/技术书籍/探索three.js/探索three.js":{"title":"探索three.js","links":["C-Knowledge/前端/技术书籍/探索three.js/欢迎来到《探索three.js》!","C-Knowledge/前端/技术书籍/探索three.js/如何使用本书","C-Knowledge/前端/技术书籍/探索three.js/运行-three.js-应用程序需要什么！","C-Knowledge/前端/技术书籍/探索three.js/欢迎来到我们的社区：网络上无处不在的three.js","C-Knowledge/前端/技术书籍/探索three.js/GitHub-上的three.js---魔法出现的地方","C-Knowledge/前端/技术书籍/探索three.js/如何在你的项目中引入three.js","C-Knowledge/前端/技术书籍/探索three.js/将-three.js-与-React、Vue.js、Angular、Svelte、TypeScript-等一起使用","C-Knowledge/前端/技术书籍/探索three.js/入门：真正的乐趣从这里开始！","C-Knowledge/前端/技术书籍/探索three.js/Three.js应用的结构","C-Knowledge/前端/技术书籍/探索three.js/你的第一个-three.js-场景：你好，立方体！","C-Knowledge/前端/技术书籍/探索three.js/介绍世界应用程序","C-Knowledge/前端/技术书籍/探索three.js/基于物理的渲染和照明","C-Knowledge/前端/技术书籍/探索three.js/变换和坐标系","C-Knowledge/前端/技术书籍/探索three.js/使我们的场景具有响应性（以及处理锯齿）","C-Knowledge/前端/技术书籍/探索three.js/动画循环","C-Knowledge/前端/技术书籍/探索three.js/纹理映射简介","C-Knowledge/前端/技术书籍/探索three.js/使用相机控制插件扩展three.js","C-Knowledge/前端/技术书籍/探索three.js/环境光：来自各个方向的光照","C-Knowledge/前端/技术书籍/探索three.js/组织你的场景","C-Knowledge/前端/技术书籍/探索three.js/内置几何体","C-Knowledge/前端/技术书籍/探索three.js/以glTF格式加载3D模型","C-Knowledge/前端/技术书籍/探索three.js/three.js动画系统","C-Knowledge/前端/技术书籍/探索three.js/Three.js-技巧和窍门大清单！"],"tags":["编程/FE/Three"],"content":"欢迎来到《探索three.js》!\n\n如何使用本书\n运行 three.js 应用程序需要什么！\n欢迎来到我们的社区：网络上无处不在的three.js\nGitHub 上的three.js - 魔法出现的地方\n如何在你的项目中引入three.js\n将 three.js 与 React、Vue.js、Angular、Svelte、TypeScript 等一起使用\n\n入门：真正的乐趣从这里开始！\n\nThree.js应用的结构\n你的第一个 three.js 场景：你好，立方体！\n介绍世界应用程序\n基于物理的渲染和照明\n变换和坐标系\n使我们的场景具有响应性（以及处理锯齿）\n动画循环\n纹理映射简介\n使用相机控制插件扩展three.js\n环境光：来自各个方向的光照\n组织你的场景\n内置几何体\n以glTF格式加载3D模型\nthree.js动画系统\n\n附录\n\n本书中使用的 HTML 和 CSS\nJavaScript 参考\n文档对象模型（DOM）和 DOM API\nJavaScript 模块\n异步 JavaScript\n处理不同的 three.js 版本\nThree.js 技巧和窍门大清单！\n"},"C-Knowledge/前端/技术书籍/数据结构手册/数据结构手册":{"title":"数据结构手册","links":[],"tags":["编程/数据结构"],"content":"二叉树\n\n二叉树-概览\n二叉树的基本操作⭐⭐\n二叉树的中序遍历⭐⭐\n二叉树的前序遍历⭐⭐\n二叉树的后序遍历⭐⭐\n重建二叉树⭐⭐\n求二叉树的遍历⭐⭐\n对称的二叉树⭐⭐\n二叉树的镜像⭐⭐\n二叉搜索树的第k个节点⭐⭐\n二叉搜索树的后序遍历⭐⭐\n二叉树的最大深度⭐⭐\n二叉树的最小深度⭐⭐\n平衡二叉树⭐⭐\n不分行从上到下打印二叉树⭐⭐\n把二叉树打印成多行⭐⭐\n二叉树中和为某一值的路径⭐⭐⭐\n二叉搜索树与双向链表⭐⭐⭐\n按之字形顺序打印二叉树⭐⭐⭐\n序列化二叉树⭐⭐⭐\n二叉树的下一个节点⭐⭐⭐\n树的子结构⭐⭐⭐\n\n#链表\n\n链表-概览\n删除链表中的节点or重复的节点⭐⭐\n从尾到头打印链表⭐⭐\n链表倒数第k个节点⭐⭐\n反转链表⭐⭐\n复杂链表的复制⭐⭐\n两个链表的第一个公共节点⭐⭐\n圈圈中最后剩下的数字⭐⭐\n链表中环的入口节点⭐⭐⭐\n\n#字符串\n\n替换空格⭐⭐\n表示数值的字符串⭐⭐\n字符流中第一个不重复的字符⭐⭐\n字符串的排列⭐⭐\n字符串翻转⭐⭐\n正则表达式匹配⭐⭐⭐\n\n#栈和队列\n\n栈和队列-概览\n用两个栈实现队列⭐⭐\n包含min函数的栈⭐⭐\n栈的压入弹出序列⭐⭐\n滑动窗口的最大值⭐⭐⭐\n\n#数组\n\n数组-概览\n调整数组顺序使奇数位于偶数前面 ⭐⭐\n在排序数组中查找数字⭐⭐\n数组中出现次数超过数组长度一半的数字⭐⭐\n连续子数组的最大和 ⭐⭐\n把数组排成最小的数 ⭐⭐\n第一个只出现一次的字符 ⭐⭐\n扑克牌顺子 ⭐⭐\n和为S的两个数字 ⭐⭐\n两数之和 ⭐⭐\n三数之和 ⭐⭐⭐\n四数之和 ⭐⭐⭐\n和为S的连续正整数序列 ⭐⭐⭐\n构建乘积数组 ⭐⭐⭐\n顺时针打印矩阵 ⭐⭐⭐\n数组中的逆序对⭐⭐⭐\n\n#堆\n\n堆-概览\n堆的基本操作⭐⭐⭐\n数据流中的中位数⭐⭐⭐\n最小的k个数⭐⭐⭐\n\n#哈希表\n\n哈希表-概览\n\n扩展阅读\n\n手写JS 实现几种数据结构\n万字总结 JS数据结构与常用的算法\n常见数据结构和Javascript实现总结\n"},"C-Knowledge/前端/技术书籍/算法手册/算法手册":{"title":"算法手册","links":[],"tags":["编程/算法"],"content":"排序\n\n复杂度\n排序-概览\n冒泡排序⭐⭐\n插入排序⭐⭐\n选择排序⭐⭐\n堆排序⭐⭐⭐\n快速排序⭐⭐⭐\n归并排序⭐⭐⭐\n\n#分治\n\n数组中的逆序对⭐⭐⭐\n\n#数学运算\n\n二进制中1的个数⭐⭐\n数值的整数次方⭐⭐\n数组中只出现一次的数字⭐⭐\n不用加减乘除做加法⭐⭐\n字符串转换成整数⭐⭐\n整数中1出现的次数⭐⭐⭐\n1+2+3+…+n⭐⭐⭐\n丑数⭐⭐⭐\n\n#查找\n\n查找-概览\n二维数组查找⭐⭐\n在排序数组中查找数字⭐⭐\n整数中1出现的次数⭐⭐\n\n#DFS和BFS\n\nDFS和BFS-概览\n\n#递归和循环\n\n递归-概览\n斐波拉契数列⭐⭐\n跳台阶⭐⭐\n变态跳台阶⭐⭐\n矩形覆盖⭐⭐\n\n#回溯算法\n\n回溯-概览\n二叉树中和为某一值的路径⭐⭐⭐\n字符串的排列⭐⭐⭐\n和为sum的n个数⭐⭐⭐\n矩阵中的路径⭐⭐⭐\n机器人的运动范围⭐⭐⭐\nN皇后问题⭐⭐⭐\nN皇后问题2⭐⭐⭐\n\n#动态规划\n\n动态规划-概览\n斐波拉契数列⭐⭐\n最小路径和⭐⭐⭐\n打家劫舍⭐⭐⭐\n\n#贪心算法\n\n贪心算法-概览\n分发饼干⭐⭐\n"},"C-Knowledge/前端/编程基础/网络/JWT":{"title":"JWT","links":[],"tags":["编程/网络"],"content":"一、常规认证的问题\n\n另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n二、JWT 的原理\nJWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n{\n  &quot;姓名&quot;: &quot;张三&quot;,\n  &quot;角色&quot;: &quot;管理员&quot;,\n  &quot;到期时间&quot;: &quot;2018 年 7 月 1 日 0 点 0 分&quot;\n}\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\nJWT 的认证流程：\n\n\n浏览器发起请求登陆，携带用户名和密码；\n\n\n服务端根据用户名和明码到数据库验证身份，根据算法，将用户标识符打包生成 token,\n\n\n服务器返回JWT信息给浏览器，JWT不应该包含敏感信息，这是很重要的一点\n\n\n浏览器发起请求获取用户资料，把刚刚拿到的 token一起发送给服务器，一般放在header里面，字段为authorization\n\n\n服务器发现数据中有 token，decode token的信息，然后再次签名，验明正身；\n\n\n服务器返回该用户的用户资料；\n\n\n服务器可以在payload设置过期时间， 如果过期了，可以让客户端重新发起验证。\n\n\n\n三、JWT 的数据结构\n实际的 JWT 大概就像下面这样。\n\n它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。\nJWT 的三个部分依次如下。\n\n\nHeader（头部）\nPayload（负载）\nSignature（签名）\n\n\n写成一行，就是下面的样子。\n\n \nHeader.Payload.Signature\n\n\n下面依次介绍这三个部分。\n3.1 Header\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。\n{\n  &quot;alg&quot;: &quot;HS256&quot;,\n  &quot;typ&quot;: &quot;JWT&quot;\n}\n上面代码中，alg 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ 属性表示这个令牌（token）的类型（type），JWT 令牌统一写为 JWT。\n最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。\n3.2 Payload\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\n\n\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n\n \n{\n  &quot;sub&quot;: &quot;1234567890&quot;,\n  &quot;name&quot;: &quot;John Doe&quot;,\n  &quot;admin&quot;: true\n}\n\n注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n这个 JSON 对象也要使用 Base64URL 算法转成字符串。\n3.3 Signature\nSignature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n\n \nHMACSHA256(\n  base64UrlEncode(header) + &quot;.&quot; +\n  base64UrlEncode(payload),\n  secret)\n\n算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。\n3.4 Base64URL\n前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。\nJWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/）。Base64 有三个字符 +、/ 和 = ，在 URL 里面有特殊含义，所以要被替换掉：= 被省略、+ 替换成 -，/ 替换成 _ 。这就是 Base64URL 算法。\n四、JWT 的使用方式\n客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。\nAuthorization: Bearer &lt;token&gt;\n通过 url 传输（不推荐）\nwww.xxx.com/pwa\n\n如果是post请求也可以放在请求体中\n另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。\n五、JWT 的几个特点\n（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。 也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n六、在 koa 项目中使用\n可以使用现成库，jwt-simple 或者 jsonwebtoken\nlet Koa = require(&#039;koa&#039;);\nlet Router = require(&#039;koa-router&#039;);\nlet bodyparser = require(&#039;koa-bodyparser&#039;);\nlet jwt = require(&#039;jwt-simple&#039;);\nlet router = new Router()\nlet app = new Koa();\napp.use(bodyparser());\n// 可以自己自定义\nlet secret = &#039;zhenglei&#039;;\n// 验证是否登陆\nrouter.post(&#039;/login&#039;,async(ctx)=&gt;{ \n    let {username,password} = ctx.request.body;\n    if(username === &#039;admin&#039; &amp;&amp; password === &#039;admin&#039;){\n       // 通常会查数据库，这里简单的演示\n       let token =  jwt.encode(username, secret);\n       ctx.body = {\n            code:200,\n            username,\n            token,\n       }\n    }\n});\n// 验证是否有权限\nrouter.get(&#039;/validate&#039;,async(ctx)=&gt;{ \n    let Authorization = ctx.get(&#039;authorization&#039;)\n    let [,token] = Authorization.split(&#039; &#039;);\n    if(token){\n        try{\n            let r = jwt.decode(token,secret);\n            ctx.body = {\n                code:200,\n                username:r,\n                token\n            }\n        }catch(e){\n            ctx.body = {\n                code:401,\n                data:&#039;没有登陆&#039;\n            }\n        }\n    }else{\n        ctx.body = {\n            code:401,\n            data:&#039;没有登陆&#039;\n        }\n    }\n  \n});\napp.use(router.routes());\napp.listen(4000);\n\n\n实现两个接口一个是 /login 验证是否登录，一个是 validate,验证是否有权限\n\n\n请求login接口的时候，客户端带username和password, 后端一般会查数据库，验证是否存在当前用户，如果存在则为username进行签名，千万不要给password这些敏感信息也带进来签名\n\n\n客户端接收后端给的token令牌，再请求其他接口，比如这个例子的/validate的时候，ajax请求的时候，可以在header指定authorization字段，后端拿到token进行decode，然后将header和payload进行再一次的签名，如果前后的签名一致，说明没有被篡改过，则权限验证通过。因为是同步的过程，所以可以用try catch来捕捉错误\n\n\n七、原理的实现\n\n\nsha256哈希算法，可以用 nodejs 的内置加密模块 crypto, 生成 base64字符串，要注意的是生成 base64需要为+ - = 做一下替换，=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。\n\n\ntoken令牌的组成是header, payload和sigin的通过.来组成\n\n\nbase64urlUnescape的解码是固定写法，decode出base64的内容\n\n\nlet myJwt = {\n    sign(content,secret){\n        let r = crypto.createHmac(&#039;sha256&#039;,secret).update(content).digest(&#039;base64&#039;);\n        return this.base64urlEscape(r)\n    },\n    base64urlEscape(str){\n        return str.replace(/\\+/g, &#039;-&#039;).replace(/\\//g, &#039;_&#039;).replace(/=/g, &#039;&#039;);\n    },\n    toBase64(content){\n        return this.base64urlEscape(Buffer.from(JSON.stringify(content)).toString(&#039;base64&#039;))\n    },\n    encode(username,secret){\n        let header = this.toBase64({ typ: &#039;JWT&#039;, alg: &#039;HS256&#039; });\n        let content = this.toBase64(username);\n        let sign = this.sign([header,content].join(&#039;.&#039;),secret);\n        return  [header,content,sign].join(&#039;.&#039;)\n    },\n    base64urlUnescape(str) {\n        str += new Array(5 - str.length % 4).join(&#039;=&#039;);\n        return str.replace(/\\-/g, &#039;+&#039;).replace(/_/g, &#039;/&#039;);\n    },\n    decode(token,secret){\n        let [header,content,sign] = token.split(&#039;.&#039;);\n        let newSign = this.sign([header,content].join(&#039;.&#039;),secret);\n        if(sign === newSign){\n            return Buffer.from(this.base64urlUnescape(content),&#039;base64&#039;).toString();\n        }else{\n            throw new Error(&#039;被篡改&#039;)\n        }\n    }\n}\n八、参考资料\n\n如何使用 NodeJS 实现 JWT 原理\nJSON Web Token 入门教程\n"},"C-Knowledge/前端/编程基础/网络/说说HTTP-常见的状态码有哪些，适用场景！":{"title":"说说HTTP 常见的状态码有哪些，适用场景！","links":["C-Knowledge/前端/编程基础/网络/502（错误网关）","C-Knowledge/前端/技术书籍/前端面试之道/浏览器缓存机制"],"tags":["编程/网络/HTTP"],"content":"一、是什么\nHTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码\n它由 RFC 2616规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展\n简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态\n二、分类\n状态码第一位数字决定了不同的响应状态，有如下：\n\n1 表示消息\n2 表示成功\n3 表示重定向\n4 表示请求错误\n5 表示服务器错误\n\n1xx：消息\n代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\n常见的有：\n\n100 Continue（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx：成功\n代表请求已成功被服务器接收、理解、并接受\n常见的有：\n\n200 OK（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n201 Created（已创建）：请求成功并且服务器创建了新的资源\n202 Accepted（已创建）：服务器已经接收请求，但尚未处理\n203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n204（无内容）：服务器成功处理请求，但没有返回任何内容\n205（重置内容）：服务器成功处理请求，但没有返回任何内容\n206（部分内容）：服务器成功处理了部分请求\n\n3xx：重定向\n表示要完成请求，需要客户端采取进一步的操作才能完成请求。通常，这些状态代码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。\n常见的有：\n\n300 （多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n301 Moved Permanently（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302 Found（临时移动）： 临时性重定向。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303 See Other（查看其他位置）：临时性重定向，且总是使用 GET 请求新的 URI。请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n304 Not Modified：自从上次请求后，请求的网页未修改过。\n305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx：请求错误\n代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。\n常见的有：\n\n400 Bad Request（错误请求）： 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n401 Unauthorized（未授权）： 请求未授权，要求身份验证。对于需要登录的网页，服务器可能返回此响应。\n403 Forbidden（禁止）： 服务器拒绝请求\n404 Not Found（未找到）： 找不到如何与 URI 相匹配的资源。\n405（方法禁用）： 禁用请求中指定的方法\n406（不接受）： 无法使用请求的内容特性响应请求的网页\n407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n408（请求超时）： 服务器等候请求时发生超时\n\n5xx：服务器错误\n表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理 （5、6字头）。\n常见的有：\n\n500  Internal Server Error（服务器内部错误）：服务器遇到错误，无法完成请求\n501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n503 Service Unavailable（服务不可用）：服务器端暂时无法处理请求（由于超载或停机维护）\n504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n三、适用场景\n下面给出一些状态码的适用场景：\n\n100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输\n206：一般用来做断点续传，或者是视频文件等大文件的加载\n301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名\n302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面\n304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分\n400：参数有误，请求无法被服务器识别\n，403：服务器拒绝执行客户端的请求，告诉客户端禁止访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回\n404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时\n503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503\n504：网关超时\n\n总结\n\n1 xx：指示信息类，表示请求已接受，继续处理（临时响应）\n2 xx：指示成功类，表示请求已成功接受\n3 xx：指示重定向，表示要完成请求必须进行更进一步的操作\n4 xx：指示客户端错误，请求有语法错误或请求无法实现\n5 xx：指示服务器错误，服务器未能实现合法的请求\n\n参考文献\n\nzh.wikipedia.org/wiki/HTTP状态码\nkebingzao.com/2018/10/05/http-status-code/\nvue3js.cn/interview\n"},"C-Knowledge/前端/编程思想":{"title":"编程思想","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！","C-Knowledge/前端/什么是链式调用！"],"tags":["编程/思想"],"content":"\n什么是函数式编程？\n什么是链式调用！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/!important-的作用和弊端，如何避免！":{"title":"!important 的作用和弊端，如何避免！","links":[],"tags":["编程/FE/CSS"],"content":"\n作用\n!important 可以忽略选择器 CSS 选择器优先级，让声明的属性总是生效\n弊端\n\n破坏原 CSS 级联规则，增加调试难度\n修改样式变得困难\n污染全局样式\n\n\n避免\n\n用 CSS 选择器优先级解决样式冲突\n不在全局、会被复用的插件中使用 !important\n通过 CSS 命名或 Shadow DOM 限制 CSS 作用域\n\n\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/==-、-===--和-Object.is()-的区别是什么！分别在什么情况使用":{"title":"== 、 ===  和 Object.is() 的区别是什么！分别在什么情况使用","links":[],"tags":["编程/JavaScript"],"content":"一、等于操作符\n等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true\n前面文章，我们提到在 JavaScript 中存在隐式转换。等于操作符（ == ）在比较中会先进行类型转换，再确定操作数是否相等\n遵循以下规则：\n如果任一操作数是布尔值，则将其转换为数值再比较是否相等\nlet result1 = (true == 1); // true\n如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等\nlet result1 = (&quot;55&quot; == 55); // true\n如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较\nlet obj = {valueOf:function(){return 1}}\nlet result1 = (obj == 1); // true\nnull和undefined相等\nlet result1 = (null == undefined ); // true\n如果有任一操作数是 NaN ，则相等操作符返回 false\nlet result1 = (NaN == NaN ); // false\n如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true\nlet obj1 = {name:&quot;xxx&quot;}\nlet obj2 = {name:&quot;xxx&quot;}\nlet result1 = (obj1 == obj2 ); // false\n下面进一步做个小结：\n\n两个都为简单类型，字符串和布尔值都会转换成数值，再比较\n简单类型与引用类型比较，对象转化成其原始类型的值，再比较\n两个都为引用类型，则比较它们是否指向同一个对象\nnull 和 undefined 相等\n存在 NaN 则返回 false\n\n二、全等操作符\n全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同\nlet result1 = (&quot;55&quot; === 55); // false，不相等，因为数据类型不同\nlet result2 = (55 === 55); // true，相等，因为数据类型相同值也相同\nundefined 和 null 与自身严格相等\nlet result1 = (null === null)  //true\nlet result2 = (undefined === undefined)  //true\n三、区别\n相等操作符（  ）会做类型转换，再进行值的比较，全等运算符不会==做类型转换\nlet result1 = (&quot;55&quot; === 55); // false，不相等，因为数据类型不同\nlet result2 = (55 === 55); // true，相等，因为数据类型相同值也相同\nnull 和 undefined 比较，相等操作符（ == ）为 true，全等为 false\nlet result1 = (null == undefined ); // true\nlet result2 = (null  === undefined); // false\n小结\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果\n&#039;&#039; == &#039;0&#039; // false\n0 == &#039;&#039; // true\n0 == &#039;0&#039; // true\n \nfalse == &#039;false&#039; // false\nfalse == &#039;0&#039; // true\n \nfalse == undefined // false\nfalse == null // false\nnull == undefined // true\n \n&#039; \\t\\r\\n&#039; == 0 // true\n但在比较null的情况的时候，我们一般使用相等操作符==\nconst obj = {};\n \nif(obj.x == null){\n  console.log(&quot;1&quot;);  //执行\n}\n等同于下面写法\nif(obj.x === null || obj.x === undefined) {\n    ...\n}\n使用相等操作符（ == ）的写法明显更加简洁了\nJavaScript 提供三种不同的值比较操作：\n\n严格相等比较，使用 ===\n抽象相等比较，使用 ==\n以及 Object.is （ECMAScript 2015/ ES6 新特性）\n\n简而言之，在比较两件事情时：\n\n== 将执行类型转换\n=== 将进行相同的比较，不做类型转换\nObject.is 除下面三个值外，表现与 === 相同\n\n-0 和 +0 不相等\nObject.is(NaN，NaN) 为 true\n\n\n\n所以，除了在比较对象属性为 null 或者 undefined 的情况下，我们可以使用相等操作符（  ），其他情况建议一律使用全等操作符（ = ）"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel八股文":{"title":"Babel八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel是什么！它的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel有哪些新特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel是如何将ES6+代码转换为可在旧版浏览器中运行的代码的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel的预设是什么！如何使用预设！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel的配置文件是什么！如何创建和使用配置文件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel支持哪些JavaScript语法和特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换哪些浏览器不支持的JavaScript特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换React的JSX语法吗！如何配置Babel来支持JSX！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换TypeScript代码吗！如何配置Babel来支持TypeScript！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换ES模块吗！如何配置Babel来支持ES模块！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换动态导入语法吗！如何配置Babel来支持动态导入！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换装饰器语法吗！如何配置Babel来支持装饰器！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换类属性语法吗！如何配置Babel来支持类属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换异步生成器函数吗！如何配置Babel来支持异步生成器函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换箭头函数吗！如何配置Babel来支持箭头函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel可以转换async-and-await语法吗！如何配置Babel来支持async-and-await！"],"tags":["编程/babel"],"content":"重点\n\nBabel是什么！它的作用是什么！\n\n八股文\n\nBabel是什么！它的作用是什么！\nBabel有哪些新特性！\nBabel是如何将ES6+代码转换为可在旧版浏览器中运行的代码的！\nBabel的预设是什么！如何使用预设！\nBabel的配置文件是什么！如何创建和使用配置文件！\nBabel支持哪些JavaScript语法和特性！\nBabel可以转换哪些浏览器不支持的JavaScript特性！\nBabel可以转换React的JSX语法吗！如何配置Babel来支持JSX！\nBabel可以转换TypeScript代码吗！如何配置Babel来支持TypeScript！\nBabel可以转换ES模块吗！如何配置Babel来支持ES模块！\nBabel可以转换动态导入语法吗！如何配置Babel来支持动态导入！\nBabel可以转换装饰器语法吗！如何配置Babel来支持装饰器！\nBabel可以转换类属性语法吗！如何配置Babel来支持类属性！\nBabel可以转换异步生成器函数吗！如何配置Babel来支持异步生成器函数！\nBabel可以转换箭头函数吗！如何配置Babel来支持箭头函数！\nBabel可以转换async&amp;await语法吗！如何配置Babel来支持async&amp;await！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-八股文":{"title":"CSS 八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/css选择器有哪些！优先级！哪些属性可以继承！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/伪元素、伪类区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对盒子模型的理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/BFC（块级格式上下文）","C-Knowledge/前端/职业规划/前端面试宝典/八股文/清除浮动的几个方式","C-Knowledge/前端/职业规划/前端面试宝典/八股文/行内元素、块级元素、空元素","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Css预编语言的理解！以及-Sass、Less、Stylus-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何去除-CSS-注释！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-选择器有哪些组合方式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-选择器命名规则","C-Knowledge/前端/职业规划/前端面试宝典/八股文/无效选择器有什么用途！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是渐进性增强样式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何优化选择器，提高性能！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/!important-的作用和弊端，如何避免！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何限制-CSS-选择器的作用域！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-中有哪些单位！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/百分比--percent-相对于谁！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用-rem-自适应布局！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用-rem-或-viewport-进行移动端适配","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Rem-布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/颜色值都有哪几种表示方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说em-and-px-and-rem-and-vh-and-vw区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是继承！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何重置元素的属性值到初始值！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比块、内联和内联块盒子","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是弹性盒模型-and-弹性布局！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/box-sizing所有的属性","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器默认是如何布局的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是外边距折叠，如何避免！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/position-属性的值有哪些及其区别","怎么解决父元素高度塌陷","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是滚动穿透，如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现水平居中","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现垂直居中","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现高度-100-percent-撑满视窗","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现两栏布局，右侧自适应！三栏布局中间自适应呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/圣杯布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/双飞翼布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现三栏布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/瀑布流布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/品布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/实现简易计算器","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用css完成视差滚动效果！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/元素水平垂直居中的方法有哪些！如果元素不定宽高呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/元素水平垂直居中","C-Knowledge/前端/职业规划/前端面试宝典/八股文/min-width、max-width、width的包含(优先级)关系","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说flexbox（弹性盒布局模型）,以及适用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下grid网格布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浮动布局","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比过渡和动画","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何优化-CSS-动画的性能！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比-CSS-动画和-JS-动画！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/纯-CSS-实现打字机效果","C-Knowledge/前端/职业规划/前端面试宝典/八股文/纯-CSS-实现暗黑、夜间模式","C-Knowledge/前端/职业规划/前端面试宝典/八股文/纯-CSS-实现骨架屏","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比-CSS-加载的方式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/加载-CSS-是否会阻塞页面渲染！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器是如何解析和渲染-CSS-的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比获取-CSS-样式的接口","C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么理解回流跟重绘！什么场景下会触发！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS3动画有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/让Chrome支持小于12px-的文字方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/实现小于-1px-像素的边","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比多方法实现图标","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现圆角边框","C-Knowledge/前端/职业规划/前端面试宝典/八股文/多方法实现小三角","C-Knowledge/前端/职业规划/前端面试宝典/八股文/css中，有哪些方式可以隐藏页面元素！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/实现文字描边","C-Knowledge/前端/职业规划/前端面试宝典/八股文/实现渐变背景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比常见图片格式和-base64-图片！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要重置浏览器默认样式，对比-Reset.css-和-Normalize.css！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack-处理-SASS-文件时，sass-loader,-css-loader，style","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何压缩-CSS-大小，如何去除无用的-CSS！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-CSS-模块化，有哪几种实现方式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/页面导入样式时，使用-link-和-@import-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何自动压缩图片！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何自动添加浏览器私有前缀属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比媒体查询与按需引入-CSS！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS3新增了哪些新特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-CSS-组件化和原子化！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比多种编写规则","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-属性的建议书写顺序，为什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如果要做优化，CSS提高性能的方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTTP2.0-时代，CSS-Sprites-还有用吗，为什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你在开发中都遇到过哪些-CSS-兼容性问题，你是如何解决的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/当你忘记一个-CSS-属性时，你一般如何做！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是响应式设计！响应式设计的基本原理是什么！如何做！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现单行-and-多行文本溢出的省略样式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS如何画一个三角形！原理是什么"],"tags":["编程/FE/CSS"],"content":"重点\n\ncss选择器有哪些！优先级！哪些属性可以继承！\n伪元素、伪类区别\n说说你对盒子模型的理解！\nBFC（块级格式上下文）\n清除浮动的几个方式\n行内元素、块级元素、空元素\n说说对Css预编语言的理解！以及 Sass、Less、Stylus 的区别\n\n八股文\n注释\n\n如何去除 CSS 注释！\n\n选择器\n\ncss选择器有哪些！优先级！哪些属性可以继承！\nCSS 选择器有哪些组合方式！\n伪元素、伪类区别\nCSS 选择器命名规则\n无效选择器有什么用途！\n什么是渐进性增强样式！\n如何优化选择器，提高性能！\n!important 的作用和弊端，如何避免！\n如何限制 CSS 选择器的作用域！\n\n单位\n\nCSS 中有哪些单位！\n百分比 % 相对于谁！\n如何使用 rem 自适应布局！\n如何使用 rem 或 viewport 进行移动端适配\nRem 布局\n颜色值都有哪几种表示方法！\n说说em&amp;px&amp;rem&amp;vh&amp;vw区别！\n说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别！\n\n继承\n\n什么是继承！\n如何重置元素的属性值到初始值！\n\n盒模型\n\n说说你对盒子模型的理解！\n对比块、内联和内联块盒子\n什么是弹性盒模型&amp;弹性布局！\nbox-sizing所有的属性\n\n布局\n\n浏览器默认是如何布局的！\n什么是外边距折叠，如何避免！\nBFC（块级格式上下文）\nposition 属性的值有哪些及其区别\n清除浮动的几个方式\n怎么解决父元素高度塌陷\n什么是滚动穿透，如何解决！\n多方法实现水平居中\n多方法实现垂直居中\n多方法实现高度 100% 撑满视窗\n如何实现两栏布局，右侧自适应！三栏布局中间自适应呢！\n圣杯布局\n双飞翼布局\n多方法实现三栏布局\n瀑布流布局\n品布局\n实现简易计算器\n如何使用css完成视差滚动效果！\n元素水平垂直居中的方法有哪些！如果元素不定宽高呢！\n元素水平垂直居中\nmin-width、max-width、width的包含(优先级)关系\n说说flexbox（弹性盒布局模型）,以及适用场景！\n介绍一下grid网格布局\n浮动布局\n行内元素、块级元素、空元素\n\n动画\n\n对比过渡和动画\n如何优化 CSS 动画的性能！\n对比 CSS 动画和 JS 动画！\n纯 CSS 实现打字机效果\n纯 CSS 实现暗黑、夜间模式\n纯 CSS 实现骨架屏\n\n原理\n\n对比 CSS 加载的方式！\n加载 CSS 是否会阻塞页面渲染！\n浏览器是如何解析和渲染 CSS 的！\n对比获取 CSS 样式的接口\n怎么理解回流跟重绘！什么场景下会触发！\nCSS3动画有哪些！\n\n设计\n\n让Chrome支持小于12px 的文字方式有哪些！区别！\n实现小于 1px 像素的边\n对比多方法实现图标\n多方法实现圆角边框\n多方法实现小三角\ncss中，有哪些方式可以隐藏页面元素！区别！\n实现文字描边\n实现渐变背景\n对比常见图片格式和 base64 图片！\n为什么要重置浏览器默认样式，对比 Reset.css 和 Normalize.css！\n\n工程化\n\n说说对Css预编语言的理解！以及 Sass、Less、Stylus 的区别\nWebpack 处理 SASS 文件时，sass-loader, css-loader，style\n如何压缩 CSS 大小，如何去除无用的 CSS！\n什么是 CSS 模块化，有哪几种实现方式！\n页面导入样式时，使用 link 和 @import 有什么区别！\n如何自动压缩图片！\n如何自动添加浏览器私有前缀属性！\n对比媒体查询与按需引入 CSS！\n\n方法论\n\nCSS3新增了哪些新特性！\n什么是 CSS 组件化和原子化！\n对比多种编写规则\nCSS 属性的建议书写顺序，为什么！\n如果要做优化，CSS提高性能的方法有哪些！\n\n综合\n\nHTTP2.0 时代，CSS Sprites 还有用吗，为什么！\n你在开发中都遇到过哪些 CSS 兼容性问题，你是如何解决的！\n当你忘记一个 CSS 属性时，你一般如何做！\n什么是响应式设计！响应式设计的基本原理是什么！如何做！\n如何实现单行&amp;多行文本溢出的省略样式！\nCSS如何画一个三角形！原理是什么\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas-八股文":{"title":"Canvas 八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas-怎么实现截图！","C-Knowledge/前端/技术书籍/多媒体前端手册/Canvas-怎么实现播放视频！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简要说明Canvas是什么，以及它在前端开发中的作用。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用Canvas绘制一个矩形，并填充它的背景色。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用Canvas绘制一条直线！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas中绘制一个圆！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释什么是Canvas的坐标系统！如何在Canvas中调整和使用坐标！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas上绘制文本！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述Canvas中的路径（Path）是什么，以及如何使用路径绘制复杂的形状！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas中绘制图像！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释Canvas中的渐变（Gradient）是什么，以及如何使用渐变填充或描边！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释什么是Canvas合成操作（Composition）！如何使用合成操作创建复杂的绘图效果！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas的底层原理是什么","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas的主要应用场景是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在实际开发中，Canvas会有哪些坑，如何解决！"],"tags":["编程/Canvas"],"content":"重点\n\nCanvas 怎么实现截图！\nCanvas 怎么实现播放视频！\n\n八股文\n\n请简要说明Canvas是什么，以及它在前端开发中的作用。\n使用Canvas绘制一个矩形，并填充它的背景色。\n如何使用Canvas绘制一条直线！\n如何在Canvas中绘制一个圆！\n解释什么是Canvas的坐标系统！如何在Canvas中调整和使用坐标！\n如何在Canvas上绘制文本！\n请描述Canvas中的路径（Path）是什么，以及如何使用路径绘制复杂的形状！\n如何在Canvas中绘制图像！\n请解释Canvas中的渐变（Gradient）是什么，以及如何使用渐变填充或描边！\n解释什么是Canvas合成操作（Composition）！如何使用合成操作创建复杂的绘图效果！\nCanvas的底层原理是什么\nCanvas的主要应用场景是什么！\n在实际开发中，Canvas会有哪些坑，如何解决！\nCanvas 怎么实现截图！\nCanvas 怎么实现播放视频！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas-怎么实现截图！":{"title":"Canvas 怎么实现截图！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/解决canvas图片getImageData,toDataURL跨域问题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/html2canvas"],"tags":["编程/Canvas"],"content":"function manualCapture() {\n\tconst video = document.getElementById(&quot;myVideo&quot;);\n\tconst canvas = document.createElement(&quot;canvas&quot;);\n\tvar ctx = canvas.getContext(&quot;2d&quot;);\n\tconst ratio = window.devicePixelRatio || 1;\n\tctx.scale(ratio, ratio);\n\tcanvas.width = video.offsetWidth * ratio;\n\tcanvas.height = video.offsetHeight * ratio;\n\tctx.drawImage(video, 0, 0, canvas.width, canvas.height);// 在画布上绘制图像\n\tconst img = document.getElementById(&quot;image&quot;);\n\tconsole.log(&quot;图片地址&quot;, canvas.toDataURL(&quot;image/jpg&quot;));\n\timg.src = canvas.toDataURL(&quot;image/jpg&quot;); // 生成图片地址\n}\n常见问题\n渲染图片跨域问题:  使用 crossorigin=&quot;anonymous&quot; 解决\n\n\n                  \n                  错误 \n                  \n                \nScreenshot.html:55 Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.\n\n\n解决canvas图片getImageData,toDataURL跨域问题\n\n扩展阅读\n\n利用canvas实现视频截图\nhtml2canvas： 页面截图下载到本地的功能。\n使用图像\n基于canvas实现的一个截图小demo\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas的主要应用场景是什么！":{"title":"Canvas的主要应用场景是什么！","links":[],"tags":["编程/Canvas"],"content":"\nCanvas的主要应用场景包括但不限于以下几个方面：\n\n\n\n绘图和可视化：Canvas提供了强大的绘图功能，可以用于创建各种图表、数据可视化、绘制图像等。例如，你可以使用Canvas来绘制折线图、柱状图、饼图、雷达图等，展示数据和统计信息。\n\n\n游戏开发：Canvas在游戏开发中具有广泛的应用。通过操作画布上的像素，开发者可以实现2D游戏中的角色动画、游戏场景渲染、碰撞检测等功能。可以使用Canvas创建简单的小游戏，也可以结合其他技术（如WebGL）创建复杂的游戏。\n\n\n图像处理和滤镜效果：Canvas提供了图像处理功能，可以用于图像的编辑、变换和滤镜效果的实现。你可以使用Canvas来调整图像的亮度、对比度、色彩饱和度，应用模糊、阴影、灰度等滤镜效果。\n\n\n交互式图形界面：Canvas可以作为交互式图形界面的基础，通过绘制按钮、图标、菜单等控件，实现用户与网页的交互。Canvas结合JavaScript和用户输入事件，可以实现自定义的界面元素和用户交互行为。\n\n\n广告和动画效果：由于Canvas可以实现动画效果，它被广泛应用于创建网页广告、动画展示和特效。你可以使用Canvas创建动态的广告横幅、产品展示、页面过渡效果等。\n\n\n\n需要注意的是，Canvas虽然具有强大的绘图能力，但相对于DOM元素来说，它在自身的结构和交互能力方面较为简单。因此，在一些需要复杂交互或具有大量文本内容的场景下，可能更适合使用基于DOM的技术来实现。Canvas的最佳应用场景是那些需要高性能绘图和图像处理的情况，以及需要自定义绘图能力的地方。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas的底层原理是什么":{"title":"Canvas的底层原理是什么","links":[],"tags":["编程/Canvas"],"content":"\n写在开头，特别提醒：Canvas的底层原理涉及到图形渲染、图像处理和像素操作等技术，不同浏览器对于Canvas的实现可能会有一些细微的差异。\n\n\nCanvas的底层原理是基于HTML5规范中的一项功能，称为Canvas API，它定义了一个位图绘图的画布。\n当你在网页上嵌入一个Canvas元素（例如&lt;canvas&gt;&lt;/canvas&gt;），浏览器会为该元素创建一个隐含的画布，并在其上建立一个二维绘图环境（2D context）。通过JavaScript代码，你可以使用Canvas API调用2D上下文提供的方法和属性来在画布上进行绘图操作。\n实际上，绘图操作是通过操作画布上的像素来实现的。画布是一个矩形网格，每个网格单元称为一个像素（pixel）。每个像素可以使用不同的颜色值进行填充，从而形成图像。通过在特定位置上设置颜色值，可以绘制线条、形状、图像和文本等内容。\nCanvas的绘图过程是通过以下步骤完成的：\n\n\n获取Canvas元素的上下文：通过JavaScript代码使用getContext方法获取一个绘图上下文，其中最常用的是2D绘图上下文，可以通过canvas.getContext(&#039;2d&#039;)来获取。\n\n\n设置绘图样式：通过设置上下文的属性（例如fillStyle和strokeStyle）来指定绘图操作的填充和描边样式，包括颜色、渐变、图案等。\n\n\n绘制路径或形状：使用上下文提供的方法（例如beginPath、moveTo、lineTo、arc等）来创建路径或定义形状。\n\n\n应用填充和描边：根据需要，可以使用上下文的方法（例如fill和stroke）来填充路径内部或绘制路径的外边框。\n\n\n绘制文本和图像：除了路径和形状，Canvas还提供了绘制文本和图像的方法，可以在画布上显示文本和图像。\n\n\n处理动画和交互：Canvas还可以用来创建交互式的动画效果。通过在每一帧之间更新画布内容，并结合用户输入或计时器来实现动画效果。\n\n\n\nCanvas的底层原理涉及到图形渲染、图像处理和像素操作等技术，不同浏览器对于Canvas的实现可能会有一些细微的差异。然而，无论具体实现方式如何，Canvas提供了一种强大的绘图能力，使开发者可以通过JavaScript代码在网页中实现各种绘图和图像处理效果。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中如何处理会话(Session)和身份验证(Authentication)！":{"title":"Express.js中如何处理会话(Session)和身份验证(Authentication)！","links":["C-Knowledge/前端/编程基础/网络/JWT"],"tags":["编程/Node/Express"],"content":"在Express.js中处理会话和身份验证可以使用不同的中间件和库来实现。下面是一些常用的方法：\n【1】 使用express-session库处理会话：\n\n安装express-session库：npm install express-session\n在应用程序中使用express-session中间件：\n\nconst express = require(&#039;express&#039;);\nconst session = require(&#039;express-session&#039;);\n \nconst app = express();\n \napp.use(session({\n  secret: &#039;your-secret-key&#039;,\n  resave: false,\n  saveUninitialized: true\n}));\n \n// 在路由中使用session\napp.get(&#039;/profile&#039;, (req, res) =&gt; {\n  if (req.session.userId) {\n\t// 用户已登录，处理相应逻辑\n  } else {\n\t// 用户未登录，进行相应处理\n  }\n});\n【2】 使用Passport库进行身份验证：\n\n安装passport库：npm install passport passport-local\n在应用程序中配置Passport和相关策略（比如Local Strategy）：\n\nconst express = require(&#039;express&#039;);\nconst passport = require(&#039;passport&#039;);\nconst LocalStrategy = require(&#039;passport-local&#039;).Strategy;\n \nconst app = express();\n \n// 配置Passport和策略\npassport.use(new LocalStrategy(\n  (username, password, done) =&gt; {\n\t// 在此处验证用户名和密码\n\t// 如果验证成功，调用done(null, user)；如果验证失败，调用done(null, false)\n  }\n));\n \n// 应用程序中使用Passport进行身份验证\napp.post(&#039;/login&#039;,\n  passport.authenticate(&#039;local&#039;, { failureRedirect: &#039;/login&#039; }),\n  (req, res) =&gt; {\n\t// 身份验证成功后的处理逻辑\n  }\n);\n【3】 使用JWT（JSON Web Token）进行身份验证：\n\n安装jsonwebtoken库：npm install jsonwebtoken\n创建和验证JWT：\n\nconst jwt = require(&#039;jsonwebtoken&#039;);\n \n// 生成JWT\nconst token = jwt.sign({ userId: &#039;123&#039; }, &#039;your-secret-key&#039;);\n \n// 验证JWT\njwt.verify(token, &#039;your-secret-key&#039;, (err, decoded) =&gt; {\n  if (err) {\n\t// 验证失败\n  } else {\n\t// 验证成功\n\tconsole.log(decoded);\n  }\n});\n上述方法中，使用express-session库处理会话，使用passport库进行身份验证，使用jsonwebtoken库创建和验证JWT。你可以根据自己的需求选择适合的方法来处理会话和身份验证。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中如何处理并发请求！解释一下多线程和事件循环。":{"title":"Express.js中如何处理并发请求！解释一下多线程和事件循环。","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，默认情况下是单线程运行的，并且使用事件循环来处理并发请求。下面是关于多线程和事件循环的解释：\n\n\n多线程：多线程是指在一个应用程序中同时运行多个线程，每个线程执行不同的任务。每个线程都有自己的执行上下文和栈。多线程编程可以提高并发性能，因为多个线程可以同时执行不同的任务，从而提高整体的效率。在多线程模型中，每个线程都可以独立处理来自客户端的请求，但也需要处理线程间的同步和资源共享问题。\n\n\n事件循环：事件循环是一种用于处理并发请求的编程模型。在事件循环模型中，应用程序通过一个事件循环监视和处理来自客户端的请求。当有请求到达时，事件循环将其放入一个任务队列中，并按照顺序逐个处理这些任务。事件循环的核心思想是单线程下的非阻塞I/O操作，即避免线程切换和同步开销。在事件循环模型中，一个任务的处理不会阻塞其他任务的执行，因此可以提供较高的并发性能。\n\n\n在Express.js中，通过事件驱动的方式处理请求，借助Node.js的事件循环机制来管理请求和响应。当有新的请求到达时，Express.js会将其包装为事件，然后使用事件循环来处理这些事件。通过这种方式，只需要一个线程来处理所有的请求，并且可以高效地处理并发请求。\n需要注意的是，虽然Express.js本身是单线程的，但在Node.js中，底层的I/O操作是通过libuv库来完成的，libuv可以利用多个线程来执行I/O操作，从而提高效率。因此，尽管主要的处理请求的线程是单线程的，但底层的I/O操作是可以并行执行的。\n总结起来，Express.js利用事件循环的机制来高效处理并发请求，通过单线程而不是多线程来提供高性能和高并发支持。这种模型通过避免线程切换和同步开销来提供非阻塞的I/O操作，从而实现了高效的并发处理。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。":{"title":"Express.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，可以通过设置响应头来实现缓存控制。为了理解缓存控制的实现方式，我们需要了解两个重要的概念：ETag和Last-Modified。\n\nETag（实体标签）：ETag是一个用于标识资源版本的标签。服务器会为每个资源生成一个唯一的ETag，并在每个响应中发送给客户端。客户端可以在请求中的 If-None-Match标头 中将上一次收到的ETag发送回服务器。服务器可以比较这两个ETag值，以确定资源是否有新的版本可用。如果两个ETag匹配，表示资源没有变化，服务器可以返回一个304 Not Modified的响应，告诉客户端使用缓存版本。\nLast-Modified（最后修改时间）：服务器会在响应中发送一个Last-Modified标头，指示资源的最后修改时间。客户端可以在后续请求中的 If-Modified-Since标头 中将上一次收到的最后修改时间发送回服务器。服务器可以比较这两个最后修改时间，以确定资源是否有新的修改。如果最后修改时间相同，表示资源没有变化，服务器可以返回一个304 Not Modified的响应。\n\n下面是一个示例，展示了如何使用ETag和Last-Modified来实现缓存控制：\napp.get(&#039;/api/data&#039;, (req, res) =&gt; {\n  // 假设这是一些动态生成的数据\n  const data = generateData();\n \n  // 设置ETag和Last-Modified响应头\n  const lastModified = new Date().toUTCString();\n  const etag = generateETag(data);\n \n  res.set(&#039;Last-Modified&#039;, lastModified);\n  res.set(&#039;ETag&#039;, etag);\n \n  // 检查客户端发送的If-None-Match和If-Modified-Since标头\n  const ifNoneMatch = req.get(&#039;If-None-Match&#039;);\n  const ifModifiedSince = req.get(&#039;If-Modified-Since&#039;);\n \n  // 如果ETag和If-None-Match匹配，发送304 Not Modified响应\n  if (ifNoneMatch === etag) {\n    return res.sendStatus(304);\n  }\n \n  // 如果Last-Modified和If-Modified-Since相同，发送304 Not Modified响应\n  if (ifModifiedSince &amp;&amp; new Date(ifModifiedSince) &gt;= new Date(lastModified)) {\n    return res.sendStatus(304);\n  }\n \n  // 返回数据\n  res.json(data);\n});\n在上面的例子中，我们使用res.set()方法设置了响应头Last-Modified和ETag，分别对应最后修改时间和实体标签。然后，我们获取请求中的If-None-Match和If-Modified-Since标头，并与服务器生成的ETag和最后修改时间进行比较。\n如果客户端发送的ETag与服务器生成的ETag匹配，或者客户端发送的最后修改时间大于等于服务器的最后修改时间，服务器将返回一个304 Not Modified的响应。\n这样，通过使用ETag和Last-Modified来进行缓存控制，可以减少网络流量，提高应用程序的性能和响应速度。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的路由是什么！如何定义和使用路由！":{"title":"Express.js中的路由是什么！如何定义和使用路由！","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，路由是定义应用程序中不同请求的处理方式的一种机制。通过路由，您可以将特定的URL路径与特定的处理程序关联起来，以便在收到该URL路径的请求时执行相应的代码逻辑。\n在Express.js中，可以通过app.METHOD()方法定义路由。其中，METHOD是HTTP方法，例如GET、POST、PUT、DELETE等。以下是定义和使用路由的示例：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 定义GET请求的路由\napp.get(&#039;/&#039;, (req, res) =&gt; {\n  res.send(&#039;欢迎来到首页&#039;);\n});\n \n// 定义POST请求的路由\napp.post(&#039;/users&#039;, (req, res) =&gt; {\n  res.send(&#039;创建新用户&#039;);\n});\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动&#039;);\n});\n在上面的例子中，我们使用app.get()和app.post()方法分别定义了GET请求和POST请求的路由。我们传递了一个路径和一个处理程序函数作为参数。\n当收到一个URL路径为’/‘的GET请求时，执行第一个路由处理程序，并发送响应’欢迎来到首页’。当收到一个URL路径为’/users’的POST请求时，执行第二个路由处理程序，并发送响应’创建新用户’。\n通过这种方式，您可以定义不同的路由，以处理不同的HTTP请求，并发送适当的响应。这样，您就可以构建具有多个不同功能的Web应用程序。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的错误处理机制是什么！如何处理错误和异常！":{"title":"Express.js中的错误处理机制是什么！如何处理错误和异常！","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，错误处理是通过中间件来处理的。 当一个请求处理过程中发生错误或异常时，中间件可以拦截这些错误并作出相应的处理。\nExpress.js提供了一个专门用于处理错误的中间件函数，即错误处理中间件。通过在应用程序中使用app.use()或者路由中使用router.use()将错误处理中间件添加到中间件链中，可以捕获和处理在请求处理过程中发生的错误。\n下面是一个示例，展示了如何处理错误：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 中间件链中的其它中间件\n \n// 错误处理中间件\napp.use((err, req, res, next) =&gt; {\n  // 处理错误逻辑\n  console.error(err);\n  res.status(500).send(&#039;Internal Server Error&#039;);\n});\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动&#039;);\n});\n在上述示例中，通过app.use()将错误处理中间件添加到中间件链的末尾。当其他中间件中调用next(err)时，就会跳转到错误处理中间件，并将错误对象作为第一个参数传递给错误处理中间件。在错误处理中间件中，可以根据需要处理错误对象，例如打印错误信息、记录日志或发送自定义错误响应。\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是，错误处理中间件必须定义为带有四个参数的函数，以便正确识别为错误处理中间件。第一个参数是错误对象，之后是请求、响应和next函数。\n\n除了使用错误处理中间件外，还可以使用try-catch语句来捕获同步操作中的错误，并使用next(err)方法将错误传递给错误处理中间件。\n在异步操作中，可以使用Promise的.catch()捕获错误并通过next(err)方法将其传递给错误处理中间件，或者使用async/await语法结合try-catch来处理异步错误。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的静态文件服务是如何实现的！举例说明如何提供静态文件访问。":{"title":"Express.js中的静态文件服务是如何实现的！举例说明如何提供静态文件访问。","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，可以通过使用内置的express.static()中间件函数来提供静态文件服务。这个中间件函数会自动根据文件路径返回对应的静态文件内容。举个例子：\n首先，创建一个名为public的文件夹，并将需要提供的静态文件放在其中，如public/images/logo.png。\n然后，在Express应用程序中使用express.static()中间件函数来指定将静态文件提供给客户端的目录。例如：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 指定静态文件目录\napp.use(express.static(&#039;public&#039;));\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动&#039;);\n});\n上述代码中，通过app.use()方法使用express.static()中间件来指定提供静态文件的目录。这里指定的目录是public，这意味着任何请求的URL路径匹配到public目录下的静态文件时，Express将会自动提供相应的文件内容。例如，当访问http://localhost:3000/images/logo.png时，将返回public/images/logo.png文件的内容。\n通过这种方式，您可以方便地将静态文件，如图像、样式表和JavaScript文件等，提供给前端页面。这对于构建Web应用程序和提供资源文件非常有用。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。":{"title":"Express.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。","links":[],"tags":["编程/Node/Express"],"content":"Express.js提供了一些内置的中间件，这些中间件可用于处理常见的任务，如解析请求体、处理静态文件、处理会话等。下面是一些常见的内置中间件及其使用示例：\n1. express.json()：解析请求体为JSON格式。\nconst express = require(&#039;express&#039;);\nconst app = express();\n \napp.use(express.json());\n2. express.urlencoded()：解析以URL编码的请求体。\nconst express = require(&#039;express&#039;);\nconst app = express();\n \napp.use(express.urlencoded({ extended: false }));\n3. express.static()：提供静态文件服务。\nconst express = require(&#039;express&#039;);\nconst app = express();\n \napp.use(express.static(&#039;public&#039;));\n4. express.Router()：为路由创建模块化的处理程序。\nconst express = require(&#039;express&#039;);\nconst router = express.Router();\n \nrouter.get(&#039;/&#039;, (req, res) =&gt; {\n  res.send(&#039;Hello World!&#039;);\n});\n \nmodule.exports = router;\n5. express-session：处理会话管理。\nconst express = require(&#039;express&#039;);\nconst session = require(&#039;express-session&#039;);\nconst app = express();\n \napp.use(session({\n  secret: &#039;secret-key&#039;,\n  resave: false,\n  saveUninitialized: true,\n}));\n使用这些内置中间件可以方便地处理常见的请求处理任务，而且它们可以像其他自定义中间件一样使用app.use()方法将其添加到应用程序中。需要根据具体的需求选择和配置合适的中间件。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Git八股文":{"title":"Git八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Git的理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的工作流程。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对版本管理的理解！常用的版本管理工具有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git中-fork,-clone,branch这三个概念，有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Git-中-HEAD、工作树和索引之间的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对git-pull-和-git-fetch-的理解！有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-stash-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-rebase-和-git-merge的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对git-reset-和-git-revert-的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的合并（merge）和重置（reset）的区别。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的三个基本状态：已修改（modified）、已暂存（staged）和已提交（committed）。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的远程仓库是什么，以及如何与远程仓库进行交互！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的忽略文件（.gitignore）是用来做什么的，以及如何配置它！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的协作开发流程，包括分支管理和代码合并的步骤。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Git的分支！如何创建和合并分支！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中撤销之前的提交！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-git-发生冲突的场景！如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看提交历史记录！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的标签（tag）是什么，以及如何创建和使用标签！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中回退到之前的提交版本！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看当前分支的状态！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看文件的修改差异！"],"tags":["编程/Git"],"content":"重点\n\n说说你对Git的理解！\n\nGit\n核心概念\n\n说说你对Git的理解！\n请描述一下Git的工作流程。\n说说你对版本管理的理解！常用的版本管理工具有哪些！\n说说Git中 fork, clone,branch这三个概念，有什么区别！\n说说Git常用的命令有哪些！\n说说Git 中 HEAD、工作树和索引之间的区别！\n说说对git pull 和 git fetch 的理解！有什么区别！\n说说你对git stash 的理解！应用场景！\n说说你对git rebase 和 git merge的理解！区别！\n说说你对git reset 和 git revert 的理解！区别！\n请解释一下Git的合并（merge）和重置（reset）的区别。\n请解释一下Git的三个基本状态：已修改（modified）、已暂存（staged）和已提交（committed）。\n请解释一下Git的远程仓库是什么，以及如何与远程仓库进行交互！\n请解释一下Git的忽略文件（.gitignore）是用来做什么的，以及如何配置它！\n请描述一下Git的协作开发流程，包括分支管理和代码合并的步骤。\n\n使用方法\n\n什么是Git的分支！如何创建和合并分支！\n如何在Git中撤销之前的提交！\n说说 git 发生冲突的场景！如何解决！\n如何在Git中查看提交历史记录！\n请描述一下Git的标签（tag）是什么，以及如何创建和使用标签！\n如何在Git中回退到之前的提交版本！\n如何在Git中查看当前分支的状态！\n如何在Git中查看文件的修改差异！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-八股文":{"title":"HTML 八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/常用的浏览器引擎是什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML-语义化，有什么好处，一定要-HTML-语义化吗-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML5，HTML5-有哪些新特性-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请列举常用的-HTML-实体字符-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-注释如何写-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/连续空格如何渲染，意义是什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何声明文档类型-DOCTYPE-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/哪些字符集编码支持简体中文，如何解决-HTML-乱码问题-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何验证-HTML-是否正确-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-MIME-types，常见的-MIME-types-有哪些-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-ARIA！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML-标签-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-标签区分大小写吗-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML-元素-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-元素有哪些分类方法-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-HTML-头部元素-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是元数据-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常见的内容结构标签有哪些，为什么我们需要结构化-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/列表标签都有哪些-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常见的标记引用标签有什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何标记缩略语-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何标记作者的联系方式-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何现实一个化学方程式或数学公式，如何表示上标和下标-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何标记计算机代码-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何标记时间和日期-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是可替换元素，为什么称它们为可替换元素-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何强制手机浏览器采用真实可视窗口宽度来加载网页-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何链接到-HTML-文档的特定部分（文档片段）","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器如何对待引号没有闭合的属性，如何理解-HTML-的宽松解析-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要设置-alt-属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/alt-属性应该填写什么内容-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要指定图片高度和宽度属性-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/title-属性应该填写什么内容-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何设置图片的说明文字-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-图像和-CSS-图像的区别是什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是矢量图形，它和位图的区别是什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-SVG！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SVG-对比光栅图形的优缺点是什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-HTML-中引入-SVG！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何创建响应式的图片-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么不能使用-JavaScirpt-来实现响应式图片-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何调试响应式-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/有哪些标签可以嵌入外部内容-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使媒体文件支持不同平台，不同设备的浏览器-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何为视频设置缩略图-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么设置-`autoplay`-的视频无法自动播放-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Iframe-的优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/简述一下-src-与-href-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要使用-CSS-而不是-`table`-表格布局-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常用的表格标签有什么-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何为表格中的列设置相同的样式-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/表格结构标签有哪些，为什么要使用-！","技术书籍/HTML-教程/表单","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何设置-`input`-和-`textarea`-的初始值-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/`button`-有哪几种类型-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-`input`-和-`button`-生成按钮有什么不同-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/哪些表单属性与向-web-服务器发送表单数据有关系-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/表单元素一定要用-`form`-包裹吗，不包裹会怎样-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何将标签连接到表单元素，连接后有什么好处-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何构建一个姓名为必填项的表单，满足语义和可访问性的要求-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何禁用表单元素-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何让表单元素自动对焦-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何将表单元素与表单关联-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何允许用户一次输入多个电子邮件地址，逗号分隔-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-下拉框有哪两种实现方式-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何构建一个兼顾老版本浏览器的自动补全输入框-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何构建单选框，如何构建复选框-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在表单中发送图片被点击时的坐标-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/哪种输入表单适合显示密码强度-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-GET-和-POST-发送表单数据，有什么不同-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是表单校验，为什么要使用表单校验-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用-HTML5-的内置表单数据校验-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-JavaScript-发送表单数据都有哪些方法-！"],"tags":["编程/FE/HTML"],"content":"重点\n\n常用的浏览器引擎是什么 ！\n什么是 HTML 语义化，有什么好处，一定要 HTML 语义化吗 ！\n什么是 HTML5，HTML5 有哪些新特性 ！\n\nHTML 八股文\n概念\n\n什么是 HTML！\n常用的浏览器引擎是什么 ！\n请列举常用的 HTML 实体字符 ！\nHTML 注释如何写 ！\n什么是 HTML 语义化，有什么好处，一定要 HTML 语义化吗 ！\n连续空格如何渲染，意义是什么 ！\n如何声明文档类型 DOCTYPE ！\n哪些字符集编码支持简体中文，如何解决 HTML 乱码问题 ！\n如何验证 HTML 是否正确 ！\n什么是 HTML5，HTML5 有哪些新特性 ！\n什么是 MIME types，常见的 MIME types 有哪些 ！\n什么是 ARIA！\n\n元素\n\n什么是 HTML 标签 ！\nHTML 标签区分大小写吗 ！\n什么是 HTML 元素 ！\nHTML 元素有哪些分类方法 ！\n什么是 HTML 头部元素 ！\n什么是元数据 ！\n常见的内容结构标签有哪些，为什么我们需要结构化 ！\n列表标签都有哪些 ！\n常见的标记引用标签有什么 ！\n如何标记缩略语 ！\n如何标记作者的联系方式 ！\n如何现实一个化学方程式或数学公式，如何表示上标和下标 ！\n如何标记计算机代码 ！\n如何标记时间和日期 ！\n什么是可替换元素，为什么称它们为可替换元素 ！\n如何强制手机浏览器采用真实可视窗口宽度来加载网页 ！\n如何链接到 HTML 文档的特定部分（文档片段）\n浏览器如何对待引号没有闭合的属性，如何理解 HTML 的宽松解析 ！\n\n图片\n\n为什么要设置 alt 属性！\nalt 属性应该填写什么内容 ！\n为什么要指定图片高度和宽度属性 ！\ntitle 属性应该填写什么内容 ！\n如何设置图片的说明文字 ！\nHTML 图像和 CSS 图像的区别是什么 ！\n什么是矢量图形，它和位图的区别是什么 ！\n什么是 SVG！\nSVG 对比光栅图形的优缺点是什么 ！\n如何在 HTML 中引入 SVG！\n如何创建响应式的图片 ！\n为什么不能使用 JavaScirpt 来实现响应式图片 ！\n如何调试响应式 ！\n\n多媒体及嵌入\n\n有哪些标签可以嵌入外部内容 ！\n如何使媒体文件支持不同平台，不同设备的浏览器 ！\n如何为视频设置缩略图 ！\n为什么设置 autoplay 的视频无法自动播放 ！\nIframe 的优缺点！\n简述一下 src 与 href 的区别\n\n表格\n\n为什么要使用 CSS 而不是 table 表格布局 ！\n常用的表格标签有什么 ！\n如何为表格中的列设置相同的样式 ！\n表格结构标签有哪些，为什么要使用 ！\n\n表单\n\n如何设置 input 和 textarea 的初始值 ！\nbutton 有哪几种类型 ！\n使用 input 和 button 生成按钮有什么不同 ！\n哪些表单属性与向 web 服务器发送表单数据有关系 ！\n表单元素一定要用 form 包裹吗，不包裹会怎样 ！\n如何将标签连接到表单元素，连接后有什么好处 ！\n如何构建一个姓名为必填项的表单，满足语义和可访问性的要求 ！\n如何禁用表单元素 ！\n如何让表单元素自动对焦 ！\n如何将表单元素与表单关联 ！\n如何允许用户一次输入多个电子邮件地址，逗号分隔 ！\nHTML 下拉框有哪两种实现方式 ！\n如何构建一个兼顾老版本浏览器的自动补全输入框 ！\n如何构建单选框，如何构建复选框 ！\n如何在表单中发送图片被点击时的坐标 ！\n哪种输入表单适合显示密码强度 ！\n使用 GET 和 POST 发送表单数据，有什么不同 ！\n什么是表单校验，为什么要使用表单校验 ！\n如何使用 HTML5 的内置表单数据校验 ！\n使用 JavaScript 发送表单数据都有哪些方法 ！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript-八股文":{"title":"JavaScript 八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/var、let、const-的差异！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是作用域-！-什么是作用域链-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-0.1-+-0.2-!==-0.3-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/==-、-===--和-Object.is()-的区别是什么！分别在什么情况使用","C-Knowledge/前端/职业规划/前端面试宝典/八股文/for-in-和-for-of的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript原型，原型链-！-有什么特点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/深拷贝浅拷贝的区别！如何实现一个深拷贝！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数组的常用方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript字符串的常用方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/DOM常见的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对闭包的理解！闭包使用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/bind、call、apply-区别！如何实现一个bind！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/谈谈this对象的理解","C-Knowledge/前端/开发技术/JavaScript/什么是防抖和节流！有什么区别！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript中如何实现函数缓存！函数缓存有哪些应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中Module的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/列举-ES6-的新特性","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对事件循环的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/GC-垃圾回收机制及内存管理","D-Unsorted/说说-JavaScript-中内存泄漏的几种情况！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript本地存储的方式有哪些！区别及应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说new操作符具体干了什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/web常见的攻击方式有哪些！如何防御！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JS-中的-8-种数据类型及区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是变量提升！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/原始数据类型和引用数据类型的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Javascript-数字精度丢失的问题，如何解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/谈谈-undefined-和-null-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/typeof-null-的结果是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/谈谈-JavaScript-中的类型转换机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数据类型判断-instanceof-和-typeof-的区别","D-Unsorted/转为32位无符号整数","C-Knowledge/前端/职业规划/前端面试宝典/八股文/parseInt-结果，并解释原因","C-Knowledge/前端/职业规划/前端面试宝典/八股文/或=--、-and--and-=-和-！！=是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/可选链-！.-有什么用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript-创建对象有哪些方式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript如何实现继承！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Map-和-WeakMap-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6新增Set、Map两种数据结构的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/类数组的转化方式有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/立即调用函数表达式（IIFE）有什么特点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/箭头函数和普通函数的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请用js去除字符串空格！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/js异步处理发展史","C-Knowledge/前端/职业规划/前端面试宝典/八股文/async-await-原理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/async-and-await的错误捕获方式","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中-Promise的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟实现-Promise！","简单介绍下-ES6-中的-Iterator-和-Iterable","你是怎么理解ES6中-Generator的？使用场景？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现红绿灯效果！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一下-GET-和-POST-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ajax原理是什么！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/模块化编程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比-import、import()-和-requrie-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Reflect-有什么用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解-ES6中-Proxy-的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对正则表达式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ES6中数组新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对象新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/ES6中函数新增了哪些扩展！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中-Decorator-的！使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript中执行上下文和执行栈是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何判断当前脚本运行在浏览器还是-Node-环境中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请指出document-load和document-ready的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/获取表单元素的事件","C-Knowledge/前端/职业规划/前端面试宝典/八股文/html-dom-的-event-事件","开发技术/JavaScript/说说JavaScript中的事件模型","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释下什么是事件代理！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对BOM的理解，常见的BOM对象你了解哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/举例说明你对尾递归的理解，有哪些应用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何判断一个元素是否在可视区域中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现大文件上传！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/大文件上传如何做断点续传！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现上拉加载，下拉刷新！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现树形结构列表和扁平列表的互相转换！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是单点登录！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/script-标签放在-header-里和放在-body-底部里有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是单点登录！如何实现！"],"tags":["编程/JavaScript"],"content":"重点\n\nvar、let、const 的差异！\n什么是作用域 ！ 什么是作用域链 ！\n为什么 0.1 + 0.2 !== 0.3 ！\n 、 =  和 Object.is() 的区别是什么！分别在什么情况使用\nfor in 和 for of的区别\nJavaScript原型，原型链 ！ 有什么特点！\n深拷贝浅拷贝的区别！如何实现一个深拷贝！\n数组的常用方法有哪些！\nJavaScript字符串的常用方法有哪些！\nDOM常见的操作有哪些！\n说说你对闭包的理解！闭包使用场景\nbind、call、apply 区别！如何实现一个bind！\n谈谈this对象的理解\n什么是防抖和节流！有什么区别！如何实现！\nJavascript中如何实现函数缓存！函数缓存有哪些应用场景！\n你是怎么理解ES6中Module的！使用场景！\n列举 ES6 的新特性\n说说你对事件循环的理解\nGC 垃圾回收机制及内存管理\n说说 JavaScript 中内存泄漏的几种情况！\nJavascript本地存储的方式有哪些！区别及应用场景！\n说说new操作符具体干了什么！\nweb常见的攻击方式有哪些！如何防御！\n\n八股文\n变量\n\nJS 中的 8 种数据类型及区别\nvar、let、const 的差异！\n什么是作用域 ！ 什么是作用域链 ！\n什么是变量提升！\n\n数据类型\n\nJS 中的 8 种数据类型及区别\n原始数据类型和引用数据类型的区别！\n为什么 0.1 + 0.2 !== 0.3 ！\n说说 Javascript 数字精度丢失的问题，如何解决！\n谈谈 undefined 和 null ！\ntypeof null 的结果是什么！\n谈谈 JavaScript 中的类型转换机制\n 、 =  和 Object.is() 的区别是什么！分别在什么情况使用\n数据类型判断 instanceof 和 typeof 的区别\n转为32位无符号整数\nparseInt 结果，并解释原因\n\n运算符\n\n或=  、&amp;&amp;= 和 ！！=是什么！\n可选链 ！. 有什么用！\nfor in 和 for of的区别\n\n对象\n\nJavaScript 创建对象有哪些方式！\nJavascript如何实现继承！\nJavaScript原型，原型链 ！ 有什么特点！\nMap 和 WeakMap 有什么区别！\n你是怎么理解ES6新增Set、Map两种数据结构的！\n深拷贝浅拷贝的区别！如何实现一个深拷贝！\n数组的常用方法有哪些！\nJavaScript字符串的常用方法有哪些！\nDOM常见的操作有哪些！\n\n函数\n\n说说你对闭包的理解！闭包使用场景\n谈谈this对象的理解\n类数组的转化方式有哪些！\nbind、call、apply 区别！如何实现一个bind！\n立即调用函数表达式（IIFE）有什么特点！\n箭头函数和普通函数的区别\n什么是防抖和节流！有什么区别！如何实现！\n请用js去除字符串空格！\n说说你对函数式编程的理解！优缺点！\nJavascript中如何实现函数缓存！函数缓存有哪些应用场景！\n\n异步\n\njs异步处理发展史\nasync await 原理\nasync&amp;await的错误捕获方式\n你是怎么理解ES6中 Promise的！使用场景！\n如何模拟实现 Promise！\n简单介绍下 ES6 中的 Iterator 和 Iterable\n你是怎么理解ES6中 Generator的？使用场景？\n如何实现红绿灯效果！\n说一下 GET 和 POST 的区别！\najax原理是什么！如何实现！\n\n 模块（Modules）\n\n模块化编程\n你是怎么理解ES6中Module的！使用场景！\n对比 import、import() 和 requrie 的区别\n\nES6\n\nReflect 有什么用！\n你是怎么理解 ES6中 Proxy 的！使用场景！\n为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty\n列举 ES6 的新特性\n说说你对正则表达式的理解！应用场景！\nES6中数组新增了哪些扩展！\n对象新增了哪些扩展！\nES6中函数新增了哪些扩展！\n你是怎么理解ES6中 Decorator 的！使用场景！\n\n运行时\n\nJavaScript中执行上下文和执行栈是什么！\n说说你对事件循环的理解\nGC 垃圾回收机制及内存管理\n说说 JavaScript 中内存泄漏的几种情况！\n如何判断当前脚本运行在浏览器还是 Node 环境中！\nJavascript本地存储的方式有哪些！区别及应用场景！\n请指出document load和document ready的区别！\n获取表单元素的事件\nhtml dom 的 event 事件\n说说JavaScript中的事件模型\n解释下什么是事件代理！应用场景！\n说说new操作符具体干了什么！\n说说你对BOM的理解，常见的BOM对象你了解哪些！\n举例说明你对尾递归的理解，有哪些应用场景\n如何判断一个元素是否在可视区域中！\n\n应用\n\n如何实现大文件上传！\n大文件上传如何做断点续传！\n如何实现上拉加载，下拉刷新！\n如何实现树形结构列表和扁平列表的互相转换！\n什么是单点登录！\nweb常见的攻击方式有哪些！如何防御！\nscript 标签放在 header 里和放在 body 底部里有什么区别！\n什么是单点登录！如何实现！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中如何处理会话(Session)和身份验证(Authentication)！":{"title":"Koa.js中如何处理会话(Session)和身份验证(Authentication)！","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中处理会话(Session)和身份验证(Authentication)可以使用中间件来实现。下面介绍一些常用的中间件和技术来处理这些功能：\n\n\nkoa-session中间件：此中间件可用于处理会话。它使用加密的cookie存储会话数据，并提供与会话相关的功能。你可以使用koa-session中间件来保存和读取会话数据，比如用户的身份验证状态、用户ID等。\n\n\nkoa-passport中间件：此中间件是一个用于身份验证和授权的库。它使用不同的策略（如本地策略、OAuth策略等）来验证用户身份。你可以使用koa-passport中间件来设置身份验证策略、处理用户登录和注销等功能。同时，koa-passport可以与koa-session结合使用，以实现会话管理。\n\n\njsonwebtoken：如果你更喜欢使用 JSON Web Tokens（JWT）来进行身份验证，可以使用jsonwebtoken库。JWT是一种基于加密的令牌，用于在服务器和客户端之间传递身份验证信息。你可以生成JWT令牌并在客户端存储，然后在每个请求中将其发送回服务器进行验证。\n\n\n你可以根据自己的需求选择合适的中间件和技术来处理会话和身份验证。无论哪种方法，都需要在适当的地方验证身份、设置会话信息，并对需要身份验证的路由进行保护。这可以通过编写中间件函数和使用它们来实现。记得在处理身份验证时保护用户的敏感数据，并注意防止安全漏洞，如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中如何处理并发请求！解释一下协程和异步编程。":{"title":"Koa.js中如何处理并发请求！解释一下协程和异步编程。","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中处理并发请求的最常用方法是使用协程和异步编程。\n协程是一种可以中断和恢复的程序执行的方式。在Koa.js中，我们使用async/await语法来实现协程。当我们在处理并发请求时，可以使用async/await结合Promise来实现异步编程。\n异步编程是一种处理并行任务的方式，它允许程序在等待任务完成时继续执行其他操作，而不必阻塞线程。在Koa.js中，我们常常使用异步函数和中间件来处理并发请求。\n下面是一个示例，演示如何处理并发请求：\nconst Koa = require(&#039;koa&#039;);\nconst app = new Koa();\n \napp.use(async (ctx, next) =&gt; {\n  const start = Date.now();\n  await next();\n  const end = Date.now();\n  console.log(`Request took ${end - start}ms`);\n});\n \napp.use(async (ctx, next) =&gt; {\n  // 模拟一个异步操作，比如从数据库中读取数据\n  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));\n  ctx.body = &#039;Hello, Koa!&#039;;\n});\n \napp.listen(3000);\n在上面的示例中，第一个中间件使用async/await语法来计算请求处理花费的时间。第二个中间件模拟了一个异步操作（比如从数据库中读取数据），在完成之后，将响应内容设置为”Hello, Koa!”。\n通过使用协程和异步编程，Koa.js能够同时处理多个请求并且保持高性能。使用async/await可以使代码更具可读性和可维护性，确保在处理并发请求时不会阻塞应用程序。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的上下文(Context)是什么！如何在中间件之间共享数据！":{"title":"Koa.js中的上下文(Context)是什么！如何在中间件之间共享数据！","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中，上下文(Context)是一个代表当前请求和响应的对象，它在每个中间件函数中作为第一个参数传递。上下文对象(ctx)包含了请求信息、响应信息和一些其他有用的属性和方法。\n上下文对象(ctx)具有以下常用属性和方法：\n\nctx.request：表示客户端请求的对象，包含了请求的方法、URL、头部和主体等信息。\nctx.response：表示服务器发送的响应对象，包含了响应的状态、头部和主体等信息。\nctx.state：用于在中间件之间共享数据的对象。可以将一些共享的状态存储在 ctx.state 中，供后续的中间件使用。\nctx.params：表示请求的路由参数的对象，例如 /:id 路径中的 id 参数可以通过 ctx.params.id 访问到。\nctx.query：表示请求的查询参数的对象，例如在 /?name=John URL 中的 name 参数可以通过 ctx.query.name 访问到。\nctx.cookies：用于读取和设置请求的 Cookie。\nctx.throw()：用于抛出一个 HTTP 错误，例如 ctx.throw(404, &#039;Not Found&#039;)。\nctx.redirect()：用于重定向到指定的 URL。\n\n在中间件之间共享数据的方式是通过上下文对象的 ctx.state 属性。可以将需要共享的数据存储在 ctx.state 中，然后在后续的中间件中通过 ctx.state 访问和使用这些数据。例如：\napp.use(async (ctx, next) =&gt; {\n  ctx.state.user = { name: &#039;John&#039; };\n  await next();\n});\n \napp.use(async (ctx) =&gt; {\n  console.log(ctx.state.user.name); // 输出 &#039;John&#039;\n  ctx.body = &#039;Hello, &#039; + ctx.state.user.name;\n});\n在上面的例子中，第一个中间件函数将用户对象存储在 ctx.state.user 中，然后在第二个中间件函数中通过 ctx.state.user.name 访问并使用这个数据。\n通过上下文对象和 ctx.state 属性，可以实现中间件之间的数据共享，使得开发者能够在请求处理的不同阶段访问和操作相同的数据。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。":{"title":"Koa.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中，可以通过设置响应头来实现缓存控制。Koa内置的ctx.set()方法可以用于设置响应头，通过设置以下头部字段可以实现缓存控制：\n\nETag: ETag是实体标签的缩写，可以看作是表示资源的唯一标识符。服务器可以为每个资源生成一个ETag，并在后续请求中将其发送给客户端。客户端可以在发起请求时将ETag作为If-None-Match请求头发送给服务器。服务器会将ETag与当前资源的ETag进行比较，如果相同，说明资源没有修改，并返回304 Not Modified响应。这样可以避免返回相同内容的资源，减少数据传输量。\n\n以下是一个示例，展示了如何在Koa.js中设置ETag：\nrouter.get(&#039;/api/users/:id&#039;, ctx =&gt; {\n  const { id } = ctx.params;\n  // 生成ETag\n  const etag = generateEtag(id);\n  // 设置ETag头部字段\n  ctx.set(&#039;ETag&#039;, etag);\n \n  // 检查If-None-Match头部字段\n  const ifNoneMatch = ctx.request.get(&#039;If-None-Match&#039;);\n  if (ifNoneMatch === etag) {\n    ctx.status = 304; // 返回304 Not Modified响应\n    return;\n  }\n \n  // 返回资源内容\n  const user = getUserById(id);\n  ctx.body = user;\n});\n\nLast-Modified: Last-Modified表示资源的最后修改时间。服务器可以在响应头中设置Last-Modified字段，客户端可以在后续请求中将其作为If-Modified-Since请求头发送给服务器。服务器会将资源的最后修改时间与当前时间进行比较，如果不同，表示资源已被修改，并返回新的响应。如果相同，说明资源没有修改，并返回304 Not Modified响应。\n\n以下是一个示例，展示了如何在Koa.js中设置Last-Modified：\nrouter.get(&#039;/api/users/:id&#039;, ctx =&gt; {\n  const { id } = ctx.params;\n  const user = getUserById(id);\n \n  // 设置Last-Modified头部字段\n  ctx.set(&#039;Last-Modified&#039;, user.lastModified.toUTCString());\n \n  // 检查If-Modified-Since头部字段\n  const ifModifiedSince = ctx.request.get(&#039;If-Modified-Since&#039;);\n  if (ifModifiedSince &amp;&amp; new Date(ifModifiedSince) &gt;= user.lastModified) {\n    ctx.status = 304; // 返回304 Not Modified响应\n    return;\n  }\n \n  // 返回资源内容\n  ctx.body = user;\n});\n这样，服务器可以根据ETag和Last-Modified来进行缓存控制，提供更高效的资源传输和减少网络流量。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的路由是什么！如何定义和使用路由！":{"title":"Koa.js中的路由是什么！如何定义和使用路由！","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中，路由用于将不同的请求映射到对应的处理函数上。通过定义和使用路由，可以根据请求的 URL 和方法执行不同的操作。\n\nKoa.js 自身不提供官方的路由功能，而是通过第三方库来添加路由功能。最常用的路由库是 koa-router，通过它可以很方便地定义和使用路由。\n\n要使用 koa-router，首先需要安装它。可以使用 npm 进行安装：\nnpm install koa-router\n安装完成后，在 Koa.js 应用中引入 koa-router 并创建一个路由对象。然后使用路由对象的 get()、post() 等方法定义各个路由，并指定对应的处理函数。\n下面是一个简单的示例，演示如何使用 koa-router 定义和使用路由：\nconst Koa = require(&#039;koa&#039;);\nconst Router = require(&#039;koa-router&#039;);\n \nconst app = new Koa();\nconst router = new Router();\n \nrouter.get(&#039;/&#039;, (ctx) =&gt; {\n  ctx.body = &#039;Hello, Koa.js!&#039;;\n});\n \nrouter.get(&#039;/users&#039;, (ctx) =&gt; {\n  ctx.body = &#039;List of users&#039;;\n});\n \nrouter.get(&#039;/users/:id&#039;, (ctx) =&gt; {\n  const userId = ctx.params.id;\n  ctx.body = `User ID: ${userId}`;\n});\n \napp.use(router.routes());\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server started on port 3000&#039;);\n});\n在上面的例子中，我们首先引入了 koa-router 模块并创建了一个 Router 对象。然后，我们使用 router.get() 方法定义了三个路由。第一个路由是根路由 &#039;/&#039;，对应的处理函数输出了一个简单的欢迎信息。第二个路由是 &#039;/users&#039;，对应的处理函数输出了一个用户列表。第三个路由是 &#039;/users/:id&#039;，其中的 :id 是一个参数，对应的处理函数输出了用户的 ID。\n最后，我们通过调用 app.use() 并传入 router.routes() 将路由添加到 Koa.js 应用中。\n通过这种方式，我们可以根据请求的 URL 和方法定义并使用路由，将不同的请求映射到对应的处理函数上。这样，我们就能够以模块化和可复用的方式组织和处理请求和响应。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的错误处理机制是什么！如何处理错误和异常！":{"title":"Koa.js中的错误处理机制是什么！如何处理错误和异常！","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中，错误处理是通过中间件来实现的。Koa.js 提供了 app.use() 方法来注册中间件，我们可以使用中间件来处理错误和异常。\n错误处理中间件需要定义在其他路由和中间件之后，以便能够捕获和处理错误。错误处理中间件接收一个 ctx 对象和一个 next 函数作为参数，其中 ctx 对象代表 Koa.js 的上下文对象，next 函数用于执行下一个中间件。\n在错误处理中间件中，可以使用 try/catch 块来捕获错误。如果发生错误，可以使用 ctx.throw() 方法抛出一个 HTTP 异常，并设置响应的状态码、消息和属性。\n以下是一个处理错误的示例：\napp.use(async (ctx, next) =&gt; {\n  try {\n    await next();\n  } catch (err) {\n    // 处理错误\n    ctx.status = err.status || 500;\n    ctx.body = err.message;\n  }\n});\n \napp.use(async (ctx) =&gt; {\n  // 模拟一个错误\n  throw new Error(&#039;Something went wrong&#039;);\n});\n在上面的例子中，首先定义了一个错误处理中间件，然后定义了一个路由处理中间件。路由处理中间件会抛出一个错误，然后错误处理中间件会捕获并处理该错误，设置响应的状态码为 500，响应消息为 “Something went wrong”。\n使用错误处理中间件可以帮助我们简化错误处理的流程，集中处理错误并返回适当的响应。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中，如何处理JSON格式数据、静态文件和文件上传！":{"title":"Koa.js中，如何处理JSON格式数据、静态文件和文件上传！","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中处理 JSON 格式数据、静态文件和文件上传可以使用以下中间件：\n1. 处理 JSON 格式数据： 可以使用 koa-bodyparser 中间件来解析请求的 body 参数。它会自动将 JSON 格式的数据解析成对象，并挂载到 ctx.request.body 上。示例代码如下：\nconst bodyParser = require(&#039;koa-bodyparser&#039;);\n \napp.use(bodyParser());\n2. 提供静态文件服务： 可以使用 koa-static 中间件来提供静态文件服务。它会将指定目录下的文件作为静态资源返回给客户端。示例代码如下：\nconst static = require(&#039;koa-static&#039;);\n \napp.use(static(&#039;public&#039;));\n上面的示例将 public 目录下的文件作为静态文件提供服务，客户端可以通过访问 /public 目录下的文件来获取静态资源。\n3. 文件上传： 可以使用 koa-multer 中间件来处理文件上传。koa-multer 提供了丰富的选项和 API 来处理文件上传请求。示例代码如下：\nconst multer = require(&#039;koa-multer&#039;);\nconst upload = multer({ dest: &#039;uploads/&#039; });\n \nrouter.post(&#039;/upload&#039;, upload.single(&#039;image&#039;), (ctx) =&gt; {\n  // 处理文件上传\n});\n上面的示例使用 koa-multer 中间件来处理文件上传请求，upload.single() 方法定义了单个文件上传的规则。在路由处理函数中，可以通过 ctx.req.file 获取上传的文件信息。\n这些中间件可以根据实际需求进行配置和使用。你可以根据需要选择合适的中间件来处理 JSON 数据、静态文件和文件上传。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。":{"title":"Koa.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。","links":[],"tags":["编程/Node/Koa"],"content":"Koa.js 提供了一些内置的中间件，可以通过 app.use() 方法注册并使用它们。以下是一些常用的内置中间件及其使用示例：\n\nkoa-static 中间件：用于提供静态文件服务。\n\nconst static = require(&#039;koa-static&#039;);\n \napp.use(static(&#039;public&#039;));\n上面的示例使用 koa-static 中间件将 public 目录下的文件作为静态文件提供服务。\n\nkoa-router 中间件：用于实现路由功能。\n\nconst Router = require(&#039;koa-router&#039;);\n \nconst router = new Router();\n \nrouter.get(&#039;/users&#039;, (ctx) =&gt; {\n  // 处理 GET /users\n});\n \napp.use(router.routes());\napp.use(router.allowedMethods());\n上面的示例使用 koa-router 中间件定义了一个 GET 请求的路由处理函数，并在应用中注册了路由中间件。\n\nkoa-bodyparser 中间件：用于解析请求的 body 参数。\n\nconst bodyParser = require(&#039;koa-bodyparser&#039;);\n \napp.use(bodyParser());\n上面的示例使用 koa-bodyparser 中间件来解析请求体的参数，使其变为可通过 ctx.request.body 获取的对象。\n这只是一些常用的内置中间件示例，还有很多其他的中间件可供使用，例如koa-session、koa-views等。你可以根据自己的需求选择和使用适合的中间件。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中如何处理并发请求！解释一下事件循环和线程池。":{"title":"Node.js中如何处理并发请求！解释一下事件循环和线程池。","links":[],"tags":["编程/Node"],"content":"在Node.js中，通过事件循环和线程池的机制来处理并发请求。以下是它们的详细解释：\n1. 事件循环（Event Loop）:\n事件循环是Node.js的核心概念，它使得Node.js可以处理大量的并发请求。事件循环负责监听事件（如I/O请求、定时器等），并且派发事件的相应处理函数。它不断地循环执行以下步骤：\n\n接收事件：事件循环等待和接收来自操作系统或应用程序的事件，在事件队列中排队等待处理。\n执行事件循环：事件循环会从事件队列中获取一个事件，执行相应的处理函数。\n处理事件：事件处理函数通常是异步的，如果需要进行I/O操作，它们将会注册回调函数并返回控制权给事件循环。\n等待和处理其他事件：事件循环继续等待和处理其他事件，例如在I/O操作完成时触发的回调函数。\n\n通过事件循环，Node.js可以实现非阻塞I/O，从而能够同时处理多个并发请求而不被阻塞。这使得Node.js非常适合构建高性能和可扩展的应用程序。\n2. 线程池（Thread Pool）:\nNode.js是基于单线程事件循环的，但是它使用线程池来处理某些任务，例如CPU密集型操作或需要进行阻塞式I/O的任务。线程池允许Node.js同时执行多个阻塞式操作，而不会阻塞事件循环本身。\n当Node.js需要执行阻塞式I/O或CPU密集型操作时，它会将这些任务委派给线程池中的线程进行处理。这些线程对于Node.js来说是透明的，它们会在后台进行处理，并在完成后将结果返回给事件循环。这样，事件循环就不会被阻塞，其他请求仍然可以得到及时处理和响应。\n线程池的大小可以通过配置进行调整，以便在应用程序的需求和硬件资源之间进行平衡。\n总结起来，Node.js通过事件循环和线程池的机制实现了高效的并发处理。事件循环通过非阻塞I/O的方式处理大量并发请求，而线程池可以处理一些需要阻塞式I/O或CPU密集型操作的任务，以保持事件循环的高效运行。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的事件(Event)是什么！如何创建和触发事件！":{"title":"Node.js中的事件(Event)是什么！如何创建和触发事件！","links":[],"tags":["编程/Node"],"content":"在Node.js中，事件是一种消息传递机制，允许对象相互通信和交互。它基于观察者模式，包含两个主要组件：事件发射器（EventEmitter）和事件监听器（Event Listener）。\n要创建和触发事件，首先需要创建一个具有事件功能的对象。这可以通过以下方式进行：\nconst EventEmitter = require(&#039;events&#039;);\n \n// 创建自定义事件发射器对象\nconst myEmitter = new EventEmitter();\n然后，可以使用on方法添加一个事件监听器来侦听某个事件，并在事件触发时执行相应的操作：\nmyEmitter.on(&#039;myEvent&#039;, () =&gt; {\n  console.log(&#039;Event has been triggered!&#039;);\n});\n最后，使用emit方法触发特定的事件：\nmyEmitter.emit(&#039;myEvent&#039;);\n在上述示例中，我们创建了一个自定义事件发射器对象myEmitter，并向其添加了一个名为myEvent的事件监听器。当我们调用myEmitter.emit(&#039;myEvent&#039;)时，事件监听器就会执行，输出”Event has been triggered!”。\n除了on方法，还可以使用once方法来添加只会触发一次的事件监听器，使用removeListener方法来移除事件监听器，使用removeAllListeners方法来移除特定事件上的所有监听器。\nNode.js有多个内置的事件发射器，例如http.Server、fs.ReadStream和process等。这些对象的实例可以触发和监听相应的事件。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的回调函数是什么！为什么要使用回调函数！":{"title":"Node.js中的回调函数是什么！为什么要使用回调函数！","links":[],"tags":["编程/Git"],"content":"在Node.js中，回调函数是一个作为参数传递给其他函数的函数，用于在异步操作完成后执行相应的处理逻辑。回调函数通常接受两个参数：错误对象（如果有错误发生）和结果数据（如果操作成功）。回调函数通过这两个参数来处理异步操作的结果。\n回调函数在Node.js中被广泛使用，主要有以下几个原因：\n\n\n处理异步操作：Node.js是基于事件驱动的编程模型，大多数操作都是非阻塞的。通过将回调函数传递给异步操作，可以在操作完成后执行相应的处理逻辑。这种机制可以避免对返回值的依赖，而是通过回调函数处理异步操作的结果。\n\n\n避免阻塞：由于Node.js是单线程的，如果直接采用同步的方式执行耗时的操作，会导致整个程序阻塞，无法处理其他请求。通过使用回调函数，可以在调用耗时操作时立即返回，继续处理其他请求，等待操作完成后再执行回调函数来处理结果，保持程序的响应性能。\n\n\n错误处理：回调函数可以接收错误对象作为参数，在异步操作发生错误时进行适当的处理。错误处理是开发中的重要环节，通过回调函数传递错误对象，可以及时发现和处理错误。\n\n\n控制流管理：回调函数可以根据业务逻辑的需要进行灵活的控制流程管理。可以根据需要执行不同的回调函数，实现复杂的逻辑控制流。\n\n\n总的来说，使用回调函数是为了处理异步操作、避免阻塞、实现错误处理和管理控制流，使得Node.js能够高效地处理并发请求和异步操作。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的数据库操作如何实现！举例说明如何连接和查询数据库。":{"title":"Node.js中的数据库操作如何实现！举例说明如何连接和查询数据库。","links":[],"tags":["编程/Node"],"content":"在Node.js中，可以使用各种第三方模块来连接和查询数据库。下面以MongoDB和MySQL为例说明如何连接和查询数据库。\nMongoDB\n连接MongoDB数据库的步骤如下：\n\n首先，你需要使用npm安装mongodb模块：\n\nnpm install mongodb\n\n创建一个数据库连接：\n\nconst MongoClient = require(&#039;mongodb&#039;).MongoClient;\n \nconst url = &#039;mongodb://localhost:27017/mydb&#039;; // MongoDB连接字符串，指定数据库名称\n \nMongoClient.connect(url, (err, db) =&gt; {\n  if (err) throw err;\n  console.log(&#039;Connected to the database&#039;);\n \n  // 在这里进行数据库查询和操作\n  // ...\n \n  db.close(); // 关闭数据库连接\n});\n在上面的例子中，我们使用MongoClient.connect()方法来连接MongoDB数据库。你需要提供一个MongoDB连接字符串，其中localhost:27017表示MongoDB服务器的地址和端口号，mydb是数据库的名称。\n一旦连接成功，你就可以进行数据库查询和操作，例如插入文档、更新文档、查询文档等。\nMySQL\n连接MySQL数据库的步骤如下：\n\n首先，你需要使用npm安装mysql模块：\n\nnpm install mysql\n\n创建一个数据库连接：\n\nconst mysql = require(&#039;mysql&#039;);\n \nconst connection = mysql.createConnection({\n  host: &#039;localhost&#039;,\n  user: &#039;root&#039;,\n  password: &#039;password&#039;,\n  database: &#039;mydb&#039; // 指定数据库名称\n});\n \nconnection.connect((err) =&gt; {\n  if (err) throw err;\n  console.log(&#039;Connected to the database&#039;);\n \n  // 在这里进行数据库查询和操作\n  // ...\n \n  connection.end(); // 关闭数据库连接\n});\n在上面的例子中，我们使用mysql.createConnection()方法来创建一个数据库连接。你需要提供MySQL服务器的地址、用户名、密码和数据库名称。\n一旦连接成功，你就可以进行数据库查询和操作，例如执行SQL查询、插入数据、更新数据等。\n\n\n                  \n                  注意❗ \n                  \n                \n请注意，在生产环境中，你可能会使用连接池来管理数据库连接，以提高性能和资源利用率。以上示例仅用于演示基本的数据库连接和查询操作。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的模块化是如何实现的！举例说明如何导入和导出模块。":{"title":"Node.js中的模块化是如何实现的！举例说明如何导入和导出模块。","links":[],"tags":["编程/Node"],"content":"在Node.js中，模块化是通过使用CommonJS规范来实现的。根据这个规范，每个文件就是一个模块，模块中的代码可以被其他文件导入和使用。\n为了导入其他模块，你可以使用require函数，并传入要导入的模块的路径作为参数。路径可以是相对路径（以当前文件所在位置为基准）或者是绝对路径。\n下面是一个导入模块的例子：\n// 导入Node.js内置的fs模块\nconst fs = require(&#039;fs&#039;);\n \n// 导入自定义的模块，相对路径\nconst myModule = require(&#039;./myModule&#039;);\n \n// 导入第三方模块，通过模块名引用\nconst axios = require(&#039;axios&#039;);\n在上面的例子中，我们分别导入了Node.js内置的fs模块、自定义的模块myModule以及第三方模块axios。\n在模块中，我们可以通过module.exports来导出变量、函数或对象。导出的内容可以被其他模块使用。\n下面是一个导出模块的例子：\n// 导出一个变量\nconst name = &#039;John&#039;;\nmodule.exports.name = name;\n \n// 导出一个函数\nfunction greet() {\n  console.log(`Hello, ${name}!`);\n}\nmodule.exports.greet = greet;\n \n// 导出一个对象\nconst person = {\n  name: &#039;Alice&#039;,\n  age: 25,\n};\nmodule.exports.person = person;\n在上面的例子中，我们通过module.exports导出了一个变量name、一个函数greet和一个对象person。其他模块可以使用require函数导入并使用这些导出的内容。\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是，Node.js默认将每个模块封装在一个函数中，并在初始化时传入module、exports、require等参数。所以，在每个模块中可以直接使用module.exports来导出内容。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的错误处理机制是什么！如何处理异步错误！":{"title":"Node.js中的错误处理机制是什么！如何处理异步错误！","links":[],"tags":["编程/Git"],"content":"Node.js中的错误处理机制主要是通过回调函数或Promise的reject来处理。在异步操作中，错误通常是通过回调函数的第一个参数返回，或者在Promise中使用reject方法抛出。\n例如，使用回调函数处理异步错误的示例代码如下：\nfs.readFile(&#039;file.txt&#039;, (err, data) =&gt; {\n  if (err) {\n    // 处理错误\n  } else {\n    // 处理数据\n  }\n});\n在这个例子中，如果读取文件时发生错误，错误信息将作为回调函数的第一个参数传递给err。您可以在错误处理程序中进行适当的错误处理。\n对于Promise，您可以使用catch方法来处理错误。例如：\nfs.promises.readFile(&#039;file.txt&#039;)\n  .then(data =&gt; {\n    // 处理数据\n  })\n  .catch(err =&gt; {\n    // 处理错误\n  });\n在这个示例中，如果读取文件时发生错误，该错误将被传递给catch方法，您可以在catch块中处理错误。\n通过这种方式处理错误可以确保在发生错误时适当地捕获和处理它们。另外，您还可以选择在需要的地方向上层传递错误，以便在适当的位置进行处理。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js如何处理跨域请求！解释一下跨域资源共享(CORS)。":{"title":"Node.js如何处理跨域请求！解释一下跨域资源共享(CORS)。","links":[],"tags":["编程/Node"],"content":"Node.js可以使用中间件来处理跨域请求。解决跨域问题的一种常见方法是使用CORS（Cross-Origin Resource Sharing）机制。\n\n\n                  \n                  跨域请求 \n                  \n                \n跨域请求是指在浏览器中，从一个域名的网页去请求另一个域名的资源。跨域请求是受到浏览器的同源策略（Same Origin Policy）限制的，该策略要求浏览器只能发送同源（协议、域名、端口号相同）的请求。\n\nCORS是一种机制，它允许服务器在响应中告知浏览器是否允许跨域访问。通过在服务器响应头部中设置特定的CORS相关字段，服务器可以告诉浏览器是否允许跨域访问，并可以指定哪些跨域请求是允许的。\n在Node.js中，你可以使用第三方中间件，比如cors、cors-anywhere等，来处理CORS。下面是使用cors中间件的示例：\n首先，你需要使用npm安装cors模块：\nnpm install cors\n然后，在你的应用程序中引入cors模块，并使用它作为中间件来处理CORS：\nconst express = require(&#039;express&#039;);\nconst cors = require(&#039;cors&#039;);\n \nconst app = express();\n \napp.use(cors());\n \n// 其他路由和中间件\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server started on port 3000&#039;);\n});\n在上面的例子中，app.use(cors())语句将cors中间件应用到所有的路由上，从而允许来自任何域名的跨域请求。你也可以配置cors中间件以指定允许的域名，请求方法等。\n这样，当你的Node.js服务器收到跨域请求时，它会在响应中包含CORS头部，告诉浏览器该请求是允许的。浏览器收到这个响应后，就会允许跨域访问。\n请注意，使用CORS机制可能会带来安全风险。你应该仔细考虑允许的域名和请求方法，并遵循安全最佳实践来防止恶意请求。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js提供了哪些内置的核心模块！举例说明如何使用其中的模块。":{"title":"Node.js提供了哪些内置的核心模块！举例说明如何使用其中的模块。","links":[],"tags":["编程/Node"],"content":"Node.js提供了很多内置的核心模块，用于处理文件系统、网络请求、数据流、加密、操作系统等各种任务。 以下是一些常用的核心模块和它们的用法示例：\n1. fs模块（文件系统）：用于读取、写入、修改文件和目录。\nconst fs = require(&#039;fs&#039;);\n \n// 读取文件\nfs.readFile(&#039;file.txt&#039;, &#039;utf8&#039;, (err, data) =&gt; {\n  if (err) throw err;\n  console.log(data);\n});\n \n// 写入文件\nfs.writeFile(&#039;file.txt&#039;, &#039;Hello, World!&#039;, (err) =&gt; {\n  if (err) throw err;\n  console.log(&#039;File written!&#039;);\n});\n2. http模块（HTTP）：用于创建 HTTP 服务器和处理 HTTP 请求和响应。\nconst http = require(&#039;http&#039;);\n \nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/plain&#039;);\n  res.end(&#039;Hello, World!&#039;);\n});\n \nserver.listen(3000, &#039;localhost&#039;, () =&gt; {\n  console.log(&#039;Server running at http://localhost:3000/&#039;);\n});\n3. path模块（路径）：用于处理文件路径的相关操作。\nconst path = require(&#039;path&#039;);\n \nconst fullPath = path.join(&#039;/dir&#039;, &#039;file.txt&#039;);\nconsole.log(fullPath); // 输出：/dir/file.txt\n \nconst basename = path.basename(&#039;/dir/file.txt&#039;);\nconsole.log(basename); // 输出：file.txt\n \nconst extname = path.extname(&#039;/dir/file.txt&#039;);\nconsole.log(extname); // 输出：.txt\n4. crypto模块（加密）：提供了加密、解密、散列和签名的功能。\nconst crypto = require(&#039;crypto&#039;);\n \nconst hash = crypto.createHash(&#039;sha256&#039;);\nhash.update(&#039;Hello, World!&#039;);\nconst hashedData = hash.digest(&#039;hex&#039;);\nconsole.log(hashedData); // 输出：7e0e1d7e90a07e9736658f3a1c3343557957424c14723f6ef804fb5ae271b4b9\n5. os模块（操作系统）：提供了与操作系统相关的功能，如获取操作系统信息和处理系统级任务。\nconst os = require(&#039;os&#039;);\n \nconst totalMemory = os.totalmem();\nconsole.log(totalMemory); // 输出：16815525888\n \nconst freeMemory = os.freemem();\nconsole.log(freeMemory); // 输出：889204992\n以上仅是一小部分Node.js提供的内置核心模块，还有许多其他模块可以用于各种不同的任务，如net模块用于创建 TCP 或 IPC 服务器和客户端，stream模块用于流操作，util模块提供了一些实用工具函数等等。根据具体需求，可以查阅官方文档了解更多模块及其用法。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/NodeJS八股文":{"title":"NodeJS八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Node-文件查找的优先级以及-Require-方法的文件查找策略！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Nodejs中的事件循环机制理解！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-fs模块的理解！-有哪些常用方法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的回调函数是什么！为什么要使用回调函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的模块化是如何实现的！举例说明如何导入和导出模块。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Stream-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的流(Stream)和管道(Pipe)。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的事件(Event)是什么！如何创建和触发事件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的中间件(Middleware)和路由(Routing)。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对中间件概念的理解，如何封装-node-中间件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中如何处理并发请求！解释一下事件循环和线程池。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的错误处理机制是什么！如何处理异步错误！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Node.js-的理解！优缺点！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Node.-js-有哪些全局对象！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-process-的理解！有哪些常用方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js提供了哪些内置的核心模块！举例说明如何使用其中的模块。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Buffer-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Node中的EventEmitter！-如何实现一个EventEmitter！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现jwt鉴权机制！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现文件上传！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如果让你来设计一个分页功能,-你会怎么设计！-前后端如何交互！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node性能如何进行监控以及优化！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js如何处理跨域请求！解释一下跨域资源共享(CORS)。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Node.js中的数据库操作如何实现！举例说明如何连接和查询数据库。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何创建和部署一个基于Node.js的Web服务器！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的缓存(Cache)和性能优化。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Express.js！它的特点是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的中间件(Middleware)机制。如何使用和创建中间件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的路由是什么！如何定义和使用路由！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的静态文件服务是如何实现的！举例说明如何提供静态文件访问。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的视图引擎(View-Engine)。如何配置和使用视图引擎！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的错误处理机制是什么！如何处理错误和异常！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中处理请求参数和查询参数！解释一下req和res对象的常用属性和方法。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中处理表单提交和文件上传！举例说明如何解析表单数据和文件。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中如何处理会话(Session)和身份验证(Authentication)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的重定向(Redirect)和路由保护(Route-protection)。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中实现API接口，并且返回JSON格式数据！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中实现日志记录(Logging)和调试(Debugging)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Express.js中如何处理并发请求！解释一下多线程和事件循环。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Koa.js！它的特点是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的中间件(Middleware)机制。如何使用和创建中间件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的上下文(Context)是什么！如何在中间件之间共享数据！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的路由是什么！如何定义和使用路由！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中处理请求参数和查询参数！解释一下ctx对象的常用属性和方法。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的错误处理机制是什么！如何处理错误和异常！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中，如何处理JSON格式数据、静态文件和文件上传！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中如何处理会话(Session)和身份验证(Authentication)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的重定向(Redirect)和路由保护(Route-protection)。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中实现API接口，并且返回JSON格式数据！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中实现日志记录(Logging)和调试(Debugging)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Koa.js中如何处理并发请求！解释一下协程和异步编程。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的异步中间件和中间件洋葱模型。"],"tags":["编程/Node"],"content":"重点\n\n说说 Node 文件查找的优先级以及 Require 方法的文件查找策略！\n说说对Nodejs中的事件循环机制理解！\n说说对 Node 中的 fs模块的理解！ 有哪些常用方法\n\n八股文\n核心概念\n\nNode.js中的回调函数是什么！为什么要使用回调函数！\nNode.js中的模块化是如何实现的！举例说明如何导入和导出模块。\n说说对 Node 中的 Stream 的理解！应用场景！\n解释一下Node.js中的流(Stream)和管道(Pipe)。\nNode.js中的事件(Event)是什么！如何创建和触发事件！\n解释一下Node.js中的中间件(Middleware)和路由(Routing)。\n说说对中间件概念的理解，如何封装 node 中间件！\nNode.js中如何处理并发请求！解释一下事件循环和线程池。\n\n使用方法\n\nNode.js中的错误处理机制是什么！如何处理异步错误！\n说说你对Node.js 的理解！优缺点！应用场景！\n说说 Node. js 有哪些全局对象！\n说说对 Node 中的 process 的理解！有哪些常用方法！\n说说对 Node 中的 fs模块的理解！ 有哪些常用方法\nNode.js提供了哪些内置的核心模块！举例说明如何使用其中的模块。\n说说对 Node 中的 Buffer 的理解！应用场景！\n说说Node中的EventEmitter！ 如何实现一个EventEmitter！\n说说对Nodejs中的事件循环机制理解！\n说说 Node 文件查找的优先级以及 Require 方法的文件查找策略！\n如何实现jwt鉴权机制！说说你的思路\n如何实现文件上传！说说你的思路\n如果让你来设计一个分页功能, 你会怎么设计！ 前后端如何交互！\nNode性能如何进行监控以及优化！\nNode.js如何处理跨域请求！解释一下跨域资源共享(CORS)。\nNode.js中的数据库操作如何实现！举例说明如何连接和查询数据库。\n如何创建和部署一个基于Node.js的Web服务器！\n解释一下Node.js中的缓存(Cache)和性能优化。\n\nExpress.js\n\n什么是Express.js！它的特点是什么！\n解释一下Express.js中的中间件(Middleware)机制。如何使用和创建中间件！\nExpress.js中的路由是什么！如何定义和使用路由！\nExpress.js中的静态文件服务是如何实现的！举例说明如何提供静态文件访问。\n解释一下Express.js中的视图引擎(View Engine)。如何配置和使用视图引擎！\nExpress.js中的错误处理机制是什么！如何处理错误和异常！\n如何在Express.js中处理请求参数和查询参数！解释一下req和res对象的常用属性和方法。\nExpress.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。\n如何在Express.js中处理表单提交和文件上传！举例说明如何解析表单数据和文件。\nExpress.js中如何处理会话(Session)和身份验证(Authentication)！\n解释一下Express.js中的重定向(Redirect)和路由保护(Route protection)。\n如何在Express.js中实现API接口，并且返回JSON格式数据！\nExpress.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。\n如何在Express.js中实现日志记录(Logging)和调试(Debugging)！\nExpress.js中如何处理并发请求！解释一下多线程和事件循环。\n\nKoa.js\n\n什么是Koa.js！它的特点是什么！\n解释一下Koa.js中的中间件(Middleware)机制。如何使用和创建中间件！\nKoa.js中的上下文(Context)是什么！如何在中间件之间共享数据！\nKoa.js中的路由是什么！如何定义和使用路由！\n如何在Koa.js中处理请求参数和查询参数！解释一下ctx对象的常用属性和方法。\nKoa.js中的错误处理机制是什么！如何处理错误和异常！\nKoa.js提供了哪些内置的中间件！举例说明如何使用其中的中间件。\nKoa.js中，如何处理JSON格式数据、静态文件和文件上传！\nKoa.js中如何处理会话(Session)和身份验证(Authentication)！\n解释一下Koa.js中的重定向(Redirect)和路由保护(Route protection)。\n如何在Koa.js中实现API接口，并且返回JSON格式数据！\nKoa.js中的缓存控制是如何实现的！解释一下ETag和Last-Modified。\n如何在Koa.js中实现日志记录(Logging)和调试(Debugging)！\nKoa.js中如何处理并发请求！解释一下协程和异步编程。\n解释一下Koa.js中的异步中间件和中间件洋葱模型。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/React八股文":{"title":"React八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React中类组件和函数组件的理解！有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-中组件之间如何通信！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-组件的生命周期可分为哪些阶段！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-和-DOM-事件处理的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说react中引入css的方式有哪几种！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Redux！请简要解释Redux的核心概念。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React服务端渲染怎么做！原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比-React-和-Vue-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-React-的理解！有哪些特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是声明式编程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下-MVVM-模式，和-MVC-模式有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何组织-React-项目文件结构！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-18-都有哪些新特性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-JSX-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么推荐在-React-中使用-JSX-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-JSX-可以有效降低-XSS-风险！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-JSX-中条件渲染！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-JSX-中循环控制！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-JSX-中-class-变成了-className-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-组件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-组件分成哪几类！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对受控组件和非受控组件的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对高阶组件的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Pure-Components-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/展示组件和容器组件的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何劫持-React-组件提高组件复用度！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何设计一个-React-组件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-组件与-Web-Components-共存的最佳实践是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React构建组件的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-的状态！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-的状态提升！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/state-和-props-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何创建动态的状态名称！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何优化-setState，减少不必要更新！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/当-State-值为-Object-时，如何优化！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-的属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么不能直接修改属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/通过属性传递组件本身的方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-key-属性有哪些注意事项！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-React-中进行静态类型检查！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何限制某个属性是必须的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何设置属性的默认值！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-是否支持-HTML-属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-是否支持自定义属性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-React-是单向数据流！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何优化-Context-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Ref-转发！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-返回空对象有哪些方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何优化不必要的渲染！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-如何渲染-HTML-，有什么风险！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-为什么要引入基于-Fiber-协调器的异步渲染！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Fiber架构的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React中的key有什么作用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对immutable的理解！如何应用在react项目中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-render方法的原理！在什么时候会被触发！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你是如何提高组件的渲染效率的！在React中如何避免不必要的render！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-diff的原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-Jsx转换成真实DOM过程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React-性能优化的手段有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React-生命周期有哪些不同阶段！每个阶段对应的方法是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/异步数据请求应在哪些生命周期里调用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useEffect-useLayoutEffect-与生命周期的对应关系是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/super()-和-super(props)-有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/对比-React-Hook-与生命周期","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React的事件机制！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React事件绑定的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-React-事件处理阻止默认行为！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何传参给事件处理函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何阻止事件处理函数被频繁调用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-17-对事件处理做了哪些改进！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何按条件加载样式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何合并多个内联样式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模块化样式，如何避免样式名冲突-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在react中组件间过渡动画如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-错误边界！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/错误边界可以捕获什么错误！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件的哪些生命周期可以用于错误捕获！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你在React项目是如何捕获错误的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何处理事件处理函数内部错误！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React-Hooks的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-State-Hook！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Effect-Hook！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何清除-Effect-Hook-的副作用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-Hook-需要遵循的规则是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useMemo-和-useCallback-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useReducer-和-useState-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useLayoutEffect-和-useEffect-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useRef-和-Refs-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对React-refs-的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何自定义-Hook！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/是否有必要使用-Hook-API-重写所有类组件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/useState-返回更新-state-的函数是同步，还是异步的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Jest-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟数据获取！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟组件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟计时器！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟浅层渲染！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何将组件渲染成-JS-对象！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何模拟-DOM-环境！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何获得测试代码覆盖率！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何测试-React-Router！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Real-DOM-和-Virtual-DOM-的区别！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-React中的setState执行机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2、Vue3、React之间的diff算法区别是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-React-Concurrent-模式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Suspense-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-如何定义任务的优先级！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Redux中，什么是Action！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux中的Reducer是什么！它的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何创建一个Redux-Store！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在React应用中使用Redux！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux中的异步操作如何处理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Redux中的中间件！请举例说明常用的Redux中间件。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux中的连接器（Connector）是什么！它的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux中的Action和Reducer之间的关系是怎样的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Redux中处理多个Reducers的数据流！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux的工作流程是怎样的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Redux中，什么时候应该使用action-creators！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux中的状态持久化是如何实现的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Redux中，什么是Redux-DevTools以及它的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Redux的理解！其工作原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对Redux中间件的理解！常用的中间件有哪些！实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Flux-和-Redux-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux-的核心原则是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-Context-和-Redux-的区别是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React-访问-ReduxStore-的方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Redux-中异步请求数据时发送多-Action-方法有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何判断项目需要引入-Redux-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你在React项目中是如何使用Redux的！-项目结构是如何划分的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写一个-redux-thunk-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对React-Router的理解！常用的Router组件有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-Router有几种模式！实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是-Next.js-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Next.js-预渲染有哪些形式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Next.js-要重新设计一套路由！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Next.js-中获取数据有哪些方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-Next.js-中为静态资源配置-CDN-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你的项目为什么选择-AntD-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/AntD-如何实现固定表头时，列头和内容对不齐怎么办！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/AntD-如何实现虚拟列表！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你在使用React-过程中遇到的常见问题！如何解决！"],"tags":["编程/React"],"content":"重点\n\n说说对React中类组件和函数组件的理解！有什么区别！\nReact 中组件之间如何通信！\nReact 组件的生命周期可分为哪些阶段！\nReact 和 DOM 事件处理的区别是！\n说说react中引入css的方式有哪几种！区别！\n什么是Redux！请简要解释Redux的核心概念。\n说说React服务端渲染怎么做！原理是什么！\n\n八股文\n认识\n\n对比 React 和 Vue ！\n说说对 React 的理解！有哪些特性！\n什么是声明式编程！\n说说你对函数式编程的理解！优缺点！\n介绍一下 MVVM 模式，和 MVC 模式有什么区别！\n如何组织 React 项目文件结构！\nReact 18 都有哪些新特性！\n\nJSX\n\n什么是 JSX ！\n为什么推荐在 React 中使用 JSX ！\n为什么 JSX 可以有效降低 XSS 风险！\n如何在 JSX 中条件渲染！\n如何在 JSX 中循环控制！\n为什么 JSX 中 class 变成了 className ！\n\n组件\n\n什么是 React 组件！\nReact 组件分成哪几类！\n说说对React中类组件和函数组件的理解！有什么区别！\n说说对受控组件和非受控组件的理解！应用场景！\n说说对高阶组件的理解！应用场景！\n什么是 Pure Components ！\n展示组件和容器组件的区别是！\n如何劫持 React 组件提高组件复用度！\n如何设计一个 React 组件！\nReact 组件与 Web Components 共存的最佳实践是！\nReact构建组件的方式有哪些！区别！\n\n状态\n\n什么是 React 的状态！\n什么是 React 的状态提升！\nstate 和 props 有什么区别！\n如何创建动态的状态名称！\n如何优化 setState，减少不必要更新！\n当 State 值为 Object 时，如何优化！\n\n属性\n\n什么是 React 的属性！\n为什么不能直接修改属性！\n通过属性传递组件本身的方法有哪些！\n使用 key 属性有哪些注意事项！\n如何在 React 中进行静态类型检查！\n如何限制某个属性是必须的！\n如何设置属性的默认值！\nReact 是否支持 HTML 属性！\nReact 是否支持自定义属性！\n\n通信\n\nReact 中组件之间如何通信！\n为什么 React 是单向数据流！\n如何优化 Context ！\n什么是 Ref 转发！\n\n渲染\n\nReact 返回空对象有哪些方法！\n如何优化不必要的渲染！\nReact 如何渲染 HTML ，有什么风险！\nReact 为什么要引入基于 Fiber 协调器的异步渲染！\n说说对Fiber架构的理解！解决了什么问题！\nReact Fiber 异步渲染分为哪几个阶段，对应生命周期是什么！\nReact中的key有什么作用！\n说说你对immutable的理解！如何应用在react项目中！\n说说React render方法的原理！在什么时候会被触发！\n说说你是如何提高组件的渲染效率的！在React中如何避免不必要的render！\n说说React diff的原理是什么！\n说说React Jsx转换成真实DOM过程！\n说说 React 性能优化的手段有哪些！\n\n生命周期\n\n说说 React 生命周期有哪些不同阶段！每个阶段对应的方法是！\nReact 组件的生命周期可分为哪些阶段！\n异步数据请求应在哪些生命周期里调用！\nuseEffect useLayoutEffect 与生命周期的对应关系是！\nsuper() 和 super(props) 有什么区别！\n对比 React Hook 与生命周期\n\n事件\n\n说说React的事件机制！\nReact事件绑定的方式有哪些！区别！\nReact 和 DOM 事件处理的区别是！\n如何在 React 事件处理阻止默认行为！\n如何传参给事件处理函数！\n如何阻止事件处理函数被频繁调用！\nReact 17 对事件处理做了哪些改进！\n\n样式管理\n\n说说react中引入css的方式有哪几种！区别！\n如何按条件加载样式！\n如何合并多个内联样式！\n如何模块化样式，如何避免样式名冲突 ！\n在react中组件间过渡动画如何实现！\n\n错误边界\n\n什么是 React 错误边界！\n错误边界可以捕获什么错误！\n组件的哪些生命周期可以用于错误捕获！\n说说你在React项目是如何捕获错误的！\n如何处理事件处理函数内部错误！\n\nHook\n\n说说对React Hooks的理解！解决了什么问题！\n什么是 State Hook！\n什么是 Effect Hook！\n如何清除 Effect Hook 的副作用！\n使用 Hook 需要遵循的规则是！\nuseMemo 和 useCallback 的区别是！\nuseReducer 和 useState 的区别是！\nuseLayoutEffect 和 useEffect 的区别是！\nuseRef 和 Refs 的区别是！\n说说对React refs 的理解！应用场景！\n如何自定义 Hook！\n是否有必要使用 Hook API 重写所有类组件！\nuseState 返回更新 state 的函数是同步，还是异步的！\n\n测试\n\n什么是 Jest ！\n如何模拟数据获取！\n如何模拟组件！\n如何模拟计时器！\n如何模拟浅层渲染！\n如何将组件渲染成 JS 对象！\n如何模拟 DOM 环境！\n如何获得测试代码覆盖率！\n如何测试 React Router！\n\n原理\n\n说说 Real DOM 和 Virtual DOM 的区别！优缺点！\n说说 React中的setState执行机制\nVue2、Vue3、React之间的diff算法区别是什么！\n什么是 React Concurrent 模式！\n什么是 Suspense ！\nReact 如何定义任务的优先级！\n\nRedux\n\n什么是Redux！请简要解释Redux的核心概念。\n在Redux中，什么是Action！\nRedux中的Reducer是什么！它的作用是什么！\n如何创建一个Redux Store！\n如何在React应用中使用Redux！\nRedux中的异步操作如何处理！\n什么是Redux中的中间件！请举例说明常用的Redux中间件。\nRedux中的连接器（Connector）是什么！它的作用是什么！\nRedux中的Action和Reducer之间的关系是怎样的！\n如何在Redux中处理多个Reducers的数据流！\nRedux的工作流程是怎样的！\n在Redux中，什么时候应该使用action creators！\nRedux中的状态持久化是如何实现的！\n在Redux中，什么是Redux DevTools以及它的作用是什么！\n说说你对Redux的理解！其工作原理！\n说说对Redux中间件的理解！常用的中间件有哪些！实现原理！\nFlux 和 Redux 的区别是！\nRedux 的核心原则是！\nReact Context 和 Redux 的区别是！\nReact 访问 ReduxStore 的方法有哪些！\nRedux 中异步请求数据时发送多 Action 方法有哪些！\n如何判断项目需要引入 Redux ！\n你在React项目中是如何使用Redux的！ 项目结构是如何划分的！\n手写一个 redux-thunk ！\n\n路由\n\n说说你对React Router的理解！常用的Router组件有哪些！\n说说React Router有几种模式！实现原理！\n\nNext. js\n\n说说React服务端渲染怎么做！原理是什么！\n什么是 Next.js ！\nNext.js 预渲染有哪些形式！\n为什么 Next.js 要重新设计一套路由！\nNext.js 中获取数据有哪些方法！\n如何在 Next.js 中为静态资源配置 CDN ！\n\nAntD\n\n你的项目为什么选择 AntD ！\nAntD 如何实现固定表头时，列头和内容对不齐怎么办！\nAntD 如何实现虚拟列表！\n\n开放问题\n\n说说你在使用React 过程中遇到的常见问题！如何解决！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/SPA首屏加载速度慢的怎么解决！":{"title":"SPA首屏加载速度慢的怎么解决！","links":["D-Unsorted/其他常见事件","C-Knowledge/前端/技术书籍/前端面试之道/浏览器缓存机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Vue-3.0中Treeshaking特性！举例说明一下！"],"tags":["编程/FE/Vue"],"content":"一、什么是首屏加载\n首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容\n首屏加载可以说是用户体验中最重要的环节\n关于计算首屏时间\n利用performance.timing提供的数据：\n\n通过 DOMContentLoaded 事件或者 performance 来计算出首屏时间\n// 方案一：\ndocument.addEventListener(&#039;DOMContentLoaded&#039;, (event) =&gt; {\n    console.log(&#039;first contentful painting&#039;);\n});\n// 方案二：\nperformance.getEntriesByName(&quot;first-contentful-paint&quot;)[0].startTime\n \n// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]\n// 会返回一个 PerformancePaintTiming的实例，结构如下：\n{\n  name: &quot;first-contentful-paint&quot;,\n  entryType: &quot;paint&quot;,\n  startTime: 507.80000002123415,\n  duration: 0,\n};\n二、加载慢的原因\n在页面渲染的过程，导致加载速度慢的因素可能如下：\n\n网络延时问题\n资源文件体积是否过大\n资源是否重复发送请求去加载了\n加载脚本的时候，渲染内容堵塞了\n\n三、解决方案\n常见的几种SPA首屏优化方式\n\n减小入口文件积\n静态资源本地缓存\nUI框架按需加载\n图片资源的压缩\n组件重复打包\n开启GZip压缩\n使用SSR\n\n减小入口文件体积\n常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n\n在vue-router配置路由的时候，采用动态加载路由的形式\nroutes:[ \n    path: &#039;Blogs&#039;,\n    name: &#039;ShowBlogs&#039;,\n    component: () =&gt; import(&#039;./components/ShowBlogs.vue&#039;)\n]\n以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n静态资源本地缓存\n后端返回资源问题：\n\n采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头\n采用Service Worker离线缓存\n\n前端合理利用 localStorage\nUI框架按需加载\n在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库\nimport ElementUI from &#039;element-ui&#039;\nVue.use(ElementUI)\n但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用\nimport { Button, Input, Pagination, Table, TableColumn, MessageBox } from &#039;element-ui&#039;;\nVue.use(Button)\nVue.use(Input)\nVue.use(Pagination)\n\n说说Vue 3.0中Treeshaking特性！举例说明一下！\n\n组件重复打包\n假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载\n解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置\nminChunks: 3\nminChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件\n图片资源的压缩\n图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素\n对于所有的图片资源，我们可以进行适当的压缩\n对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。\n开启 GZip 压缩\n拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin\ncnmp i compression-webpack-plugin -D\n在vue.congig.js中引入并修改webpack配置\nconst CompressionPlugin = require(&#039;compression-webpack-plugin&#039;)\n \nconfigureWebpack: (config) =&gt; {\n        if (process.env.NODE_ENV === &#039;production&#039;) {\n            // 为生产环境修改配置...\n            config.mode = &#039;production&#039;\n            return {\n                plugins: [new CompressionPlugin({\n                    test: /\\.js$|\\.html$|\\.css/, //匹配文件名\n                    threshold: 10240, //对超过10k的数据进行压缩\n                    deleteOriginalAssets: false //是否删除原文件\n                })]\n            }\n        }\n在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用\nconst compression = require(&#039;compression&#039;)\napp.use(compression())  // 在其他中间件使用之前调用\n使用SSR\nSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器\n从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染\n小结\n减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化\n下图是更为全面的首屏优化的方案\n\n大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化\n参考文献\n\nzhuanlan.zhihu.com/p/88639980\nwww.chengrang.com/how-browsers-work.html\njuejin.cn/post/6844904185264095246\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/SSR-解决了什么问题！有做过-SSR-吗！你是怎么做的！":{"title":"SSR 解决了什么问题！有做过 SSR 吗！你是怎么做的！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/SPA首屏加载速度慢的怎么解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React服务端渲染怎么做！原理是什么！"],"tags":["编程/FE/Vue"],"content":"一、是什么\nServer-Side Rendering 我们称其为SSR，意为服务端渲染\n指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程\n先来看看Web3个阶段的发展史：\n\n传统服务端渲染SSR\n单页面应用SPA\n服务端渲染SSR\n\n传统web开发\n网页内容在服务端渲染完成，⼀次性传输到浏览器\n\n打开页面查看源码，浏览器拿到的是全部的dom结构\n单页应用SPA\n单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染\n\n打开页面查看源码，浏览器拿到的仅有宿主元素#app，并没有内容\n服务端渲染SSR\nSSR 解决方案，后端渲染出完整的首屏的 dom 结构返回，前端拿到的内容包括首屏及完整 SPA 结构，应用激活后依然按照 SPA 方式运行\n\n看完前端发展，我们再看看Vue官方对SSR的解释：\n\n\n                  \n                  重点 \n                  \n                \nVue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序\n服务器渲染的 Vue.js 应用程序也可以被认为是**“同构”或”通用”**，因为应用程序的大部分代码都可以在服务器和客户端上运行\n\n我们从上门解释得到以下结论：\n\nVue SSR是一个在SPA上进行改良的服务端渲染\n通过Vue SSR渲染的页面，需要在客户端激活才能实现交互\nVue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA\n\n二、解决了什么\nSSR主要解决了以下两种问题：\n\nSEO：搜索引擎优先爬取页面 HTML 结构，使用 SSR 时，服务端已经生成了和业务想关联的 HTML，有利于 SEO\n首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）\n\n但是使用SSR同样存在以下的缺点：\n\n复杂度：整个项目的复杂度\n库的支持性，代码兼容\n性能问题\n\n每个请求都是n个实例的创建，不然会污染，消耗会变得很大\n缓存 node serve、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。\n降级：监控cpu、内存占用过多，就spa，返回单个的壳\n\n\n服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用\n\n所以在我们选择是否使用SSR前，我们需要慎重问问自己这些问题：\n\n需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现\n首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢\n\n三、如何实现\n对于同构开发，我们依然使用webpack打包，我们要解决两个问题：服务端首屏渲染和客户端激活\n这里需要生成一个服务器bundle文件用于服务端首屏渲染和一个客户端bundle文件用于客户端激活\n\n代码结构 除了两个不同入口之外，其他结构和之前vue应用完全相同\nsrc\n├── router\n├────── index.js # 路由声明\n├── store\n├────── index.js # 全局状态\n├── main.js # ⽤于创建vue实例\n├── entry-client.js # 客户端⼊⼝，⽤于静态内容“激活”\n└── entry-server.js # 服务端⼊⼝，⽤于⾸屏内容渲染\n\n路由配置\nimport Vue from &quot;vue&quot;;\nimport Router from &quot;vue-router&quot;;\n \nVue.use(Router);\n//导出⼯⼚函数\n \nexport function createRouter() {\n    return new Router({\n        mode: &#039;history&#039;,\n        routes: [\n            // 客户端没有编译器，这⾥要写成渲染函数\n            { path: &quot;/&quot;, component: { render: h =&gt; h(&#039;div&#039;, &#039;index page&#039;) } },\n            { path: &quot;/detail&quot;, component: { render: h =&gt; h(&#039;div&#039;, &#039;detail page&#039;) } }\n        ]\n    });\n}\n主文件main.js\n跟之前不同，主文件是负责创建vue实例的工厂，每次请求均会有独立的vue实例创建\nimport Vue from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\nimport { createRouter } from &quot;./router&quot;;\n// 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例\n// 上下⽂⽤于给vue实例传递参数\nexport function createApp(context) {\n    const router = createRouter();\n    const app = new Vue({\n        router,\n        context,\n        render: h =&gt; h(App)\n    });\n    return { app, router };\n}\n编写服务端入口src/entry-server.js\n它的任务是创建Vue实例并根据传入url指定首屏\nimport { createApp } from &quot;./main&quot;;\n// 返回⼀个函数，接收请求上下⽂，返回创建的vue实例\nexport default context =&gt; {\n    // 这⾥返回⼀个Promise，确保路由或组件准备就绪\n    return new Promise((resolve, reject) =&gt; {\n        const { app, router } = createApp(context);\n        // 跳转到⾸屏的地址\n        router.push(context.url);\n        // 路由就绪，返回结果\n        router.onReady(() =&gt; {\n            resolve(app);\n        }, reject);\n    });\n};\n编写客户端入口entry-client.js\n客户端入口只需创建vue实例并执行挂载，这⼀步称为激活\nimport { createApp } from &quot;./main&quot;;\n// 创建vue、router实例\nconst { app, router } = createApp();\n// 路由就绪，执⾏挂载\nrouter.onReady(() =&gt; {\n    app.$mount(&quot;#app&quot;);\n});\n对webpack进行配置\n安装依赖\nnpm install webpack-node-externals lodash.merge -D\n对vue.config.js进行配置\n// 两个插件分别负责打包客户端和服务端\nconst VueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);\nconst VueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);\nconst nodeExternals = require(&quot;webpack-node-externals&quot;);\nconst merge = require(&quot;lodash.merge&quot;);\n// 根据传⼊环境变量决定⼊⼝⽂件和相应配置项\nconst TARGET_NODE = process.env.WEBPACK_TARGET === &quot;node&quot;;\nconst target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot;;\nmodule.exports = {\n    css: {\n        extract: false\n    },\n    outputDir: &#039;./dist/&#039;+target,\n    configureWebpack: () =&gt; ({\n        // 将 entry 指向应⽤程序的 server / client ⽂件\n        entry: `./src/entry-${target}.js`,\n        // 对 bundle renderer 提供 source map ⽀持\n        devtool: &#039;source-map&#039;,\n        // target设置为node使webpack以Node适⽤的⽅式处理动态导⼊，\n        // 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。\n        target: TARGET_NODE ? &quot;node&quot; : &quot;web&quot;,\n        // 是否模拟node全局变量\n        node: TARGET_NODE ? undefined : false,\n        output: {\n            // 此处使⽤Node⻛格导出模块\n            libraryTarget: TARGET_NODE ? &quot;commonjs2&quot; : undefined\n        },\n        // webpack.js.org/configuration/externals/#function\n        // github.com/liady/webpack-node-externals\n        // 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。\n        externals: TARGET_NODE\n        ? nodeExternals({\n            // 不要外置化webpack需要处理的依赖模块。\n            // 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件，\n            // 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单\n            whitelist: [/\\.css$/]\n        })\n        : undefined,\n        optimization: {\n            splitChunks: undefined\n        },\n        // 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。\n        // 服务端默认⽂件名为 `vue-ssr-server-bundle.json`\n        // 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。\n        plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new\n                  VueSSRClientPlugin()]\n    }),\n    chainWebpack: config =&gt; {\n        // cli4项⽬添加\n        if (TARGET_NODE) {\n            config.optimization.delete(&#039;splitChunks&#039;)\n        }\n \n        config.module\n            .rule(&quot;vue&quot;)\n            .use(&quot;vue-loader&quot;)\n            .tap(options =&gt; {\n            merge(options, {\n                optimizeSSR: false\n            });\n        });\n    }\n};\n对脚本进行配置，安装依赖\nnpm i cross-env -D\n定义创建脚本package.json\n&quot;scripts&quot;: {\n &quot;build:client&quot;: &quot;vue-cli-service build&quot;,\n &quot;build:server&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build&quot;,\n &quot;build&quot;: &quot;npm run build:server &amp;&amp; npm run build:client&quot;\n}\n\n执行打包：npm run build\n\n最后修改宿主文件/public/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;\n        &lt;title&gt;Document&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!--vue-ssr-outlet--&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n                  \n                  注意❗ \n                  \n                \n是服务端渲染入口位置，注意不能为了好看而在前后加空格\n\n安装vuex\nnpm install -S vuex\n创建vuex工厂函数\nimport Vue from &#039;vue&#039;\nimport Vuex from &#039;vuex&#039;\nVue.use(Vuex)\nexport function createStore () {\n    return new Vuex.Store({\n        state: {\n            count:108\n        },\n        mutations: {\n            add(state){\n                state.count += 1;\n            }\n        }\n    })\n}\n在main.js文件中挂载store\nimport { createStore } from &#039;./store&#039;\nexport function createApp (context) {\n    // 创建实例\n    const store = createStore()\n    const app = new Vue({\n        store, // 挂载\n        render: h =&gt; h(App)\n    })\n    return { app, router, store }\n}\n服务器端渲染的是应用程序的”快照”，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据\n在store进行一步数据获取\nexport function createStore() {\n    return new Vuex.Store({\n        mutations: {\n            // 加⼀个初始化\n            init(state, count) {\n                state.count = count;\n            },\n        },\n        actions: {\n            // 加⼀个异步请求count的action\n            getCount({ commit }) {\n                return new Promise(resolve =&gt; {\n                    setTimeout(() =&gt; {\n                        commit(&quot;init&quot;, Math.random() * 100);\n                        resolve();\n                    }, 1000);\n                });\n            },\n        },\n    });\n}\n组件中的数据预取逻辑\nexport default {\n    asyncData({ store, route }) { // 约定预取逻辑编写在预取钩⼦asyncData中\n        // 触发 action 后，返回 Promise 以便确定请求结果\n        return store.dispatch(&quot;getCount&quot;);\n    }\n};\n服务端数据预取，entry-server.js\nimport { createApp } from &quot;./app&quot;;\nexport default context =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        // 拿出store和router实例\n        const { app, router, store } = createApp(context);\n        router.push(context.url);\n        router.onReady(() =&gt; {\n            // 获取匹配的路由组件数组\n            const matchedComponents = router.getMatchedComponents();\n \n            // 若⽆匹配则抛出异常\n            if (!matchedComponents.length) {\n                return reject({ code: 404 });\n            }\n \n            // 对所有匹配的路由组件调⽤可能存在的`asyncData()`\n            Promise.all(\n                matchedComponents.map(Component =&gt; {\n                    if (Component.asyncData) {\n                        return Component.asyncData({\n                            store,\n                            route: router.currentRoute,\n                        });\n                    }\n                }),\n            )\n                .then(() =&gt; {\n                // 所有预取钩⼦ resolve 后，\n                // store 已经填充⼊渲染应⽤所需状态\n                // 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时，\n                // 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML\n                context.state = store.state;\n \n                resolve(app);\n            })\n                .catch(reject);\n        }, reject);\n    });\n};\n客户端在挂载到应用程序之前，store 就应该获取到状态，entry-client.js\n// 导出store\nconst { app, router, store } = createApp();\n// 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML \n// 在客户端挂载到应⽤程序之前，store 就应该获取到状态：\nif (window.__INITIAL_STATE__) {\n    store.replaceState(window.__INITIAL_STATE__);\n}\n客户端数据预取处理，main.js\nVue.mixin({\n    beforeMount() {\n        const { asyncData } = this.$options;\n        if (asyncData) {\n            // 将获取数据操作分配给 promise\n            // 以便在组件中，我们可以在数据准备就绪后\n            // 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务\n            this.dataPromise = asyncData({\n                store: this.$store,\n                route: this.$route,\n            });\n        }\n    },\n});\n修改服务器启动文件\n// 获取⽂件路径\nconst resolve = dir =&gt; require(&#039;path&#039;).resolve(__dirname, dir)\n// 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由\napp.use(express.static(resolve(&#039;../dist/client&#039;), {index: false}))\n// 第 2 步：获得⼀个createBundleRenderer\nconst { createBundleRenderer } = require(&quot;vue-server-renderer&quot;);\n// 第 3 步：服务端打包⽂件地址\nconst bundle = resolve(&quot;../dist/server/vue-ssr-server-bundle.json&quot;);\n// 第 4 步：创建渲染器\nconst renderer = createBundleRenderer(bundle, {\n    runInNewContext: false, // ssr.vuejs.org/zh/api/#runinnewcontext\n    template: require(&#039;fs&#039;).readFileSync(resolve(&quot;../public/index.html&quot;), &quot;utf8&quot;), // 宿主⽂件\n    clientManifest: require(resolve(&quot;../dist/client/vue-ssr-clientmanifest.json&quot;)) // 客户端清单\n});\napp.get(&#039;*&#039;, async (req,res)=&gt;{\n    // 设置url和title两个重要参数\n    const context = {\n        title:&#039;ssr test&#039;,\n        url:req.url\n    }\n    const html = await renderer.renderToString(context);\n    res.send(html)\n})\n小结\n\n使用ssr不存在单例模式，每次用户请求都会==创建一个新的vue实例==\n实现ssr需要实现服务端首屏渲染和客户端激活\n服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取\n\n首屏异步获取数据，在服务端预渲染的时候就应该已经完成\n切换组件通过mixin混入，在beforeMount钩子完成数据获取\n\n\n\n参考文献\n\njuejin.cn/post/6896007907050487816\nvue3js.cn/docs/zh\n\n\n\nSPA首屏加载速度慢的怎么解决！\n说说React服务端渲染怎么做！原理是什么！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/TypeScript八股文":{"title":"TypeScript八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-typescript-的数据类型有哪些！","开发技术/TypeScript","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-的理解！与-JavaScript-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/字面量类型和联合类型的使用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/any-与-unknown-类型的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/void-和-never-类型的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/interface和type的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是索引签名，以及作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/元组类型和数组的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中枚举类型的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中接口的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中类的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中函数的理解！与-JavaScript-函数的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中泛型的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-中高级类型的理解！有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-TypeScript-装饰器的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-TypeScript-中命名空间与模块的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何在-React-项目中应用-TypeScript！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何在Vue项目中应用TypeScript！"],"tags":["编程/TypeScript"],"content":"重点\n\n说说 typescript 的数据类型有哪些！\n\n八股文\nTypeScript\n\n说说你对 TypeScript 的理解！与 JavaScript 的区别！\n字面量类型和联合类型的使用场景！\nany 与 unknown 类型的区别！\nvoid 和 never 类型的区别！\ninterface和type的区别\n什么是索引签名，以及作用是什么！\n元组类型和数组的区别！\n说说 typescript 的数据类型有哪些！\n说说你对 TypeScript 中枚举类型的理解！应用场景！\n说说你对 TypeScript 中接口的理解！应用场景！\n说说你对 TypeScript 中类的理解！应用场景！\n说说你对 TypeScript 中函数的理解！与 JavaScript 函数的区别！\n说说你对 TypeScript 中泛型的理解！应用场景！\n说说你对 TypeScript 中高级类型的理解！有哪些！\n说说你对 TypeScript 装饰器的理解！应用场景！\n说说对 TypeScript 中命名空间与模块的理解！区别！\n说说如何在 React 项目中应用 TypeScript！\n说说如何在Vue项目中应用TypeScript！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite八股文":{"title":"Vite八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-是什么！它与传统的前端构建工具（如Webpack）有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-是如何实现快速的开发服务器启动时间的！它的原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-支持哪些前端框架！如何在-Vite-中集成这些框架！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的-HMR（热模块替换）是如何工作的！它在构建过程中有什么优势！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-提供了哪些常用的构建插件和中间件！如何使用它们！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在-Vite-中使用-TypeScript！有哪些配置项可以定制-TypeScript-编译！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的-CSS-模块化是如何实现的！如何引用和导入-CSS-模块！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的代码拆分是如何实现的！如何在项目中使用代码拆分功能！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中支持的自动化测试工具有哪些！如何配置自动化测试！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的路由功能是如何实现的！有哪些路由模式可以使用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的国际化支持是如何实现的！如何处理多语言资源文件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在-Vite-中如何处理环境变量！如何配置不同环境下的不同参数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在-Vite-中如何使用第三方库！可以直接引入吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的模板编译是如何实现的！它支持哪些模板引擎！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理图片和其他静态资源文件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-支持哪些常用的构建模式！如何配置不同的构建模式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理-SVG-图标和矢量图形！有哪些相关的插件可供选择！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-的构建性能相对于传统的前端构建工具有什么优势！它是如何提升构建性能的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-如何处理样式预处理器！支持哪些样式预处理器！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的错误处理机制是怎样的！如何捕获并处理构建过程中的错误！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中可以如何实现按需加载和懒加载！有哪些相关的插件或配置可供选择！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理跨域请求！如何配置开发服务器以支持跨域请求！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理静态文件缓存！可以通过配置控制文件的缓存策略吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中是否支持组件级别的样式作用域！如果支持，有什么特点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理多页面应用（MPA）！如何配置多个入口文件和路由！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中的构建结果是否支持压缩和优化！如何配置构建结果的压缩和优化选项！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理-Web-Worker-和-Service-Worker！有什么配置项可以用于控制它们的行为！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何处理第三方依赖库的引入和打包！可以使用-CDN-引入吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中是否支持使用-Babel-编译-JavaScript-代码！如何配置-Babel！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite-中如何进行单元测试和集成测试！有哪些相关的测试工具可以使用！"],"tags":["编程/Vite"],"content":"重点\n\nVite 是什么！它与传统的前端构建工具（如Webpack）有什么区别！\n\nVite 八股文\n\nVite 是什么！它与传统的前端构建工具（如Webpack）有什么区别！\nVite 是如何实现快速的开发服务器启动时间的！它的原理是什么！\nVite 支持哪些前端框架！如何在 Vite 中集成这些框架！\nVite 中的 HMR（热模块替换）是如何工作的！它在构建过程中有什么优势！\nVite 提供了哪些常用的构建插件和中间件！如何使用它们！\n如何在 Vite 中使用 TypeScript！有哪些配置项可以定制 TypeScript 编译！\nVite 中的 CSS 模块化是如何实现的！如何引用和导入 CSS 模块！\nVite 中的代码拆分是如何实现的！如何在项目中使用代码拆分功能！\nVite 中支持的自动化测试工具有哪些！如何配置自动化测试！\nVite 中的路由功能是如何实现的！有哪些路由模式可以使用！\nVite 中的国际化支持是如何实现的！如何处理多语言资源文件！\n在 Vite 中如何处理环境变量！如何配置不同环境下的不同参数！\n在 Vite 中如何使用第三方库！可以直接引入吗！\nVite 中的模板编译是如何实现的！它支持哪些模板引擎！\nVite 中如何处理图片和其他静态资源文件！\nVite 支持哪些常用的构建模式！如何配置不同的构建模式！\nVite 中如何处理 SVG 图标和矢量图形！有哪些相关的插件可供选择！\nVite 的构建性能相对于传统的前端构建工具有什么优势！它是如何提升构建性能的！\nVite 如何处理样式预处理器！支持哪些样式预处理器！\nVite 中的错误处理机制是怎样的！如何捕获并处理构建过程中的错误！\nVite 中可以如何实现按需加载和懒加载！有哪些相关的插件或配置可供选择！\nVite 中如何处理跨域请求！如何配置开发服务器以支持跨域请求！\nVite 中如何处理静态文件缓存！可以通过配置控制文件的缓存策略吗！\nVite 中是否支持组件级别的样式作用域！如果支持，有什么特点！\nVite 中如何处理多页面应用（MPA）！如何配置多个入口文件和路由！\nVite 中的构建结果是否支持压缩和优化！如何配置构建结果的压缩和优化选项！\nVite 中如何处理 Web Worker 和 Service Worker！有什么配置项可以用于控制它们的行为！\nVite 中如何处理第三方依赖库的引入和打包！可以使用 CDN 引入吗！\nVite 中是否支持使用 Babel 编译 JavaScript 代码！如何配置 Babel！\nVite 中如何进行单元测试和集成测试！有哪些相关的测试工具可以使用！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-中的数据为什么频繁变化时只会更新一次":{"title":"Vue 中的数据为什么频繁变化时只会更新一次","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的"],"tags":["编程/FE/Vue"],"content":"Vue 可以响应数据变化，数据变化后会自动更新视图，如果每次修改都触发视图更新，会导致多次重复和不必要的渲染操作，例如一个组件使用了两个 data 的属性，更新两个属性如果触发两次渲染的话，会影响性能。因此 Vue 采取异步更新。\n每次更新响应的属性之后，会将渲染的 Watcher 放到一个队列中，在下个事件循环中再执行。当数据变化后，把 watcher.update 函数存放进 nextTick 的回调数组中，并且会做过滤。通过 wachter 的 id 来判断回调数组中是否已经存在这个 watcher 的更新函数不存在，才 push。之后调用 nextTick 时遍历回调数组，便会执行了更新。\n所以，不管你修改多少次数据，nextTick 的回调数组中只存在唯一一个 watcher.update，从而页面只会更新一次。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的":{"title":"Vue 的双向数据绑定是如何实现的","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下-MVVM-模式，和-MVC-模式有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue.observable你有了解过吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对发布订阅、观察者模式的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-model-是什么，有什么用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数据响应式原理"],"tags":["编程/FE/Vue"],"content":"一、什么是双向绑定\n我们先从单向绑定切入单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定举个栗子\n\n当用户填写表单时，View的状态就被更新了，如果此时可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定关系图如下\n\n二、双向绑定的原理是什么\n我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成\n\n数据层（Model）：应用的数据及业务逻辑\n视图层（View）：应用的展示效果，各类UI组件\n业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来\n\n而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理\n理解ViewModel\n它的主要职责就是：\n\n数据变化后更新视图\n视图变化后更新数据\n\n当然，它还有两个主要部分组成\n\n监听器（Observer）：对所有数据的属性进行监听\n解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数\n\n三、实现双向绑定\n我们还是以Vue为例，先来看看Vue中的双向绑定流程是什么的\n\nnew Vue() 首先执行初始化，对 data 执行响应化处理，这个过程发生 Observer 中\n同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中\n同时定义⼀个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数\n由于data的某个key在⼀个视图中可能出现多次，所以每个key都需要⼀个管家Dep来管理多个Watcher\n将来data中数据⼀旦发生变化，会首先[[你了解vue的diff算法吗！说说看|找到对应的Dep]]，通知所有Watcher执行更新函数\n\n流程图如下：\n\n\n\n                  \n                  提示💡 \n                  \n                \nObserver 是管理 Model，Compile 是管理 View，每个属性 key 对应一个 Dep，一个属性 key 对应多个 Watcher，Watcher 与 View 中 key的使用一一对应的，每个 Watcher 都要绑定更新函数。并将所有 Watcher 注册到 Dep 中。当属性 key 发生变化时，通知更新视图。\n\n\n\n                  \n                  提示💡 \n                  \n                \n\n响应式处理：每个属性对应一个Dep\n模版编译：View 中属性的使用，会对应一个 Watcher 并绑定更新函数\n注册：将Watcher注册到对应的 Dep\n更新：当数据发生变化，找到对应的 Dep ，通知所有的 Watcher 进行更新\n\n\n\n说说你对发布订阅、观察者模式的理解！区别！\n\n实现\n先来一个构造函数：执行初始化，对data执行响应化处理\nclass Vue {  \n  constructor(options) {  \n    this.$options = options;  \n    this.$data = options.data;  \n        \n    // 对data选项做响应式处理  \n    observe(this.$data);  \n        \n    // 代理data到vm上  \n    proxy(this);  \n        \n    // 执行编译  \n    new Compile(options.el, this);  \n  }  \n}  \n对data选项执行响应化具体操作\nfunction observe(obj) {  \n  if (typeof obj !== &quot;object&quot; || obj == null) {  \n    return;  \n  }  \n  new Observer(obj);  \n}  \n  \nclass Observer {  \n  constructor(value) {  \n    this.value = value;  \n    this.walk(value);  \n  }  \n  walk(obj) {  \n    Object.keys(obj).forEach((key) =&gt; {  \n      defineReactive(obj, key, obj[key]);  \n    });  \n  }  \n}  \n编译Compile\n对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数\n\nclass Compile {  \n  constructor(el, vm) {  \n    this.$vm = vm;  \n    this.$el = document.querySelector(el);  // 获取dom  \n    if (this.$el) {  \n      this.compile(this.$el);  \n    }  \n  }  \n  compile(el) {  \n    const childNodes = el.childNodes;   \n    Array.from(childNodes).forEach((node) =&gt; { // 遍历子元素  \n      if (this.isElement(node)) {   // 判断是否为节点  \n        console.log(&quot;编译元素&quot; + node.nodeName);  \n      } else if (this.isInterpolation(node)) {  \n        console.log(&quot;编译插值⽂本&quot; + node.textContent);  // 判断是否为插值文本 {{}}  \n      }  \n      if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) {  // 判断是否有子元素  \n        this.compile(node);  // 对子元素进行递归遍历  \n      }  \n    });  \n  }  \n  isElement(node) {  \n    return node.nodeType == 1;  \n  }  \n  isInterpolation(node) {  \n    return node.nodeType == 3 &amp;&amp; /\\{\\{(.*)\\}\\}/.test(node.textContent);  \n  }  \n}  \n  \n依赖收集\n视图中会用到data中某key，这称为依赖。同⼀个key可能出现多次，每次都需要收集出来用⼀个Watcher来维护它们，此过程称为依赖收集多个Watcher需要⼀个Dep来管理，需要更新时由Dep统⼀通知\n\n实现思路\n\ndefineReactive时为每⼀个key创建⼀个Dep实例\n初始化视图时读取某个key，例如name1，创建⼀个watcher1\n由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中\n当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新\n\n// 负责更新视图  \nclass Watcher {  \n  constructor(vm, key, updater) {  \n    this.vm = vm  \n    this.key = key  \n    this.updaterFn = updater  \n  \n    // 创建实例时，把当前实例指定到Dep.target静态属性上  \n    Dep.target = this  \n    // 读一下key，触发get  \n    vm[key]  \n    // 置空  \n    Dep.target = null  \n  }  \n  \n  // 未来执行dom更新函数，由dep调用的  \n  update() {  \n    this.updaterFn.call(this.vm, this.vm[this.key])  \n  }  \n}  \n声明Dep\nclass Dep {  \n  constructor() {  \n    this.deps = [];  // 依赖管理  \n  }  \n  addDep(dep) {  \n    this.deps.push(dep);  \n  }  \n  notify() {   \n    this.deps.forEach((dep) =&gt; dep.update());  \n  }  \n}  \n创建watcher时触发getter\nclass Watcher {  \n  constructor(vm, key, updateFn) {  \n    Dep.target = this;  \n    this.vm[this.key];  \n    Dep.target = null;  \n  }  \n}  \n  \n依赖收集，创建Dep实例\nfunction defineReactive(obj, key, val) {  \n  this.observe(val);  \n  const dep = new Dep();  \n  Object.defineProperty(obj, key, {  \n    get() {  \n      Dep.target &amp;&amp; dep.addDep(Dep.target);// Dep.target也就是Watcher实例  \n      return val;  \n    },  \n    set(newVal) {  \n      if (newVal === val) return;  \n      dep.notify(); // 通知dep执行更新方法  \n    },  \n  });  \n}  \n总结\n双向数据绑定中一个比较重要的方式：\n\n通过 v-model 指令实现的，它结合了 v-bind 和 @input 两个指令的功能来实现 MVVM 的数据双向绑定。\n其原理是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来给各个属性添加 setter，getter 方法并劫持监听，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n就必须要实现以下几点：\n1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。\n2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。\n3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。\n\n参考文献\n\nwww.liaoxuefeng.com/wiki/1022910821149312/1109527162256416\njuejin.cn/post/6844903942254510087#heading-9\n\n\n\n数据响应式原理\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue.observable你有了解过吗！说说看":{"title":"Vue.observable你有了解过吗！说说看","links":["C-Knowledge/前端/开发技术/Vue/全局-API"],"tags":["编程/FE/Vue"],"content":"一、Observable 是什么\nObservable 翻译过来我们可以理解成可观察的\n我们先来看一下其在Vue中的定义\n\n\n                  \n                  重点 \n                  \n                \nVue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象\n\n返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器\nVue.observable({ count : 1})\n其作用等同于\nnew vue({ count : 1})\n在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象\n在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的\n二、使用场景\n在非父子组件通信时，可以使用通常的 bus 或者使用 vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable 就是一个很好的选择\n创建一个js文件\n// 引入vue\nimport Vue from &#039;vue\n// 创建state对象，使用observable让state对象可响应\nexport let state = Vue.observable({\n  name: &#039;张三&#039;,\n  &#039;age&#039;: 38\n})\n// 创建对应的方法\nexport let mutations = {\n  changeName(name) {\n    state.name = name\n  },\n  setAge(age) {\n    state.age = age\n  }\n}\n在.vue文件中直接使用即可\n&lt;template&gt;\n  &lt;div&gt;\n    姓名：{{ name }}\n    年龄：{{ age }}\n    &lt;button @click=&quot;changeName(&#039;李四&#039;)&quot;&gt;改变姓名&lt;/button&gt;\n    &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\nimport { state, mutations } from &#039;@/store\nexport default {\n  // 在计算属性中拿到值\n  computed: {\n    name() {\n      return state.name\n    },\n    age() {\n      return state.age\n    }\n  },\n  // 调用mutations里面的方法，更新数据\n  methods: {\n    changeName: mutations.changeName,\n    setAge: mutations.setAge\n  }\n}\n三、原理分析\n源码位置：src\\core\\observer\\index.js\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  // 判断是否存在__ob__响应式属性\n  if (hasOwn(value, &#039;__ob__&#039;) &amp;&amp; value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &amp;&amp;\n    !isServerRendering() &amp;&amp;\n    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;\n    Object.isExtensible(value) &amp;&amp;\n    !value._isVue\n  ) {\n    // 实例化Observer响应式对象\n    ob = new Observer(value)\n  }\n  if (asRootData &amp;&amp; ob) {\n    ob.vmCount++\n  }\n  return ob\n}\nObserver类\nexport class Observer {\n    value: any;\n    dep: Dep;\n    vmCount: number; // number of vms that have this object as root $data\n \n    constructor (value: any) {\n        this.value = value\n        this.dep = new Dep()\n        this.vmCount = 0\n        def(value, &#039;__ob__&#039;, this)\n        if (Array.isArray(value)) {\n            if (hasProto) {\n                protoAugment(value, arrayMethods)\n            } else {\n                copyAugment(value, arrayMethods, arrayKeys)\n            }\n            this.observeArray(value)\n        } else {\n            // 实例化对象是一个对象，进入walk方法\n            this.walk(value)\n        }\n}\nwalk函数\nwalk (obj: Object) {\n    const keys = Object.keys(obj)\n    // 遍历key，通过defineReactive创建响应式对象\n    for (let i = 0; i &lt; keys.length; i++) {\n        defineReactive(obj, keys[i])\n    }\n}\ndefineReactive方法\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n \n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property &amp;&amp; property.configurable === false) {\n    return\n  }\n \n  // cater for pre-defined getter/setters\n  const getter = property &amp;&amp; property.get\n  const setter = property &amp;&amp; property.set\n  if ((!getter || setter) &amp;&amp; arguments.length === 2) {\n    val = obj[key]\n  }\n \n  let childOb = !shallow &amp;&amp; observe(val)\n  // 接下来调用Object.defineProperty()给对象定义响应式属性\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter &amp;&amp; !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow &amp;&amp; observe(newVal)\n      // 对观察者watchers进行通知,state就成了全局响应式对象\n      dep.notify()\n    }\n  })\n}\n参考文献\n\nblog.csdn.net/qq_32682301/article/details/105419673\nwbbyouzi.com/archives/343\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2-的生命周期有哪些":{"title":"Vue2 的生命周期有哪些","links":[],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n创建、挂载、更新、卸载，以及它们分别的使用场景。\n\n一、生命周期是什么\n生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())\n二、生命周期有哪些\nVue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n生命周期描述beforeCreate组件实例被创建之初created组件实例已经完全创建beforeMount组件挂载之前mounted组件挂载到实例上去之后beforeUpdate组件数据发生变化，更新之前updated组件数据更新之后beforeDestroy组件实例销毁之前destroyed组件实例销毁之后activatedkeep-alive 缓存的组件激活时deactivatedkeep-alive 缓存的组件停用时调用errorCaptured捕获一个来自子孙组件的错误时被调用\n三、生命周期整体流程\nVue生命周期流程图\n\n具体分析\nbeforeCreate → created\n\n初始化vue实例，进行数据观测\n\ncreated\n\n完成数据观测，属性与方法的运算，watch、event事件回调的配置\n可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算\n此时vm.$el 并没有被创建\n\ncreated → beforeMount\n\n判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译\n优先级：render &gt; template &gt; outerHTML\nvm.el获取到的是挂载DOM的\n\nbeforeMount\n\n在此阶段可获取到vm.el\n此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上\n\nbeforeMount → mounted\n\n此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM\n\nmounted\n\nvm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM\n\nbeforeUpdate\n\n更新的数据必须是被渲染在模板上的（el、template、render之一）\n此时view层还未更新\n若在beforeUpdate中再次修改数据，不会再次触发更新方法\n\nupdated\n\n完成view层的更新\n若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）\n\nbeforeDestroy\n\n实例被销毁前调用，此时实例属性与方法仍可访问\n\ndestroyed\n\n完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器\n并不能清除DOM，仅仅销毁实例\n\n使用场景分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n生命周期描述beforeCreate执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务created组件初始化完毕，各种数据可以使用，常用于异步数据获取beforeMount未执行渲染、更新，dom未创建mounted初始化结束，dom已创建，可用于获取访问数据和dom元素beforeUpdate更新前，可用于获取更新前各种状态updated更新后，所有状态已是最新beforeDestroy销毁前，可用于一些定时器或订阅的取消destroyed组件已销毁，作用同上\n四、题外话：数据请求在created和mouted的区别\ncreated是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。触发时机上created是比mounted要更早的，两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。\n参考文献\n\njuejin.cn/post/6844903811094413320\nbaike.baidu.com/\ncn.vuejs.org/\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2、Vue3、React之间的diff算法区别是什么！":{"title":"Vue2、Vue3、React之间的diff算法区别是什么！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解vue的diff算法吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React-diff的原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用-key-属性有哪些注意事项！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你知道vue中key的原理吗！说说你对它的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React中的key有什么作用！"],"tags":["编程/FE/Vue"],"content":"Diff 的发展\n严格 Diff\n\n\ndiff 优化\n\n\n                  \n                  提示💡 \n                  \n                \n原则是尽量减少 DOM 操作，能不动就不动，能复用不创建。\n\n\n\nReact diff：仅右移动\n从左到右，用新节点依次对比旧节点，如果相同就将旧节点向右移动，否则继续向后遍历所有旧节点。\n\nVue 2 ：双端比较\n\n一共四个指针，新旧指针之间按顺序进行两两比较，如果比对成功，就向中间移动指针，继续按上述顺序进行比较。\n直到新旧节点的任意头尾指针发生交叉，就终止比较。\n如果没匹配到就使用 key 进行比较，key 相同则复用并移动到新虚拟 Dom 的位置，否则丢弃。\n\n\nVue 3： 最长递增子序列\n最长递增子序列的特征是递增顺序并且连续，下面的例子则是 3、5、7 。\n\n先进行指针比较，如果相同位置的节点不动，在不同节点中找出最小子序列，整体复用，其余节点进行删除或新增，减少中间的比较次数。\n\n为什么要使用 key\n\n如果不使用 key，下面的节点回全部删除重建，有 key 就可以进行复用相同节点。\n\n总结\n虚拟 DOM 的 Diff 算法\n\n将新旧虚拟 DOM 看作两棵节点树，节点个数为 n\n\n左侧树的节点需要与右侧树的节点一一对比，需要 O (n²) 复杂度\n删除未找到的节点，需要再找合适节点放到被删除位置，需要 O (n) 复杂度\n添加新节点，需要 O (n) 复杂度\n\n\n综上，Diff 虚拟 DOM 的复杂度是 O (n³)\n\nVue 2 、 Vue 3、React\nReact 基于以下两个假设的基础之上提出 O (n) 的启发式算法\n\n两个不同类型的元素会产生不同的树\n可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变\n\nReact Diffing 算法\n\nTree Diff\n\n对比两棵树时，首选比较两棵树的根节点。不同类型的根节点元素会有不同的形态\n\n根节点为不同类型的元素\n\nReact 会拆卸原有的树并且建立起新的树\n当卸载一棵树时\n\n对应的 DOM 节点会被销毁\n\n建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中\n\n\n组件实例将执行 componentWillUnmount() 方法\n\n\n\n\n根节点为相同类型的元素\n\nReact 会保留节点\n仅比对及更新有改变的属性\n\n\n处理完根节点，React 继续对子节点进行递归\n\n\n通过 updateDepth 控制 Virtual Dom 树层级\n只比较同一个父节点的子节点\n通过删除和创建节点实现跨层级移动\n避免跨层级移动，优先 CSS 控制显示隐藏\n\n\nComponent Diff\n\n同类型组件\n\n组件实例会保持不变，因此可以在不同的渲染时保持 state 一致\nReact 将更新该组件实例的 props 以及保证与最新的元素保持一致\n调用该实例的 UNSAFE_componentWillReceiveProps、 UNSAFE_componentWillUpdate() 以及 componentDidUpdate() 方法\n调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归\n通过 shouldComponentUpdate、useMemo、useCallback 手动优化\n不同类型组件，输出内容相似\n\n建议改成同一类型，避免重新渲染组件\n\n\n\n\n不同类型组件\n\n删除和创建\n\n\n\n\nElement Diff\n\n默认情况下，React 会同时遍历两个子元素的列表，递归 DOM 节点的子元素\n\n产生差异时，生成一个 mutation\n\n\n用 key 标识节点\n\n避免使用索引 index，而应使用例如 id 唯一标识来作为 key\n\n\n只顺序移动位置变到前面的节点\n相同类型 React 元素，保留 DOM 节点，仅对比及更新改变的属性\n\n\n\nVue 2. x 优化 Diff 算法\n\n基本优化与 React 相同\npathNode\n\n新老节点相同，不更新\n新老节点都是静态节点，key 相同\n\n新节点. elm = 老节点. elm\n新节点. componentInstance = 老节点. componentInstance\n\n\n新老节点存在，不相同\n\n用 updateChildren 更新\n\n\n\n\nupdateChildren\n\n虚拟 DOM 双指针，真实 DOM 双指针，一一对应\n两端到中间，直到虚拟 DOM 或真实 DOM，左指针 &gt; 右指针\n\n\n\nVue 3. x 优化 Diff 算法\n\n创建 VNode 确定类型，内容不会变化的 DOM 添加静态标记\n在 mount / patch 中用位运算判断 VNode 类型\n\n静态提升 hoistStatic\n\n不参与更新的元素，只创建一次，渲染时直接复用\n\n\n事件侦听器缓存 cacheHandlers\n\n缓存函数，不追踪变化，提升性能\n\n\n\n\n\nVue 2 和 Vue3\nVue 2 和 Vue 3 在 diff 算法方面的差异主要体现在：在处理完可复用节点后对剩余节点的处理方式。Vue 2 是通过创建一个存放 key 和对应虚拟 DOM 节点的映射列表 {key, oldVnode}，然后遍历新节点列表的剩余节点，根据新的虚拟 DOM 节点的 key 查看它是否可以在映射表中找到可复用的节点的方式来处理剩余节点，并把这个可复用节点移动到正确的位置。\n而 Vue 3 则是创建了一个映射关系数组，这个映射关系数组存放了新节点数组中的剩余节点在旧节点数组上的索引的映射关系。建立完这个数组时随即也就知道了哪些节点是可复用的，然后通过这个数组计算最长递增子序列，这个序列中的节点位置不动，然后将新节点数组中的剩余节点移动到正确的位置。\n\n\n你了解vue的diff算法吗！说说看\n说说React diff的原理是什么！\n使用 key 属性有哪些注意事项！\n你知道vue中key的原理吗！说说你对它的理解\nReact中的key有什么作用！\n【【前端面试】Vue 3 DOM Diff】 \n【【尚硅谷】Vue 源码解析之虚拟 DOM 和 diff 算法】 【[5.17]—5-19-Vue 2 和 Vue 3 和 React 三者的 diff 算法有什么】\n【75. 说说 Vue 2 和 Vue 3 中 diff 算法的区别】\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中的过滤器了解吗！过滤器的应用场景有哪些！":{"title":"Vue中的过滤器了解吗！过滤器的应用场景有哪些！","links":[],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n管道符。\n\n一、是什么\n过滤器（filter）是输送介质管道上不可缺少的一种装置\n大白话，就是把一些不必要的东西过滤掉\n过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数\nVue 允许你自定义过滤器，可被用于一些常见的文本格式化\n\n\n                  \n                  注意❗ \n                  \n                \nps: Vue3 中已废弃 filter\n\n二、如何用\nvue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：\n&lt;!-- 在双花括号中 --&gt;\n{{ message | capitalize }}\n \n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n定义filter\n在组件的选项中定义本地的过滤器\nfilters: {\n  capitalize: function (value) {\n    if (!value) return &#039;&#039;\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n定义全局过滤器：\nVue.filter(&#039;capitalize&#039;, function (value) {\n  if (!value) return &#039;&#039;\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n \nnew Vue({\n  // ...\n})\n\n\n                  \n                  注意❗ \n                  \n                \n注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器\n\n过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数\n过滤器可以串联：\n{{ message | filterA | filterB }}\n在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。\n过滤器是 JavaScript函数，因此可以接收参数：\n{{ message | filterA(&#039;arg1&#039;, arg2) }}\n这里，filterA 被定义为接收三个参数的过滤器函数。\n其中 message 的值作为第一个参数，普通字符串 &#039;arg1&#039; 作为第二个参数，表达式 arg2 的值作为第三个参数\n举个例子：\n&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;{{ msg | msgFormat(&#039;疯狂&#039;,&#039;--&#039;)}}&lt;/p&gt;\n&lt;/div&gt;\n \n&lt;script&gt;\n    // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat\n    Vue.filter(&#039;msgFormat&#039;, function(msg, arg, arg2) {\n        // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则\n        return msg.replace(/单纯/g, arg+arg2)\n    })\n&lt;/script&gt;\n小结：\n\n局部过滤器优先于全局过滤器被调用\n一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右\n\n三、应用场景\n平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等\n比如我们要实现将30000 ⇒ 30,000，这时候我们就需要使用过滤器\nVue.filter(&#039;toThousandFilter&#039;, function (value) {\n     if (!value) return &#039;&#039;\n     value = value.toString()\n     return .replace(str.indexOf(&#039;.&#039;) &gt; -1 ? /(\\d)(?=(\\d{3})+\\.)/g : /(\\d)(?=(?:\\d{3})+$)/g, &#039;$1,&#039;)\n})\n四、原理分析\n使用过滤器\n{{ message | capitalize }}\n在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲\n_s(_f(&#039;filterFormat&#039;)(message))\n首先分析一下_f：\n_f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回\n// 变为\nthis.$options.filters[&#039;filterFormat&#039;](message) // message为参数\n关于resolveFilter\nimport { indentity,resolveAsset } from &#039;core/util/index&#039; \n \nexport function resolveFilter(id){\n    return resolveAsset(this.$options,&#039;filters&#039;,id,true) || identity\n}\n内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；\nresolveAsset的代码如下：\nexport function resolveAsset(options,type,id,warnMissing){ // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 &#039;filters&#039;,实际这个函数还可以拿到其他很多东西\n    if(typeof id !== &#039;string&#039;){ // 判断传递的过滤器id 是不是字符串，不是则直接返回\n        return \n    }\n    const assets = options[type]  // 将我们注册的所有过滤器保存在变量中\n    // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配\n    if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器\n    // 没有找到，代码继续执行\n    const camelizedId  = camelize(id) // 万一你是驼峰的呢\n    if(hasOwn(assets,camelizedId)) return assets[camelizedId]\n    // 没找到，继续执行\n    const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢\n    if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId]\n    // 如果还是没找到，则检查原型链(即访问属性)\n    const result = assets[id] || assets[camelizedId] || assets[PascalCaseId]\n    // 如果依然没找到，则在非生产环境的控制台打印警告\n    if(process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; warnMissing &amp;&amp; !result){\n        warn(&#039;Failed to resolve &#039; + type.slice(0,-1) + &#039;: &#039; + id, options)\n    }\n    // 无论是否找到，都返回查找结果\n    return result\n}\n下面再来分析一下_s：\n_s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的text属性中，渲染到视图中\nfunction toString(value){\n    return value == null\n    ? &#039;&#039;\n    : typeof value === &#039;object&#039;\n      ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距\n      : String(value)\n}\n\n最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式\nfunction parseFilters (filter) {\n    let filters = filter.split(&#039;|&#039;)\n    let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组\n    let i\n    if (filters) {\n        for(i = 0;i &lt; filters.length;i++){\n            experssion = warpFilter(expression,filters[i].trim()) // 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数\n        }\n    }\n    return expression\n}\n// warpFilter函数实现\nfunction warpFilter(exp,filter){\n    // 首先判断过滤器是否有其他参数\n    const i = filter.indexof(&#039;(&#039;)\n    if(i&lt;0){ // 不含其他参数，直接进行过滤器表达式字符串的拼接\n        return `_f(&quot;${filter}&quot;)(${exp})`\n    }else{\n        const name = filter.slice(0,i) // 过滤器名称\n        const args = filter.slice(i+1) // 参数，但还多了 ‘)’\n        return `_f(&#039;${name}&#039;)(${exp},${args}` // 注意这一步少给了一个 &#039;)&#039;\n    }\n}\n小结\n\n在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）\n编译后通过调用resolveFilter函数找到对应过滤器并返回结果\n执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图\n\n参考文献\n\ncn.vuejs.org/v2/guide/filters.html#ad\nblog.csdn.net/weixin_42724176/article/details/105546684\nvue3js.cn\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中组件和插件有什么区别！":{"title":"Vue中组件和插件有什么区别！","links":[],"tags":["编程/FE/Vue"],"content":"一、组件是什么\n回顾以前对组件的定义：\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件\n组件的优势\n\n降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n二、插件是什么\n插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：\n\n添加全局方法或者属性。如: vue-custom-element\n添加全局资源：指令/过滤器/过渡等。如 vue-touch\n通过全局混入来添加一些组件选项。如vue-router\n添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router\n\n三、两者的区别\n两者的区别主要表现在以下几个方面：\n\n编写形式\n注册形式\n使用场景\n\n编写形式\n编写组件\n编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件\nvue文件标准格式\n&lt;template&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{ \n    ...\n}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上\n&lt;template id=&quot;testComponent&quot;&gt;     // 组件显示的内容\n    &lt;div&gt;component!&lt;/div&gt;   \n&lt;/template&gt;\n \nVue.component(&#039;componentA&#039;,{ \n    template: &#039;#testComponent&#039;  \n    template: `&lt;div&gt;component&lt;/div&gt;`  // 组件内容少可以通过这种形式\n})\n编写插件\nvue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n \n  // 2. 添加全局资源\n  Vue.directive(&#039;my-directive&#039;, {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n \n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n \n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n注册形式\n组件注册\nvue组件注册主要分为全局注册与局部注册\n全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项\nVue.component(&#039;my-component-name&#039;, { /* ... */ })\n局部注册只需在用到的地方通过components属性注册一个组件\nconst component1 = {...} // 定义一个组件\n \nexport default {\n\tcomponents:{\n\t\tcomponent1   // 局部注册\n\t}\n}\n插件注册\n插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项\nVue.use(插件名字,{ /* ... */} )\n\n\n                  \n                  注意❗ \n                  \n                \n注册插件的时候，需要在调用 new Vue() 启动应用之前完成\nVue.use 会自动阻止多次注册相同插件，只会注册一次\n\n使用场景\n\n\n                  \n                  提示💡 \n                  \n                \n组件服务于业务，插件服务于工具。\n\n具体的其实在插件是什么章节已经表述了，这里在总结一下\n组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue\n插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身\n简单来说，插件就是指对Vue的功能的增强或补充\n参考文献\n\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue八股文":{"title":"Vue八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下-MVVM-模式，和-MVC-模式有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2-的生命周期有哪些","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue单向数据流的特点、vueX使用方式","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2、Vue3、React之间的diff算法区别是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/路由的-hash-模式和-history-模式的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SPA首屏加载速度慢的怎么解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一说-Vue-的性能优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对vue的mixin的理解，有什么应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】this.$set()-的用处及用法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】Vue中的-$nextTick-作用及实现原理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue组件之间的通信方式都有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue实例挂载的过程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/平时发送异步请求在哪个生命周期，并解释原因","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】created-和-mouted-区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/keep-alive-中的生命周期有哪些","C-Knowledge/前端/职业规划/前端面试宝典/八股文/父子组件生命周期执行顺序","C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件中的-data-为什么是一个函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue.observable你有了解过吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-model-是什么，有什么用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-中的数据为什么频繁变化时只会更新一次","C-Knowledge/前端/职业规划/前端面试宝典/八股文/动态给vue的data添加一个新的属性时会发生什么！怎样解决！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中组件和插件有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue常用的修饰符有哪些有什么应用场景","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你有写过自定义指令吗！自定义指令的应用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue中的过滤器了解吗！过滤器的应用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/父子组件通信","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】子组件可以直接改变父组件的值吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/兄弟组件通信","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对slot的理解！slot使用场景有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是状态管理！为什么需要状态管理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/mutations-能不能做异步","C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么解决刷新页面时，Vuex-中数据丢失的问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vuex-和-localStorage-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Vuex！它是用来解决什么问题的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vuex的核心概念有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vuex的状态(state)是如何工作的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/状态(state)和属性(getters)之间有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是mutations！它们的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在mutation中修改状态(state)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是actions！它们的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在组件中触发一个action！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在action中进行异步操作！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是getters！它们的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在组件中使用一个getter！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何将Vuex集成到Vue应用程序中！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Vue组件中访问Vuex的状态(state)！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如果想要在Vuex中添加一个新的模块，应该做哪些步骤！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Vue组件中使用mapState、mapGetters、mapMutations和mapActions辅助函数！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Vuex中，如何处理模块化命名空间(namespace)的问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vuex是否支持插件！如果支持，举例说明如何创建一个插件。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Vue应用程序中进行跨模块的状态(state)访问！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vuex的严格模式(strict-mode)是什么！如何启用它！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】虚拟-dom-的解析过程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解vue的diff算法吗！说说看","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你知道vue中key的原理吗！说说你对它的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue3有了解过吗！能说说跟vue2的区别吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0的设计目标是什么！做了哪些优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0性能提升主要是通过哪几方面体现的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/生命周期的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数据响应式原理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件通信区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue3.0-所采用的-Composition-Api-与-Vue2.x-使用的-Options-Api-有什么不同！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Vue-3.0中Treeshaking特性！举例说明一下！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/用Vue3.0-写过组件吗！如果想实现一个-Modal你会怎么设计！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-if-和-v-show-的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-if-和-v-for-哪个优先级更高","C-Knowledge/前端/职业规划/前端面试宝典/八股文/slot（插槽）的作用","C-Knowledge/前端/职业规划/前端面试宝典/八股文/computed（计算属性）和-watch（监听属性）的区别","开发技术/Vue/计算属性","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-实现路由跳转的方法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-router-和-route的区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-keep-alive-的理解是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SSR-解决了什么问题！有做过-SSR-吗！你是怎么做的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Vue-的优缺点","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-模板编译原理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/有使用过vue吗！说说你对vue的理解","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue项目中有封装过axios吗！主要是封装哪方面的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解axios的原理吗！有看过它的源码吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue项目中你是如何解决跨域的呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue项目本地开发完成后部署到服务器后报404是什么原因呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么处理vue项目中的错误的！"],"tags":["编程/FE/Vue"],"content":"重点\n\n介绍一下 MVVM 模式，和 MVC 模式有什么区别！\n你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢\nVue2 的生命周期有哪些\nVue 的双向数据绑定是如何实现的\n为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty\nvue单向数据流的特点、vueX使用方式\n什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路\nVue2、Vue3、React之间的diff算法区别是什么！\n路由的 hash 模式和 history 模式的区别\nSPA首屏加载速度慢的怎么解决！\n说一说 Vue 的性能优化\n\nVue 八股文\nVue 设计模式\n\n介绍一下 MVVM 模式，和 MVC 模式有什么区别！\n你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢\n说说你对vue的mixin的理解，有什么应用场景！\n【延伸问答】this.$set() 的用处及用法\n【延伸问答】Vue中的 $nextTick 作用及实现原理\nVue组件之间的通信方式都有哪些！\n\n生命周期\n\nVue实例挂载的过程\nVue2 的生命周期有哪些\n平时发送异步请求在哪个生命周期，并解释原因\n【延伸问答】created 和 mouted 区别\nkeep-alive 中的生命周期有哪些\n父子组件生命周期执行顺序\n\n数据绑定\n\n组件中的 data 为什么是一个函数！\nVue 的双向数据绑定是如何实现的\nVue.observable你有了解过吗！说说看\nv-model 是什么，有什么用！\n为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty\n【延伸问答】this.$set() 的用处及用法\nVue 中的数据为什么频繁变化时只会更新一次\n【延伸问答】Vue中的 $nextTick 作用及实现原理\n动态给vue的data添加一个新的属性时会发生什么！怎样解决！\nVue中组件和插件有什么区别！\nVue常用的修饰符有哪些有什么应用场景\n你有写过自定义指令吗！自定义指令的应用场景有哪些！\nVue中的过滤器了解吗！过滤器的应用场景有哪些！\n\n组件通信\n\nVue组件之间的通信方式都有哪些！\n父子组件通信\n【延伸问答】子组件可以直接改变父组件的值吗！\n兄弟组件通信\n说说你对slot的理解！slot使用场景有哪些！\n\n状态管理\n\n什么是状态管理！为什么需要状态管理！\nvue单向数据流的特点、vueX使用方式\nmutations 能不能做异步\n怎么解决刷新页面时，Vuex 中数据丢失的问题！\nVuex 和 localStorage 的区别\n什么是Vuex！它是用来解决什么问题的！\nVuex的核心概念有哪些！\nVuex的状态(state)是如何工作的！\n状态(state)和属性(getters)之间有什么区别！\n什么是mutations！它们的作用是什么！\n如何在mutation中修改状态(state)！\n什么是actions！它们的作用是什么！\n如何在组件中触发一个action！\n如何在action中进行异步操作！\n什么是getters！它们的作用是什么！\n如何在组件中使用一个getter！\n如何将Vuex集成到Vue应用程序中！\n如何在Vue组件中访问Vuex的状态(state)！\n如果想要在Vuex中添加一个新的模块，应该做哪些步骤！\n如何在Vue组件中使用mapState、mapGetters、mapMutations和mapActions辅助函数！\n在Vuex中，如何处理模块化命名空间(namespace)的问题！\nVuex是否支持插件！如果支持，举例说明如何创建一个插件。\n如何在Vue应用程序中进行跨模块的状态(state)访问！\nVuex的严格模式(strict mode)是什么！如何启用它！\n\n虚拟 dom 和 diff 算法\n\n什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路\n【延伸问答】虚拟 dom 的解析过程\n你了解vue的diff算法吗！说说看\n你知道vue中key的原理吗！说说你对它的理解\n\nVue2 和 Vue3 的区别\n\nvue3有了解过吗！能说说跟vue2的区别吗！\nVue3.0的设计目标是什么！做了哪些优化\nVue3.0性能提升主要是通过哪几方面体现的！\n生命周期的区别\nVue2、Vue3、React之间的diff算法区别是什么！\n数据响应式原理\n组件通信区别\nVue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同！\n说说Vue 3.0中Treeshaking特性！举例说明一下！\n用Vue3.0 写过组件吗！如果想实现一个 Modal你会怎么设计！\n\n标签和属性\n\nv-if 和 v-show 的区别\nv-if 和 v-for 哪个优先级更高\nslot（插槽）的作用\ncomputed（计算属性）和 watch（监听属性）的区别\n计算属性缓存 vs 方法\n\n路由\n\nVue 实现路由跳转的方法\n路由的 hash 模式和 history 模式的区别\nVue router 和 route的区别\nSPA首屏加载速度慢的怎么解决！\n\n性能优化\n\n说说你对 keep-alive 的理解是什么！\n\n服务端渲染\n\nSSR 解决了什么问题！有做过 SSR 吗！你是怎么做的！\n\n开放性问题\n\n说说 Vue 的优缺点\nVue 模板编译原理\n说一说 Vue 的性能优化\n有使用过vue吗！说说你对vue的理解\nVue项目中有封装过axios吗！主要是封装哪方面的！\n你了解axios的原理吗！有看过它的源码吗！\n说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢！\nvue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！\nVue项目中你是如何解决跨域的呢！\nvue项目本地开发完成后部署到服务器后报404是什么原因呢！\n你是怎么处理vue项目中的错误的！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue实例挂载的过程":{"title":"Vue实例挂载的过程","links":[],"tags":["编程/FE/Vue"],"content":"一、思考\n我们都听过知其然知其所以然这句话\n那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？\n过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等\n一、分析\n首先找到vue的构造函数\n源码位置：src\\core\\instance\\index.js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp;\n    !(this instanceof Vue)\n  ) {\n    warn(&#039;Vue is a constructor and should be called with the `new` keyword&#039;)\n  }\n  this._init(options)\n}\noptions是用户传递过来的配置项，如data、methods等常用的方法\nvue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法\ninitMixin(Vue);     // 定义 _init\nstateMixin(Vue);    // 定义 $set $get $delete $watch 等\neventsMixin(Vue);   // 定义事件  $on  $once $off $emit\nlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy\nrenderMixin(Vue);   // 定义 _render 返回虚拟dom\n首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法\n源码位置：src\\core\\instance\\init.js\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; config.performance &amp;&amp; mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n \n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else { // 合并vue属性\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#039;production&#039;) {\n      // 初始化proxy拦截器\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    // 初始化组件生命周期标志位\n    initLifecycle(vm)\n    // 初始化组件事件侦听\n    initEvents(vm)\n    // 初始化渲染方法\n    initRender(vm)\n    callHook(vm, &#039;beforeCreate&#039;)\n    // 初始化依赖注入内容，在初始化data、props之前\n    initInjections(vm) // resolve injections before data/props\n    // 初始化props/data/method/watch/methods\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, &#039;created&#039;)\n \n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; config.performance &amp;&amp; mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n    // 挂载元素\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n仔细阅读上面的代码，我们得到以下结论：\n\n在调用beforeCreate之前，数据初始化并未完成，==像data、props这些属性无法访问到==\n到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此==无法访问到dom元素==\n挂载方法是调用vm.$mount方法\n\ninitState方法是完成props/data/method/watch/methods的初始化\n源码位置：src\\core\\instance\\state.js\nexport function initState (vm: Component) {\n  // 初始化组件的watcher列表\n  vm._watchers = []\n  const opts = vm.$options\n  // 初始化props\n  if (opts.props) initProps(vm, opts.props)\n  // 初始化methods方法\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    // 初始化data  \n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n我们和这里主要看初始化data的方法为initData，它与initState在同一文件上\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  // 获取到组件上的data\n  data = vm._data = typeof data === &#039;function&#039;\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; warn(\n      &#039;data functions should return an object:\\n&#039; +\n      &#039;vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#039;,\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== &#039;production&#039;) {\n      // 属性名不能与方法名重复\n      if (methods &amp;&amp; hasOwn(methods, key)) {\n        warn(\n          `Method &quot;${key}&quot; has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    // 属性名不能与state名称重复\n    if (props &amp;&amp; hasOwn(props, key)) {\n      process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; warn(\n        `The data property &quot;${key}&quot; is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) { // 验证key值的合法性\n      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  // 响应式监听data是数据的变化\n  observe(data, true /* asRootData */)\n}\n仔细阅读上面的代码，我们可以得到以下结论：\n\n初始化顺序：props、methods、data\ndata定义的时候可选择函数形式或者对象形式（组件只能为函数形式）\n\n关于数据响应式在这就不展开详细说明\n上文提到挂载方法是调用vm.$mount方法\n源码位置：\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 获取或查询元素\n  el = el &amp;&amp; query(el)\n \n  /* istanbul ignore if */\n  // vue 不允许直接挂载到body或页面文档上\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; warn(\n      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`\n    )\n    return this\n  }\n \n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    // 存在template模板，解析vue模板文件\n    if (template) {\n      if (typeof template === &#039;string&#039;) {\n        if (template.charAt(0) === &#039;#&#039;) {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== &#039;production&#039;) {\n          warn(&#039;invalid template option:&#039; + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      // 通过选择器获取元素内容\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; config.performance &amp;&amp; mark) {\n        mark(&#039;compile&#039;)\n      }\n      /**\n       *  1.将temmplate解析ast tree\n       *  2.将ast tree转换成render语法字符串\n       *  3.生成render方法\n       */\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== &#039;production&#039;,\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n \n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; config.performance &amp;&amp; mark) {\n        mark(&#039;compile end&#039;)\n        measure(`vue ${this._name} compile`, &#039;compile&#039;, &#039;compile end&#039;)\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n阅读上面代码，我们能得到以下结论：\n\n不要将根元素放到body或者html上\n可以在对象中定义template/render或者直接使用template、el表示元素选择器\n最终都会解析成 render 函数，调用 compileToFunctions，会将 template 解析成 render 函数\n\n对template的解析步骤大致分为以下几步：\n\n将 html 文档片段解析成 AST 描述符\n将 AST 描述符解析成字符串\n生成render函数\n\n生成render函数，挂载到vm上后，会再次调用mount方法\n源码位置：src\\platforms\\web\\runtime\\index.js\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  // 渲染组件\n  return mountComponent(this, el, hydrating)\n}\n调用mountComponent渲染组件\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  // 如果没有获取解析的render函数，则会抛出警告\n  // render是解析模板文件生成的\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== &#039;production&#039;) {\n      /* istanbul ignore if */\n      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#039;#&#039;) ||\n        vm.$options.el || el) {\n        warn(\n          &#039;You are using the runtime-only build of Vue where the template &#039; +\n          &#039;compiler is not available. Either pre-compile the templates into &#039; +\n          &#039;render functions, or use the compiler-included build.&#039;,\n          vm\n        )\n      } else {\n        // 没有获取到vue的模板文件\n        warn(\n          &#039;Failed to mount component: template or render function not defined.&#039;,\n          vm\n        )\n      }\n    }\n  }\n  // 执行beforeMount钩子\n  callHook(vm, &#039;beforeMount&#039;)\n \n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; config.performance &amp;&amp; mark) {\n    updateComponent = () =&gt; {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n \n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n \n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    // 定义更新函数\n    updateComponent = () =&gt; {\n      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render\n      vm._update(vm._render(), hydrating)\n    }\n  }\n  // we set this to vm._watcher inside the watcher&#039;s constructor\n  // since the watcher&#039;s initial patch may call $forceUpdate (e.g. inside child\n  // component&#039;s mounted hook), which relies on vm._watcher being already defined\n  // 监听当前组件状态，当有数据变化时，更新组件\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n        // 数据更新引发的组件更新\n        callHook(vm, &#039;beforeUpdate&#039;)\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n \n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, &#039;mounted&#039;)\n  }\n  return vm\n}\n阅读上面代码，我们得到以下结论：\n\n会触发beforeCreate钩子\n定义updateComponent渲染页面视图的方法\n监听组件数据，一旦发生变化，触发beforeUpdate生命钩子\n\nupdateComponent方法主要执行在vue初始化时声明的render，update方法\nrender的作用主要是生成vnode\n源码位置：src\\core\\instance\\render.js\n// 定义vue 原型上的render方法\nVue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // render函数来自于组件的option\n    const { render, _parentVnode } = vm.$options\n \n    if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n            _parentVnode.data.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n        )\n    }\n \n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n        // There&#039;s no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component&#039;s render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm\n        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode\n        vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n        handleError(e, vm, `render`)\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; vm.$options.renderError) {\n            try {\n                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n            } catch (e) {\n                handleError(e, vm, `renderError`)\n                vnode = vm._vnode\n            }\n        } else {\n            vnode = vm._vnode\n        }\n    } finally {\n        currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) {\n        vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n        if (process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; Array.isArray(vnode)) {\n            warn(\n                &#039;Multiple root nodes returned from render function. Render function &#039; +\n                &#039;should return a single root node.&#039;,\n                vm\n            )\n        }\n        vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中\n源码位置：src\\core\\instance\\lifecycle.js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    // 设置当前激活的作用域\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      // 执行具体的挂载逻辑\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    restoreActiveInstance()\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent&#039;s updated hook.\n  }\n三、结论\n\nnew Vue的时候调用会调用_init方法\n\n定义 [[【延伸问答】this.set()的用处及用法∣set]]、$get 、$delete、$watch 等方法\n定义 $on、$off、$emit、$off等事件\n定义 _update、$forceUpdate、$destroy生命周期\n\n\n调用$mount进行页面的挂载\n挂载的时候主要是通过mountComponent方法\n定义updateComponent更新函数\n执行render生成虚拟DOM\n_update 将虚拟 DOM 生成真实 DOM 结构，并且渲染到页面中。\n\n参考文献\n\nwww.cnblogs.com/gerry2019/p/12001661.html\ngithub.com/vuejs/vue/tree/dev/src/core/instance\nvue3js.cn\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue常用的修饰符有哪些有什么应用场景":{"title":"Vue常用的修饰符有哪些有什么应用场景","links":[],"tags":["编程/FE/Vue"],"content":"一、修饰符是什么\n在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号\n在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理\nvue中修饰符分为以下五种：\n\n表单修饰符\n事件修饰符\n鼠标按键修饰符\n键值修饰符\nv-bind修饰符\n\n二、修饰符的作用\n表单修饰符\n在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model\n关于表单的修饰符有如下：\n\nlazy\ntrim\nnumber\n\nlazy\n在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步\n&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;\n&lt;p&gt;{{value}}&lt;/p&gt;\ntrim\n自动过滤用户输入的首空格字符，而中间的空格不会过滤\n&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;\nnumber\n自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值\n&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n事件修饰符\n事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：\n\nstop\nprevent\nself\nonce\ncapture\npassive\nnative\n\nstop\n阻止了事件冒泡，相当于调用了event.stopPropagation方法\n&lt;div @click=&quot;shout(2)&quot;&gt;\n  &lt;button @click.stop=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n&lt;/div&gt;\n//只输出1\nprevent\n阻止了事件的默认行为，相当于调用了event.preventDefault方法\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\nself\n只当在 event.target 是当前元素自身时触发处理函数\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n\n                  \n                  注意❗ \n                  \n                \n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击\n\nonce\n绑定了事件以后只能触发一次，第二次就不会触发\n&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\ncapture\n使事件触发从包含这个元素的顶层开始往下触发\n&lt;div @click.capture=&quot;shout(1)&quot;&gt;\n    obj1\n&lt;div @click.capture=&quot;shout(2)&quot;&gt;\n    obj2\n&lt;div @click=&quot;shout(3)&quot;&gt;\n    obj3\n&lt;div @click=&quot;shout(4)&quot;&gt;\n    obj4\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n// 输出结构: 1 2 4 3 \npassive\n在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符\n&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;\n&lt;!-- 而不会等待 `onScroll` 完成  --&gt;\n&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;\n&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;\n\n\n                  \n                  注意❗ \n                  \n                \n不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。\npassive 会告诉浏览器你不想阻止事件的默认行为\n\nnative\n让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件\n&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;\n\n\n                  \n                  注意❗ \n                  \n                \n使用.native修饰符来操作普通HTML标签是会令事件失效的\n\n鼠标按钮修饰符\n鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：\n\nleft 左键点击\nright 右键点击\nmiddle 中键点击\n\n&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n键盘修饰符\n键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：\nkeyCode存在很多，但vue为我们提供了别名，分为以下两种：\n\n普通键（enter、tab、delete、space、esc、up…）\n系统修饰键（ctrl、alt、meta、shift…）\n\n// 只有按键为keyCode的时候才触发\n&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout()&quot;&gt;\n还可以通过以下方式自定义一些全局的键盘码别名\nVue.config.keyCodes.f2 = 113\nv-bind修饰符\nv-bind修饰符主要是为属性进行操作，用来分别有如下：\n\nasync\nprop\ncamel\n\nasync\n能对props进行一个双向绑定\n//父组件\n&lt;comp :myMessage.sync=&quot;bar&quot;&gt;&lt;/comp&gt; \n//子组件\nthis.$emit(&#039;update:myMessage&#039;,params);\n以上这种方法相当于以下的简写\n//父亲组件\n&lt;comp :myMessage=&quot;bar&quot; @update:myMessage=&quot;func&quot;&gt;&lt;/comp&gt;\nfunc(e){\n this.bar = e;\n}\n//子组件js\nfunc2(){\n  this.$emit(&#039;update:myMessage&#039;,params);\n}\n使用async需要注意以下两点：\n\n使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致\n注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用\n将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的\n\nprops\n设置自定义标签属性，避免暴露数据，防止污染HTML结构\n&lt;input id=&quot;uid&quot; title=&quot;title1&quot; value=&quot;1&quot; :index.prop=&quot;index&quot;&gt;\ncamel\n将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox\n&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt;\n三、应用场景\n根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：\n\n.stop：阻止事件冒泡\n.native：绑定原生事件\n.once：事件只执行一次\n.self ：将事件绑定在自身身上，相当于阻止事件冒泡\n.prevent：阻止默认事件\n.caption：用于事件捕获\n.once：只触发一次\n.keyCode：监听特定键盘按下\n.right：右键\n\n参考文献\n\nsegmentfault.com/a/1190000016786254\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue组件之间的通信方式都有哪些！":{"title":"Vue组件之间的通信方式都有哪些！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/父子组件通信","C-Knowledge/前端/职业规划/前端面试宝典/八股文/兄弟组件通信","C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件通信区别"],"tags":["编程/FE/Vue"],"content":"一、组件间通信的概念\n开始之前，我们把组件间通信这个词进行拆分\n\n组件\n通信\n\n都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信\n二、组件间通信解决了什么\n在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统\n二、组件间通信的分类\n组件间通信的分类可以分成以下\n\n父子组件 之间的通信\n兄弟组件 之间的通信\n祖孙与后代组件之间的通信\n非关系组件间之间的通信\n\n关系图:\n\n三、组件间通信的方案\n整理vue中8种常规的通信方案\n\n通过 props 传递\n通过 $emit 触发自定义事件\n使用 ref\nEventBus\n$parent 或$root\nattrs 与 listeners\nProvide 与 Inject\nVuex\n\nprops传递数据\n\n\n适用场景：父组件传递数据给子组件\n子组件设置props属性，定义接收父组件传递过来的参数\n父组件在使用子组件标签中通过字面量来传递值\n\nChildren.vue\nprops:{  \n    // 字符串形式  \n name:String // 接收的类型参数  \n    // 对象形式  \n    age:{    \n        type:Number, // 接收的类型为数值  \n        defaule:18,  // 默认值为18  \n       require:true // age属性必须传递  \n    }  \n}  \nFather.vue组件\n&lt;Children name=&quot;jack&quot; age=18 /&gt;  \n$emit 触发自定义事件\n\n适用场景：子组件传递数据给父组件\n子组件通过 $emit 触发自定义事件，$emit 第二个参数为传递的数值\n父组件绑定监听器获取到子组件传递过来的参数\n\nChilfen.vue\nthis.$emit(&#039;add&#039;, good)  \nFather.vue\n&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  \nref\n\n父组件在使用子组件的时候设置ref\n父组件通过设置子组件ref来获取数据\n\n父组件\n&lt;Children ref=&quot;foo&quot; /&gt;  \n  \nthis.$refs.foo  // 获取子组件实例，通过子组件实例我们就能拿到对应的数据  \nEventBus\n\n\n                  \n                  提示💡 \n                  \n                \n建立一个总线，所有数据都在总线上拿。\n\n\n使用场景：兄弟组件传值\n创建一个中央事件总线EventBus\n兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n另一个兄弟组件通过$on监听自定义事件\n\nBus.js\n// 创建一个中央时间总线类  \nclass Bus {  \n  constructor() {  \n    this.callbacks = {};   // 存放事件的名字  \n  }  \n  $on(name, fn) {  \n    this.callbacks[name] = this.callbacks[name] || [];  \n    this.callbacks[name].push(fn);  \n  }  \n  $emit(name, args) {  \n    if (this.callbacks[name]) {  \n      this.callbacks[name].forEach((cb) =&gt; cb(args));  \n    }  \n  }  \n}  \n  \n// main.js  \nVue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  \n// 另一种方式  \nVue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  \nChildren1.vue\nthis.$bus.$emit(&#039;foo&#039;)  \nChildren2.vue\nthis.$bus.$on(&#039;foo&#039;, this.handle)  \n\n兄弟组件通信\n\n$parent 或$root\n\n通过共同祖辈$parent或者$root搭建通信桥连\n\n兄弟组件\nthis.$parent.on(&#039;add&#039;,this.add)\n另一个兄弟组件\nthis.$parent.emit(&#039;add&#039;)\n$attrs 与$ listeners\n\n适用场景：祖先传递数据给子孙\n设置批量向下传属性$attrs和 $listeners\n包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。\n可以通过 v-bind=&quot;$attrs&quot; 传⼊内部组件\n\n// child：并未在props中声明foo  \n&lt;p&gt;{{$attrs.foo}}&lt;/p&gt;  \n  \n// parent  \n&lt;HelloWorld foo=&quot;foo&quot;/&gt;  \n// 给Grandson隔代传值，communication/index.vue  \n&lt;Child2 msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child2&gt;  \n  \n// Child2做展开  \n&lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt;  \n  \n// Grandson使⽤  \n&lt;div @click=&quot;$emit(&#039;some-event&#039;, &#039;msg from grandson&#039;)&quot;&gt;  \n{{msg}}  \n&lt;/div&gt;  \nprovide 与 inject\n\n在祖先组件定义provide属性，返回传递的值\n在后代组件通过inject接收组件传递过来的值\n\n祖先组件\nprovide(){  \n    return {  \n        foo:&#039;foo&#039;  \n    }  \n}  \n后代组件\ninject:[&#039;foo&#039;] // 获取到祖先组件传递过来的值  \nvuex\n\n\n适用场景: 复杂关系的组件数据传递\n\n\nVuex作用相当于一个用来存储共享变量的容器 \n\n\nstate用来存放共享变量的地方\n\n\ngetter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值\n\n\nmutations用来存放修改state的方法。\n\n\nactions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作\n\n\n小结\n\n父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref\n兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递\n祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject\n复杂关系的组件数据传递可以通过vuex存放共享的变量\n\n参考文献\n\njuejin.cn/post/6844903990052782094#heading-0\nzh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1\nvue3js.cn/docs/zh\n\n\n\n组件通信区别\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack-4和Webpack-5有哪些主要的区别！":{"title":"Webpack 4和Webpack 5有哪些主要的区别！","links":[],"tags":["编程/Webpack"],"content":"以下是Webpack 4和Webpack 5之间的一些主要区别的表格总结：\n\n这仅是一些主要的区别，实际上Webpack 5还引入了许多其他功能和改进，如更好的性能、优化的缓存策略、更好的构建速度等。要根据你的具体项目需求和场景，选择合适的Webpack版本。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack中的提取公共代码（Extracting-Common-Code）是什么！如何进行配置！":{"title":"Webpack中的提取公共代码（Extracting Common Code）是什么！如何进行配置！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中，当多个模块中存在相同的代码时，我们可以使用提取公共代码来避免代码的重复加载，从而减小打包后的文件体积。这样可以提高页面的加载速度。\n为了在Webpack中配置提取公共代码，我们可以使用插件 webpack.optimize.SplitChunksPlugin（Webpack4中）、webpack.optimize.CommonsChunkPlugin（Webpack3及更早版本中）。\nWebpack4中的配置示例：\nconst path = require(&#039;path&#039;);\n \nmodule.exports = {\n  entry: {\n    main: &#039;./src/main.js&#039;,\n    vendor: &#039;./src/vendor.js&#039;\n  },\n  output: {\n    filename: &#039;[name].bundle.js&#039;,\n    path: path.resolve(__dirname, &#039;dist&#039;)\n  },\n  optimization: {\n    splitChunks: {\n      chunks: &#039;all&#039;,\n      name: &#039;common&#039;\n    }\n  }\n};\n上面的例子中，我们通过 entry 属性指定了入口文件 main.js 和 vendor.js，它们分别会生成 main.bundle.js 和 vendor.bundle.js。\n在 optimization.splitChunks 中，我们指定了 chunks: &#039;all&#039;，这会将所有模块中重复的代码提取为一个单独的文件。我们还可以通过 name 属性指定提取的公共代码文件的名称，这里我们指定为 common.bundle.js。\n在Webpack4中，SplitChunksPlugin 成为了默认配置，我们可以直接通过 optimization 属性进行配置。但是在Webpack3及更早的版本中，还需要使用 CommonsChunkPlugin 插件来进行配置。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack八股文":{"title":"Webpack八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对webpack的理解！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的构建流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Loader和Plugin的区别！编写Loader，Plugin的思路！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的热更新是如何做到的！原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack-proxy工作原理！为什么能解决跨域！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何提高webpack的构建速度！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/与webpack类似的工具还有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的核心概念是什么！请解释entry、output、loader和plugin。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack中常见的Loader！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack中常见的Plugin！解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Webpack-Loader和Plugin的执行顺序！如何控制它们的执行顺序！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）！它们有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的Resolve模块解析是什么！请解释resolve.modules、resolve.alias和resolve.extensions的作用。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的模块化（Module-Federation）是什么，它解决了什么问题！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的动态导入（Dynamic-Imports）和预加载（Preloading）的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何配置Webpack的开发环境和生产环境的不同配置！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，什么是环境变量（Environment-Variables）！如何在配置中使用它们！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的Tree-Shaking是什么！如何配置实现代码的无用代码剔除！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中实现Code-Splitting和按需加载的路由（Dynamic-Imports）！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中使用ES6+的语法和新特性，例如ES-Modules、Async-and-Await等！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的DevServer是什么！如何配置用于开发环境的Webpack-DevServer！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用Webpack进行代码分析和打包分析（Bundle-Analysis）！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理第三方库（vendor-libraries）和动态链接库（Dynamic-Linking-Libraries）！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理样式文件，例如CSS、Sass、Less等！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack中的提取公共代码（Extracting-Common-Code）是什么！如何进行配置！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理多页应用（Multiple-Pages-Application）的构建！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的静态资源引入优化（Asset-Resource-Optimization）是什么，如何进行优化配置！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，如何使用Babel来转译和处理JavaScript文件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的持久化缓存（Persistent-Caching）是什么，如何配置使用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何自定义一个-webpack-插件-！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何借助webpack来优化前端性能！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack-4和Webpack-5有哪些主要的区别！"],"tags":["编程/Webpack"],"content":"重点\n\n说说你对webpack的理解！解决了什么问题！\n说说webpack的构建流程！\n说说Loader和Plugin的区别！编写Loader，Plugin的思路！\n说说webpack的热更新是如何做到的！原理是什么！\n说说webpack proxy工作原理！为什么能解决跨域！\n如何提高webpack的构建速度！\n与webpack类似的工具还有哪些！区别！\n\n八股文\n核心概念\n\n说说你对webpack的理解！解决了什么问题！\nWebpack的核心概念是什么！请解释entry、output、loader和plugin。\n说说webpack中常见的Loader！解决了什么问题！\n说说webpack中常见的Plugin！解决了什么问题！\n说说Loader和Plugin的区别！编写Loader，Plugin的思路！\n什么是Webpack Loader和Plugin的执行顺序！如何控制它们的执行顺序！\n在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）！它们有什么区别！\nWebpack的Resolve模块解析是什么！请解释resolve.modules、resolve.alias和resolve.extensions的作用。\n解释一下Webpack的模块化（Module Federation）是什么，它解决了什么问题！\n解释一下Webpack的动态导入（Dynamic Imports）和预加载（Preloading）的区别！\n\n使用方法\n\n如何配置Webpack的开发环境和生产环境的不同配置！\n在Webpack中，什么是环境变量（Environment Variables）！如何在配置中使用它们！\n如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件！\nWebpack的Tree Shaking是什么！如何配置实现代码的无用代码剔除！\n如何在Webpack中实现Code Splitting和按需加载的路由（Dynamic Imports）！\n如何在Webpack中使用ES6+的语法和新特性，例如ES Modules、Async&amp;Await等！\n解释一下Webpack的DevServer是什么！如何配置用于开发环境的Webpack DevServer！\n如何使用Webpack进行代码分析和打包分析（Bundle Analysis）！\n如何在Webpack中处理第三方库（vendor libraries）和动态链接库（Dynamic Linking Libraries）！\n如何在Webpack中处理样式文件，例如CSS、Sass、Less等！\nWebpack中的提取公共代码（Extracting Common Code）是什么！如何进行配置！\n如何在Webpack中处理多页应用（Multiple Pages Application）的构建！\nWebpack的静态资源引入优化（Asset Resource Optimization）是什么，如何进行优化配置！\n在Webpack中，如何使用Babel来转译和处理JavaScript文件！\nWebpack的持久化缓存（Persistent Caching）是什么，如何配置使用！\n\n底层原理\n\n说说webpack的构建流程！\n说说webpack的热更新是如何做到的！原理是什么！\n说说webpack proxy工作原理！为什么能解决跨域！\n解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。\n\n构建优化\n\n如何自定义一个 webpack 插件 ！\n说说如何借助webpack来优化前端性能！\n如何提高webpack的构建速度！\n\n其他\n\n与webpack类似的工具还有哪些！区别！\nWebpack 4和Webpack 5有哪些主要的区别！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的Resolve模块解析是什么！请解释resolve.modules、resolve.alias和resolve.extensions的作用。":{"title":"Webpack的Resolve模块解析是什么！请解释resolve.modules、resolve.alias和resolve.extensions的作用。","links":[],"tags":["编程/Webpack"],"content":"Webpack的Resolve模块解析是用于解析模块路径的配置选项。它可以帮助Webpack正确地确定模块的位置。\n\nresolve.modules用于指定模块的搜索路径。当Webpack在解析导入语句时，它会按照指定的顺序依次查找这些路径来确定模块的位置。默认情况下，Webpack会在当前工作目录和node_modules文件夹中查找。\nresolve.alias用于创建模块的路径别名。通过配置别名，可以让Webpack在导入模块时使用更简短的路径。这对于减少代码中的冗余路径非常有用。\nresolve.extensions用于指定可以省略的文件扩展名。当导入模块时没有指定文件扩展名时，Webpack会按照指定的顺序依次尝试添加扩展名来解析模块。这样可以让我们在导入模块时省略掉繁琐的扩展名，提高开发效率。\n\n通过合理配置这些选项，我们可以让Webpack更快地找到模块的位置，并且在导入模块时更加方便简洁。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的Tree-Shaking是什么！如何配置实现代码的无用代码剔除！":{"title":"Webpack的Tree Shaking是什么！如何配置实现代码的无用代码剔除！","links":[],"tags":["编程/Webpack"],"content":"Webpack的Tree Shaking是一个用于删除代码中未被引用的未使用代码的优化技术。\n它可以显著减小打包后的文件体积，提高网页加载速度。\n要配置Webpack实现代码的无用代码剔除，需要进行以下几个步骤：\n\n\n确保你的代码是使用ES6模块语法编写的，而不是CommonJS（require）语法。因为Tree Shaking只对ES6模块有效。\n\n\n在Webpack配置文件中，通过设置mode为production，启用Webpack的生产模式，此时Tree Shaking功能会默认开启。\n\n\n确保你的package.json文件中的sideEffects字段被正确配置。sideEffects字段告诉Webpack哪些文件是没有副作用的，可以进行Tree Shaking。如果你的应用是纯粹的JavaScript应用，可以将sideEffects设置为&quot;sideEffects&quot;: false。如果你的应用使用了一些有副作用的模块（例如CSS文件），你需要将这些模块添加到sideEffects字段中。这样Webpack就不会将这些有副作用的模块进行Tree Shaking。\n\n\n需要注意的是，Tree Shaking只适用于ES6模块语法，并且只能剔除未引用的代码，不能剔除被动态引用的代码（例如通过字符串拼接生成模块路径）。另外，一些特定的代码结构可能会导致Tree Shaking失效，例如使用eval、with等特殊语法。\n配置完成后，运行Webpack打包构建，未被引用的代码将会被删除，从而减小文件体积。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的持久化缓存（Persistent-Caching）是什么，如何配置使用！":{"title":"Webpack的持久化缓存（Persistent Caching）是什么，如何配置使用！","links":[],"tags":["编程/Webpack"],"content":"Webpack的持久化缓存（Persistent Caching）是一种优化构建性能的机制。\n当使用持久化缓存时，Webpack会根据文件内容生成哈希值，并将这个哈希值作为文件名的一部分。这样，如果文件的内容没有发生变化，Webpack就可以使用缓存中的文件，而不需要重新构建。只有当文件内容发生变化时，Webpack才会重新构建。\n配置Webpack使用持久化缓存非常简单，只需要在配置文件中的output字段中添加chunkFilename属性，并使用[chunkhash]作为文件名的一部分。例如：\nconst path = require(&#039;path&#039;);\n \nmodule.exports = {\n  // ...\n  output: {\n    // ...\n    chunkFilename: &#039;[chunkhash].js&#039;,\n  },\n  // ...\n};\n以上配置会根据文件内容生成一个唯一的哈希值，作为每个chunk的文件名。当使用持久化缓存时，只有在文件内容发生变化时，对应的chunk的文件名才会改变，否则将使用缓存中的文件。这样可以减少构建时间，提高开发环境的效率。\n\n\n                  \n                  注意❗ \n                  \n                \n请注意，持久化缓存只在生产环境中起作用，因为在开发环境下，通常需要实时更新构建结果，以便进行调试和热模块替换。在开发环境中，可以考虑使用Webpack的开发服务器来自动刷新页面。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的核心概念是什么！请解释entry、output、loader和plugin。":{"title":"Webpack的核心概念是什么！请解释entry、output、loader和plugin。","links":[],"tags":["编程/Webpack"],"content":"Webpack的核心概念包括entry（入口）、output（输出）、loader（加载器）和plugin（插件）。\n\n\nEntry（入口）：Webpack将从指定的入口文件开始分析和构建依赖关系树。入口可以是单个文件或多个文件，Webpack会根据入口配置找出所有的依赖模块。\n\n\nOutput（输出）：指定Webpack打包后的文件输出的路径和文件名。可以通过配置output选项来指定输出文件的路径、名称和格式等。\n\n\nLoader（加载器）：Webpack本身只能处理JavaScript模块，但通过Loader的使用，可以处理其他类型的文件（如CSS、LESS、图片等）。Loader的作用是在模块加载时对其进行转换和处理。\n\n\nPlugin（插件）：插件用于扩展Webpack的功能。它可以在打包的不同阶段执行特定的任务。例如，可以使用插件来压缩代码、拆分代码、生成HTML文件等。插件通过在Webpack配置中引入并实例化，然后将其添加到plugins数组中。\n\n\n综上所述，Webpack的核心概念包括entry、output、loader和plugin。\n\nentry指定Webpack的入口文件\noutput定义打包输出的文件及路径\nloader用于处理不同类型的文件\nplugin用于扩展Webpack的功能\n\n这些概念共同协作，实现了模块打包和构建的功能。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack的静态资源引入优化（Asset-Resource-Optimization）是什么，如何进行优化配置！":{"title":"Webpack的静态资源引入优化（Asset Resource Optimization）是什么，如何进行优化配置！","links":[],"tags":["编程/Webpack"],"content":"Webpack的静态资源引入优化（Asset Resource Optimization）是指通过优化静态资源的处理和引入方式，以减少打包后的文件体积，提高页面加载速度。\n以下是一些常用的优化配置：\n\n压缩资源文件：使用插件如 TerserPlugin 压缩 JavaScript 文件，使用插件如 OptimizeCSSAssetsPlugin 压缩 CSS 文件。\n\nconst TerserPlugin = require(&#039;terser-webpack-plugin&#039;);\nconst OptimizeCSSAssetsPlugin = require(&#039;optimize-css-assets-webpack-plugin&#039;);\n \nmodule.exports = {\n  // ...\n  optimization: {\n    minimizer: [\n      new TerserPlugin(),\n      new OptimizeCSSAssetsPlugin()\n    ]\n  },\n  // ...\n};\n\n合并资源文件：通过配置合适的代码分割策略，将多个小文件合并为一个单独的文件。\n\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: &#039;all&#039;\n    }\n  },\n  // ...\n};\n上述配置能够将公共的代码提取出来，使得每个页面只需要引入一份公共代码。\n\n使用CDN引入外部资源：将一些不常变化的外部资源，如jQuery、Bootstrap等，通过CDN引入，减少打包体积。\n\nmodule.exports = {\n  // ...\n  externals: {\n    jquery: &#039;jQuery&#039;\n  },\n  // ...\n};\n在上述配置中，我们将外部资源 jQuery 指定为全局变量 jQuery，通过 CDN 引入，而不是打包进入最终的输出文件。\n\n使用文件指纹（hash）：通过在输出文件名中加入文件指纹，可以实现在文件内容变化时，生成新的文件名，从而缓存新的文件。\n\nmodule.exports = {\n  // ...\n  output: {\n    filename: &#039;[name].[contenthash].js&#039;\n  },\n  // ...\n};\n上述配置中，我们使用 [contenthash] 占位符为输出文件名加入文件指纹。\n这些是一些常见的静态资源引入优化配置，通过合理的配置，可以降低打包后的文件大小，提高页面加载速度。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/css中，有哪些方式可以隐藏页面元素！区别！":{"title":"css中，有哪些方式可以隐藏页面元素！区别！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/重绘和回流","C-Knowledge/前端/技术书籍/CSS世界/display-与元素的显隐","C-Knowledge/前端/技术书籍/CSS世界/visibility-与元素的显隐","技术书籍/CSS世界/absolute与clip"],"tags":["编程/FE/CSS"],"content":"一、前言\n在平常的样式排版中，我们经常遇到将某个模块隐藏的场景\n通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的\n但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法\n二、实现方式\n通过css实现隐藏元素方法有如下：\n\ndisplay:none\nvisibility:hidden\nopacity:0\n设置height、width模型属性为0\nposition:absolute\nclip-path\n\ndisplay:none\n设置元素的display为none是最常用的隐藏元素的方法\n.hide {\n    display:none;\n}\n将元素设置为display:none后，元素在页面上将彻底消失\n元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘\n消失后，自身绑定的事件不会触发，也不会有过渡效果\n特点：元素不可见，不占据空间，无法响应点击事件\nvisibility:hidden\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法\n从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘\n.hidden{\n    visibility:hidden\n}\n给人的效果是隐藏了，所以他自身的事件不会触发\n特点：元素不可见，占据页面空间，无法响应点击事件\nopacity:0\nopacity属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的\n不会引发重排，一般情况下也会引发重绘\n\n\n                  \n                  注意❗ \n                  \n                \n如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘\n\n.transparent {\n    opacity:0;\n}\n由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是：其子元素不能设置 opacity 来达到显示的效果\n\n特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件\n设置height、width属性为0\n将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素\n.hiddenBox {\n    margin:0;     \n    border:0;\n    padding:0;\n    height:0;\n    width:0;\n    overflow:hidden;\n}\n特点：元素不可见，不占据页面空间，无法响应点击事件\nposition:absolute\n将元素移出可视区域\n.hide {\n   position: absolute;\n   top: -9999px;\n   left: -9999px;\n}\n特点：元素不可见，不影响页面布局\nclip-path\n通过裁剪的形式\n.hide {\n  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);\n}\n特点：元素不可见，占据页面空间，无法响应点击事件\n小结\n最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们\n三、区别\n关于display: none、visibility: hidden、opacity: 0的区别，如下表所示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndisplay: nonevisibility: hiddenopacity: 0页面中不存在存在存在重排会不会不会重绘会会不一定自身绑定事件不触发不触发可触发transition不支持支持支持子元素可复原不能能不能被遮挡的元素可触发事件能能不能\n总结\n\n\nopacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的\n\n\nvisibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）\n\n\ndisplay：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n属性不占位读屏软件隐藏用于隐藏主体内容 SEOdisplay: none√√不抓取visibility: hidden×√可能抓取opacity: 0××疑似作弊input type = hidden√√不抓取position: absolute / fixed√×疑似作弊aria-hidden = true×√未知text-indent &lt; 0√×常用于在 Logo 处标识网站名称font-size: 0√×疑似作弊overflow: hidden√（裁剪）×抓取clip-path: polygon (0 0, 0 0, 0 0, 0 0)√×未知\n参考文献\n\nwww.cnblogs.com/a-cat/p/9039962.html\n\n\n\n重绘和回流\ndisplay 与元素的显隐\nvisibility 与元素的显隐\n2 ．最佳可访问性隐藏\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/html2canvas":{"title":"html2canvas","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/总结一下使用html2canvas截图时遇到的问题"],"tags":["编程/Canvas"],"content":"\n总结一下使用html2canvas截图时遇到的问题\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/keep-alive-中的生命周期有哪些":{"title":"keep-alive 中的生命周期有哪些","links":[],"tags":["编程/FE/Vue"],"content":"keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。\n如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。\n同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。\n\n\n                  \n                  提示💡 \n                  \n                \n类比小程序页面切换的生命周期。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/mutations-能不能做异步":{"title":"mutations 能不能做异步","links":[],"tags":["编程/FE/Vue"],"content":"不能，Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。每个 mutation 执行完成后都会对应到一个新的状态变更。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app八股文":{"title":"uni-app八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简述一下uni-app的跨平台工作原理。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是条件编译！在uni-app中如何实现条件编译！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在uni-app中如何处理各平台的差异性！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app中的页面生命周期有哪些！请简要介绍。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简述一下uni-app的定义和特点。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app兼容哪些前端框架！请列举几个。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在uni-app中如何使用组件！有没有一些常用的内置组件！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下uni-app中的页面导航和传参的方式。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在uni-app中实现数据的双向绑定！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请谈谈uni-app的小程序打包和发布流程。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app中如何实现本地存储和缓存！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app如何处理异步请求！有哪些常用的网络请求库！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简述一下uni-app中的模块化开发思想。","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app是否支持自定义插件和扩展！如何使用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app中的热更新是如何实现的！有什么注意事项！"],"tags":["编程/uniapp"],"content":"重点\n\n请简述一下uni-app的跨平台工作原理。\n什么是条件编译！在uni-app中如何实现条件编译！\n在uni-app中如何处理各平台的差异性！\nuni-app中的页面生命周期有哪些！请简要介绍。\n\n八股文\n\n请简述一下uni-app的定义和特点。\nuni-app兼容哪些前端框架！请列举几个。\n请简述一下uni-app的跨平台工作原理。\n什么是条件编译！在uni-app中如何实现条件编译！\nuni-app中的页面生命周期有哪些！请简要介绍。\n在uni-app中如何使用组件！有没有一些常用的内置组件！\n请解释一下uni-app中的页面导航和传参的方式。\n如何在uni-app中实现数据的双向绑定！\n请谈谈uni-app的小程序打包和发布流程。\nuni-app中如何实现本地存储和缓存！\nuni-app如何处理异步请求！有哪些常用的网络请求库！\n请简述一下uni-app中的模块化开发思想。\n在uni-app中如何处理各平台的差异性！\nuni-app是否支持自定义插件和扩展！如何使用！\nuni-app中的热更新是如何实现的！有什么注意事项！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/v-model-是什么，有什么用！":{"title":"v-model 是什么，有什么用！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue组件之间的通信方式都有哪些！"],"tags":["编程/FE/Vue"],"content":"v-model 是一个常用的表单指令，也是唯一一个双向绑定指令。双向的含义是：\n\n状态的变化能更新到视图上；\n用户在表单中的修改也能更新到状态中。\n\nv-model 的本质是对自定义属性和自定义事件的综合使用，默认情况下是 value 属性和 input 事件。\n例如：\n&lt;!-- 在大部分情况下，以下两种写法是等价的 --&gt;\n&lt;el-input v-model=&quot;foo&quot; /&gt;\n \n&lt;el-input :value=&quot;foo&quot; @input=&quot;foo = $event&quot; /&gt;\n所以，我们可以把它使用在任意的自定义组件中，来达到父子组件通讯的目的。\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;input v-model=&quot;message&quot; /&gt;\n    &lt;p&gt;Message: {{ message }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      message: &#039;&#039;,\n    };\n  },\n};\n&lt;/script&gt;\n动态绑定\nv-model=&quot;ruleForm[`score${index}`]&quot;\n\nvue动态绑定v-model属性名方式\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue3有了解过吗！能说说跟vue2的区别吗！":{"title":"vue3有了解过吗！能说说跟vue2的区别吗！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说Vue-3.0中Treeshaking特性！举例说明一下！","C-Knowledge/前端/开发技术/Vue/'Teleport'","C-Knowledge/前端/开发技术/Vue/Vue3-API"],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \ntree-shaking、数据绑定、组合式 Api、TypeScript 支持\n\n一、Vue3介绍\n关于vue3的重构背景，尤大是这样说的：\nVue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了\n在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」\n简要就是：\n\n利用新的语言特性(es6)\n解决架构问题\n\n哪些变化\n\n从上图中，我们可以概览Vue3的新特性，如下：\n\n速度更快\n体积减少\n更易维护\n更接近原生\n更易使用\n\n速度更快\nvue3相比vue2\n\n重写了虚拟Dom实现\n编译模板的优化\n更高效的组件初始化\nundate性能提高1.3~2倍\nSSR速度提高了2~3倍\n\n\n体积更小\n通过 webpack 的 tree-shaking 功能，可以将无用模块“剪辑”，仅打包需要的\n能够tree-shaking，有两大好处：\n\n对开发人员，能够对vue实现更多其他的功能，而不必担忧整体体积过大\n对使用者，打包出来的包体积变小了\n\nvue可以开发出更多其他的功能，而不必担忧vue打包出来的整体体积过多\n\n更易维护\nCompositon Api\n\n可与现有的Options API一起使用\n灵活的逻辑组合与复用\nVue3模块可以和其他框架搭配使用\n\n\n更好的Typescript支持\nVUE3是基于typescipt编写的，可以享受到自动的类型定义提示\n\n编译器重写\n\n更接近原生\n可以自定义渲染 API\n\n更易使用\n响应式 Api 暴露出来\n\n轻松识别组件重新渲染原因\n\n二、Vue3新增特性\nVue 3 中需要关注的一些新功能包括：\n\nframents\nTeleport\nComposition API\ncreateRenderer\n\nFraments\n在 Vue3.x 中，组件现在支持有多个根节点\n&lt;!-- Layout.vue --&gt;\n&lt;template&gt;\n  &lt;header&gt;...&lt;/header&gt;\n  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;\n  &lt;footer&gt;...&lt;/footer&gt;\n&lt;/template&gt;\nTeleport\nTeleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术，就有点像哆啦A梦的“任意门”\n在vue2中，像 modals,toast 等这样的元素，如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位、z-index 和样式就会变得很困难\n通过 ‘Teleport’，我们可以在组件的逻辑位置写模板代码，然后在 Vue 应用范围之外渲染它。\n&lt;button @click=&quot;showToast&quot; class=&quot;btn&quot;&gt;打开 toast&lt;/button&gt;\n&lt;!-- to 属性就是目标位置 --&gt;\n&lt;teleport to=&quot;#teleport-target&quot;&gt;\n    &lt;div v-if=&quot;visible&quot; class=&quot;toast-wrap&quot;&gt;\n        &lt;div class=&quot;toast-msg&quot;&gt;我是一个 Toast 文案&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/teleport&gt;\ncreateRenderer\n通过createRenderer，我们能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台\n我们可以将其生成在canvas画布上\n\n关于createRenderer，我们了解下基本使用，就不展开讲述了\nimport { createRenderer } from &#039;@vue/runtime-core&#039;\n \nconst { render, createApp } = createRenderer({\n  patchProp,\n  insert,\n  remove,\n  createElement,\n  // ...\n})\n \nexport { render, createApp }\n \nexport * from &#039;@vue/runtime-core&#039;\nComposition Api\nComposition Api，也就是组合式 api，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理\n\n关于compositon api的使用，这里以下图展开\n\n简单使用:\nexport default {\n    setup() {\n        const count = ref(0)\n        const double = computed(() =&gt; count.value * 2)\n        function increment() {\n            count.value++\n        }\n        onMounted(() =&gt; console.log(&#039;component mounted!&#039;))\n        return {\n            count,\n            double,\n            increment\n        }\n    }\n}\n三、非兼容变更\nGlobal API\n\n全局 Vue API 已更改为使用应用程序实例\n全局和内部 API 已经被重构为可 tree-shakable\n\n模板指令\n\n组件上 v-model 用法已更改\n&lt;template v-for&gt;和 非 v-for节点上key用法已更改\n在同一元素上使用的 [[v-if 和 v-for 哪个优先级更高| v-if 和 v-for 优先级]]已更改\nv-bind=&quot;object&quot; 现在排序敏感\nv-for 中的 ref 不再注册 ref 数组\n\n组件\n\n只能使用普通函数创建功能组件\nfunctional 属性在单文件组件 (SFC)\n异步组件现在需要 defineAsyncComponent 方法来创建\n\n渲染函数\n\n渲染函数API改变\n$scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露\n自定义指令 API 已更改为与组件生命周期一致\n一些转换 class 被重命名了：\n\nv-enter → v-enter-from\nv-leave → v-leave-from\n\n\n组件 watch 选项和实例方法 $watch不再支持点分隔字符串路径，请改用计算函数作为参数\n在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。VUE3.x 现在使用应用程序容器的 innerHTML。\n\n其他小改变\n\ndestroyed 生命周期选项被重命名为 unmounted\nbeforeDestroy 生命周期选项被重命名为 beforeUnmount\n[prop default工厂函数不再有权访问 this 是上下文\n自定义指令 API 已更改为与组件生命周期一致\ndata 应始终声明为函数\n来自 mixin 的 data 选项现在可简单地合并\nattribute 强制策略已更改\n一些过渡 class 被重命名\n组建 watch 选项和实例方法 $watch不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。\n&lt;template&gt; 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 &lt;template&gt; 元素，而不是渲染其内部内容。\n在Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。\n\n移除 API\n\nkeyCode 支持作为 v-on 的修饰符\n$on，$off和$once 实例方法\n过滤filter\n内联模板 attribute\n$destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。\n\n参考文献\n\nvue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4\ncomposition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue单向数据流的特点、vueX使用方式":{"title":"vue单向数据流的特点、vueX使用方式","links":[],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n数据，获取，修改。\n\n\n官方文档介绍：\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\nVuex 的构成有以下几个部分：\n\nstate : Vuex 的基本数据，用来存储变量。\nmutations : 提交更改数据，同步更新状态。\nactions : 提交 mutations ，可异步操作。\ngetters ：是 store 的计算属性。\nmodules : 模块，每个模块里面有四个属性。\n\n工作流程：\n1.在组件中，用一个 this.$store.dispath 这个方法触发 actions 提交修改数据的操作。\n2.Actions 用 commit 来触发 mutations 来修改数据。\n3.mutations 接收到 commit 的请求，就会自动通过 Mutate 来修改 state 里面的数据，也只有 Mutations 可以操作 state 中的状态数据，状态一改变，组件中就重新渲染。\n4.最后由 store 触发每一个调用它的组件更新。\n可参考下图：\n\n注：图源 Vuex 官网\n\n\n\n\nVuex-单向数据流\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！":{"title":"vue要做权限管理该怎么做！如果控制到按钮级别的权限怎么做！","links":["C-Knowledge/前端/编程基础/网络/JWT","C-Knowledge/前端/编程基础/网络/说说HTTP-常见的状态码有哪些，适用场景！"],"tags":["编程/FE/Vue"],"content":"一、是什么\n权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源\n而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发\n\n页面加载触发\n页面上的按钮点击触发\n\n总的来说，所有的请求发起都触发自前端路由或视图\n所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：\n\n\n路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页\n\n\n视图方面，用户只能看到自己有权浏览的内容和有权操作的控件\n\n\n最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截\n\n\n#二、如何做\n前端权限控制可以分为四个方面：\n\n接口权限\n按钮权限\n菜单权限\n路由权限\n\n接口权限\n接口权限目前一般采用 JWT 的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录\n登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token\naxios.interceptors.request.use(config =&gt; {\n    config.headers[&#039;token&#039;] = cookie.get(&#039;token&#039;)\n    return config\n})\naxios.interceptors.response.use(res=&gt;{},{response}=&gt;{\n    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误\n        router.push(&#039;/login&#039;)\n    }\n})\n路由权限控制\n方案一\n初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验\nconst routerMap = [\n  {\n    path: &#039;/permission&#039;,\n    component: Layout,\n    redirect: &#039;/permission/index&#039;,\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: &#039;permission&#039;,\n      icon: &#039;lock&#039;,\n      roles: [&#039;admin&#039;, &#039;editor&#039;] // you can set roles in root nav\n    },\n    children: [{\n      path: &#039;page&#039;,\n      component: () =&gt; import(&#039;@/views/permission/page&#039;),\n      name: &#039;pagePermission&#039;,\n      meta: {\n        title: &#039;pagePermission&#039;,\n        roles: [&#039;admin&#039;] // or you can only set roles in sub nav\n      }\n    }, {\n      path: &#039;directive&#039;,\n      component: () =&gt; import(&#039;@/views/permission/directive&#039;),\n      name: &#039;directivePermission&#039;,\n      meta: {\n        title: &#039;directivePermission&#039;\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]\n \n这种方式存在以下四种缺点：\n\n加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。\n全局路由守卫里，每次路由跳转都要做权限判断。\n菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n方案二\n初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制\n登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由\nimport router from &#039;./router&#039;\nimport store from &#039;./store&#039;\nimport { Message } from &#039;element-ui&#039;\nimport NProgress from &#039;nprogress&#039; // progress bar\nimport &#039;nprogress/nprogress.css&#039;// progress bar style\nimport { getToken } from &#039;@/utils/auth&#039; // getToken from cookie\n \nNProgress.configure({ showSpinner: false })// NProgress Configuration\n \n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf(&#039;admin&#039;) &gt;= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)\n}\n \nconst whiteList = [&#039;/login&#039;, &#039;/authredirect&#039;]// no redirect whitelist\n \nrouter.beforeEach((to, from, next) =&gt; {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === &#039;/login&#039;) {\n      next({ path: &#039;/&#039; })\n      NProgress.done() // if current page is dashboard will not trigger\tafterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch(&#039;GetUserInfo&#039;).then(res =&gt; { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: [&#039;editor&#039;,&#039;develop&#039;]\n          store.dispatch(&#039;GenerateRoutes&#039;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) =&gt; {\n          store.dispatch(&#039;FedLogOut&#039;).then(() =&gt; {\n            Message.error(err || &#039;Verification failed, please login again&#039;)\n            next({ path: &#039;/&#039; })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: &#039;/401&#039;, replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next(&#039;/login&#039;) // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n \nrouter.afterEach(() =&gt; {\n  NProgress.done() // finish progress bar\n})\n \n按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限\n这种方式也存在了以下的缺点：\n\n全局路由守卫里，每次路由跳转都要做判断\n菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n菜单权限\n菜单权限可以理解成将页面与路由进行解耦\n方案一\n菜单与路由分离，菜单由后端返回\n前端定义路由信息\n{\n    name: &quot;login&quot;,\n    path: &quot;/login&quot;,\n    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)\n}\nname字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n全局路由守卫里做判断\nfunction hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n \n}\n \nRouter.beforeEach(async (to, from, next) =&gt; {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(&quot;GetUserInfo&quot;)\n        await store.dispatch(&#039;updateAccessMenu&#039;)\n        if (to.path === &#039;/login&#039;) {\n          next({ name: &#039;home_index&#039; })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next(&#039;/login&#039;)\n        }\n      }\n    } else {\n      if (to.path === &#039;/login&#039;) {\n        next({ name: &#039;home_index&#039; })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: &#039;/403&#039;,replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next(&#039;/login&#039;)\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n \nRouter.afterEach((to) =&gt; {\n  window.scrollTo(0, 0);\n});\n每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的\n如果根据路由name找不到对应的菜单，就表示用户有没权限访问\n如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载\n这种方式的缺点：\n\n菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用\n全局路由守卫里，每次路由跳转都要做判断\n\n方案二\n菜单和路由都由后端返回\n前端统一定义路由组件\nconst Home = () =&gt; import(&quot;../pages/Home.vue&quot;);\nconst UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};\n后端路由组件返回以下格式\n[\n    {\n        name: &quot;home&quot;,\n        path: &quot;/&quot;,\n        component: &quot;home&quot;\n    },\n    {\n        name: &quot;home&quot;,\n        path: &quot;/userinfo&quot;,\n        component: &quot;userInfo&quot;\n    }\n]\n在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件\n如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理\n这种方法也会存在缺点：\n\n全局路由守卫里，每次路由跳转都要做判断\n前后端的配合要求更高\n\n按钮权限\n方案一\n按钮权限也可以用v-if判断\n但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断\n这种方式就不展开举例了\n方案二\n通过自定义指令进行按钮权限的判断\n首先配置路由\n{\n    path: &#039;/permission&#039;,\n    component: Layout,\n    name: &#039;权限测试&#039;,\n    meta: {\n        btnPermissions: [&#039;admin&#039;, &#039;supper&#039;, &#039;normal&#039;]\n    },\n    //页面需要的权限\n    children: [{\n        path: &#039;supper&#039;,\n        component: _import(&#039;system/supper&#039;),\n        name: &#039;权限测试页&#039;,\n        meta: {\n            btnPermissions: [&#039;admin&#039;, &#039;supper&#039;]\n        } //页面需要的权限\n    },\n    {\n        path: &#039;normal&#039;,\n        component: _import(&#039;system/normal&#039;),\n        name: &#039;权限测试页&#039;,\n        meta: {\n            btnPermissions: [&#039;admin&#039;]\n        } //页面需要的权限\n    }]\n}\n自定义权限鉴定指令\nimport Vue from &#039;vue&#039;\n/**权限指令**/\nconst has = Vue.directive(&#039;has&#039;, {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(&quot;btnPermissions&quot;);\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) &gt; -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n在使用的按钮中只需要引用v-has指令\n&lt;el-button @click=&#039;editClick&#039; type=&quot;primary&quot; v-has&gt;编辑&lt;/el-button&gt;\n小结\n关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n参考文献\n\nmp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw\nsegmentfault.com/a/1190000020887109\njuejin.cn/post/6844903648057622536#heading-6\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】Vue中的-$nextTick-作用及实现原理":{"title":"【延伸问答】Vue中的 $nextTick 作用及实现原理","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对事件循环的理解","C-Knowledge/前端/技术书籍/前端面试之道/20、前端面试之道-Vue-常考进阶知识点"],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \nVue 异步更新DOM，DOM 更新后立即执行。\n\n一、NextTick是什么\n官方对其的定义\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n什么意思呢？\n我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue 将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再 统一进行更新\n举例一下\nHtml结构\n&lt;div id=&quot;app&quot;&gt; {{ message }} &lt;/div&gt;\n构建一个vue实例\nconst vm = new Vue({\n  el: &#039;#app&#039;,\n  data: {\n    message: &#039;原始值&#039;\n  }\n})\n修改message\nthis.message = &#039;修改后的值1&#039;\nthis.message = &#039;修改后的值2&#039;\nthis.message = &#039;修改后的值3&#039;\n这时候想获取页面最新的DOM节点，却发现获取到的是旧值\nconsole.log(vm.$el.textContent) // 原始值\n这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中\n如果我们一直修改相同数据，异步操作队列还会进行去重\n等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新\n为什么要有nextTick\n举个例子\n{{num}}\nfor(let i=0; i&lt;100000; i++){\n    num = i\n}\n如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略\n二、使用场景\n如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()\n\n第一个参数为：回调函数（可以获取最近的DOM结构）\n第二个参数为：执行函数上下文\n\n// 修改数据\nvm.message = &#039;修改后的值&#039;\n// DOM 还没有更新\nconsole.log(vm.$el.textContent) // 原始的值\nVue.nextTick(function () {\n  // DOM 更新了\n  console.log(vm.$el.textContent) // 修改后的值\n})\n组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上\nthis.message = &#039;修改后的值&#039;\nconsole.log(this.$el.textContent) // =&gt; &#039;原始的值&#039;\nthis.$nextTick(function () {\n    console.log(this.$el.textContent) // =&gt; &#039;修改后的值&#039;\n})\n$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情\nthis.message = &#039;修改后的值&#039;\nconsole.log(this.$el.textContent) // =&gt; &#039;原始的值&#039;\nawait this.$nextTick()\nconsole.log(this.$el.textContent) // =&gt; &#039;修改后的值&#039;\n三、实现原理\nnextTick 主要使用了 宏任务和微任务。根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate 如果以上都不行则采用 setTimeout。\nVue 在更新 Dom 时是异步执行的，只要监听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 Dom 操作完成后才调用。\n源码位置：/src/core/util/next-tick.js\ncallbacks也就是异步操作队列\ncallbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次\nexport function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve;\n \n  // cb 回调函数会经统一处理压入 callbacks 数组\n  callbacks.push(() =&gt; {\n    if (cb) {\n      // 给 cb 回调函数执行加上了 try-catch 错误处理\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, &#039;nextTick&#039;);\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n \n  // 执行异步延迟函数 timerFunc\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n \n  // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用\n  if (!cb &amp;&amp; typeof Promise !== &#039;undefined&#039;) {\n    return new Promise(resolve =&gt; {\n      _resolve = resolve;\n    });\n  }\n}\ntimerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：\nPromise.then、MutationObserver、setImmediate、setTimeout\n通过上面任意一种方法，进行降级操作\nexport let isUsingMicroTask = false\nif (typeof Promise !== &#039;undefined&#039; &amp;&amp; isNative(Promise)) {\n  //判断1：是否原生支持Promise\n  const p = Promise.resolve()\n  timerFunc = () =&gt; {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n} else if (!isIE &amp;&amp; typeof MutationObserver !== &#039;undefined&#039; &amp;&amp; (\n  isNative(MutationObserver) ||\n  MutationObserver.toString() === &#039;[object MutationObserverConstructor]&#039;\n)) {\n  //判断2：是否原生支持MutationObserver\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () =&gt; {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n} else if (typeof setImmediate !== &#039;undefined&#039; &amp;&amp; isNative(setImmediate)) {\n  //判断3：是否原生支持setImmediate\n  timerFunc = () =&gt; {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  //判断4：上面都不行，直接用setTimeout\n  timerFunc = () =&gt; {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n无论是微任务还是宏任务，都会放到flushCallbacks使用\n这里将callbacks里面的函数复制一份，同时callbacks置空\n依次执行callbacks里面的函数\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i &lt; copies.length; i++) {\n    copies[i]()\n  }\n}\n小结：\n\n把回调函数放入callbacks等待执行\n将执行函数放到微任务或者宏任务中\n事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调\n\n总结\n因为 Vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新 DOM，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更。\nthis.$nextTick() 方法主要是用在随数据改变而改变的 dom 应用场景中，Vue 中数据和 dom 渲染由于是异步的，所以，要让 Dom 结构随数据改变这样的操作都应该放进 this.$nextTick() 的回调函数中。\n简单的理解，vue.js 中 this.$nextTick() 就是起到了一个等待数据的作用，也就是说，将一些回调延迟，等到 DOM 更新之后再开始执行。\n\n\nNextTick 原理分析\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】created-和-mouted-区别":{"title":"【延伸问答】created 和 mouted 区别","links":[],"tags":["编程/FE/Vue"],"content":"created 生命周期钩子函数会在组件实例被创建之后立即调用，但是此时组件的模板还没有被渲染成 HTML，因此在这个时候不能访问组件中的 DOM 元素。\nmounted 生命周期钩子函数则会在组件的模板被渲染成 HTML 之后调用，这个时候可以访问组件中的 DOM 元素。通常在这个钩子函数中进行异步请求数据、初始化插件、订阅事件等操作。\n总之，created 钩子函数适用于组件初始化时需要进行一些操作，而 mounted 钩子函数适用于需要操作组件的 DOM 元素时。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】this.$set()-的用处及用法":{"title":"【延伸问答】this.$set() 的用处及用法","links":["C-Knowledge/前端/技术书籍/前端面试之道/手写题：set-方法的实现"],"tags":["编程/FE/Vue"],"content":"用处\n由于 Vue2 中的 Object.defineProperty 在实现数据监听上有一些缺陷，this.$set() 就是为了解决这一缺陷而产生的。\n当我们想让一个数据的变化变为响应式时，可以使用 this.$set() 向响应式对象中添加一个属性，来确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)。\n使用场景\n当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，可以使用this.$set()方法。\n用法 ：this.$set( target, key, value )\n\ntarget：需要添加属性的对象。\nkey：需要添加的属性名。\nvalue：需要添加的属性值。\n\n\n\n手写题：set 方法的实现\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/与webpack类似的工具还有哪些！区别！":{"title":"与webpack类似的工具还有哪些！区别！","links":[],"tags":["编程/Webpack"],"content":"一、模块化工具\n模块化是一种处理复杂系统分解为更好的可管理模块的方式\n可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(bundle)\n在前端领域中，并非只有webpack这一款优秀的模块打包工具，还有其他类似的工具，例如Rollup、Parcel、snowpack，以及最近风头无两的Vite\n通过这些模块打包工具，能够提高我们的开发效率，减少开发成本\n这里没有提及gulp、grunt是因为它们只是定义为构建工具，不能类比\nRollup\nRollup 是一款 ES Modules 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多\n现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等\n举个例子：\n// ./src/messages.js\nexport default {\n  hi: &#039;Hey Guys, I am zce~&#039;\n}\n \n// ./src/logger.js\nexport const log = msg =&gt; {\n  console.log(&#039;---------- INFO ----------&#039;)\n  console.log(msg)\n  console.log(&#039;--------------------------&#039;)\n}\n \nexport const error = msg =&gt; {\n  console.error(&#039;---------- ERROR ----------&#039;)\n  console.error(msg)\n  console.error(&#039;---------------------------&#039;)\n}\n \n// ./src/index.js\nimport { log } from &#039;./logger&#039;\nimport messages from &#039;./messages&#039;\nlog(messages.hi)\n然后通过rollup进行打包\n$ npx rollup ./src/index.js --file ./dist/bundle.js\n打包结果如下图\n\n可以看到，代码非常简洁，完成不像webpack那样存在大量引导代码和模块函数\n并且error方法由于没有被使用，输出的结果中并无error方法，可以看到，rollup默认开始Tree-shaking 优化输出结果\n因此，可以看到Rollup的优点：\n\n代码效率更简洁、效率更高\n默认支持 Tree-shaking\n\n但缺点也十分明显，加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup需要使用插件去完成\n综合来看，rollup并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用CommonJs方式导出成员，并且rollup不支持HMR，使开发效率降低\n但是在用于打包JavaScript 库时，rollup比 webpack 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略\nParcel\nParcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序\nParcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。如下所示：\n&lt;!-- ./src/index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Parcel Tutorials&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nmain.js文件通过ES Moudle方法导入其他模块成员\n// ./src/main.js\nimport { log } from &#039;./logger&#039;\nlog(&#039;hello parcel&#039;)\n// ./src/logger.js\nexport const log = msg =&gt; {\n  console.log(&#039;---------- INFO ----------&#039;)\n  console.log(msg)\n}\n运行之后，使用命令打包\nnpx parcel src/index.html\n执行命令后，Parcel不仅打包了应用，同时也启动了一个开发服务器，跟webpack Dev Server一样\n跟webpack类似，也支持模块热替换，但用法更简单\n同时，Parcel有个十分好用的功能：支持自动安装依赖，像webpack开发阶段突然使用安装某个第三方依赖，必然会终止dev server然后安装再启动。而Parcel则免了这繁琐的工作流程\n同时，Parcel能够零配置加载其他类型的资源文件，无须像webpack那样配置对应的loader\n打包命令如下：\nnpx parcel src/index.html\n由于打包过程是多进程同时工作，构建速度会比Webpack 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中\n\n可以感受到，Parcel给开发者一种很大的自由度，只管去实现业务代码，其他事情用Parcel解决\nSnowpack\nSnowpack，是一种闪电般快速的前端构建工具，专为现代Web设计，较复杂的打包工具（如Webpack或Parcel）的替代方案，利用JavaScript的本机模块系统，避免不必要的工作并保持流畅的开发体验\n开发阶段，每次保存单个文件时，Webpack和Parcel都需要重新构建和重新打包应用程序的整个bundle。而Snowpack为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，Snowpack会重新构建该单个文件\n下图给出webpack与snowpack打包区别：\n\n在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新\nVite\nvite ，是一种新型前端构建工具，能够显著提升前端开发体验\n它主要由两部分组成：\n\n一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的模块热更新HMR\n一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源\n\n其作用类似webpack+ webpack-dev-server，其特点如下：\n\n快速的冷启动\n即时的模块热更新\n真正的按需编译\n\nvite会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快\n利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间\n原理图如下所示：\n\n在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高\nwebpack\n相比上述的模块化工具，webpack大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载\n与其他构建工具相比，有如下优势：\n\n智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容\n万物模块：对 js、css、图片等资源文件都支持打包\n开箱即用：HRM、Tree-shaking等功能\n代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间\n插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性\n易于调试：支持 SourceUrls 和 SourceMaps\n快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快\n生态环境好：社区更丰富，出现的问题更容易解决\n\n参考文献\n\nzhuanlan.zhihu.com/p/95684686\ncn.vitejs.dev/guide/\nsegmentfault.com/a/1190000039370642\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty":{"title":"为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty","links":["C-Knowledge/前端/技术书籍/JavaScript教程/属性描述对象","C-Knowledge/前端/技术书籍/前端面试之道/20、前端面试之道-Vue-常考进阶知识点","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数组-API--方法重写","C-Knowledge/前端/技术书籍/ES6-入门教程/Proxy","C-Knowledge/前端/职业规划/前端面试宝典/八股文/动态给vue的data添加一个新的属性时会发生什么！怎样解决！"],"tags":["编程/FE/Vue"],"content":"Object. defineProperty\nvue2.x 就是通过 Object.defineProperty 实现数据劫持，把 data 中绑定的属性全部转换成 getter()/setter()，然后结合订阅发布者模式实现响应式。getter()可以读取数据，收集依赖，setter()可以改写数据，在数据发生改变时发布消息通知订阅者，触发监听回调，更新视图。\n\n响应式函数\n定义一个响应式函数defineReactive\nfunction update() {\n    app.innerText = obj.foo\n}\n \nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n调用 defineReactive，数据发生变化触发 update 方法，实现数据响应式。\nconst obj = {}\ndefineReactive(obj, &#039;foo&#039;, &#039;&#039;)\nsetTimeout(()=&gt;{\n    obj.foo = new Date().toLocaleTimeString()\n},1000)\n在对象存在多个 key 情况下，需要进行遍历。\nfunction observe(obj) {\n    if (typeof obj !== &#039;object&#039; || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key =&gt; {\n        defineReactive(obj, key, obj[key])\n    })\n}\n如果存在嵌套对象的情况，还需要在 defineReactive 中进行递归。\nfunction defineReactive(obj, key, val) {\n    observe(val)\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n当给 key 赋值为对象的时候，还需要在 set 属性中进行递归。\nset(newVal) {\n    if (newVal !== val) {\n        observe(newVal) // 新值是对象的情况\n        notifyUpdate()\n    }\n}\n定义一个响应式函数defineReactive\nObject. defineProperty 的缺陷\n\nObject.defineProperty 不能监控数组下标的变化，导致通过数组下标添加的元素不能实时响应，并且- 数组 API 方法无法监听到。\n\nconst arrData = [1,2,3,4,5];\narrData.forEach((val,index)=&gt;{\n    defineProperty(arrData,index,val)\n})\narrData.push() // no ok\narrData.pop()  // no ok\narrDate[0] = 99 // ok\n\n无法劫持到对象的删除与添加属性操作。\n\nconst obj = {\n    foo: &quot;foo&quot;,\n    bar: &quot;bar&quot;\n}\nobserve(obj)\ndelete obj.foo // no ok\nobj.jar = &#039;xxx&#039; // no ok\n\nObject. defineProperty 只能监听对象的属性，导致需要对每个对象、每个属性都进行遍历，如果属性值也是对象，则需要进行深度遍历，造成性能问题。\n\nVue2 中，增加了 [[【延伸问答】this.$set() 的用处及用法|set]]、delete API，并且对数组 API  方法重写进行一个重写。\n也可以使用 v-if 和 this.$forceUpdate() 进行强制刷新，但不推荐经常使用。\nProxy\n在 Vue3.x 中使用了 Proxy 代替了 Object.defineProperty，因为它是对整个对象进行代理，所以可以监听对象某个属性值的变化，还可以监听对象属性的新增和删除，而且还可以监听数组。\n\n\n                  \n                  注意❗ \n                  \n                \nProxy 不兼容 IE，也没有 polyfill, defineProperty 能支持到 IE 9 。\n\n响应式方法\n定义一个响应式方法 reactive\nfunction reactive(obj) {\n    if (typeof obj !== &#039;object&#039; &amp;&amp; obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return res\n        }\n    })\n    return observed\n}\n测试一下简单数据的操作，发现都能劫持。\nconst state = reactive({\n    foo: &#039;foo&#039;\n})\n// 1.获取\nstate.foo // ok\n// 2.设置已存在属性\nstate.foo = &#039;fooooooo&#039; // ok\n// 3.设置不存在属性\nstate.dong = &#039;dong&#039; // ok\n// 4.删除属性\ndelete state.dong // ok\n再测试嵌套对象情况，这时候发现就不那么 OK 了。\nconst state = reactive({\n    bar: { a: 1 }\n})\n \n// 设置嵌套对象属性\nstate.bar.a = 10 // no ok\n如果要解决，需要在 get 之上再进行一层代理。\nfunction reactive(obj) {\n    if (typeof obj !== &#039;object&#039; &amp;&amp; obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return isObject(res) ? reactive(res) : res\n        },\n    return observed\n}\n总结\nObject. defineProperty  的缺点。\n\n不能监控数组下标的变化\n无法劫持到对象的删除与添加 属性操作。\n只能监听对象的属性 ，需要深度遍历。\n\nVue2 中的兼容处理。\n\n增加了 [[【延伸问答】this.$set() 的用处及用法|set]]、delete API\n对数组 API  方法重写进行一个重写。\n也可以使用 v-if 和 this.$forceUpdate() 进行强制刷新，但不推荐经常使用。\n\n由上可知，Object.defineProperty 与 Proxy 的区别如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObject.definePropertyProxy定义代理对象某个属性代理整个对象对象新增属性❌✅数组新增修改和 length❌✅this指向目标对象指向代理对象兼容性兼容 IE不兼容 IE8 及以下使用上考虑因素多更方便，方法更多（13 种 handler）"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Express.js！它的特点是什么！":{"title":"什么是Express.js！它的特点是什么！","links":[],"tags":["编程/Node/Express"],"content":"Express.js是一个流行的Node.js Web应用程序框架，它建立在Node.js的HTTP模块之上，并提供了一组简洁、灵活和易于使用的API，用于构建Web应用程序和API。\nExpress.js的特点包括\n\n\n简洁而灵活：Express.js提供了一组简单而灵活的API，使开发者能够快速构建Web应用程序。它不会强加太多约束，允许开发者自定义和配置应用程序的行为。\n\n\n路由功能：Express.js支持路由功能，使开发者能够定义不同的URL路径和HTTP方法与相应的处理函数之间的映射关系。这样，开发者可以根据请求的URL和HTTP方法，将请求分发到相应的处理函数上进行处理。\n\n\n中间件（Middleware）：Express.js中的中间件是一个非常强大且重要的概念。中间件是在请求和响应之间执行的函数，它可以修改请求和响应对象、执行某些特定的任务，或者将控制权传递给下一个中间件。中间件使得可以在请求的不同阶段进行预处理和后处理，例如身份验证、日志记录、错误处理等。\n\n\n视图模板：Express.js支持使用模板引擎来生成动态的HTML（或其他格式）视图。开发者可以选择喜欢的模板引擎（如pug、EJS等），并将其与Express.js集成，以便以一种简单和可维护的方式生成视图。\n\n\n大量的第三方中间件和插件：Express.js生态系统非常丰富，有大量的第三方中间件和插件可供选择。这些中间件和插件可以帮助开发者解决许多常见的任务和问题，例如身份验证、会话管理、数据库集成等。\n\n\n响应处理：Express.js提供了方便的API来处理各种类型的响应，包括JSON数据、静态文件、重定向等。\n\n\n总体而言，Express.js是一个轻量级而强大的Web应用程序框架，它将许多常见的Web开发任务封装为易于使用的API，让开发者可以更专注于业务逻辑的实现而不是底层细节。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Git的分支！如何创建和合并分支！":{"title":"什么是Git的分支！如何创建和合并分支！","links":[],"tags":["编程/Git"],"content":"Git的分支是指在代码仓库中独立存在的一个代码版本。 分支可以用来同时进行不同的开发工作，每个分支都有自己的提交历史和修改记录。\n在Git中，创建和合并分支的步骤如下：\n\n\n创建分支：使用git branch命令可以创建一个新的分支。例如，要创建一个名为”feature”的分支，可以运行git branch feature命令。\n\n\n切换分支：使用git checkout命令可以切换到指定的分支。例如，要切换到”feature”分支，可以运行git checkout feature命令。\n\n\n开发和提交：在切换到新分支后，可以在该分支上进行开发工作。添加、修改和删除文件，并使用git add和git commit命令将修改提交到该分支。\n\n\n合并分支：当在新分支上的开发工作完成后，可以将该分支的修改合并到其他分支上。首先，切换到目标分支（例如主分支）：git checkout main。然后，使用git merge命令将新分支的修改合并到目标分支上：git merge feature。\n\n\n解决冲突：在合并分支时，如果目标分支和新分支对同一文件进行了不同的修改，可能会发生冲突。需要手动解决冲突，选择保留哪些修改或进行修改的合并。\n\n\n删除分支：在分支合并完成后，可以使用git branch -d命令删除不再需要的分支。例如，要删除”feature”分支，可以运行git branch -d feature命令。\n\n\n通过创建和合并分支，开发者可以在不影响主分支的情况下进行并行开发和测试，提高团队的工作效率。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Koa.js！它的特点是什么！":{"title":"什么是Koa.js！它的特点是什么！","links":[],"tags":["编程/Node/Koa"],"content":"Koa.js 是一个基于 Node.js 的后端框架，它由 Express.js 的团队创造，旨在提供更简洁、更优雅的编程体验。下面是 Koa.js 的特点：\n\n\n异步流程控制：Koa.js 使用 async/await 来处理异步操作，极大地简化了编写异步代码的过程。通过使用 async 函数和 await 关键字，可以避免回调地狱（Callback Hell）和使用 Promise 链的繁琐和难以理解的代码。\n\n\n中间件：Koa.js 通过中间件（Middleware）来处理请求和响应。中间件是函数，它可以在请求到达路由之前或响应返回给客户端之前修改请求和响应。Koa.js 的中间件系统非常灵活，可以串联多个中间件，并且在需要时可以动态添加或删除中间件，以满足各种场景需求。\n\n\n上下文（Context）对象：Koa.js 提供了一个上下文对象，用于封装原始的 Node.js 请求和响应对象，并提供了更加便捷的 API 来处理请求和响应。上下文对象包含了一些常用的属性和方法，例如请求和响应的头部信息、请求体的解析等。\n\n\n轻量灵活：Koa.js 是一个非常轻量级的框架，核心代码只有几百行。它没有集成过多的功能，而是通过中间件来扩展功能。这使得 Koa.js 非常灵活，可以根据需求选择适用的中间件，并深度定制应用程序的行为。\n\n\n错误处理：Koa.js 提供了一种优雅的方式来处理错误。它使用 try/catch 结构捕获同步和异步代码中的错误，并将错误传递给应用程序中定义的错误处理中间件。这样可以统一处理错误，而不会导致应用程序崩溃。\n\n\n高度可扩展：因为 Koa.js 的核心功能非常简洁，所以可以通过中间件轻松地扩展功能。这意味着可以根据应用程序的需求选择性地添加所需的功能，而不必包含大量不需要的功能。\n\n\n总结起来，Koa.js 是一个基于 Node.js 的轻量级框架，具有异步流程控制、中间件体系、上下文对象等特点。它通过简洁而优雅的代码编写方式，提供了灵活可扩展的方法来开发高性能的后端应用程序。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Vuex！它是用来解决什么问题的！":{"title":"什么是Vuex！它是用来解决什么问题的！","links":[],"tags":["编程/Vuex"],"content":"\nVuex是一个专为Vue.js应用程序开发的状态管理模式。它解决了Vue.js应用程序中的状态管理问题。\n在一个大型的Vue.js应用程序中，组件之间的状态共享和响应式更新是一个常见的需求。而且，随着应用程序复杂性的增加，这些共享状态的管理可能变得困难和混乱。\nVuex通过引入一个集中的状态管理机制，使得应用程序的状态变化可追踪、可预测，并且易于维护。它的核心思想是将状态保存在一个单一的地方（称之为store），并通过mutation（同步的方式）或action（异步的方式）来修改状态。这样，每个组件都可以从store中获取所需的状态，并在状态变化时得到通知。\n通过Vuex，我们可以更好地组织和管理应用程序的数据流，提高开发效率和代码质量。它尤其适用于大型应用程序或多个组件共享状态的情况下。\n总的来说，Vuex帮助我们解决了Vue.js应用程序中状态管理的问题，使得状态的管理和使用更加简单和可预测。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是Webpack-Loader和Plugin的执行顺序！如何控制它们的执行顺序！":{"title":"什么是Webpack Loader和Plugin的执行顺序！如何控制它们的执行顺序！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中，Loader和Plugin的执行顺序是不同的。\nLoader是用于对模块的源代码进行转换和处理的工具。\n它们按照从右到左，从下到上的顺序链式调用。\n也就是说，Loader的执行顺序是从最后一个配置的Loader开始，逐级向前执行。例如，如下所示的Loader配置中，执行顺序是style-loader → css-loader → sass-loader：\nmodule: {\n  rules: [\n    { test: /\\.scss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;] }\n  ]\n}\nPlugin则在整个Webpack构建过程中提供了更广泛的功能。它们可以用于执行范围更广的任务，如资源优化、文件操作、环境变量注入等。Plugin的执行顺序是由Webpack确定的，通常是通过订阅Webpack的生命周期事件来触发不同的插件操作。因此，Plugin的执行顺序是与Webpack的生命周期相关的。\n如果你想明确控制Loader或Plugin的执行顺序，可以使用Webpack的 enforce属性。对于Loader，你可以在配置中使用该属性来指定Loader的执行顺序。在相同的位置中，值越高的enforce属性的Loader将在值较低的Loader之前执行。例如：\nmodule: {\n  rules: [\n    { test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] },\n    { test: /\\.css$/, use: [&quot;style-loader&quot;, { loader: &quot;css-loader&quot;, options: { modules: true } }], enforce: &quot;post&quot; }\n  ]\n}\n对于Plugin，你可以通过配置的顺序来控制执行顺序。Webpack会按照配置中的插件顺序依次调用它们的相应钩子函数。因此，你可以通过调整插件的顺序来控制它们的执行顺序。\n总的来说，通过Loader的链式调用和Plugin的配置顺序，你可以相对灵活地控制它们的执行顺序。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是响应式设计！响应式设计的基本原理是什么！如何做！":{"title":"什么是响应式设计！响应式设计的基本原理是什么！如何做！","links":["开发技术/HTML-and-CSS/媒体查询","C-Knowledge/前端/技术书籍/CSS-新世界/rem-和-vw-单位与移动端适配最佳实践"],"tags":["编程/FE/CSS"],"content":"一、是什么\n响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整\n描述响应式界面最著名的一句话就是“Content is like water”\n大白话便是“如果将屏幕看作容器，那么内容就像水一样”\n响应式网站常见特点：\n\n同时适配PC + 平板 + 手机等\n标签导航在接近手持终端设备时改变为经典的抽屉式导航\n网站的布局会根据视口来调整模块的大小和位置\n\n\n二、实现方式\n响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;\n属性对应如下：\n\nwidth=device-width: 是自适应手机屏幕的尺寸宽度\nmaximum-scale:是缩放比例的最大值\ninital-scale:是缩放的初始化\nuser-scalable:是用户的可以缩放的操作\n\n实现响应式布局的方式有如下：\n\n媒体查询\n百分比\nvw/vh\nrem\n\n媒体查询\nCSS3中的增加了更多的媒体查询，就像if条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表\n使用@Media查询，可以针对不同的媒体类型定义不同的样式，如：\n@media screen and (max-width: 1920px) { ... }\n当视口在375px - 600px之间，设置特定字体大小18px\n@media screen (min-width: 375px) and (max-width: 600px) {\n  body {\n    font-size: 18px;\n  }\n}\n通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片\n比如给小屏幕手机设置@2x 图，为大屏幕手机设置@3x 图，通过媒体查询就能很方便的实现\n\n媒体查询\n\n百分比\n通过百分比单位 ” % ” 来实现响应式的效果\n比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果\nheight、width属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：\n\n子元素的top/left和bottom/right如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度/宽度\n子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。\n子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width\nborder-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度\n\n可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式\nvw/vh\nvw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一\n与百分比布局很相似，在以前文章提过与%的区别，这里就不再展开述说\nrem\n在以前也讲到，rem是相对于根元素html的font-size属性，默认情况下浏览器字体大小为16px，此时1rem = 16px\n可以利用前面提到的媒体查询，针对不同设备分辨率改变font-size的值，如下：\n@media screen and (max-width: 414px) {\n  html {\n    font-size: 18px\n  }\n}\n \n@media screen and (max-width: 375px) {\n  html {\n    font-size: 16px\n  }\n}\n \n@media screen and (max-width: 320px) {\n  html {\n    font-size: 12px\n  }\n}\n为了更准确监听设备可视窗口变化，我们可以在css之前插入script标签，内容如下：\n//动态为根元素设置字体大小\nfunction init () {\n    // 获取屏幕宽度\n    var width = document.documentElement.clientWidth\n    // 设置根元素字体大小。此时为宽的10等分\n    document.documentElement.style.fontSize = width / 10 + &#039;px&#039;\n}\n \n//首次加载应用，设置一次\ninit()\n// 监听手机旋转的事件的时机，重新设置\nwindow.addEventListener(&#039;orientationchange&#039;, init)\n// 监听手机窗口变化，重新设置\nwindow.addEventListener(&#039;resize&#039;, init)\n无论设备可视窗口如何变化，始终设置rem为width的1/10，实现了百分比布局\n除此之外，我们还可以利用主流UI框架，如：element ui、antd提供的栅格布局实现响应式\n\nrem 和 vw 单位与移动端适配最佳实践\n\n小结\n响应式设计实现通常会从以下几方面思考：\n\n弹性盒子（包括图片、表格、视频）和媒体查询等技术\n使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围\n使用相对单位使得内容自适应调节\n选择断点，针对不同断点实现不同布局和内容展示\n\n三、总结\n响应式布局优点可以看到：\n\n面对不同分辨率设备灵活性强\n能够快捷解决多设备显示适应问题\n\n缺点：\n\n仅适用布局、信息、框架并不复杂的部门类型网站\n兼容各种设备工作量大，效率低下\n代码累赘，会出现隐藏无用的元素，加载时间加长\n其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果\n一定程度上改变了网站原有的布局结构，会出现用户混淆的情况\n\n参考文献\n\nbaike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1\njuejin.cn/post/6844904082751111176\nvue3js.cn/interview\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是状态管理！为什么需要状态管理！":{"title":"什么是状态管理！为什么需要状态管理！","links":[],"tags":["编程/FE/Vue"],"content":"在开发过程中，我们会遇到应用程序需要处理各种各样的数据的情况，这些数据需要保存在应用中的某一个位置，对于这些数据的管理我们就称之为状态管理。\n当我们在使用 Vue 进行单页应用开发时，经常会在各个组件间进行数据通信，比较简单的情况下，可以使用 props 和事件进行传递，但当组件逻辑逐渐复杂后，通过 props 和事件就会使数据传输变得比较混乱了。这时需要通过 Vuex 状态管理模式来管理各个模块数据的变化和操作。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路":{"title":"什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路","links":["React-Native","Weex"],"tags":["编程/FE/Vue"],"content":"\n\n                  \n                  提示💡 \n                  \n                \nJavaScript对象，DOM抽象。 避免操作DOM和跨平台。\n\n一、什么是虚拟DOM\n虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex）\n实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上\n在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别\n创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应\n在vue中同样使用到了虚拟DOM技术\n定义真实DOM\n&lt;div id=&quot;app&quot;&gt;\n    &lt;p class=&quot;p&quot;&gt;节点内容&lt;/p&gt;\n    &lt;h3&gt;{{ foo }}&lt;/h3&gt;\n&lt;/div&gt;\n实例化vue\nconst app = new Vue({\n    el:&quot;#app&quot;,\n    data:{\n        foo:&quot;foo&quot;\n    }\n})\n观察render的render，我们能得到虚拟DOM\n(function anonymous(\n) {\n\twith(this){return _c(&#039;div&#039;,{attrs:{&quot;id&quot;:&quot;app&quot;}},[_c(&#039;p&#039;,{staticClass:&quot;p&quot;},\n\t\t\t\t\t  [_v(&quot;节点内容&quot;)]),_v(&quot; &quot;),_c(&#039;h3&#039;,[_v(_s(foo))])])}})\n通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能\n小结\nVirtual DOM（虚拟 DOM） 是对 真实 DOM 的抽象，本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。\nconst vnode = {\n  type: &#039;div&#039;,\n  props: {\n    id: &#039;hello&#039;\n  },\n  children: [\n    /* 更多 vnode */\n  ]\n}\n这里所说的 vnode 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 &lt;div&gt; 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。\n一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为挂载 (mount)。\n如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为更新 (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。\n虚拟 DOM 带来的主要收益是它让开发者能够灵活、声明式地创建、检查和组合所需 UI 的结构，同时只需把具体的 DOM 操作留给渲染器去处理。\n二、为什么需要虚拟DOM\nDOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的\n真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： \n由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验\n举个例子：\n你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程\n当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程\n而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算\n\n\n                  \n                  注意❗ \n                  \n                \n很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI\n\n避免频繁修改真实 DOM\n\n\n                  \n                  技巧💡 \n                  \n                \nJavaScript 代码执行比直接操作 DOM 快，减少对实际 DOM 的操作次数。\n\n首先，我们都知道频繁地操作变动 真实 DOM 会引起浏览器的重绘和回流，这些会大大地消耗浏览器的性能，而在前端性能优化的其中一个方向就是尽可能少地操作 真实 DOM，从而达到提升性能的目的。因为仅仅修改虚拟 DOM 中的内容，不会带来页面的重绘和回流操作。在完成虚拟 DOM 修改后，进行真实 DOM 的修改，才会使页面重绘。因此我们需要这一层抽象，在 patch（绘制） 过程中尽可能地一次性将差异更新到 DOM 中, 这样在一定程度上保证了 DOM 的性能不会很差。\n\n跨平台实现\n最后，也是虚拟 DOM 最初的目的，就是更好的跨平台, 比如 Node. js 就没有 DOM，如果想实现 SSR （服务端渲染），那么一个方式就是借助虚拟 DOM，因为虚拟 DOM 本身是 JavaScript 对象。\n三、如何实现虚拟DOM\n首先可以看看vue中VNode的结构\n源码位置：src/core/vdom/vnode.js\nexport default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array&lt;VNode&gt;;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component&#039;s scope\n  functionalContext: Component | void; // only for functional component root nodes\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n \n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array&lt;VNode&gt;,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions\n  ) {\n    /*当前节点的标签名*/\n    this.tag = tag\n    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/\n    this.data = data\n    /*当前节点的子节点，是一个数组*/\n    this.children = children\n    /*当前节点的文本*/\n    this.text = text\n    /*当前虚拟节点对应的真实dom节点*/\n    this.elm = elm\n    /*当前节点的名字空间*/\n    this.ns = undefined\n    /*编译作用域*/\n    this.context = context\n    /*函数化组件作用域*/\n    this.functionalContext = undefined\n    /*节点的key属性，被当作节点的标志，用以优化*/\n    this.key = data &amp;&amp; data.key\n    /*组件的option选项*/\n    this.componentOptions = componentOptions\n    /*当前节点对应的组件的实例*/\n    this.componentInstance = undefined\n    /*当前节点的父节点*/\n    this.parent = undefined\n    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/\n    this.raw = false\n    /*静态节点标志*/\n    this.isStatic = false\n    /*是否作为跟节点插入*/\n    this.isRootInsert = true\n    /*是否为注释节点*/\n    this.isComment = false\n    /*是否为克隆节点*/\n    this.isCloned = false\n    /*是否有v-once指令*/\n    this.isOnce = false\n  }\n \n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next github.com/answershuto/learnVue*/\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n这里对VNode进行稍微的说明：\n\n所有对象的 context 选项都指向了 Vue 实例\nelm 属性则指向了其相对应的真实 DOM 节点\n\nvue是通过createElement生成VNode\n源码位置：src/core/vdom/create-element.js\nexport function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode | Array&lt;VNode&gt; {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断\nexport function _createElement(\n    context: Component,\n    tag?: string | Class&lt;Component&gt; | Function | Object,\n    data?: VNodeData,\n    children?: any,\n    normalizationType?: number\n): VNode | Array&lt;VNode&gt; {\n    if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) {\n        process.env.NODE_ENV !== &#039;production&#039; &amp;&amp; warn(\n            `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n            &#039;Always create fresh vnode data objects in each render!&#039;,\n            context`\n        )\n        return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) &amp;&amp; isDef(data.is)) {\n        tag = data.is\n    }\n    if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode()\n    }\n    ... \n    // support single function children as default scoped slot\n    if (Array.isArray(children) &amp;&amp;\n        typeof children[0] === &#039;function&#039;\n    ) {\n        data = data || {}\n        data.scopedSlots = { default: children[0] }\n        children.length = 0\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children)\n    } else if ( === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children)\n    }\n\t// 创建VNode\n    ...\n}\n可以看到_createElement接收5个参数：\n\ncontext 表示 VNode 的上下文环境，是 Component 类型\ntag 表示标签，它可以是一个字符串，也可以是一个 Component\ndata 表示 VNode 的数据，它是一个 VNodeData 类型\nchildren 表示当前 VNode的子节点，它是任意类型的\nnormalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的\n\n根据normalizationType 的类型，children会有不同的定义\nif (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n} else if ( === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n}\nsimpleNormalizeChildren方法调用场景是 render 函数是编译生成的\nnormalizeChildren方法调用场景分为下面两种：\n\nrender 函数是用户手写的\n编译 slot、v-for 的时候会产生嵌套数组\n\n无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了\n规范化children的源码位置在：src/core/vdom/helpers/normalzie-children.js\n在规范化children后，就去创建VNode\nlet vnode, ns\n// 对tag进行判断\nif (typeof tag === &#039;string&#039;) {\n  let Ctor\n  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)\n  if (config.isReservedTag(tag)) {\n    // 如果是内置的节点，则直接创建一个普通VNode\n    vnode = new VNode(\n      config.parsePlatformTagName(tag), data, children,\n      undefined, undefined, context\n    )\n  } else if (isDef(Ctor = resolveAsset(context.$options, &#039;components&#039;, tag))) {\n    // component\n    // 如果是component类型，则会通过createComponent创建VNode节点\n    vnode = createComponent(Ctor, data, context, children, tag)\n  } else {\n    vnode = new VNode(\n      tag, data, children,\n      undefined, undefined, context\n    )\n  }\n} else {\n  // direct component options / constructor\n  vnode = createComponent(tag, data, context, children)\n}\ncreateComponent同样是创建VNode\n源码位置：src/core/vdom/create-component.js\nexport function createComponent (\n  Ctor: Class&lt;Component&gt; | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array&lt;VNode&gt;,\n  tag?: string\n): VNode | Array&lt;VNode&gt; | void {\n  if (isUndef(Ctor)) {\n    return\n  }\n // 构建子类构造函数 \n  const baseCtor = context.$options._base\n \n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor)\n  }\n \n  // if at this stage it&#039;s not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== &#039;function&#039;) {\n    if (process.env.NODE_ENV !== &#039;production&#039;) {\n      warn(`Invalid Component definition: ${String(Ctor)}`, context)\n    }\n    return\n  }\n \n  // async component\n  let asyncFactory\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)\n    if (Ctor === undefined) {\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n \n  data = data || {}\n \n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor)\n \n  // transform component v-model data into props &amp; events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data)\n  }\n \n  // extract props\n  const propsData = extractPropsFromVNodeData(data, Ctor, tag)\n \n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n \n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  const listeners = data.on\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn\n \n  if (isTrue(Ctor.options.abstract)) {\n    const slot = data.slot\n    data = {}\n    if (slot) {\n      data.slot = slot\n    }\n  }\n \n  // 安装组件钩子函数，把钩子函数合并到data.hook中\n  installComponentHooks(data)\n \n  //实例化一个VNode返回。组件的VNode是没有children的\n  const name = Ctor.options.name || tag\n  const vnode = new VNode(\n    `vue-component-${Ctor.cid}${name ? `-${name}` : &#039;&#039;}`,\n    data, undefined, undefined, undefined, context,\n    { Ctor, propsData, listeners, tag, children },\n    asyncFactory\n  )\n  if (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) {\n    return renderRecyclableComponentTemplate(vnode)\n  }\n \n  return vnode\n}\n稍微提下createComponent生成VNode的三个关键流程：\n\n构造子类构造函数Ctor\ninstallComponentHooks安装组件钩子函数\n实例化 vnode\n\n小结\ncreateElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构。\n参考文献\n\nustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96\njuejin.cn/post/6876711874050818061\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍一下-MVVM-模式，和-MVC-模式有什么区别！":{"title":"介绍一下 MVVM 模式，和 MVC 模式有什么区别！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue实例挂载的过程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的"],"tags":["编程/FE/Vue"],"content":"MVVM\nMVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型。\n\n模型（Model）指的是后端传递的数据。\n视图（View）指的是所看到的页面。\n视图模型（ViewModel）是 MVVM 模式的核心，它是连接 View 和 Model 的桥梁（自动处理）。\n\n视图模型有两个方向的作用：\n\n将模型（Model）转化成视图（View），即将后端传递的数据转化成所看到的页面，实现的方式是：数据绑定。\n将视图（View）转化成模型（Model），即将所看到的页面转化成后端的数据，实现的方式是：DOM 事件监听。\n\n当这两个方向的数据转换都实现时，我们称之为数据的双向绑定。\nMVVM模型图解：\n\nVue 实现：\nMVC\nMVC 是 Model-View-Controller 的简写，即模型-视图-控制器。\n\nM 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。\nC 即 Controller 指的是页面业务逻辑。\n\n使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信，也就是 View 跟 Model ，必须通过 Controller 来承上启下。\nMVC 模型图解：\n\nMVVM 与 MVC 最大的区别就是：MVVM 实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（双向绑定）。\n总结\n相同点\n\n目的相同：分离模型 Model 和视图 View\n\n不同点\n\n\nMVC\n\n构成：模型 Model - 视图 View - 控制器 Controller\n分为主动 MVC 和 被动 MVC\n\n主动 MVC：视图订阅数据更新\n被动 MVC：控制器操作视图\n\n\n渲染\n\n后端返回 HTML，利于 SEO\n后端返回数据，前端使用模板引擎或操作 DOM\n\n\n\n\n\nMVVM\n\n构成：模型 Model - 视图 View - 视图模型 ViewModel\nViewModel 单向或双向数据绑定 View 和 Model 层，实现自动同步\n渲染\n\n后端减少关心视图，前端 SSR 利于 SEO\n前端减少操作 DOM\n\n\n\n\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解vue的diff算法吗！说说看":{"title":"你了解vue的diff算法吗！说说看","links":[],"tags":["编程/FE/Vue"],"content":"是什么\ndiff 算法是一种对同层 DOM 节点进行比较的高效算法，传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，而改进后的 diff 算法避免了对 DOM 树进行逐层搜索遍历，所以时间复杂度只有 O(n)。diff 算法的在很多场景下都有应用，例如在 Vue 虚拟 DOM 渲染成真实 DOM 的新旧虚拟 DOM 节点比较更新时，就用到了该算法。\ndiff 算法特点：\n\n不会跨层级比较，只会在同层级进行比较。\n在 diff 比较的过程中，循环从两边向中间比较。\n\n\n\n                  \n                  注意❗ \n                  \n                \n\nKey 和标签名一致就为同一节点。\n能交换就尽量不删除和新增。\n\n\n比较方式\ndiff 整体策略为：深度优先，同层比较。\n基本原理\ndiff 算法的基本原理有以下几点：\n\n对于同层级节点首先对比新旧节点的头尾，头与头、尾与尾分别进行对比，寻找未移动的节点。\n新旧节点头尾对比完后，然后进行头与尾、尾与头的交叉对比，这一步的目的是寻找可复用的节点。\n在交叉对比结束后，因为有可能还有可复用的节点，所以创建一个老节点 keyToIndex 的哈希表 map 记录 key，然后继续遍历新节点索引通过 key 查找可以复用的旧的节点。\n节点遍历完成后，通过新老索引，移除多余旧节点或者增加新节点。\n\n举例说明\n下面举个vue通过diff算法更新的例子：\n\n比较只会在同层级进行, 不会跨层级比较\n\n\n\n比较的过程中，循环从两边向中间收拢\n\n新旧 VNode 节点如下图所示：\n\n第一次循环后，发现旧节点 D 与新节点 D 相同，直接复用旧节点 D 作为 diff 后的第一个真实节点，同时旧节点 endIndex 移动到 C，新节点的 startIndex 移动到了 C。\n\n第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E。\n\n第三次循环中，发现 E 没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动。\n\n第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B。\n\n第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F。\n\n新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点 F，直接创建 F 节点对应的真实节点放到 B 节点后面。\n\n\n小结\n更新流程\n\nupdateChildren\n\n首尾指针法\n\n\n当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁\n通过isSameVnode进行判断，相同则调用patchVnode方法\npatchVnode做了以下操作：\n\n找到对应的真实dom，称为el\n如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点\n如果oldVnode有子节点而VNode没有，则删除el子节点\n如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el\n如果两者都有子节点，则执行updateChildren函数比较子节点\n\n\nupdateChildren主要做了以下操作：\n\n设置新旧VNode的头尾指针\n新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新节点，从哈希表寻找 key 一致的 VNode 节点再分情况操作。\n\n\n\n\n\n【6分钟彻底掌握vue的diff算法，前端面试不再怕！】 \n【【李发亮】图解 Vue. js Virtual DOM 的 Diff 算法核心】 \n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢":{"title":"你对SPA单页面的理解，它的优缺点分别是什么！如何实现SPA应用呢","links":["C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：SPA","C-Knowledge/前端/技术书籍/JavaScript教程/History-对象","C-Knowledge/前端/职业规划/前端面试宝典/八股文/路由的-hash-模式和-history-模式的区别"],"tags":["编程/FE/Vue"],"content":"一、什么是SPA\nSPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图\n\n我们熟知的JS框架如react,vue,angular,ember都属于SPA\n二、SPA和MPA的区别\n上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图\n\n单页应用与多页应用的区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单页面应用（SPA）多页面应用（MPA）组成一个主页面和多个页面片段多个主页面刷新方式局部刷新整页刷新url模式哈希模式历史模式SEO搜索引擎优化难实现，可使用SSR方式改善容易实现数据传递容易通过url、cookie、localStorage等传递页面切换速度快，用户体验良好切换加载资源，速度慢，用户体验差维护成本相对容易相对复杂\n单页应用优缺点\n优点：\n\n具有桌面应用的即时性、网站的可移植性和可访问性\n用户体验好、快，内容的改变不需要重新加载整个页面\n良好的前后端分离，分工更明确\n\n缺点：\n\n不利于搜索引擎的抓取\n首次渲染速度相对较慢\n\n三、实现一个SPA\n原理\n\n监听地址栏中 hash 变化驱动界面变化\n用pushsate记录浏览器的历史，驱动界面发送变化\n\n\n实现\nhash 模式\n核心通过监听url中的hash来进行路由跳转\n// 定义 Router  \nclass Router {  \n    constructor () {  \n        this.routes = {}; // 存放路由path及callback  \n        this.currentUrl = &#039;&#039;;  \n          \n        // 监听路由change调用相对应的路由回调  \n        window.addEventListener(&#039;load&#039;, this.refresh, false);  \n        window.addEventListener(&#039;hashchange&#039;, this.refresh, false);  \n    }  \n      \n    route(path, callback){  \n        this.routes[path] = callback;  \n    }  \n      \n    push(path) {  \n        this.routes[path] &amp;&amp; this.routes[path]()  \n    }  \n}  \n  \n// 使用 router  \nwindow.miniRouter = new Router();  \nminiRouter.route(&#039;/&#039;, () =&gt; console.log(&#039;page1&#039;))  \nminiRouter.route(&#039;/page2&#039;, () =&gt; console.log(&#039;page2&#039;))  \n  \nminiRouter.push(&#039;/&#039;) // page1  \nminiRouter.push(&#039;/page2&#039;) // page2  \nhistory模式\nhistory 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api\n\nhistory.pushState 浏览器历史纪录添加记录\nhistory.replaceState修改浏览器历史纪录中当前纪录\nhistory.popState 当 history 发生变化时触发\n\n// 定义 Router  \nclass Router {  \n    constructor () {  \n        this.routes = {};  \n        this.listerPopState()  \n    }  \n      \n    init(path) {  \n        history.replaceState({path: path}, null, path);  \n        this.routes[path] &amp;&amp; this.routes[path]();  \n    }  \n      \n    route(path, callback){  \n        this.routes[path] = callback;  \n    }  \n      \n    push(path) {  \n        history.pushState({path: path}, null, path);  \n        this.routes[path] &amp;&amp; this.routes[path]();  \n    }  \n      \n    listerPopState () {  \n        window.addEventListener(&#039;popstate&#039; , e =&gt; {  \n            const path = e.state &amp;&amp; e.state.path;  \n            this.routers[path] &amp;&amp; this.routers[path]()  \n        })  \n    }  \n}  \n  \n// 使用 Router  \n  \nwindow.miniRouter = new Router();  \nminiRouter.route(&#039;/&#039;, ()=&gt; console.log(&#039;page1&#039;))  \nminiRouter.route(&#039;/page2&#039;, ()=&gt; console.log(&#039;page2&#039;))  \n  \n// 跳转  \nminiRouter.push(&#039;/page2&#039;)  // page2  \n四、题外话：如何给SPA做SEO\n下面给出基于Vue的SPA如何实现SEO的三种方式\n\nSSR服务端渲染\n\n将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js\n\n静态化\n\n目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果\n\n使用Phantomjs针对爬虫处理\n\n原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图\n\n参考文献\n\nsegmentfault.com/a/1190000019623624\njuejin.cn/post/6844903512107663368\nwww.cnblogs.com/constantince/p/5586851.html\n\n\n\n路由的 hash 模式和 history 模式的区别\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6新增Set、Map两种数据结构的！":{"title":"你是怎么理解ES6新增Set、Map两种数据结构的！","links":["D-Unsorted/数组去重","C-Knowledge/前端/职业规划/前端面试宝典/八股文/GC-垃圾回收机制及内存管理","D-Unsorted/部署私有属性","D-Unsorted/缓存","C-Knowledge/前端/技术书籍/ES6-入门教程/Set-和-Map-数据结构"],"tags":["编程/ES6"],"content":"如果要用一句来描述，我们可以说\nSet是一种叫做集合的数据结构，Map是一种叫做字典的数据结构\n什么是集合？什么又是字典？\n\n集合 ：是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合\n字典 ：是一些元素的集合。每个元素有一个称作 key 的域，不同元素的 key 各不相同\n\n区别？\n\n共同点：集合、字典都可以存储不重复的值\n不同点：集合是以==[值，值]的形式存储元素，字典是以[键，值]==的形式存储\n\n一、Set\nSet是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合\nSet本身是一个构造函数，用来生成 Set 数据结构\nconst s = new Set();\n增删改查\nSet的实例关于增删改查的方法：\n\nadd()\ndelete()\nhas()\nclear()\n\nadd()\n添加某个值，返回 Set 结构本身\n当添加实例中已经存在的元素，set不会进行处理添加\ns.add(1).add(2).add(2); // 2只被添加了一次\ndelete()\n删除某个值，返回一个布尔值，表示删除是否成功\ns.delete(1)\nhas()\n返回一个布尔值，判断该值是否为Set的成员\ns.has(2)\nclear()\n清除所有成员，没有返回值\ns.clear()\n遍历\nSet实例遍历的方法有如下：\n关于遍历的方法，有如下：\n\nkeys()：返回键名的遍历器\nvalues()：返回键值的遍历器\nentries()：返回键值对的遍历器\nforEach()：使用回调函数遍历每个成员\n\nSet的遍历顺序就是插入顺序\nkeys方法、values方法、entries方法返回的都是遍历器对象\nlet set = new Set([&#039;red&#039;, &#039;green&#039;, &#039;blue&#039;]);\n \nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n \nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n \nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [&quot;red&quot;, &quot;red&quot;]\n// [&quot;green&quot;, &quot;green&quot;]\n// [&quot;blue&quot;, &quot;blue&quot;]\nforEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this\nlet set = new Set([1, 4, 9]);\nset.forEach((value, key) =&gt; console.log(key + &#039; : &#039; + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n\n扩展运算符和 Set 结构相结合实现 数组或字符串去重\n// 数组\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)]; // [3, 5, 2]\n \n// 字符串\nlet str = &quot;352255&quot;;\nlet unique = [...new Set(str)].join(&quot;&quot;); // &quot;352&quot;\n实现并集、交集、和差集\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n \n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n \n// 交集\nlet intersect = new Set([...a].filter(x =&gt; b.has(x)));\n// set {2, 3}\n \n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x =&gt; !b.has(x)));\n// Set {1}\n二、Map\nMap类型是键值对的有序列表，而键和值都可以是任意类型\nMap本身是一个构造函数，用来生成 Map 数据结构\nconst m = new Map()\n增删改查\nMap 结构的实例针对增删改查有以下属性和操作方法：\n\nsize 属性\nset()\nget()\nhas()\ndelete()\nclear()\n\nsize\nsize属性返回 Map 结构的成员总数。\nconst map = new Map();\nmap.set(&#039;foo&#039;, true);\nmap.set(&#039;bar&#039;, false);\n \nmap.size // 2\nset()\n设置键名key对应的键值为value，然后返回整个 Map 结构\n如果key已经有值，则键值会被更新，否则就新生成该键\n同时返回的是当前Map对象，可采用链式写法\nconst m = new Map();\n \nm.set(&#039;edition&#039;, 6)        // 键是字符串\nm.set(262, &#039;standard&#039;)     // 键是数值\nm.set(undefined, &#039;nah&#039;)    // 键是 undefined\nm.set(1, &#039;a&#039;).set(2, &#039;b&#039;).set(3, &#039;c&#039;) // 链式操作\nget()\nget方法读取key对应的键值，如果找不到key，返回undefined\nconst m = new Map();\n \nconst hello = function() {console.log(&#039;hello&#039;);};\nm.set(hello, &#039;Hello ES6!&#039;) // 键是函数\n \nm.get(hello)  // Hello ES6!\nhas()\nhas方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\nconst m = new Map();\n \nm.set(&#039;edition&#039;, 6);\nm.set(262, &#039;standard&#039;);\nm.set(undefined, &#039;nah&#039;);\n \nm.has(&#039;edition&#039;)     // true\nm.has(&#039;years&#039;)       // false\nm.has(262)           // true\nm.has(undefined)     // true\ndelete()\ndelete方法删除某个键，返回true。如果删除失败，返回false\nconst m = new Map();\nm.set(undefined, &#039;nah&#039;);\nm.has(undefined)     // true\n \nm.delete(undefined)\nm.has(undefined)       // false\nclear()\nclear方法清除所有成员，没有返回值\nlet map = new Map();\nmap.set(&#039;foo&#039;, true);\nmap.set(&#039;bar&#039;, false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n\n遍历\nMap结构原生提供三个遍历器生成函数和一个遍历方法：\n\nkeys()：返回键名的遍历器\nvalues()：返回键值的遍历器\nentries()：返回所有成员的遍历器\nforEach()：遍历 Map 的所有成员\n\n遍历顺序就是插入顺序\nconst map = new Map([\n  [&#039;F&#039;, &#039;no&#039;],\n  [&#039;T&#039;,  &#039;yes&#039;],\n]);\n \nfor (let key of map.keys()) {\n  console.log(key);\n}\n// &quot;F&quot;\n// &quot;T&quot;\n \nfor (let value of map.values()) {\n  console.log(value);\n}\n// &quot;no&quot;\n// &quot;yes&quot;\n \nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n \n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n \n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n \nmap.forEach(function(value, key, map) {\n  console.log(&quot;Key: %s, Value: %s&quot;, key, value);\n});\n三、WeakSet 和 WeakMap\nWeakSet\n创建WeakSet实例\nconst ws = new WeakSet();\n\nWeakSet可以接受一个具有 Iterable接口的对象作为参数\nconst a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n在API中WeakSet与Set有两个区别：\n\n没有遍历操作的API\n没有size属性\n\nWeakSet只能成员只能是引用类型，而不能是其他类型的值\nlet ws=new WeakSet();\n \n// 成员不是引用类型\nlet weakSet=new WeakSet([2,3]);\nconsole.log(weakSet) // 报错\n \n// 成员为引用类型\nlet obj1={name:1}\nlet obj2={name:1}\nlet ws=new WeakSet([obj1,obj2]); \nconsole.log(ws) //WeakSet {{…}, {…}}\nWeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失\nWeakMap\nWeakMap结构与Map结构类似，也是用于生成键值对的集合\n在API中WeakMap与Map有两个区别：\n\n没有遍历操作的API\n没有clear清空方法\n\n// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n \n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([[k1, &#039;foo&#039;], [k2, &#039;bar&#039;]]);\nwm2.get(k2) // &quot;bar&quot;\nWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\nmap.set(null, 2)\n// TypeError: Invalid value used as weak map key\nWeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用\n举个场景例子：\n在网页的 DOM 元素上添加数据，就可以使用WeakMap结构，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除\nconst wm = new WeakMap();\n \nconst element = document.getElementById(&#039;example&#039;);\n \nwm.set(element, &#039;some information&#039;);\nwm.get(element) // &quot;some information&quot;\n\n\n                  \n                  注意❗ \n                  \n                \n注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用\n\n下面代码中，键值obj会在WeakMap产生新的引用，当你修改obj不会影响到内部\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n \nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n总结\nSet\nES 6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nWeakSet\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n\nWeakSet 的成员只能是对象和 Symbol 值，而不能是其他类型的值。\nWeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\nMap\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。为了解决这个问题，ES 6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，==各种类型的值（包括对象）都可以当作键==。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\nWeakMap\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。WeakMap 与 Map 的区别有两点。\n\nWeakMap 只接受对象（==null 除外==）和 Symbol 值作为键名，不接受其他类型的值作为键名。\n其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\nWeakMap 就是为了解决忘记删除引用而导致内存泄露的问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\nWeakMap 的用途：\n\nWeakMap 应用的典型场合就是 DOM 节点作为键名。\nWeakMap 的另一个用处是部署私有属性。\n\nWeakRef\nWeakSet 和 WeakMap 是基于弱引用的数据结构，ES2021 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。\n弱引用对象的一大用处，就是作为 缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。\n参考文献\n\nes6.ruanyifeng.com/#docs/set-map\n\n\n\nSet 和 Map 数据结构\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/你有写过自定义指令吗！自定义指令的应用场景有哪些！":{"title":"你有写过自定义指令吗！自定义指令的应用场景有哪些！","links":[],"tags":["编程/FE/Vue"],"content":"一、什么是指令\n开始之前我们先学习一下指令系统这个词\n指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力\n在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统\n我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能\n除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令\n指令使用的几种方式：\n//会实例化一个指令，但这个指令没有参数 \n`v-xxx`\n \n// -- 将值传到指令中\n`v-xxx=&quot;value&quot;`  \n \n// -- 将字符串传入到指令中，如`v-html=&quot;&#039;&lt;p&gt;内容&lt;/p&gt;&#039;&quot;`\n`v-xxx=&quot;&#039;string&#039;&quot;` \n \n// -- 传参数（`arg`），如`v-bind:class=&quot;className&quot;`\n`v-xxx:arg=&quot;value&quot;` \n \n// -- 使用修饰符（`modifier`）\n`v-xxx:arg.modifier=&quot;value&quot;` \n二、如何实现\n注册一个自定义指令有全局注册与局部注册\n全局注册主要是通过Vue.directive方法进行注册\nVue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数\n// 注册一个全局自定义指令 `v-focus`\nVue.directive(&#039;focus&#039;, {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能\n  }\n})\n局部注册通过在组件options选项中设置directive属性\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能\n    }\n  }\n}\n然后你可以在模板中任何元素上使用新的 v-focus property，如下：\n&lt;input v-focus /&gt;\n自定义指令也像组件那样存在钩子函数：\n\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\ninserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用\nunbind：只调用一次，指令与元素解绑时调用\n\n所有的钩子函数的参数都有以下：\n\nel：指令所绑定的元素，可以用来直接操作 DOM\nbinding：一个对象，包含以下 property：\n\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }\n\n\nvnode：Vue 编译生成的虚拟节点\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用\n\n\n\n                  \n                  注意❗ \n                  \n                \n除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行\n\n举个例子：\n&lt;div v-demo=&quot;{ color: &#039;white&#039;, text: &#039;hello!&#039; }&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\n    Vue.directive(&#039;demo&#039;, function (el, binding) {\n    console.log(binding.value.color) // &quot;white&quot;\n    console.log(binding.value.text)  // &quot;hello!&quot;\n    })\n&lt;/script&gt;\n三、应用场景\n使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：\n\n表单防止重复提交\n图片懒加载\n一键 Copy的功能\n\n表单防止重复提交\n表单防止重复提交这种情况设置一个v-throttle自定义指令来实现\n举个例子：\n// 1.设置v-throttle自定义指令\nVue.directive(&#039;throttle&#039;, {\n  bind: (el, binding) =&gt; {\n    let throttleTime = binding.value; // 节流时间\n    if (!throttleTime) { // 用户若不设置节流时间，则默认2s\n      throttleTime = 2000;\n    }\n    let cbFun;\n    el.addEventListener(&#039;click&#039;, event =&gt; {\n      if (!cbFun) { // 第一次执行\n        cbFun = setTimeout(() =&gt; {\n          cbFun = null;\n        }, throttleTime);\n      } else {\n        event &amp;&amp; event.stopImmediatePropagation();\n      }\n    }, true);\n  },\n});\n// 2.为button标签设置v-throttle自定义指令\n&lt;button @click=&quot;sayHello&quot; v-throttle&gt;提交&lt;/button&gt;\n图片懒加载\n设置一个v-lazy自定义指令完成图片懒加载\nconst LazyLoad = {\n    // install方法\n    install(Vue,options){\n    \t  // 代替图片的loading图\n        let defaultSrc = options.default;\n        Vue.directive(&#039;lazy&#039;,{\n            bind(el,binding){\n                LazyLoad.init(el,binding.value,defaultSrc);\n            },\n            inserted(el){\n                // 兼容处理\n                if(&#039;IntersectionObserver&#039; in window){\n                    LazyLoad.observe(el);\n                }else{\n                    LazyLoad.listenerScroll(el);\n                }\n                \n            },\n        })\n    },\n    // 初始化\n    init(el,val,def){\n        // data-src 储存真实src\n        el.setAttribute(&#039;data-src&#039;,val);\n        // 设置src为loading图\n        el.setAttribute(&#039;src&#039;,def);\n    },\n    // 利用IntersectionObserver监听el\n    observe(el){\n        let io = new IntersectionObserver(entries =&gt; {\n            let realSrc = el.dataset.src;\n            if(entries[0].isIntersecting){\n                if(realSrc){\n                    el.src = realSrc;\n                    el.removeAttribute(&#039;data-src&#039;);\n                }\n            }\n        });\n        io.observe(el);\n    },\n    // 监听scroll事件\n    listenerScroll(el){\n        let handler = LazyLoad.throttle(LazyLoad.load,300);\n        LazyLoad.load(el);\n        window.addEventListener(&#039;scroll&#039;,() =&gt; {\n            handler(el);\n        });\n    },\n    // 加载真实图片\n    load(el){\n        let windowHeight = document.documentElement.clientHeight\n        let elTop = el.getBoundingClientRect().top;\n        let elBtm = el.getBoundingClientRect().bottom;\n        let realSrc = el.dataset.src;\n        if(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0){\n            if(realSrc){\n                el.src = realSrc;\n                el.removeAttribute(&#039;data-src&#039;);\n            }\n        }\n    },\n    // 节流\n    throttle(fn,delay){\n        let timer; \n        let prevTime;\n        return function(...args){\n            let currTime = Date.now();\n            let context = this;\n            if(!prevTime) prevTime = currTime;\n            clearTimeout(timer);\n            \n            if(currTime - prevTime &gt; delay){\n                prevTime = currTime;\n                fn.apply(context,args);\n                clearTimeout(timer);\n                return;\n            }\n \n            timer = setTimeout(function(){\n                prevTime = Date.now();\n                timer = null;\n                fn.apply(context,args);\n            },delay);\n        }\n    }\n \n}\nexport default LazyLoad;\n一键 Copy的功能\nimport { Message } from &#039;ant-design-vue&#039;;\n \nconst vCopy = { //\n  /*\n    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置\n    el: 作用的 dom 对象\n    value: 传给指令的值，也就是我们要 copy 的值\n  */\n  bind(el, { value }) {\n    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到\n    el.handler = () =&gt; {\n      if (!el.$value) {\n      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意\n        Message.warning(&#039;无复制内容&#039;);\n        return;\n      }\n      // 动态创建 textarea 标签\n      const textarea = document.createElement(&#039;textarea&#039;);\n      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域\n      textarea.readOnly = &#039;readonly&#039;;\n      textarea.style.position = &#039;absolute&#039;;\n      textarea.style.left = &#039;-9999px&#039;;\n      // 将要 copy 的值赋给 textarea 标签的 value 属性\n      textarea.value = el.$value;\n      // 将 textarea 插入到 body 中\n      document.body.appendChild(textarea);\n      // 选中值并复制\n      textarea.select();\n      // textarea.setSelectionRange(0, textarea.value.length);\n      const result = document.execCommand(&#039;Copy&#039;);\n      if (result) {\n        Message.success(&#039;复制成功&#039;);\n      }\n      document.body.removeChild(textarea);\n    };\n    // 绑定点击事件，就是所谓的一键 copy 啦\n    el.addEventListener(&#039;click&#039;, el.handler);\n  },\n  // 当传进来的值更新的时候触发\n  componentUpdated(el, { value }) {\n    el.$value = value;\n  },\n  // 指令与元素解绑的时候，移除事件绑定\n  unbind(el) {\n    el.removeEventListener(&#039;click&#039;, el.handler);\n  },\n};\n \nexport default vCopy;\n关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景\n参考文献\n\nvue3js.cn/docs/zh\njuejin.cn/post/6844904197448531975#heading-5\nwww.cnblogs.com/chenwenhao/p/11924161.html#_label2\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/你知道vue中key的原理吗！说说你对它的理解":{"title":"你知道vue中key的原理吗！说说你对它的理解","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/你了解vue的diff算法吗！说说看"],"tags":["编程/FE/Vue"],"content":"一、Key是什么\n开始之前，我们先还原两个实际工作场景\n\n当我们在使用v-for时，需要给单元加上key\n\n&lt;ul&gt;\n    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;\n&lt;/ul&gt;\n\n用+new Date()生成的时间戳作为key，手动强制触发重新渲染\n\n&lt;Comp :key=&quot;+new Date()&quot; /&gt;\n那么这背后的逻辑是什么，key的作用又是什么？\n一句话来讲\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n场景背后的逻辑\n当我们在使用v-for时，需要给单元加上key\n\n如果不用 key，Vue 会采用 就地复地原则：最小化 element 的移动，并且会尝试尽最大程度在同适当的地方对相同类型的 element，做 patch 或者 reuse。\n如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed\n\n用+new Date()生成的时间戳作为key，手动强制触发重新渲染\n\n当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染\n\n二、设置key与不设置key区别\n举个例子：\n创建一个实例，2秒后往items数组插入数据\n&lt;body&gt;\n  &lt;div id=&quot;demo&quot;&gt;\n    &lt;p v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;{{item}}&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // 创建实例\n    const app = new Vue({\n      el: &#039;#demo&#039;,\n      data: { items: [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;] },\n      mounted () {\n        setTimeout(() =&gt; { \n          this.items.splice(2, 0, &#039;f&#039;)  // \n       }, 2000);\n     },\n   });\n  &lt;/script&gt;\n&lt;/body&gt;\n在不使用key的情况，vue会进行这样的操作：\n\n分析下整体流程：\n\n比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作\n比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作\n比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作\n循环结束，将E插入到DOM中\n\n一共发生了3次更新，1次插入操作\n在使用key的情况：vue会进行这样的操作：\n\n比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C，F，不相同类型的节点\n\n比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作\n\n\n比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作\n循环结束，将F插入到C之前\n\n一共发生了0次更新，1次插入操作\n通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率\n设置 key 值一定能提高 diff 效率吗？\n其实不然，文档中也明确表示\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素\n\n这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出\n==建议尽可能在使用 v-for 时提供 key==，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升\n三、原理分析\n源码位置：core/vdom/patch.js\n这里判断是否为同一个key，首先判断的是key值是否相等如果没有设置key，那么key为undefined，这时候undefined是恒等于undefined\nfunction sameVnode (a, b) {\n    return (\n        a.key === b.key &amp;&amp; (\n            (\n                a.tag === b.tag &amp;&amp;\n                a.isComment === b.isComment &amp;&amp;\n                isDef(a.data) === isDef(b.data) &amp;&amp;\n                sameInputType(a, b)\n            ) || (\n                isTrue(a.isAsyncPlaceholder) &amp;&amp;\n                a.asyncFactory === b.asyncFactory &amp;&amp;\n                isUndef(b.asyncFactory.error)\n            )\n        )\n    )\n}\nupdateChildren方法中会对新旧vnode进行diff，然后将比对出的结果用来更新真实的DOM\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    ...\n    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n            ...\n        } else if (isUndef(oldEndVnode)) {\n            ...\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            ...\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            ...\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n            ...\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n            ...\n        } else {\n            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n            idxInOld = isDef(newStartVnode.key)\n                ? oldKeyToIdx[newStartVnode.key]\n                : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n            if (isUndef(idxInOld)) { // New element\n                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n            } else {\n                vnodeToMove = oldCh[idxInOld]\n                if (sameVnode(vnodeToMove, newStartVnode)) {\n                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n                    oldCh[idxInOld] = undefined\n                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n                } else {\n                    // same key but different element. treat as new element\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n                }\n            }\n            newStartVnode = newCh[++newStartIdx]\n        }\n    }\n    ...\n}\n总结\n\n为了性能优化\n\n因为 Vue 底层是虚拟 DOM，更新 DOM 时用 diff 算法对新旧节点进行一一对比，找到可以复用的节点，减少操作真实 DOM 的次数。\n在更新数据渲染列表时，如果数据的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据的顺序，而是采用“就地复用”策略，简单地复用此处的每个元素。因此通过为每个节点设置一个 key 值，来以便 Vue 判断节点是否可以复用，从而高效的实现更新渲染虚拟 DOM。\n\n确保正确的组件状态\n\n在使用带有状态的组件（如表单、动画等）时，如果不使用 key，可能会出现状态错乱的问题。使用 key 可以确保 Vue 对每个节点都能够正确地保存组件状态。\n参考文献\n\njuejin.cn/post/6844903826693029895\njuejin.cn/post/6844903985397104648\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用Canvas绘制一个矩形，并填充它的背景色。":{"title":"使用Canvas绘制一个矩形，并填充它的背景色。","links":[],"tags":["编程/Canvas"],"content":"使用Canvas绘制一个矩形并填充背景色，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n绘制矩形，并设置其背景色：\n\nctx.fillStyle = &#039;red&#039;; // 设置填充色，可以使用CSS颜色值\nctx.fillRect(50, 50, 100, 100); // 绘制矩形，参数为矩形的起始点坐标和宽高\n完整的示例代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Canvas绘制矩形&lt;/title&gt;\n  &lt;style&gt;\n    canvas {\n      border: 1px solid black;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    const canvas = document.getElementById(&#039;myCanvas&#039;);\n    const ctx = canvas.getContext(&#039;2d&#039;);\n    ctx.fillStyle = &#039;red&#039;;\n    ctx.fillRect(50, 50, 100, 100);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n运行这段代码，将在Canvas区域内绘制一个红色的矩形，起始点坐标为(50, 50)，宽高为100x100。你可以根据需要调整矩形的位置和大小，以及填充色的值。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/兄弟组件通信":{"title":"兄弟组件通信","links":[],"tags":["编程/FE/Vue"],"content":"借用父组件\n方法1：借用父组件实现平行组件间通信，子组件1先调用 emit 方法将参数传给父组件，父组件再通过 props 传递给子组件2。\n\n总线 Bus\n方法2：用事件总线 Bus 传值，父组件引入子组件，子组件需要传值的用 Bus.emit()，接收方用 Bus.on()。\n//父组件\n&lt;template&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;ChildOne /&gt;\n        &lt;ChildTwo /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport ChildOne from &quot;./ChildOne&quot;;\nimport ChildTwo from &quot;./ChildTwo&quot;\nexport default {\n    name :&quot;Father&quot;,\n    components: { ChildOne, ChildTwo }\n};\n&lt;template&gt;\n    &lt;div class=&quot;childOne&quot;&gt;\n    &lt;h1&gt;我是子组件1&lt;/h1&gt;\n        &lt;button @click=&quot;changeTwo&quot;&gt;点击我改变子组件2的值&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nimport Bus from &quot;@/bus/bus&quot;\nexport default {\n    name:&quot;ChildOne&quot;,\n    methods:{\n        changeTwo(){\n            Bus.$emit(&quot;changeName&quot;,&quot;参数（选填）&quot;)\n        }   \n    }  \n}\n&lt;/script&gt;\n&lt;template&gt;\n    &lt;div class=&quot;childTwo&quot;&gt;\n        &lt;h1&gt;我是子组件2&lt;/h1&gt;\n        &lt;p&gt;{{name}}&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nimport Bus from &quot;@/bus/bus&quot;\nexport default {\n    name:&quot;childTwo&quot;,\n    data(){\n        return {\n            name: &quot;zhangsan&quot;,\n        };\n    },\n    mounted(){\n        Bus.$on(&quot;changeName&quot;，(data) =&gt; { this.name = data });\n    }\n&lt;/script&gt;"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/八股文":{"title":"八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTML-八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/CSS-八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript-八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/网络八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/音视频八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Canvas-八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/TypeScript八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Babel八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Git八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/NodeJS八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/算法与数据结构八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/设计模式八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/操作系统八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/安全八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/开放题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/图形学八股文","C-Knowledge/前端/技术书籍/Web前端面试官系列/Web前端面试官系列"],"tags":["场景/面试"],"content":"前端基础\n\nHTML 八股文\nCSS 八股文\nJavaScript 八股文\n网络八股文\n音视频八股文\nCanvas 八股文\nTypeScript八股文\n浏览器八股文\n\n框架\n\nVue八股文\nReact八股文\n小程序八股文\nuni-app八股文\n\n工程化\n\nWebpack八股文\nVite八股文\nBabel八股文\n\n工具\n\nGit八股文\n\n服务端\n\nNodeJS八股文\n\n计算机基础\n\n算法与数据结构八股文\n设计模式八股文\n操作系统八股文\n\n其他\n\n安全八股文\n开放题\n图形学八股文\n\n扩展阅读\n\n中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)\n(中篇)中高级前端大厂面试秘籍，寒冬中为您保驾护航，直通大厂\n(下篇)中高级前端大厂面试秘籍，寒冬中为您保驾护航，直通大厂\nWeb前端面试官系列\nVue、React 框架，项目高频经典面试题\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/动态给vue的data添加一个新的属性时会发生什么！怎样解决！":{"title":"动态给vue的data添加一个新的属性时会发生什么！怎样解决！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/【延伸问答】this.$set()-的用处及用法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么-Vue3-用-proxy-代替了-Vue2-中的-Object.defineProperty"],"tags":["编程/FE/Vue"],"content":"一、直接添加属性的问题\n我们从一个例子开始\n定义一个p标签，通过v-for指令进行遍历\n然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行\n&lt;p v-for=&quot;(value,key) in item&quot; :key=&quot;key&quot;&gt;\n    {{ value }}\n&lt;/p&gt;\n&lt;button @click=&quot;addProperty&quot;&gt;动态添加新属性&lt;/button&gt;\n实例化一个vue实例，定义data属性和methods方法\nconst app = new Vue({\n    el:&quot;#app&quot;,\n   \tdata:()=&gt;{\n       \titem:{\n            oldProperty:&quot;旧属性&quot;\n        }\n    },\n    methods:{\n        addProperty(){\n            this.items.newProperty = &quot;新属性&quot;  // 为items添加新属性\n            console.log(this.items)  // 输出带有newProperty的items\n        }\n    }\n})\n点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新\n二、原理分析\n为什么产生上面的情况呢？\n下面来分析一下\nvue2是用过Object.defineProperty实现数据响应式\nconst obj = {}\nObject.defineProperty(obj, &#039;foo&#039;, {\n        get() {\n            console.log(`get foo:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                console.log(`set foo:${newVal}`);\n                val = newVal\n            }\n        }\n    })\n}\n当我们访问foo属性或者设置foo值的时候都能够触发setter与getter\nobj.foo   \nobj.foo = &#039;new&#039;\n但是我们为obj添加新属性的时候，却无法触发事件属性的拦截\nobj.bar  = &#039;新属性&#039;\n\n原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据\n三、解决方案\nVue 不允许在已经创建的实例上动态添加新的响应式属性\n若想实现数据与视图同步更新，可采取下面三种解决方案：\n\nVue.set()\nObject.assign()\n$forcecUpdated()\n\nVue.set()\nVue.set( target, propertyName/index, value )\n参数\n\n{Object | Array} target\n{string | number} propertyName/index\n{any} value\n\n返回值：设置的值\n通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新\n关于Vue.set源码（省略了很多与本节不相关的代码）\n源码位置：src\\core\\observer\\index.js\nfunction set (target: Array&lt;any&gt; | Object, key: any, val: any): any {\n  ...\n  defineReactive(ob.value, key, val)\n  ob.dep.notify()\n  return val\n}\n这里无非再次调用defineReactive方法，实现新增属性的响应式\n关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截\n大致代码如下：\nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                console.log(`set ${key}:${newVal}`);\n                val = newVal\n            }\n        }\n    })\n}\n\n为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty\n\nObject.assign()\n直接使用Object.assign()添加到对象的新属性不会触发更新\n应创建一个新的对象，合并原对象和混入对象的属性\nthis.someObject = Object.assign({},this.someObject,{newProperty1:1,newProperty2:2 ...})\n$forceUpdate\n如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事\n$forceUpdate迫使Vue 实例重新渲染\n\n\n                  \n                  注意❗ \n                  \n                \nPS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n小结\n\n如果为对象添加少量的新属性，可以直接采用Vue.set()\n如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象\n如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)\n\n\n\n                  \n                  注意❗ \n                  \n                \nPS：vue3 是用过 proxy 实现数据响应式的，直接动态添加新属性仍可以实现数据响应式\n\n参考文献\n\ncn.vuejs.org/v2/api/#Vue-set\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/图形学八股文":{"title":"图形学八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/渲染管线的流程！","C-Knowledge/前端/开发技术/JavaScript/beam"],"tags":["编程/图形学"],"content":"\n渲染管线的流程！\nbeam\n\n\n\n收集的图形学面试问题小结资料\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）！它们有什么区别！":{"title":"在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）！它们有什么区别！","links":[],"tags":["编程/Webpack"],"content":"代码分离（code splitting）和懒加载（lazy loading）是Webpack中用于优化资源加载的两种技术。\n\n\n                  \n                  代码分离 \n                  \n                \n代码分离是将打包生成的代码文件拆分成多个较小的文件，而不是将所有代码打包到一个文件中。\n\n这样做的好处是可以提高初始加载速度，并减小每个页面的加载所需的数据量。通过代码分离，只需在需要时加载特定模块，提高了页面的响应速度和用户体验。\n懒加载是指在需要时才加载某个模块，而不是在初始加载时就将所有代码一次性加载完毕。通过懒加载，可以将页面分成多个模块，并根据需要动态地加载模块。这可以减少初始加载时间，只加载目前需要的模块，在用户与页面进行交互时再根据需要进行加载，提高了页面的性能和加载速度。\n两者的区别在于：\n\n代码分离是将代码文件拆分成较小的文件，其中每个文件可能包含多个模块。这样做可以在初始加载时减少数据量，但仍然需要一次性加载所需的文件。\n懒加载是将页面分成多个模块，在需要时才去加载相应的模块。这样做可以进一步减小初始加载时间，只加载当前可见的模块，随着用户与页面交互，再按需加载其他模块。\n\n在Webpack中，可以通过配置和使用动态导入（Dynamic Imports）来实现代码分离和懒加载。这样可以根据需要将模块进行分割，并在需要时动态加载模块。通过代码分离和懒加载，可以提高页面的性能和加载速度，避免一次性加载过多的资源文件，从而提升用户体验。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，什么是环境变量（Environment-Variables）！如何在配置中使用它们！":{"title":"在Webpack中，什么是环境变量（Environment Variables）！如何在配置中使用它们！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中，环境变量（Environment Variables）是指在构建过程中可供访问的全局变量。这些变量可以在Webpack配置中使用，根据不同的环境来执行不同的操作，例如，在开发环境和生产环境下使用不同的配置。\n在Webpack中，使用环境变量有以下几个步骤：\n\n设置环境变量：首先，需要在项目的构建环境中设置环境变量。如在Unix或者Linux系统中，可以使用export命令设置环境变量，如：\n\nexport NODE_ENV=development\n\n配置Webpack：在Webpack配置文件中，可以使用process.env来访问全局环境变量。例如，可以根据NODE_ENV变量的值来判断当前是开发环境还是生产环境，可以使用以下代码来配置不同的变量：\n\nmodule.exports = {\n  // ...\n  devtool: process.env.NODE_ENV === &#039;production&#039; ? &#039;source-map&#039; : &#039;eval&#039;,\n  // ...\n};\n在上述示例中，根据NODE_ENV的值是否为production，选择不同的devtool选项。\n\n使用环境变量：在Webpack配置文件中，可以使用环境变量来配置不同的插件、加载器或其他的配置。例如，可以使用DefinePlugin插件来定义环境变量并在代码中使用。在Webpack配置文件中添加如下代码来配置DefinePlugin插件：\n\nconst webpack = require(&#039;webpack&#039;);\n \nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.DefinePlugin({\n      &#039;process.env.NODE_ENV&#039;: JSON.stringify(process.env.NODE_ENV || &#039;development&#039;)\n    })\n  ],\n  // ...\n};\n上述示例中，我们使用DefinePlugin插件来定义process.env.NODE_ENV变量，并将其值设置为当前环境变量的值，如果环境变量未设置，则默认为development。\n这样，在代码中可以使用process.env.NODE_ENV来访问当前环境变量的值，例如：\nif (process.env.NODE_ENV === &#039;development&#039;) {\n  // do something in development mode\n} else {\n  // do something in production mode\n}\n使用上述方法，你可以轻松地在Webpack配置中使用环境变量来根据不同的环境做出相应的配置。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/在Webpack中，如何使用Babel来转译和处理JavaScript文件！":{"title":"在Webpack中，如何使用Babel来转译和处理JavaScript文件！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中使用Babel来转译和处理JavaScript文件非常简单。你只需要按照以下步骤进行配置：\n\n首先，安装必要的依赖：\n\nnpm install babel-loader @babel/core @babel/preset-env --save-dev\n\n在Webpack配置文件中，添加一个配置项来处理JavaScript文件。这可以是一个简单的对象或一个数组，具体取决于你的配置需求。\n\n如果你只有一个入口文件，可以使用对象配置：\nmodule.exports = {\n  entry: &#039;./src/index.js&#039;,\n  output: {\n    filename: &#039;bundle.js&#039;,\n    path: path.resolve(__dirname, &#039;dist&#039;)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: &#039;babel-loader&#039;,\n          options: {\n            presets: [&#039;@babel/preset-env&#039;]\n          }\n        }\n      }\n    ]\n  }\n};\n如果你有多个入口文件，可以使用数组配置：\nmodule.exports = {\n  entry: {\n    app: [&#039;./src/index.js&#039;, &#039;./src/other.js&#039;],\n  },\n  output: {\n    filename: &#039;[name].bundle.js&#039;,\n    path: path.resolve(__dirname, &#039;dist&#039;)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: &#039;babel-loader&#039;,\n          options: {\n            presets: [&#039;@babel/preset-env&#039;]\n          }\n        }\n      }\n    ]\n  }\n};\n这样配置后，Webpack会将所有以.js结尾的文件传递给Babel加载器（babel-loader）进行处理，并使用@babel/preset-env预设来转译ES6+代码为ES5语法。\n\n在你的项目根目录下创建一个.babelrc文件，并添加如下配置：\n\n{\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n这样就完成了Babel在Webpack中的基本配置。当你运行Webpack时，所有的JavaScript文件都会经过Babel进行转译和处理。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/在实际开发中，Canvas会有哪些坑，如何解决！":{"title":"在实际开发中，Canvas会有哪些坑，如何解决！","links":[],"tags":["编程/Canvas"],"content":"\n在实际开发中，使用Canvas可能会遇到一些常见的坑，以下是其中几个以及对应的解决方法：\n\n\n\n渲染性能问题：由于Canvas是直接操作像素的，过多的绘图操作或复杂的绘图计算可能导致性能问题，尤其是在移动设备上。解决方法包括优化绘图逻辑，减少绘图调用次数，避免不必要的重绘，使用合适的数据结构和算法等。\n\n\n图像质量问题：在Canvas中绘制图像时，如果图像的尺寸与Canvas的尺寸不匹配，或者进行了缩放操作，可能会导致图像失真或模糊。解决方法是使用image-rendering CSS属性来控制图像的渲染质量，或者使用高分辨率图像并结合devicePixelRatio进行缩放。\n\n\n坐标系统问题：Canvas的坐标系统与普通的坐标系略有不同，原点位于左上角，水平向右增长，垂直向下增长。这与一些常见的坐标系统（如数学中的笛卡尔坐标系）不同，可能导致混淆和计算错误。解决方法是熟悉Canvas的坐标系统，并使用坐标转换函数（如translate和transform）进行必要的转换。\n\n\n高分辨率屏幕适配问题：在高分辨率屏幕上显示Canvas时，可能出现模糊或缩小的情况。解决方法是使用window.devicePixelRatio获取设备像素比，然后将Canvas的实际尺寸乘以设备像素比以适应高分辨率屏幕。\n\n\n线条模糊问题：在Canvas中绘制细线时，可能会出现线条模糊的情况。这是因为Canvas默认将线条的中心点分布在像素上，导致线条在像素间模糊。解决方法是使用context.lineWidth设置线条宽度为奇数（如1、3、5），并将坐标调整为半个像素的位置。\n\n\n跨域问题：在使用Canvas绘制图像时，如果图像源位于不同的域名或子域名，可能会遇到跨域问题。解决方法之一是在服务器端进行跨域资源共享（CORS）设置，允许Canvas访问来自其他域名的图像资源。\n\n\n\n以上是一些常见的Canvas坑和对应的解决方法，实际开发中还可能遇到其他问题。 重要的是理解Canvas的工作原理，熟悉Canvas API，并不断积累经验以解决问题并优化性能。\n\n以上问题涉及了Canvas的基本知识和使用方法，涵盖了绘制基本形状、文本、图像以及使用渐变和合成操作等方面。日常开发中请注意积累。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/大文件上传如何做断点续传！":{"title":"大文件上传如何做断点续传！","links":[],"tags":["编程/JavaScript"],"content":"一、是什么\n不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂\n文件上传简单，文件变大就复杂\n上传大文件时，以下几个变量会影响我们的用户体验\n\n服务器处理数据的能力\n请求超时\n网络波动\n\n上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等\n为了解决上述问题，我们需要对大文件上传单独处理\n这里涉及到分片上传及断点续传两个概念\n分片上传\n分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传\n如下图\n\n上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件\n大致流程如下：\n\n将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；\n初始化一个分片上传任务，返回本次分片上传唯一标识；\n按照一定的策略（串行或并行）发送各个分片数据块；\n发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件\n\n断点续传\n断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分\n每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度\n一般实现方式有两种：\n\n服务器端返回，告知从哪开始\n浏览器端自行处理\n\n上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可\n如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可\n二、实现思路\n整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕\n\n下面的内容都是伪代码\n读取文件内容：\nconst input = document.querySelector(&#039;input&#039;);\ninput.addEventListener(&#039;change&#039;, function() {\n    var file = this.files[0];\n});\n可以使用md5实现文件的唯一性\nconst md5code = md5(file);\n然后开始对文件进行分割\nvar reader = new FileReader();\nreader.readAsArrayBuffer(file);\nreader.addEventListener(&quot;load&quot;, function(e) {\n    //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，\n    var slice = e.target.result.slice(0, 10*1024*1024);\n});\nh5上传一个（一片）\nconst formdata = new FormData();\nformdata.append(&#039;0&#039;, slice);\n//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案\nformdata.append(&#039;filename&#039;, file.filename);\nvar xhr = new XMLHttpRequest();\nxhr.addEventListener(&#039;load&#039;, function() {\n    //xhr.responseText\n});\nxhr.open(&#039;POST&#039;, &#039;&#039;);\nxhr.send(formdata);\nxhr.addEventListener(&#039;progress&#039;, updateProgress);\nxhr.upload.addEventListener(&#039;progress&#039;, updateProgress);\n \nfunction updateProgress(event) {\n    if (event.lengthComputable) {\n        //进度条\n    }\n}\n这里给出常见的图片和视频的文件类型判断\nfunction checkFileType(type, file, back) {\n/**\n* type png jpg mp4 ...\n* file input.change=&gt; this.files[0]\n* back callback(boolean)\n*/\n    var args = arguments;\n    if (args.length != 3) {\n        back(0);\n    }\n    var type = args[0]; // type = &#039;(png|jpg)&#039; , &#039;png&#039;\n    var file = args[1];\n    var back = typeof args[2] == &#039;function&#039; ? args[2] : function() {};\n    if (file.type == &#039;&#039;) {\n        // 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型\n        var imgType = [\n            &#039;ff d8 ff&#039;, //jpg\n            &#039;89 50 4e&#039;, //png\n \n            &#039;0 0 0 14 66 74 79 70 69 73 6F 6D&#039;, //mp4\n            &#039;0 0 0 18 66 74 79 70 33 67 70 35&#039;, //mp4\n            &#039;0 0 0 0 66 74 79 70 33 67 70 35&#039;, //mp4\n            &#039;0 0 0 0 66 74 79 70 4D 53 4E 56&#039;, //mp4\n            &#039;0 0 0 0 66 74 79 70 69 73 6F 6D&#039;, //mp4\n \n            &#039;0 0 0 18 66 74 79 70 6D 70 34 32&#039;, //m4v\n            &#039;0 0 0 0 66 74 79 70 6D 70 34 32&#039;, //m4v\n \n            &#039;0 0 0 14 66 74 79 70 71 74 20 20&#039;, //mov\n            &#039;0 0 0 0 66 74 79 70 71 74 20 20&#039;, //mov\n            &#039;0 0 0 0 6D 6F 6F 76&#039;, //mov\n \n            &#039;4F 67 67 53 0 02&#039;, //ogg\n            &#039;1A 45 DF A3&#039;, //ogg\n \n            &#039;52 49 46 46 x x x x 41 56 49 20&#039;, //avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)\n        ];\n        var typeName = [\n            &#039;jpg&#039;,\n            &#039;png&#039;,\n            &#039;mp4&#039;,\n            &#039;mp4&#039;,\n            &#039;mp4&#039;,\n            &#039;mp4&#039;,\n            &#039;mp4&#039;,\n            &#039;m4v&#039;,\n            &#039;m4v&#039;,\n            &#039;mov&#039;,\n            &#039;mov&#039;,\n            &#039;mov&#039;,\n            &#039;ogg&#039;,\n            &#039;ogg&#039;,\n            &#039;avi&#039;,\n        ];\n        var sliceSize = /png|jpg|jpeg/.test(type) ? 3 : 12;\n        var reader = new FileReader();\n        reader.readAsArrayBuffer(file);\n        reader.addEventListener(&quot;load&quot;, function(e) {\n            var slice = e.target.result.slice(0, sliceSize);\n            reader = null;\n            if (slice &amp;&amp; slice.byteLength == sliceSize) {\n                var view = new Uint8Array(slice);\n                var arr = [];\n                view.forEach(function(v) {\n                    arr.push(v.toString(16));\n                });\n                view = null;\n                var idx = arr.join(&#039; &#039;).indexOf(imgType);\n                if (idx &gt; -1) {\n                    back(typeName[idx]);\n                } else {\n                    arr = arr.map(function(v) {\n                        if (i &gt; 3 &amp;&amp; i &lt; 8) {\n                            return &#039;x&#039;;\n                        }\n                        return v;\n                    });\n                    var idx = arr.join(&#039; &#039;).indexOf(imgType);\n                    if (idx &gt; -1) {\n                        back(typeName[idx]);\n                    } else {\n                        back(false);\n                    }\n \n                }\n            } else {\n                back(false);\n            }\n \n        });\n    } else {\n        var type = file.name.match(/\\.(\\w+)$/)[1];\n        back(type);\n    }\n}\n调用方法如下\ncheckFileType(&#039;(mov|mp4|avi)&#039;,file,function(fileType){\n    // fileType = mp4,\n    // 如果file的类型不在枚举之列，则返回false\n});\n上面上传文件的一步，可以改成：\nformdata.append(&#039;filename&#039;, md5code+&#039;.&#039;+fileType);\n有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断\n后端主要做的内容为：根据前端传给后台的md5值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传\n如果想要暂停切片的上传，可以使用XMLHttpRequest的 abort方法\n三、使用场景\n\n大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度\n网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part\n流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见\n\n小结\n当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如\n\n切片上传失败怎么办\n上传过程中刷新页面怎么办\n如何进行并行上传\n切片什么时候按数量切，什么时候按大小切\n如何结合 Web Worker 处理大文件上传\n如何实现秒传\n\n人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 _\n参考文献\n\nsegmentfault.com/a/1190000009448892\nbaike.baidu.com/\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用Canvas绘制一条直线！":{"title":"如何使用Canvas绘制一条直线！","links":[],"tags":["编程/Canvas"],"content":"使用Canvas绘制一条直线，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n绘制直线：\n\nctx.beginPath(); // 开始新的路径\nctx.moveTo(50, 50); // 移动到起始点的坐标\nctx.lineTo(150, 150); // 绘制到结束点的坐标\nctx.stroke(); // 绘制路径\n完整的示例代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Canvas绘制直线&lt;/title&gt;\n  &lt;style&gt;\n    canvas {\n      border: 1px solid black;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    const canvas = document.getElementById(&#039;myCanvas&#039;);\n    const ctx = canvas.getContext(&#039;2d&#039;);\n    ctx.beginPath();\n    ctx.moveTo(50, 50);\n    ctx.lineTo(150, 150);\n    ctx.stroke();\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n运行这段代码，将在Canvas区域内绘制一条起始点坐标为(50, 50)，结束点坐标为(150, 150)的直线。你可以根据需要调整直线的起始点和结束点的坐标，以实现不同位置和倾斜角度的直线绘制。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何使用Webpack进行代码分析和打包分析（Bundle-Analysis）！":{"title":"如何使用Webpack进行代码分析和打包分析（Bundle Analysis）！","links":[],"tags":["编程/Webpack"],"content":"要使用Webpack进行代码分析和打包分析，可以使用Webpack的插件来实现。以下是一种常用的方法：\n\n安装插件：首先，需要安装webpack-bundle-analyzer插件。使用以下命令进行安装：\n\nnpm install webpack-bundle-analyzer --save-dev\n\n配置Webpack：在Webpack配置文件中，添加webpack-bundle-analyzer插件的配置。例如，可以在plugins节中添加以下代码：\n\nconst BundleAnalyzerPlugin = require(&#039;webpack-bundle-analyzer&#039;).BundleAnalyzerPlugin;\n \nmodule.exports = {\n  // ...\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ],\n  // ...\n};\n\n运行Webpack：运行Webpack命令，构建项目并生成打包分析报告。例如，可以运行以下命令：\n\nwebpack --config webpack.config.js\n\n查看打包分析报告：完成构建后，会在命令行中输出一个URL，通过该URL打开生成的打包分析报告。在浏览器中打开该URL，就可以查看代码分析和打包分析的结果。\n\n通过以上步骤，你可以使用Webpack和webpack-bundle-analyzer来进行代码分析和打包分析。这将帮助你了解项目中的代码结构、模块依赖以及打包文件的大小等信息，以便进一步做性能优化和代码优化。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何创建和部署一个基于Node.js的Web服务器！":{"title":"如何创建和部署一个基于Node.js的Web服务器！","links":[],"tags":["编程/Node"],"content":"要创建和部署一个基于Node.js的Web服务器，您可以按照以下步骤进行操作：\n\n安装Node.js: 首先确保您的计算机上已经安装了Node.js。您可以从Node.js官方网站下载并安装适用于您操作系统的版本。\n创建一个新的项目目录: 在文件系统中创建一个新的目录来存放您的项目文件。\n初始化项目: 在命令行中进入您的项目目录，使用以下命令初始化一个新的Node.js项目：\n\nnpm init\n这将会创建一个package.json文件，其中包含了您的项目的相关配置信息。\n\n安装必要的依赖: 使用Node包管理器（npm）安装您需要的任何依赖包。例如，如果您想要创建一个基于Express.js框架的Web服务器，您可以运行以下命令安装Express.js依赖包：\n\nnpm install express\n\n\n创建服务器文件: 在您的项目目录中创建一个新的JavaScript文件，例如server.js。\n\n\n导入所需的模块: 在server.js文件中，您可以导入所需的模块，例如Express.js模块：\n\n\nconst express = require(&#039;express&#039;);\n\n配置服务器: 使用导入的模块来配置和创建您的Web服务器。以下是一个简单的Express.js服务器的例子：\n\nconst express = require(&#039;express&#039;);\nconst app = express();\n \napp.get(&#039;/&#039;, (req, res) =&gt; {\n  res.send(&#039;Hello World!&#039;);\n});\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server is running on port 3000&#039;);\n});\n在上面的例子中，我们使用Express.js创建了一个简单的服务器，它通过app.get()方法定义了根路径的请求处理函数，并使用app.listen()方法来监听3000端口。\n\n运行服务器: 在命令行中进入您的项目目录，并运行以下命令启动您的服务器：\n\nnode server.js\n您的Web服务器现在应该正在运行，并侦听指定的端口（在这个例子中是3000）。\n\n部署服务器: 要将您的Web服务器部署到生产环境，您需要将您的代码和依赖打包，并将其部署到一个服务器上。这个过程可能因您的部署环境而有所不同，可以使用工具如Docker、Nginx等。\n\n这些步骤只是一个基本的概述，用于帮助您入门。根据您的需求，您可能需要进一步了解关于Node.js和Web服务器的更多概念和技术。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas上绘制文本！":{"title":"如何在Canvas上绘制文本！","links":[],"tags":["编程/Canvas"],"content":"要在Canvas上绘制文本，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n设置文本样式：\n\nctx.font = &#039;24px Arial&#039;; // 设置字体样式和大小\nctx.fillStyle = &#039;red&#039;; // 设置字体颜色\n\n绘制文本：\n\nconst text = &#039;Hello, 阿珊和她的猫!&#039;; // 要绘制的文本\nconst x = 50; // 文本的x坐标\nconst y = 100; // 文本的y坐标\n \nctx.fillText(text, x, y); // 绘制填充文本\n// ctx.strokeText(text, x, y); // 绘制描边文本（可选）\n完整的示例代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Canvas绘制文本&lt;/title&gt;\n  &lt;style&gt;\n    canvas {\n      border: 1px solid black;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    const canvas = document.getElementById(&#039;myCanvas&#039;);\n    const ctx = canvas.getContext(&#039;2d&#039;);\n \n    ctx.font = &#039;24px Arial&#039;;\n    ctx.fillStyle = &#039;red&#039;;\n \n    const text = &#039;Hello, 阿珊和她的猫!&#039;;\n    const x = 50;\n    const y = 100;\n \n    ctx.fillText(text, x, y);\n    // ctx.strokeText(text, x, y);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n运行这段代码，将在Canvas区域内绘制红色的文本 “Hello, 阿珊和她的猫!”，文本的左下角位于 (50, 100) 的位置。你可以根据需要调整文本的内容、位置、字体样式和颜色等参数。使用fillText方法绘制填充文本，使用strokeText方法绘制描边文本（可选）。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas中绘制一个圆！":{"title":"如何在Canvas中绘制一个圆！","links":[],"tags":["编程/Canvas"],"content":"要在Canvas中绘制一个圆，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n绘制圆：\n\nconst centerX = canvas.width / 2; // 圆心的x坐标\nconst centerY = canvas.height / 2; // 圆心的y坐标\nconst radius = 50; // 圆的半径\nconst startAngle = 0; // 圆的起始角度\nconst endAngle = 2 * Math.PI; // 圆的结束角度\n \nctx.beginPath(); // 开始新的路径\nctx.arc(centerX, centerY, radius, startAngle, endAngle); // 绘制圆形路径\nctx.stroke(); // 绘制路径\n完整的示例代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Canvas绘制圆&lt;/title&gt;\n  &lt;style&gt;\n    canvas {\n      border: 1px solid black;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    const canvas = document.getElementById(&#039;myCanvas&#039;);\n    const ctx = canvas.getContext(&#039;2d&#039;);\n    \n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = 50;\n    const startAngle = 0;\n    const endAngle = 2 * Math.PI;\n    \n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, startAngle, endAngle);\n    ctx.stroke();\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n运行这段代码，将在Canvas区域内绘制一个以Canvas中心为圆心，半径为50的圆。你可以根据需要调整圆心坐标和半径的值，以实现不同位置和大小的圆的绘制。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Canvas中绘制图像！":{"title":"如何在Canvas中绘制图像！","links":[],"tags":["编程/Canvas"],"content":"要在Canvas上绘制图像，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n创建一个图像元素：\n\nconst image = new Image();\n\n指定图像的源：\n\nimage.src = &#039;./by.jpg&#039;;\n请将 &#039;path/to/image.jpg&#039; 替换为你要绘制的图像的实际路径。\n\n等待图像加载完成后再进行绘制：\n\nimage.onload = function() {\n  ctx.drawImage(image, x, y, width, height);\n};\n请将 x、y、width 和 height 替换为你希望绘制图像的位置和尺寸。x 和 y 是图像左上角的坐标，width 和 height 是图像的宽度和高度。\n完整的示例代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Canvas绘制图像&lt;/title&gt;\n  &lt;style&gt;\n    canvas {\n      border: 1px solid black;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    const canvas = document.getElementById(&#039;myCanvas&#039;);\n    const ctx = canvas.getContext(&#039;2d&#039;);\n \n    const image = new Image();\n    image.src = &#039;./by.jpg&#039;; // 替换为实际图像的路径\n \n    image.onload = function() {\n      const x = 50; // 图像的x坐标\n      const y = 50; // 图像的y坐标\n      const width = 250; // 图像的宽度\n      const height = 200; // 图像的高度\n \n      ctx.drawImage(image, x, y, width, height);\n    };\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n运行这段代码，将在Canvas上绘制指定图像，并根据设置的位置和尺寸进行缩放和绘制。请确保替换 &#039;./by.jpg&#039; 为你实际使用的图像的路径，并根据需要调整图像的位置和尺寸。你可以通过调整 x、y、width 和 height 的值来控制图像的绘制位置和缩放大小。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中处理表单提交和文件上传！举例说明如何解析表单数据和文件。":{"title":"如何在Express.js中处理表单提交和文件上传！举例说明如何解析表单数据和文件。","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中处理表单提交和文件上传可以使用中间件来处理请求体的解析。对于表单提交，可以使用express.urlencoded()中间件解析以URL编码的请求体，而对于文件上传，则可以使用multer中间件解析和处理文件。\n下面是一个示例，展示了如何在Express.js中处理表单提交和文件上传：\n\n安装所需的依赖：\n\nnpm install express multer\n\n在应用程序中使用中间件来解析表单数据和上传的文件：\n\nconst express = require(&#039;express&#039;);\nconst multer = require(&#039;multer&#039;);\nconst app = express();\n \n// 使用express.urlencoded()中间件解析表单数据\napp.use(express.urlencoded({ extended: false }));\n \n// 使用multer中间件处理文件上传\nconst upload = multer({ dest: &#039;uploads/&#039; });\n \n// 处理表单提交\napp.post(&#039;/form&#039;, (req, res) =&gt; {\n  console.log(req.body); // 解析的表单数据\n  res.send(&#039;Form submitted&#039;);\n});\n \n// 处理文件上传\napp.post(&#039;/upload&#039;, upload.single(&#039;file&#039;), (req, res) =&gt; {\n  console.log(req.file); // 上传的文件信息\n  res.send(&#039;File uploaded&#039;);\n});\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server is running on port 3000&#039;);\n});\n在上述示例中，express.urlencoded()中间件用于解析表单数据，multer中间件用于处理文件上传。upload.single(&#039;file&#039;)表示只处理名为’file’的单个文件上传。解析的表单数据可以通过req.body访问，而上传的文件信息可以通过req.file访问。\n需要注意的是，在示例中上传的文件将保存在指定的目录uploads/下。你可以根据自己的需求和配置修改保存文件的路径和文件名。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中处理请求参数和查询参数！解释一下req和res对象的常用属性和方法。":{"title":"如何在Express.js中处理请求参数和查询参数！解释一下req和res对象的常用属性和方法。","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，请求参数和查询参数都可以通过req对象来访问和处理。req对象代表了客户端发起的HTTP请求，而res对象则代表了服务器对客户端的响应。\n针对请求参数，可以通过req.params属性来访问。它是一个对象，包含了通过路由定义的参数。例如，在定义路由时使用了/users/:id这样的格式，那么可以通过req.params.id来访问id参数的值。\n对于查询参数，可以通过req.query属性来访问。它也是一个对象，包含了客户端在URL中传递的查询参数。例如，对于URL /users?id=1&amp;name=John，可以通过req.query.id和req.query.name来分别获取id和name的值。\n除了请求参数和查询参数，req对象还有一些其他常用属性和方法：\n\nreq.body：如果使用了中间件解析请求体，比如body-parser，则可以通过该属性获取请求体的内容。\nreq.header(field)：获取指定请求头的值。\nreq.cookies：获取所有的客户端发送的Cookie。\nreq.get(field)：获取指定请求头的值，不区分大小写。\nreq.path：获取请求的路径部分。\nreq.method：获取请求的HTTP方法。\n\n而res对象用于构建服务器对客户端的响应，常用的属性和方法包括：\n\nres.send(data)：发送数据给客户端，可以自动根据数据类型选择合适的响应头。\nres.json(data)：以JSON格式发送数据给客户端。\nres.status(code)：设置响应的HTTP状态码。\nres.set(field, value)：设置响应头的值。\nres.cookie(name, value [, options])：设置Cookie。\nres.redirect([status,] path)：进行重定向到指定路径。\n\n这些是req和res对象的一些常用属性和方法，可以根据具体需求查看Express.js的官方文档来获取更详细的信息。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中实现API接口，并且返回JSON格式数据！":{"title":"如何在Express.js中实现API接口，并且返回JSON格式数据！","links":[],"tags":["编程/Node/Express"],"content":"要在Express.js中实现API接口并返回JSON格式数据，可以使用Express的路由功能以及res.json()方法。下面是一个基本的示例，展示了如何创建一个API路由，并返回JSON格式数据：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 定义一个API路由\napp.get(&#039;/api/users&#039;, (req, res) =&gt; {\n  // 假设这是一个从数据库中获取用户数据的逻辑\n  const users = [\n    { id: 1, name: &#039;John&#039; },\n    { id: 2, name: &#039;Jane&#039; },\n    { id: 3, name: &#039;Bob&#039; }\n  ];\n  \n  // 将用户数据以JSON格式发送回客户端\n  res.json(users);\n});\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动，监听端口3000&#039;);\n});\n在上面的例子中，我们创建了一个GET请求的API路由/api/users。在路由处理程序中，我们假设从数据库中获取了用户数据，并将其存储在一个包含用户对象的数组中。\n然后，我们使用res.json()方法将这个数组以JSON格式发送回客户端。\n最后，我们通过调用app.listen()方法启动服务器并监听端口3000。\n当我们访问http://localhost:3000/api/users时，服务器将返回以下JSON数据：\n[\n  { &quot;id&quot;: 1, &quot;name&quot;: &quot;John&quot; },\n  { &quot;id&quot;: 2, &quot;name&quot;: &quot;Jane&quot; },\n  { &quot;id&quot;: 3, &quot;name&quot;: &quot;Bob&quot; }\n]\n使用res.json()的好处是它自动设置正确的Content-Type标头，将响应的主体内容转换为JSON，并发送响应。这样可以简化返回JSON格式数据的过程。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Express.js中实现日志记录(Logging)和调试(Debugging)！":{"title":"如何在Express.js中实现日志记录(Logging)和调试(Debugging)！","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，可以使用中间件来实现日志记录和调试功能。下面是一些常用的方法：\n\n\n使用morgan日志记录中间件：morgan是一个流行的HTTP请求日志记录中间件，可以方便地记录请求的详细信息，例如请求方法、URL、状态码、响应时间等。可以通过以下步骤在Express.js中使用morgan：\n\n首先，安装morgan依赖：npm install morgan\n然后，在你的Express应用程序中引入morgan中间件：const morgan = require(&#039;morgan&#039;)\n将morgan中间件添加到应用程序中间件链中：app.use(morgan(&#039;combined&#039;))\n你可以选择不同的日志格式。combined是一种常用的格式，包含了较为详细的日志信息。你可以根据需要选择其他格式。\n\n\n\n使用debug模块进行调试：debug是另一个常用的调试工具，它可以帮助你在代码中添加调试日志，并根据需要打印出来。可以通过以下步骤在Express.js中使用debug：\n\n首先，安装debug依赖：npm install debug\n然后，在你的应用程序中引入debug模块：const debug = require(&#039;debug&#039;)(&#039;app:debug&#039;)\n将debug语句添加到代码中，例如：debug(&#039;This is a debug message&#039;)\n最后，设置DEBUG环境变量来启用或禁用调试输出。在Windows系统中，可以使用set DEBUG=app:*来启用名为app:*的调试命名空间。在其他系统上，可以使用export DEBUG=app:*。\n\n\n\n使用上述方法，你可以方便地在Express.js应用程序中记录日志和进行调试。morgan提供了灵活的日志格式，并且非常容易集成到Express中间件中。debug模块则提供了简洁的调试语句，帮助你在开发过程中快速识别问题所在。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中回退到之前的提交版本！":{"title":"如何在Git中回退到之前的提交版本！","links":[],"tags":["编程/Git"],"content":"要在Git中回退到之前的提交版本，可以使用Git命令git reset。\n首先，使用以下命令查看提交历史，找到要回退的版本的哈希值：\ngit log\n然后，使用以下命令进行版本回退：\ngit reset &lt;commit-hash&gt;\n将&lt;commit-hash&gt;替换为你想回退到的提交版本的哈希值。\ngit reset命令有不同的选项，常见的有三个：--soft、--mixed和--hard。\n\n使用--soft选项，将会回退到指定提交版本，但保留暂存区和工作目录的修改。你可以重新提交这些修改。\n\ngit reset --soft &lt;commit-hash&gt;\n\n使用--mixed选项，将会回退到指定提交版本，并同时重置暂存区的修改，但保留工作目录的修改。你需要重新将工作目录的修改添加到暂存区后，才能提交这些修改。\n\ngit reset --mixed &lt;commit-hash&gt;\n\n使用--hard选项，将会回退到指定提交版本，并同时重置暂存区和工作目录的修改。这个选项会丢失工作目录中所有未提交的修改，请谨慎使用。\n\ngit reset --hard &lt;commit-hash&gt;\n请注意，回退到之前的提交版本会修改Git仓库的历史记录。如果你的代码已经推送到远程仓库，请确保与其他开发人员协调好操作，以免引起冲突。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中撤销之前的提交！":{"title":"如何在Git中撤销之前的提交！","links":[],"tags":["编程/Git"],"content":"在Git中，可以使用以下方法来撤销之前的提交：\n\n\n撤销最后一次提交：使用git revert命令可以撤销最后一次提交。该命令会创建一个新的提交，将之前提交的修改内容反向应用到代码中。例如，要撤销最后一次提交，可以运行git revert HEAD命令。\n\n\n撤销多个提交：如果需要撤销多个提交，可以使用git revert命令指定要撤销的提交范围。例如，要撤销最后三次提交，可以运行git revert HEAD~3..HEAD命令。\n\n\n撤销特定提交：使用git revert命令可以指定要撤销的具体提交。可以通过提交的哈希值或引用来指定提交。例如，要撤销提交哈希值为abc123的提交，可以运行git revert abc123命令。\n\n\n撤销提交但保留修改：如果只想撤销提交而不删除修改的内容，可以使用git reset命令。该命令会将HEAD指针移动到指定的提交，但不会创建新的提交。例如，要撤销最后一次提交但保留修改，可以运行git reset HEAD~1命令。\n\n\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是，撤销提交会创建新的提交记录，并将修改应用到代码中。这样可以保留修改历史，并且其他开发者可以看到撤销的操作。如果需要完全删除某个提交及其修改，可以使用git reset命令的--hard选项，但这会永久删除提交记录，慎用。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看当前分支的状态！":{"title":"如何在Git中查看当前分支的状态！","links":[],"tags":["编程/Git"],"content":"在Git中，你可以使用git status命令来查看当前分支的状态。执行git status命令后，Git会显示以下几种状态信息：\n\n\nOn branch &lt;branch_name&gt;：这是当前所在的分支名称，可以从此处确认你当前所在的分支。\n\n\nYour branch is up to date with &#039;origin/&lt;branch_name&gt;&#039;：如果你的分支是与远程仓库上的同名分支保持同步的，则会显示该消息，表示当前分支与远程分支是最新的。\n\n\nChanges not staged for commit：这里列出了在工作目录中发生的但未被暂存的更改（已修改但未使用git add命令添加到暂存区）。\n\n\nChanges to be committed：这里列出了已经通过git add命令添加到暂存区的更改（即将被提交的更改）。\n\n\nUntracked files：这里列出了在工作目录中存在但没有被跟踪的文件。\n\n\n除了上述状态信息，git status命令还提供一些建议和操作建议，如提交你的更改、拉取最新的更新、处理冲突等。\n另外，使用git status -s或git status --short命令可以以简洁的方式展示状态信息，更方便快捷地查看当前分支的状态。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看提交历史记录！":{"title":"如何在Git中查看提交历史记录！","links":[],"tags":["编程/Git"],"content":"在Git中，可以使用git log命令来查看提交历史记录。\n执行该命令后，会显示所有的提交记录，包括提交的哈希值、作者、提交日期和提交信息等。\n默认情况下，git log会按照提交时间的倒序显示最新的提交记录在前面。 你也可以使用一些选项来自定义git log的输出格式和范围，例如限制显示的提交数量、按照作者过滤提交记录等。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Git中查看文件的修改差异！":{"title":"如何在Git中查看文件的修改差异！","links":[],"tags":["编程/Git"],"content":"要在 Git 中查看文件的修改差异，您可以使用 diff 命令。 diff 命令将显示您当前分支与另一个分支或一个文件之间的差异。\n以下是使用 diff 命令的一些示例：\n\n查看当前分支与远程分支之间的差异：\n\n$ git diff HEAD origin/master  \n\n查看当前分支与本地分支之间的差异：\n\n$ git diff local branch  \n\n查看某个文件的差异：\n\n$ git diff &lt;file&gt;  \n在上面的示例中，您将看到有关指定文件的所有差异。您可以使用 diff 命令将它们保存到本地仓库中，或将其附加到另一个分支上。\n\n\n                  \n                  注意❗ \n                  \n                \n请注意，diff 命令只会显示您当前分支与另一个分支或一个文件之间的差异。如果您想查看指定文件在当前分支和远程分支之间的差异，则需要使用 git diff 命令。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中处理请求参数和查询参数！解释一下ctx对象的常用属性和方法。":{"title":"如何在Koa.js中处理请求参数和查询参数！解释一下ctx对象的常用属性和方法。","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中，可以通过 ctx.request 对象来获取请求的参数和查询参数。ctx.request 对象是 Koa.js 提供的用于获取请求信息的对象，其中包含了一些常用的属性和方法。\n以下是 ctx.request 对象的常用属性和方法：\n\nctx.request.path：获取当前请求的路径（不包含查询参数）。\nctx.request.query：获取当前请求的查询参数（一个包含所有查询参数的对象）。\nctx.request.querystring：获取当前请求的查询参数字符串。\n\n举个例子，假设我们处理的是一个 POST 请求，请求的路径是 /users，并且请求的参数是一个 JSON 对象，包含用户的姓名和年龄。我们可以通过 ctx.request.body 来获取这些参数：\nrouter.post(&#039;/users&#039;, (ctx) =&gt; {\n  const { name, age } = ctx.request.body;\n \n  // 对获取到的参数进行处理\n  // ...\n \n  ctx.body = &#039;User created!&#039;;\n});\n另外，ctx 对象还有一些常用的属性和方法，可以用于获取和设置响应状态、设置响应头、获取请求方法等等。以下列出一些常用的 ctx 对象的属性和方法：\n\nctx.status：获取或设置响应的状态码。\nctx.headers：获取请求的头部信息。\nctx.method：获取请求的方法（GET、POST等）。\nctx.params：获取命名路由参数的值。\nctx.redirect(url)：重定向到指定的 URL。\nctx.throw(status, [message], [properties])：抛出一个 HTTP 异常，并设置响应的状态码、消息和属性。\n\n这些属性和方法可以在路由的处理函数中使用，用于获取和设置请求和响应的相关信息。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中实现API接口，并且返回JSON格式数据！":{"title":"如何在Koa.js中实现API接口，并且返回JSON格式数据！","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中实现API接口并返回JSON格式数据非常简单。以下是一个示例：\n首先，安装koa-bodyparser中间件，用于解析请求体中的JSON数据：\nnpm install koa-bodyparser\n然后，创建一个新的Koa实例并使用koa-bodyparser中间件：\nconst Koa = require(&#039;koa&#039;);\nconst bodyParser = require(&#039;koa-bodyparser&#039;);\n \nconst app = new Koa();\napp.use(bodyParser());\n接下来，编写路由处理程序来处理API请求并返回JSON格式的响应。例如：\nconst Router = require(&#039;koa-router&#039;);\n \nconst router = new Router();\n \nrouter.get(&#039;/api/users&#039;, ctx =&gt; {\n  const users = [\n    { id: 1, name: &#039;Alice&#039; },\n    { id: 2, name: &#039;Bob&#039; },\n    { id: 3, name: &#039;Charlie&#039; }\n  ];\n  ctx.body = users; // 将用户数组作为JSON响应返回\n});\n \nrouter.post(&#039;/api/users&#039;, ctx =&gt; {\n  const user = ctx.request.body; // 获取请求体中的用户数据\n  // 保存用户数据到数据库或执行其他操作\n  ctx.body = { message: &#039;User created successfully&#039; }; // 返回JSON响应\n});\n \napp.use(router.routes());\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server started on port 3000&#039;);\n});\n上述示例中，当访问/api/users GET路由时，服务器将返回包含用户数组的JSON响应。当访问/api/users POST路由时，服务器将从请求体中获取用户数据，并返回一个包含成功消息的JSON响应。\n通过这种方式，你可以很容易地编写API接口并返回JSON格式的数据。你可以定义更多的路由和处理程序来满足你的API需求，并使用适当的状态码和数据结构来构建响应。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Koa.js中实现日志记录(Logging)和调试(Debugging)！":{"title":"如何在Koa.js中实现日志记录(Logging)和调试(Debugging)！","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中，可以使用各种工具和中间件来实现日志记录和调试。下面是一些常见的方法：\n\n使用koa-logger中间件：koa-logger是一个常用的中间件，可以方便地记录请求和响应的日志。它会将日志信息打印到控制台上。在应用程序中使用koa-logger中间件只需简单的安装和配置即可，以下是一个示例：\n\nconst Koa = require(&#039;koa&#039;);\nconst logger = require(&#039;koa-logger&#039;);\n \nconst app = new Koa();\n \napp.use(logger());\n \n// ...其他中间件和路由\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server running on http://localhost:3000&#039;);\n});\n\n使用自定义的中间件进行日志记录：如果需要更多自定义选项来控制日志的格式和输出位置，可以编写自己的中间件进行日志记录。以下是一个示例：\n\nfunction logger(ctx, next) {\n  const start = Date.now();\n \n  return next().then(() =&gt; {\n\tconst ms = Date.now() - start;\n\tconsole.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n  });\n}\n \napp.use(logger);\n \n// ...其他中间件和路由\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server running on http://localhost:3000&#039;);\n});\n在这个例子中，我们使用了一个自定义中间件来记录每个请求的响应时间。\n\n使用调试工具：除了日志记录，您还可以使用调试工具进行调试。例如，您可以使用koa-helmet中间件来增加安全头，使用koa-bodyparser中间件来解析请求正文，使用koa-route中间件来处理路由等。通过使用这些中间件，您可以更好地监视和控制应用程序的行为。\n\nconst Koa = require(&#039;koa&#039;);\nconst helmet = require(&#039;koa-helmet&#039;);\nconst bodyParser = require(&#039;koa-bodyparser&#039;);\nconst route = require(&#039;koa-route&#039;);\n \nconst app = new Koa();\n \napp.use(helmet());\napp.use(bodyParser());\n \napp.use(route.get(&#039;/api/users&#039;, (ctx) =&gt; {\n  // 处理API请求\n}));\n \n// ...其他中间件和路由\n \napp.listen(3000, () =&gt; {\n  console.log(&#039;Server running on http://localhost:3000&#039;);\n});\n这些是在Koa.js中实现日志记录和调试的一些常见方法。您可以根据您的需求选择适合的方法来记录日志和进行调试。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中使用ES6+的语法和新特性，例如ES-Modules、Async-and-Await等！":{"title":"如何在Webpack中使用ES6+的语法和新特性，例如ES Modules、Async&Await等！","links":[],"tags":["编程/Webpack"],"content":"要在Webpack中使用ES6+的语法和新特性，你需要进行以下配置：\n\n安装依赖：首先确保你的项目中已经安装了Babel相关的依赖，包括@babel/core、@babel/preset-env和babel-loader。你可以使用以下命令安装它们：\n\nnpm install --save-dev @babel/core @babel/preset-env babel-loader\n\n配置Webpack：在Webpack的配置文件中，添加一个规则来处理JavaScript文件。在这个规则中，将babel-loader应用于所有以.js为扩展名的文件。你还需要指定@babel/preset-env作为Babel的预设：\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: &#039;babel-loader&#039;,\n          options: {\n            presets: [&#039;@babel/preset-env&#039;]\n          }\n        }\n      }\n    ]\n  }\n};\n\n配置Babel：在项目的根目录下创建一个名为.babelrc的文件，并在其中指定Babel的配置。你可以使用以下配置来启用ES Modules和Async/Await的支持：\n\n{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      {\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      }\n    ]\n  ]\n}\n上述配置中的useBuiltIns选项将根据代码中使用的特性自动导入必要的Polyfill，corejs选项指定所使用的Core.js版本。\n完成上述配置后，Webpack将使用Babel来转译你的JavaScript代码，使其兼容目标环境。你就可以在Webpack中使用ES6+的语法和新特性了。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件！":{"title":"如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件！","links":[],"tags":["编程/Webpack"],"content":"Webpack提供了各种加载器（Loader）来处理不同类型的资源文件。下面是处理图片、CSS和字体文件的示例：\n1. 图片文件\n\n安装 file-loader 或 url-loader：npm install file-loader 或 npm install url-loader\n在Webpack配置文件中配置加载器：\n\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: [\n        {\n          loader: &#039;file-loader&#039;,\n          options: {\n            name: &#039;[name].[hash].[ext]&#039;, // 文件指纹配置\n            outputPath: &#039;images/&#039;, // 输出目录\n          }\n        }\n      ]\n    }\n  ]\n}\n以上配置将处理以 .png、.jpg 或 .gif 结尾的图片文件，并将它们输出到指定的目录中。\n2. CSS 文件\n\n安装 style-loader 和 css-loader：npm install style-loader css-loader\n在Webpack配置文件中配置加载器：\n\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/,\n      use: [&#039;style-loader&#039;, &#039;css-loader&#039;]\n    }\n  ]\n}\n以上配置将处理以 .css 结尾的 CSS 文件，并使用 style-loader 和 css-loader 进行加载和处理。\n3. 字体文件\n\n安装 file-loader 或 url-loader：npm install file-loader 或 npm install url-loader\n在Webpack配置文件中配置加载器：\n\nmodule: {\n  rules: [\n    {\n      test: /\\.(woff|woff2|eot|ttf|otf)$/,\n      use: [\n        {\n          loader: &#039;file-loader&#039;,\n          options: {\n            name: &#039;[name].[hash].[ext]&#039;, // 文件指纹配置\n            outputPath: &#039;fonts/&#039; // 输出目录\n          }\n        }\n      ]\n    }\n  ]\n}\n以上配置将处理以 .woff、.woff2、.eot、.ttf 或 .otf 结尾的字体文件，并将它们输出到指定的目录中。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，在配置加载器时，你可以根据自己的需求自定义加载器的选项。这些加载器可以在Webpack配置中的 module.rules 中进行定义。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理多页应用（Multiple-Pages-Application）的构建！":{"title":"如何在Webpack中处理多页应用（Multiple Pages Application）的构建！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中构建多页应用可以通过以下步骤进行配置：\n\n\n在项目文件夹中创建多个页面的入口文件。每个页面一个入口文件，例如 page1.js，page2.js 等。每个入口文件都需明确定义其对应的 HTML 模板文件。\n\n\n在Webpack配置文件中，通过 entry 属性指定每个入口文件。\n\n\nentry: {\n  page1: &#039;./src/page1.js&#039;,\n  page2: &#039;./src/page2.js&#039;\n}\n\n使用 HtmlWebpackPlugin 插件来自动生成 HTML 文件。在Webpack配置文件中进行如下配置：\n\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;);\n \nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: &#039;page1.html&#039;,\n      template: &#039;./src/page1.html&#039;,\n      chunks: [&#039;page1&#039;]\n    }),\n    new HtmlWebpackPlugin({\n      filename: &#039;page2.html&#039;,\n      template: &#039;./src/page2.html&#039;,\n      chunks: [&#039;page2&#039;]\n    }),\n    // ...\n  ]\n};\n在上述配置中，我们使用 HtmlWebpackPlugin 生成了 page1.html 和 page2.html 文件。通过 filename 属性指定生成的文件名，通过 template 属性指定模板文件的路径。通过 chunks 属性指定使用哪些入口文件对应的代码块。\n\n可选地，配置 output 属性来指定输出的文件名和路径。在Webpack配置文件中进行如下配置：\n\noutput: {\n  filename: &#039;[name].bundle.js&#039;,\n  path: path.resolve(__dirname, &#039;dist&#039;)\n}\n上述配置中，我们使用 [name] 占位符来根据入口文件的名称为每个输出的 JavaScript 文件命名。\n这样配置完成后，Webpack会根据每个入口文件生成对应的 HTML 文件和 JavaScript 文件，以及可能的 CSS 文件等其他资源文件。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理样式文件，例如CSS、Sass、Less等！":{"title":"如何在Webpack中处理样式文件，例如CSS、Sass、Less等！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中处理样式文件非常简单，你可以使用相应的loader来处理不同类型的样式文件。\n对于CSS文件，你可以使用css-loader和style-loader。css-loader负责解析CSS文件，而style-loader将解析后的CSS文件注入到HTML页面中。\n对于Sass文件，你需要使用sass-loader来解析Sass文件，并使用css-loader和style-loader来处理解析后的CSS文件。\n对于Less文件，你需要使用less-loader来解析Less文件，并使用css-loader和style-loader来处理解析后的CSS文件。\n在Webpack的配置文件中，你需要像下面这样配置相应的loader：\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/,\n      use: [&#039;style-loader&#039;, &#039;css-loader&#039;],\n    },\n    {\n      test: /\\.scss$/,\n      use: [&#039;style-loader&#039;, &#039;css-loader&#039;, &#039;sass-loader&#039;],\n    },\n    {\n      test: /\\.less$/,\n      use: [&#039;style-loader&#039;, &#039;css-loader&#039;, &#039;less-loader&#039;],\n    },\n  ],\n}\n在配置中，test字段指定了要匹配的文件类型，use字段指定了要使用的loader及其加载顺序。\n当你在代码中导入样式文件时，Webpack会根据配置自动处理这些文件，并将其注入到HTML页面中。\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是，如果你希望将样式文件提取为独立的CSS文件而不是将其注入到HTML页面中，你可以使用MiniCssExtractPlugin插件。这个插件可以将CSS文件从JavaScript文件中提取出来，并生成独立的CSS文件。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中处理第三方库（vendor-libraries）和动态链接库（Dynamic-Linking-Libraries）！":{"title":"如何在Webpack中处理第三方库（vendor libraries）和动态链接库（Dynamic Linking Libraries）！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中处理第三方库和动态链接库主要有两种方式：通过提取第三方库作为独立的包（vendor bundle）和使用动态链接库（DLL）。\n独立的包\n\n提取第三方库作为独立的包（vendor bundle）：这种方式适用于将第三方库与应用程序的代码分开打包。以下是实现的步骤：\n\na. 在Webpack配置中，通过使用 optimization.splitChunks 配置选项，将第三方库抽离出来，并生成一个独立的包。\nmodule.exports = {\n  // ...\n  optimization: {\n\tsplitChunks: {\n\t  chunks: &#039;all&#039;,\n\t  name: &#039;vendor&#039;\n\t}\n  }\n};\nb. 使用 HtmlWebpackPlugin 插件生成HTML文件，并在这个文件中引入 vendor bundle。\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;);\n \nmodule.exports = {\n  // ...\n  plugins: [\n\tnew HtmlWebpackPlugin({\n\t  template: &#039;./src/index.html&#039;,\n\t  chunks: [&#039;vendor&#039;, &#039;main&#039;]\n\t})\n  ]\n};\n这样，Webpack会将第三方库打包为一个独立的包，可以在HTML文件中单独引入。\n动态链接库\n\n使用动态链接库（DLL）：DLL是一种预先编译的JavaScript库，可以在多次构建过程中重复使用。以下是实现的步骤：\n\na. 创建一个Webpack配置文件，用于打包第三方库为DLL。\n// webpack.dll.config.js\n \nmodule.exports = {\n  entry: {\n\tvendor: [&#039;react&#039;, &#039;react-dom&#039;, &#039;lodash&#039;] // 第三方库的名称，比如React、React DOM、Lodash\n  },\n  output: {\n\tpath: path.resolve(__dirname, &#039;dist&#039;),\n\tfilename: &#039;[name].dll.js&#039;,\n\tlibrary: &#039;[name]&#039;\n  },\n  plugins: [\n\tnew webpack.DllPlugin({\n\t  name: &#039;[name]&#039;,\n\t  path: path.resolve(__dirname, &#039;dist/[name].manifest.json&#039;)\n\t})\n  ]\n};\nb. 在命令行中运行Webpack配置文件，以生成第三方库的DLL文件。\nwebpack --config webpack.dll.config.js\nc. 在应用程序的Webpack配置中，使用 webpack.DllReferencePlugin 引用生成的DLL文件，并指定 DLL 文件的路径。\nmodule.exports = {\n  // ...\n  plugins: [\n\tnew webpack.DllReferencePlugin({\n\t  manifest: require(&#039;./dist/vendor.manifest.json&#039;)\n\t})\n  ]\n};\n这样，当进行应用程序的构建时，Webpack会使用预先编译的DLL文件，而不是重新打包第三方库，提高构建速度。\n通过上述两种方式之一，你可以更好地处理第三方库和动态链接库，提高打包效率并减小构建产物的体积。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在Webpack中实现Code-Splitting和按需加载的路由（Dynamic-Imports）！":{"title":"如何在Webpack中实现Code Splitting和按需加载的路由（Dynamic Imports）！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中，你可以使用Code Splitting和按需加载的路由来优化应用程序的性能和加载速度。下面是实现这两个功能的一些步骤：\n1. Code Splitting：通过将应用程序拆分为多个独立的代码块，可以按需加载和并行加载这些代码块。这样可以减小初始加载的文件大小，提高加载速度。\n\n\n使用Webpack的动态导入语法来创建异步代码块，比如使用import()函数或require.ensure()函数。\n\n\n在路由配置或需要延迟加载的地方使用动态导入语法，例如：\n\n\nconst About = () =&gt; import(&#039;./About&#039;);\n\n配置Webpack的optimization.splitChunks选项，将共享的代码块从应用程序代码中提取出来，以便更好地利用缓存，并减少重复加载的代码。\n\n2. 按需加载的路由：在应用程序中使用按需加载的路由可以延迟加载组件，当用户访问特定路由时才加载相关代码。这样可以减小初始加载的文件大小，提高初始加载速度。\n\n使用路由库（如React Router、Vue Router等）的按需加载功能来延迟加载路由组件。\n配置Webpack的output.filename选项为使用[name].[chunkhash].js的格式，这样可以为每个生成的路由组件生成一个唯一的文件名。\n\n通过以上步骤，你就可以在Webpack中实现Code Splitting和按需加载的路由。这样可以将应用程序的代码拆分为更小的模块，并且只在需要时加载它们，从而提高性能和加载速度。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何在mutation中修改状态(state)！":{"title":"如何在mutation中修改状态(state)！","links":[],"tags":["编程/Vuex"],"content":"在mutation中修改状态(state)的步骤如下：\n\n\n找到要修改的状态属性：在state对象中找到要修改的属性。例如，如果你有一个名为todos的状态属性，并且想要修改其中的一个todo项，你可以使用state.todos来访问该属性。\n\n\n编写mutation方法：在mutation对象中编写一个方法，用于修改状态。方法的第一个参数是state对象，后面的参数是你要传递的任何其他数据。在该方法中，你可以直接修改状态属性。例如，你可以使用state.todos[index] = newValue来修改指定位置的todo项。\n\n\n调用mutation方法：在组件中通过commit方法调用mutation方法。commit方法接受两个参数，第一个参数是mutation方法的名称，第二个参数是要传递给mutation方法的数据。例如，你可以使用this.$store.commit(&#039;mutationName&#039;, data)来调用mutation方法。\n\n\n需要注意的是，mutation方法是同步的，它们应该只用于修改状态。如果你需要进行异步操作，应该使用actions来触发mutation方法。在actions中可以使用异步操作(如API调用)，然后再调用mutation方法来修改状态。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何实现jwt鉴权机制！说说你的思路":{"title":"如何实现jwt鉴权机制！说说你的思路","links":["C-Knowledge/前端/编程基础/网络/JWT"],"tags":["编程/Node"],"content":"一、是什么\nJWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息\n\n在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下：\n\n服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证\n后续访问会根据这个令牌判断用户时候有权限进行访问\n\nToken，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了编码\n\nheader\n每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256\n{  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot; } \n因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        \n\npayload\n载荷即消息体，这里会存放实际的内容，也就是Token的数据声明，例如用户的id和name，默认情况下也会携带令牌的签发时间iat，通过还可以设置过期时间，如下：\n{\n  &quot;sub&quot;: &quot;1234567890&quot;,\n  &quot;name&quot;: &quot;John Doe&quot;,\n  &quot;iat&quot;: 1516239022\n}\n同样进行Base64编码后，字符串如下：\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ\nSignature\n签名是对头部和载荷内容进行签名，一般情况，设置一个secretKey，对前两个的结果进行HMACSHA25算法，公式如下：\nSignature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)\n一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致\n二、如何实现\nToken的使用分成了两部分：\n\n生成token：登录成功的时候，颁发token\n验证token：访问某些资源或者接口时，验证token\n\n生成 token\n借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token：\n\n第一个参数指的是 Payload\n第二个是秘钥，服务端特有\n第三个参数是 option，可以定义 token 过期时间\n\nconst crypto = require(&quot;crypto&quot;),\n  jwt = require(&quot;jsonwebtoken&quot;);\n// TODO:使用数据库\n// 这里应该是用数据库存储，这里只是演示用\nlet userList = [];\n \nclass UserController {\n  // 用户登录\n  static async login(ctx) {\n    const data = ctx.request.body;\n    if (!data.name || !data.password) {\n      return ctx.body = {\n        code: &quot;000002&quot;, \n        message: &quot;参数不合法&quot;\n      }\n    }\n    const result = userList.find(item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&#039;md5&#039;).update(data.password).digest(&#039;hex&#039;))\n    if (result) {\n      // 生成token\n      const token = jwt.sign(  \n        {\n          name: result.name\n        },\n        &quot;test_token&quot;, // secret\n        { expiresIn: 60 * 60 } // 过期时间：60 * 60 s\n      );\n      return ctx.body = {\n        code: &quot;0&quot;,\n        message: &quot;登录成功&quot;,\n        data: {\n          token\n        }\n      };\n    } else {\n      return ctx.body = {\n        code: &quot;000002&quot;,\n        message: &quot;用户名或密码错误&quot;\n      };\n    }\n  }\n}\n \nmodule.exports = UserController;\n在前端接收到token后，一般情况会通过localStorage进行缓存，然后将token放到HTTP请求头Authorization 中，关于Authorization 的设置，前面要加上 Bearer ，注意后面带有空格\naxios.interceptors.request.use(config =&gt; {\n  const token = localStorage.getItem(&#039;token&#039;);\n  config.headers.common[&#039;Authorization&#039;] = &#039;Bearer &#039; + token; // 留意这里的 Authorization\n  return config;\n})\n校验token\n使用 koa-jwt 中间件进行验证，方式比较简单\n/ 注意：放在路由前面\napp.use(koajwt({\n  secret: &#039;test_token&#039;\n}).unless({ // 配置白名单\n  path: [/\\/api\\/register/, /\\/api\\/login/]\n}))\n\nsecret 必须和 sign 时候保持一致\n可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验\n校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验\n\n获取token用户的信息方法如下：\nrouter.get(&#039;/api/userInfo&#039;,async (ctx,next) =&gt;{\n    const authorization =  ctx.header.authorization // 获取jwt\n    const token = authorization.replace(&#039;Beraer &#039;,&#039;&#039;)\n    const result = jwt.verify(token,&#039;test_token&#039;)\n    ctx.body = result\n\n\n                  \n                  注意❗ \n                  \n                \n注意：上述的 HMA256 加密算法为单秘钥的形式，一旦泄露后果非常的危险\n\n在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌\n这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择RS256\n三、优缺点\n优点：\n\njson具有通用性，所以可以跨语言\n组成简单，字节占用小，便于传输\n服务端无需保存会话信息，很容易进行水平扩展\n一处生成，多处使用，可以在分布式系统中，解决单点登录问题\n可防护CSRF攻击\n\n缺点：\n\npayload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息\n需要保护好加密密钥，一旦泄露后果不堪设想\n为避免token被劫持，最好使用https协议\n\n参考文献\n\nwww.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\nblog.wangjunfeng.com/post/golang-jwt/\nvue3js.cn/interview/\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何提高webpack的构建速度！":{"title":"如何提高webpack的构建速度！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/常用的路径起一个别名"],"tags":["编程/Webpack"],"content":"一、背景\n随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 webpack 的构建时间也会越来越久\n构建时间与我们日常开发效率密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率\n所以，优化webpack 构建速度是十分重要的环节\n二、如何优化\n常见的提升构建速度的手段有如下：\n\n优化 loader 配置\n合理使用 resolve.extensions\n优化 resolve.modules\n优化 resolve.alias\n使用 DLLPlugin 插件\n使用 cache-loader\nterser 启动多线程\n合理使用 sourceMap\n\n优化loader配置\n在使用loader时，可以通过配置include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader\n如采用 ES6 的项目为例，在配置 babel-loader时，可以这样：\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能\n        test: /\\.js$/,\n        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启\n        use: [&#039;babel-loader?cacheDirectory&#039;],\n        // 只对项目根目录下的 src 目录中的文件采用 babel-loader\n        include: path.resolve(__dirname, &#039;src&#039;),\n      },\n    ]\n  },\n};\n合理使用 resolve.extensions\n在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码\n通过resolve.extensions是解析到文件时自动添加拓展名，默认情况如下：\nmodule.exports = {\n    ...\n    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]\n}\n当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找\n当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度\n优化 resolve.modules\nresolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块。默认值为[&#039;node_modules&#039;]，所以默认会从node_modules中查找文件 当安装的第三方模块都放在项目根目录下的 ./node_modules目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：\nmodule.exports = {\n  resolve: {\n    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n    // 其中 __dirname 表示当前工作目录，也就是项目根目录\n    modules: [path.resolve(__dirname, &#039;node_modules&#039;)]\n  },\n};\n优化 resolve.alias\nalias 给一些**常用的路径起一个别名**，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是 ./../../ 的形式\n通过配置alias以减少查找过程\nmodule.exports = {\n    ...\n    resolve:{\n        alias:{\n            &quot;@&quot;:path.resolve(__dirname,&#039;./src&#039;)\n        }\n    }\n}\n使用 DLLPlugin 插件\nDLL全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中\n使用步骤分成两部分：\n\n打包一个 DLL 库\n引入 DLL 库\n\n打包一个 DLL 库\nwebpack内置了一个DllPlugin可以帮助我们打包一个DLL的库文件\nmodule.exports = {\n    ...\n    plugins:[\n        new webpack.DllPlugin({\n            name:&#039;dll_[name]&#039;,\n            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)\n        })\n    ]\n}\n引入 DLL 库\n使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库\n然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中\nmodule.exports = {\n    ...\n    new webpack.DllReferencePlugin({\n        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),\n        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)\n    }),\n    new AddAssetHtmlPlugin({\n        outputPath:&quot;./auto&quot;,\n        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)\n    })\n}\n使用 cache-loader\n在一些性能开销较大的 loader之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度\n保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此loader\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.ext$/,\n                use: [&#039;cache-loader&#039;, ...loaders],\n                include: path.resolve(&#039;src&#039;),\n            },\n        ],\n    },\n};\nterser 启动多线程\n使用多进程并行运行来提高构建速度\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        parallel: true,\n      }),\n    ],\n  },\n};\n合理使用 sourceMap\n打包生成 sourceMap 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：\n\n三、总结\n优化Webpack的构建速度是一个常见的需求，下面是一些常见的优化策略：\n\n\n通过配置缓存：可以使用cache-loader或者hard-source-webpack-plugin来启用缓存，避免重复编译没有改动的文件。\n\n\n通过配置多线程/并行构建：可以使用thread-loader或者happypack来在多个工作线程中并行处理任务，加快构建速度。\n\n\n减少文件的解析和处理：可以通过配置resolve.extensions来减少Webpack的文件解析，只处理特定格式的文件。另外，使用include和exclude选项来限制需要处理的文件范围。\n\n\n优化Loader的配置：可以使用exclude选项来排除不必要的目录，只对需要处理的目录使用对应的Loader。另外，可以使用resolve.alias来配置别名，减少模块查找时间。\n\n\n使用Tree Shaking：通过配置mode为production，并且在package.json中将sideEffects设置为false或者具体的文件列表，开启Tree Shaking功能，剔除掉未使用的代码。\n\n\n合理使用Webpack的插件：根据具体需求，合理选择和配置Webpack的插件，避免不必要的处理和压缩。\n\n\n使用DllPlugin和缓存：可以将一些不经常变动的库使用DllPlugin预先编译，并将结果文件缓存起来，这样可以避免每次构建都重新编译这些库。\n\n\n以上是一些常见的Webpack构建速度优化策略，根据具体的项目需求和情况选择合适的优化方式。\n可以看到，优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手。\n参考文献\n\ngithub.com/ly2011/blog/issues/44\nxie.infoq.cn/article/541418eb82a674741a0ad8865\nzhuanlan.zhihu.com/p/139498741\nvue3js.cn/interview\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解OSI七层模型！":{"title":"如何理解OSI七层模型！","links":["Web-Clip/@互联网协议入门（一）---阮一峰的网络日志","Web-Clip/@互联网协议入门（二）---阮一峰的网络日志"],"tags":["编程/网络"],"content":"一、是什么\nOSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架\nOSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰\n二、划分\nOSI主要划分了七层，如下图所示：\n\n应用层\n应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\n该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议等\n在应用层交互的数据单元我们称之为报文\n表示层\n表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\n该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\n会话层\n会话层就是负责建立、管理和终止表示层实体之间的通信会话\n该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n传输层\n传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\n传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\n其中，主要的传输层协议是TCP和UDP\n网络层\n两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\n网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\n在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\n在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\n数据链路层\n数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧\n每一帧的数据可以分成：报头head和数据data两部分:\n\nhead 标明数据发送者、接受者、数据类型，如 MAC地址\ndata 存储了计算机之间交互的数据\n\n通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\n物理层\n作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\n该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\n该层主要是和硬件有关，与软件关系不大\n三、传输过程\n数据在各层之间的传输如下图所示：\n\n\n应用层报文被传送到运输层\n在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用\n应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变\n运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报\n网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧\n在物理层数据帧被封装成比特流，之后通过传输介质传送到对端\n对端再一步步解开封装，获取到传送的数据\n\n参考文献\n\nzh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B\nzhuanlan.zhihu.com/p/32059190\nleetcode-cn.com/leetbook/detail/networks-interview-highlights/\nvue3js.cn/interview\n@互联网协议入门（一） - 阮一峰的网络日志\n@互联网协议入门（二） - 阮一峰的网络日志\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何配置Webpack的开发环境和生产环境的不同配置！":{"title":"如何配置Webpack的开发环境和生产环境的不同配置！","links":[],"tags":["编程/Webpack"],"content":"在Webpack中，可以通过配置不同的Webpack配置文件或统一的配置文件来区分开发环境和生产环境的配置。\n一种常见的做法是创建两个独立的Webpack配置文件，分别针对开发环境和生产环境进行配置。一般来说，开发环境的配置更侧重于开发体验和调试工具，而生产环境的配置则更关注代码优化、压缩和资源的优化。\n例如，可以创建以下两个Webpack配置文件：\n1. webpack.config.dev.js（开发环境配置文件）\nconst webpack = require(&#039;webpack&#039;);\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;);\n \nmodule.exports = {\n  mode: &#039;development&#039;,\n  entry: &#039;./src/index.js&#039;,\n  output: {\n    filename: &#039;bundle.js&#039;,\n    path: path.resolve(__dirname, &#039;dist&#039;),\n  },\n  devServer: {\n    port: 3000,\n    hot: true,\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: &#039;./public/index.html&#039;,\n    }),\n  ],\n};\n2. webpack.config.prod.js（生产环境配置文件）\nconst webpack = require(&#039;webpack&#039;);\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;);\nconst MiniCssExtractPlugin = require(&#039;mini-css-extract-plugin&#039;);\nconst TerserWebpackPlugin = require(&#039;terser-webpack-plugin&#039;);\n \nmodule.exports = {\n  mode: &#039;production&#039;,\n  entry: &#039;./src/index.js&#039;,\n  output: {\n    filename: &#039;bundle.js&#039;,\n    path: path.resolve(__dirname, &#039;dist&#039;),\n  },\n  optimization: {\n    minimizer: [new TerserWebpackPlugin()],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: &#039;./public/index.html&#039;,\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true,\n        removeRedundantAttributes: true,\n        useShortDoctype: true,\n      },\n    }),\n    new MiniCssExtractPlugin({\n      filename: &#039;styles.css&#039;,\n    }),\n  ],\n};\n在此示例中，开发环境的配置文件仅包含了开发服务器（devServer）和热模块替换（hot module replacement）的配置，而生产环境的配置文件则包含了代码压缩（TerserWebpackPlugin）和CSS提取（MiniCssExtractPlugin）等插件的配置。\n另一种做法是使用同一个配置文件，并在其中根据环境变量来判断不同的配置。可以使用webpack-merge工具来合并共享的配置和环境特定的配置。以下是一个示例：\nconst webpackMerge = require(&#039;webpack-merge&#039;);\nconst commonConfig = require(&#039;./webpack.config.common&#039;);\n \nmodule.exports = (env) =&gt; {\n  const envConfig = require(`./webpack.config.${env}.js`);\n  return webpackMerge(commonConfig, envConfig);\n};\n在此示例中，webpack.config.common.js是共享的基本配置文件，而webpack.config.dev.js和webpack.config.prod.js分别是开发环境和生产环境的特定配置文件。根据传入的环境变量，可以决定加载哪个环境的配置文件。\n在命令行中使用Webpack时，可以通过设置环境变量来指定所需的配置文件，例如：\nwebpack --config webpack.config.js --env production\n以上是一些常见的配置不同环境的方法，你可以根据自己的需求选择适合的方式来配置Webpack的开发环境和生产环境。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/安全八股文":{"title":"安全八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/加密算法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/WEB-攻击","C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么实现接口防刷","DOS、-DDOS攻击原理和防范","C-Knowledge/前端/编程基础/网络/JWT"],"tags":["场景/前端安全"],"content":"安全\n\n加密算法\nWEB 攻击\n怎么实现接口防刷\nDOS、 DDOS攻击原理和防范\nJWT\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序八股文":{"title":"小程序八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的多端适配和体验优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对微信小程序的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的生命周期函数有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/cover-view-解决非同层渲染问题","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/`openid`-和-`unionid`-的区别是什么","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的基本概念和特点","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的目录结构和文件类型","C-Knowledge/前端/职业规划/前端面试宝典/八股文/页面逻辑和视图层的关系","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的模块化开发","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的开发工具和环境搭建","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的日志和监控怎么做的","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序中路由跳转的方式有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的登录流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的发布流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的支付流程！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用App()函数创建小程序实例","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的全局配置文件app.json","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的页面配置文件page.json","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用wxml语法定义页面结构","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用wxss语法定义页面样式","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的事件绑定和处理机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/使用setData()方法更新页面数据","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数据绑定和模板语法","C-Knowledge/前端/职业规划/前端面试宝典/八股文/网络请求和API调用","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的缓存机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/图片和音视频的展示和处理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的路由和页面跳转","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的生命周期函数","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的分享和转发功能","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的组件库和自定义组件","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的权限管理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的登录和用户认证","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的支付功能","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的定位和地图功能","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的数据上报和统计","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的分包加载和优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的版本控制和发布流程","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说微信小程序的实现原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说提高微信小程序的应用速度的手段有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的安全性和数据保护","C-Knowledge/前端/职业规划/前端面试宝典/八股文/小程序的推广和营销策略"],"tags":["编程/小程序"],"content":"重点\n\n小程序的多端适配和体验优化\n\n八股文\n核心概念\n\n说说你对微信小程序的理解！优缺点！\n说说微信小程序的生命周期函数有哪些！\ncover-view 解决非同层渲染问题\nopenid 和 unionid 的区别是什么\n小程序的基本概念和特点\n小程序的目录结构和文件类型\n页面逻辑和视图层的关系\n小程序的模块化开发\n\n使用方法\n\n小程序的开发工具和环境搭建\n小程序的日志和监控怎么做的\n说说微信小程序中路由跳转的方式有哪些！区别！\n说说微信小程序的登录流程！\n说说微信小程序的发布流程！\n说说微信小程序的支付流程！\n使用App()函数创建小程序实例\n小程序的全局配置文件app.json\n小程序的页面配置文件page.json\n使用wxml语法定义页面结构\n使用wxss语法定义页面样式\n小程序的事件绑定和处理机制\n使用setData()方法更新页面数据\n数据绑定和模板语法\n网络请求和API调用\n小程序的缓存机制\n图片和音视频的展示和处理\n小程序的路由和页面跳转\n小程序的生命周期函数\n小程序的分享和转发功能\n小程序的组件库和自定义组件\n小程序的权限管理\n小程序的登录和用户认证\n小程序的支付功能\n小程序的定位和地图功能\n小程序的数据上报和统计\n小程序的分包加载和优化\n小程序的版本控制和发布流程\n\n底层原理\n\n说说微信小程序的实现原理！\n\n性能优化&amp;安全\n\n说说提高微信小程序的应用速度的手段有哪些！\n小程序的多端适配和体验优化\n小程序的安全性和数据保护\n小程序的推广和营销策略\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/平时发送异步请求在哪个生命周期，并解释原因":{"title":"平时发送异步请求在哪个生命周期，并解释原因","links":[],"tags":["编程/FE/Vue"],"content":"我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n\n能更快获取到服务端数据，减少页面加载时间，用户体验更好；\nSSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/平时说的软解和硬解，具体是什么！":{"title":"平时说的软解和硬解，具体是什么！","links":[],"tags":["编程/FE/音视频"],"content":"硬解就是硬件解码，指利用GPU 来部分代替 CPU 进行解码，软解就是软件解码，指利用软件让 CPU 来进行解码。两者的具体区别如下所示：\n\n硬解码：是将原来全部交由CPU来处理的视频数据的一部分交由GPU来做，而GPU的并行运算能力要远远高于CPU，这样可以大大的降低对CPU的负载，CPU的占用率较低了之后就可以同时运行一些其他的程序了，当然，对于较好的处理器来说，比如i5 2320，或者AMD 任何一款四核心处理器来说，硬解和软件的区别只是个人偏好问题了吧。　　\n软解码：即通过软件让CPU来对视频进行解码处理；而硬解码：指不借助于CPU，而通过专用的子卡设备来独立完成视频解码任务。曾经的VCD/DVD解压卡、视频压缩卡等都隶属于硬解码这个范畴。而现如今，要完成高清解码已经不再需要额外的子卡，因为硬解码的模块已经被整合到显卡GPU的内部，所以目前的主流显卡（集显）都能够支持硬解码技术。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/开放题":{"title":"开放题","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/介绍项目、难点、解决方案","项目私有定制功能举例","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何衡量技术产生的业务价值","平时怎么学习前端知识","未来技术规划","C-Knowledge/前端/职业规划/前端面试宝典/八股文/了解哪些开源项目，举例说明","除了前端，还了解哪些技术方向，举例说明","为什么选前端","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/如何复制别人的好的效果"],"tags":["场景/面试"],"content":"开放题\n\n介绍项目、难点、解决方案\n项目私有定制功能举例\n如何衡量技术产生的业务价值\n平时怎么学习前端知识\n未来技术规划\n了解哪些开源项目，举例说明\n除了前端，还了解哪些技术方向，举例说明\n为什么选前端\n如何复制别人的好的效果\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么解决刷新页面时，Vuex-中数据丢失的问题！":{"title":"怎么解决刷新页面时，Vuex 中数据丢失的问题！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript本地存储的方式有哪些！区别及应用场景！"],"tags":["编程/FE/Vue"],"content":"原因：因为 Vuex 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载 Vue 实例，Vuex 里面的数据就会被清空。\n解决方法：\n1、直接保存到浏览器缓存分为两种：localStorage 或 sessionStorage\nlocalStorage 和 sessionStorage 都是 HTML5 标准中提供的用于在客户端存储数据的 API。我们可以在 Vuex 中监听 beforeunload 事件，在页面关闭之前将 Store 中的数据存储到 localStorage 或 sessionStorage 中。在页面加载时，我们可以从 localStorage 或 sessionStorage 中获取之前保存的数据，并将其重新加载到 Vuex 中。\n2、使用插件\n可以使用 vuex-persistedstate 等插件来将 Vuex 数据持久化到本地存储中。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/总结一下使用html2canvas截图时遇到的问题":{"title":"总结一下使用html2canvas截图时遇到的问题","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/解决canvas图片getImageData,toDataURL跨域问题"],"tags":["编程/Canvas"],"content":"近期做需求，有个页面截图下载到本地的功能，这里记录一下使用html2canvas时遇到的问题，简单搭建了一个demo项目(项目地址)，用来调试当时遇到的问题。 具体问题如下：\n\n图片跨域问题\n图片清晰度问题\n图片样式缺失问题\n长图截取不全问题\n\n使用\n\n安装\n\n官网地址: html2canvas.hertzen.com/\nnpm install --save html2canvas\n\n使用\n\nhtml2canvas接收两个参数，分别是截取的目标dom元素和配置项，配置项非必传。调用html2canvas方法后，会返回一个绘制好的canvas对象，再通过调用canvas对象的toDataURL方法可以转换成一个图片。\n// 具体代码如下：\nconst canvas = await html2canvas(document.body, options); // options为对应的配置项\nconst code = canvas.toDataURL(); // 转换为Base64编码的字符串\nconst aLink = document.createElement(&#039;a&#039;); // 创建a标签自动下载\naLink.download = &#039;下载图片&#039;;\naLink.href = code;\naLink.click();\n遇到的问题\n1. 跨域问题\nhtml2canvas配置项中自带了两个跟跨域相关的配置字段,分别是allowTaint和useCORS\n1、allowTaint\n由于html2canvas受浏览器同源策略的限制，使用非同源的图片会taint(污染)画布，因此默认allowTaint: false，不允许污染画布，同时图片也不能画在画布上。\n在配置项中设置allowTaint: true,虽然会污染画布，但可以将跨域的图片渲染到画布上了。\nconst canvas = await html2canvas(element, { allowTaint: true });\n \n不过我不太推荐这种方式，因为它会导致另外一个问题，被污染的画布因为同源策略而存在安全问题，导致调用html2canvas后返回的canvas对象中toDataUrl、getImageData等方法会报错，从而没办法将canvas画布信息转换成base64格式的字符串了，这不符合我的预期。 所以我将这个配置项pass掉，不用allowTaint，而是使用useCORS。\n\n使用allowTaint属性后，报错如下：\n\n\n2、useCORS\n在配置项中设置useCORS：true，可以解决跨域问题，原理相同。\nconst canvas = await html2canvas(element, { useCORS: true });\n图片我用百度的图标当做网络图片，效果图如下：\n\n未设置useCORS\n\n\n\n设置useCORS\n\n\n\n\n                  \n                  注意❗ \n                  \n                \n注意： allowTaint和useCORS不要同时使用，如果二者同时设置为true，仍然会认为画布已被污染而不可用。\n\n2. 图片清晰度问题\n通过配置项将scale属性对应的值调整大一点即可，我项目中设置的是4, 在html2canvas中scale默认值为浏览器设备像素比。\nconst canvas = await html2canvas(element, { scale: 4 });\n未设置scale和设置scale下载图片到本地后，通过下面这张图可以明显看出来，设置了scale的图片大小要比没有设置的大很多。\n\n下面两张图是通过调整scale对应值的大小，图片的清晰度对比会更加明显一些。\n\n设置scale: 0.8\n\n\n\n设置scale: 4\n\n\n3. 图片样式缺失问题\n此问题的原因在于html2canvas有一些css样式是不支持的，导致截取出来的图片有部分样式缺失。因此写页面的时候只要自己注意一下就好了。\n官方文档上面也有说明支持哪些css属性，不支持哪些css属性。具体详情可以点击传送门。\n下面这些css属性是当前不支持的：\n\nbackground-blend-mode\nborder-image\nbox-decoration-break\nbox-shadow\nfilter\nfont-variant-ligatures\nmix-blend-mode\nobject-fit\nrepeating-linear-gradient()\nwriting-mode\nzoom\n\n4. 长图截取不全问题\n遇到这个问题的时候，当时查看官方文档没有找到对应的解决方案，后来自己调试样式，发现设置截图元素的高度就可以完美解决了。\n\n解决方案： 给要截图的元素设置height：fit-content。\n\n效果图：\n\n\n\n                  \n                  注意❗ \n                  \n                \n注意：fit-content有兼容性问题，使用的时候需要注意该属性是否符合你的目标浏览器的兼容性。\n\n给截图元素不设置高度或者设置height: auto发现都不起作用，后来尝试使用fit-content这个相对较新的属性后，可以完美解决高度问题。\n\n\n                  \n                   扩展知识\n                  \n                \nheight: fit-content用于根据元素内容的大小来自动调整元素的高度。它允许你根据内容动态地设置元素的高度，而不是使用固定的像素值或百分比。（这段话来自chatGPT）\n另外fit-content可以和min-height和max-height搭配使用。\n\n与min-height搭配使用：当内容实际高度小于指定的最小高度时，元素的高度为min-height指定的高度，否则为元素的实际高度。。\n与max-height搭配使用：当内容高度大于指定的最大高度时，元素的高度为max-height指定的高度，否则为元素的实际高度。\n\n\n以上是我在做这个功能时遇到的问题，文中若有不对的地方欢迎各位掘友纠正~。\n参考文章\n\nhtml2canvas.hertzen.com/configurati…\nblog.fuwenhao.com/post/351.ht…\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/或=--、-and--and-=-和-！！=是什么！":{"title":"或=  、&&= 和 ！！=是什么！","links":[],"tags":["编程/JavaScript"],"content":"x ||= y\n逻辑或赋值运算符 ||= 的含义是：如果 x 为假，将 y 赋值给 x，即：\nif (!x) { \n    x = y \n}\n逻辑或赋值 ||= 的应用：\nconst a = { duration: 50, title: &#039;&#039; };\n \na.duration ||= 10;\nconsole.log(a.duration); // 50\n \na.title ||= &#039;title is empty.&#039;;\nconsole.log(a.title); // &quot;title is empty&quot;\nx &amp;&amp;= y\n逻辑与赋值运算符 &amp;&amp;= 的含义是：如果 x 为真，将 y 赋值给 x，即：\nif (x) { \n    x= y \n}\n逻辑与赋值运算符 &amp;&amp;= 的应用：\nconst a = { duration: 50, title: &#039;&#039; };\n \na.duration &amp;&amp;= 10;\nconsole.log(a.duration); // 10\n \na.title &amp;&amp;= &#039;title is empty.&#039;;\nconsole.log(a.title); // &quot;&quot;\nx ??= y\n逻辑空赋值运算符 x ??= y 的含义是：如果 x 为空值（null 或 undefined），将 y 赋值给 x，即\nif (x === null || x === undefined) { \n    x = y \n}\n逻辑空赋值运算符 ??= 的应用：\nconst a = { duration: 50, title: &#039;&#039; };\n \na.duration ??= 10;\nconsole.log(a.duration); // 50\n \na.title ??= &#039;title is empty.&#039;;\nconsole.log(a.title); // &quot;&quot;"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：instanceof":{"title":"手写题：instanceof","links":[],"tags":["编程/手写","编程/JavaScript"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n顺着原型链去找，直到找到相同的原型对象，返回 true，否则为 false 。\n\n跌代实现\nfunction myInstanceof(left, right) {\n    // 这里先用typeof来判断基础数据类型，如果是，直接返回false\n    if(typeof left !== &#039;object&#039; || left === null) return false;\n    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象\n    let proto = Object.getPrototypeOf(left);\n    while(true) {                  \n        if(proto === null) return false;\n        if(proto === right.prototype) return true;//找到相同原型对象，返回true\n        proto = Object.getPrototypeof(proto);\n    }\n}\n递归实现\nfunction myInstanceof(target, origin) {\n  const proto = Object.getPrototypeOf(target);\n  if (proto) {\n\tif (origin.prototype === proto) {\n\t  return true;\n\t} else {\n\t  return myInstanceof(proto, origin)\n\t}\n  } else {\n\treturn false;\n  }\n}\n测试代码\n// 定义构建函数\nlet Car = function() {}\nlet benz = new Car()\nmyInstanceof(benz, Car) // true\nlet car = new String(&#039;xxx&#039;)\nmyInstanceof(car, String)// true\nlet str = &#039;xxx&#039;\nmyInstanceof(str, String) // false"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：new操作符":{"title":"手写题：new操作符","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/JavaScript原型，原型链-！-有什么特点！"],"tags":["编程/JavaScript","编程/手写"],"content":"function myNew(Func, ...args) {\n    // 1.创建一个新对象\n    const obj = {}\n    // 2.新对象原型指向构造函数原型对象\n    obj.__proto__ = Func.prototype\n    // 3.将构造函数的this指向新对象\n    let result = Func.apply(obj, args)\n    // 4.根据返回值判断\n    return result instanceof Object ? result : obj\n}\n测试代码：\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.sayName = function () {\n    console.log(this.name)\n}\nconst person1 = myNew(Person,&#039;Tom&#039;, 20)\nconsole.log(person1)  // Person {name: &quot;Tom&quot;, age: 20}\nt.sayName() // &#039;Tom&#039;\n扩展阅读\n\nJavaScript原型，原型链 ！ 有什么特点！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：手动实现call(),-apply(),-bind()":{"title":"手写题：手动实现call(), apply(), bind()","links":["Web-Clip/@Js-手动实现bind方法，超详细思路分析！---听风是风---博客园","Web-Clip/@手动实现call、apply、bind-_-awesome-coding-js","Web-Clip/@手动实现call(),-apply(),-bind()---掘金","C-Knowledge/前端/技术书籍/JavaScript教程/this-关键字"],"tags":["编程/JavaScript","编程/手写"],"content":"call()\nES5 写法\nFunction.prototype.myCall = function(context) {\n  // 首先判断调用对象\n  if(typeof this !== &#039;function&#039;) {\n    throw new TypeError(&#039;error&#039;)\n  }\n  // 获取参数\n  var args = [...arguments].slice(1); //第一个是对象，从第二个开始\n  var result = null\n  // 判断content（this指针要指向的对象）是否传入, 如果没有设置为window\n  context = context || window\n  // 将调用函数设置为对象的方法\n  context.fn = this\n  // 调用函数\n  result = context.fn(...args);\n  // 删除属性\n  delete context.fn\n  return result\n}\nES6 写法\n\n\n                  \n                  提示💡 \n                  \n                \n\n1.判断当前this是否为函数，防止Function.prototype.myCall() 直接调用\n2.context 为可选参数，如果不传的话默认上下文为 window\n3.为context 创建一个 Symbol（保证不会重名）属性，将当前函数赋值给这个属性\n4.处理参数，传入第一个参数后的其余参数\n4.调用函数后即删除该Symbol属性\n\n\nFunction.prototype.myCall = function(context = window, ...args) {\n  // 首先判断调用对象\n  if(typeof this !== &#039;function&#039;) {\n    throw new TypeError(&#039;error&#039;)\n  }\n  //将调用函数设置为对象的方法\n  const fn = Symbol(); // 避免重名\n  context[fn] = this\n  // 调用函数\n  const result = context[fn](...args);\n  // 删除属性\n  delete context[fn]\n  return result\n}\n测试代码\nconst obj = {};\n \nconst f = function () {\n  return this;\n};\n \nf() === window // true\nf.myCall(obj) === obj // true\napply()\n\n\n                  \n                  提示💡 \n                  \n                \napply实现类似call，参数为数组。\n\nES5 写法\nFunction.prototype.myApply = function (context) {\n  // 首先判断调用对象是否为函数\n  if(typeof this !== &#039;function&#039;) {\n    throw new TypeError(&#039;error&#039;)\n  }\n  var result = null\n  // 判断传入的对象是否存在，在浏览器中默认是window, 在node.js中默认是Object\n  context = context || window\n  // 把当前调用的函数赋值给传入对象的\n  // context.fn 可以理解为： context.prototype.\n  context.fn = this\n  if (arguments[1]) {\n    result = context.fn([...arguments[1]]) // 调用赋值的函数\n  }\n  delete context.fn\n  return result\n}\nES6写法\nFunction.prototype.myApply = function (context = window, args) {\n  // 首先判断调用对象是否为函数\n  if(typeof this !== &#039;function&#039;) {\n    throw new TypeError(&#039;error&#039;)\n  }\n  if (this === Function.prototype) return; // 用于防止 Function.prototype.myCall() 直接调用\n  // 把当前调用的函数赋值给传入对象的\n  // context.fn 可以理解为： context.prototype.\n  const fn = Symbol();\n  context[fn] = this\n  let result;\n  if (Array.isArray(args)) {\n\tresult = context[fn](...args);\n  } else {\n\tresult = context[fn]();\n  }\n  delete context.fn\n  return result\n}\n测试代码\nfunction f(x, y){\n  console.log(x + y);\n}\n \nf.myCall(null, 1, 1) // 2\nf.myApply(null, [1, 1]) // 2\nbind()\n简单版本\nFunction.prototype.myBind = function (obj) {\n    const fn = this;\n    return function () {\n        fn.apply(obj);\n    };\n};\n测试代码\nvar counter = {\n  count: 0,\n  inc: function () {\n    this.count++;\n  }\n};\n \nvar func = counter.inc.myBind(counter);\nfunc();\ncounter.count // 1\n进阶版本: 函数柯里化、new关键字\n\n\n                  \n                  提示💡 \n                  \n                \n\n修改[[this 关键字|this指向]]\n动态传递参数（函数柯里化）\n\n// 方式一：只在bind中传递函数参数\nfn.bind(obj,1,2)()\n \n// 方式二：在bind中传递函数参数，也在返回函数中传递参数\nfn.bind(obj,1)(2)\n\n兼容new关键字\n\n\nFunction.prototype.myBind = function (context) {\n    // 判断调用对象是否为函数\n    if (typeof this !== &quot;function&quot;) {\n        throw new TypeError(&quot;Error&quot;);\n    }\n    // 获取参数\n    const args = [...arguments].slice(1),\n          fn = this;\n    return function Fn() {\n        // 根据调用方式，传入不同绑定值\n        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments)); \n    }\n}\n测试代码\nfunction fn(...args) {\n  console.log(this, args);\n}\nlet obj = {\n  myname: &quot;张三&quot;,\n};\n \nconst bindFn = fn.myBind(obj, 0); // this 也会变成传入的obj ，bind不是立即执行需要执行一次\nbindFn(1, 2); // this指向obj\nfn(1, 2); // this指向window\nnew bindFn(1, 2); // 兼容new关键字\n扩展阅读\n\n@Js 手动实现bind方法，超详细思路分析！ - 听风是风 - 博客园\n@手动实现call、apply、bind _ awesome-coding-js\n@手动实现call(), apply(), bind() - 掘金\nthis 关键字\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/操作系统八股文":{"title":"操作系统八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说什么是进程！什么是线程！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对操作系统的理解！核心概念有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-linux系统下-文件操作常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-linux-系统下-文本编辑常用的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-linux-用户管理的理解！相关的命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对输入输出重定向和管道的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对-shell-的理解！常见的命令！","浏览器处理AJAX请求和渲染页面是同一个进程吗，为什么"],"tags":["编程/操作系统"],"content":"操作系统\n\n说说什么是进程！什么是线程！区别！\n说说你对操作系统的理解！核心概念有哪些！\n说说 linux系统下 文件操作常用的命令有哪些！\n说说 linux 系统下 文本编辑常用的命令有哪些！\n说说你对 linux 用户管理的理解！相关的命令有哪些！\n说说你对输入输出重定向和管道的理解！应用场景！\n说说你对 shell 的理解！常见的命令！\n浏览器处理AJAX请求和渲染页面是同一个进程吗，为什么\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器八股文":{"title":"浏览器八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/重绘和回流","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说地址栏输入-URL-敲下回车后发生了什么！","C-Knowledge/前端/技术书籍/前端面试之道/浏览器缓存机制","C-Knowledge/前端/职业规划/前端面试宝典/八股文/跨域","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器的主要功能","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器的内核分别是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器是如何渲染-UI-的！","你如何获取浏览器URL中查询字符串中的参数？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/前端性能优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/渐进增强与优雅降级的理解及区别","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器样式兼容","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常见的兼容性问题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/GC-垃圾回收机制及内存管理","D-Unsorted/说说-JavaScript-中内存泄漏的几种情况！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/关于DOMContentLoaded和load事件说法正确的是！"],"tags":["编程/FE/浏览器"],"content":"重点\n\n重绘和回流\n说说地址栏输入 URL 敲下回车后发生了什么！\n浏览器缓存机制\n跨域\n\n浏览器\n\n浏览器缓存机制\n浏览器的主要功能\n浏览器的内核分别是什么！\n浏览器是如何渲染 UI 的！\n说说地址栏输入 URL 敲下回车后发生了什么！\n你如何获取浏览器URL中查询字符串中的参数？\n重绘和回流\n前端性能优化\n跨域\n渐进增强与优雅降级的理解及区别\n浏览器样式兼容\n常见的兼容性问题\nGC 垃圾回收机制及内存管理\n说说 JavaScript 中内存泄漏的几种情况！\n关于DOMContentLoaded和load事件说法正确的是！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/渲染管线的流程！":{"title":"渲染管线的流程！","links":[],"tags":["编程/图形学"],"content":"\n这里有一张更加形象的图：\n\n图1.3 渲染管线流程1\n其中， gl_Position在从顶点着色器输出了之后，会用OpenGL自己的函数进行归一化和视口变换，其具体过程如下：\n\n图1.4 归一化与视口变换过程\n而片段处理程序的input是顶点处理程序的output经过了插值之后得到的值"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/父子组件生命周期执行顺序":{"title":"父子组件生命周期执行顺序","links":[],"tags":["编程/FE/Vue"],"content":"1. 挂载阶段\n该过程主要涉及 beforeCreate、created、beforeMount、mounted 4 个钩子函数。执行顺序为：\n父 beforeCreate → 父 created → 父 beforeMount → 子 beforeCreate → 子 created → 子 beforeMount → 子 mounted → 父 mounted\n一定得等子组件挂载完毕后，父组件才能挂在完毕，所以父组件的 mounted 在最后。\n2 .更新阶段\n该过程主要涉及 beforeUpdate、updated 2 个钩子函数。注意，当父子组件有数据传递时，才有这个更新阶段执行顺序的比较。执行顺序为：\n父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated\n3 .销毁阶段\n该过程主要涉及beforeDestroy、destroyed 2 个钩子函数。执行顺序为：\n父 beforeDestroy → 子 beforeDestroy → 子 destroyed → 父 destroyed\n总结\n\n\n                  \n                  提示💡 \n                  \n                \n不管子级还是父级触发，先父级后子级再父级，即父子子父。类似事件冒泡。\n\n1.当父组件执行完 beforeMount 挂载开始后，会依次执行子组件中的钩子，直到全部子组件 mounted 挂载到实例上，父组件才会进入 mounted 钩子\n2.子级触发事件，会先触发父级 beforeUpdate 钩子，再去触发子级 beforeUpdate 钩子，下面又是先执行子级 updated 钩子，后执行父级 updated 钩子"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/父子组件通信":{"title":"父子组件通信","links":[],"tags":["编程/FE/Vue"],"content":"\nprops 用于在子组件中接收父组件传递的数据。\n//父组件传递 name 和 age 为&quot;zhangsan&quot;、&quot;20&quot;\n&lt;Child name=&quot;zhangsan&quot; age=&quot;20&quot;&gt;&lt;/Child&gt;\n \n//子组件接受 name 和 age\nexport default {\n    props: [&#039;name&#039;, &#039;age&#039;]\n}\nemit 用于子组件调用父组件中的方法和传值。父组件引入了 Child 子组件，并在子组件上定义了一个”sayHello”方法，当触发子组件中的 click 事件时，会通过 this.$emit(‘sayHello’) 调用父组件中的”sayHello”方法。\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;父组件&lt;/h1&gt;\n        &lt;Child @sayHello=&quot;sayHello&quot;&gt;&lt;/Child&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n​\n&lt;script&gt;\nimport Child from &quot;./Child.vue&quot;;\nexport default {\n    components: {\n        Child,\n    },\n    methods: {\n        sayHello() {\n            console.log(&#039;hello&#039;);\n        }\n    }\n};\n&lt;/script&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h2&gt;子组件&lt;/h2&gt;\n        &lt;!-- 先调用自己的方法，在自己的方法中触发父亲的自定义事件 --&gt;\n        &lt;button @click=&quot;sayHello&quot;&gt;sayHello&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n​\n&lt;script&gt;\nexport default {\n    methods: {\n        sayHello() {\n            this.$emit(&#039;sayHello&#039;);\n        }\n    }\n};\n&lt;/script&gt;"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/算法与数据结构八股文":{"title":"算法与数据结构八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法中时间复杂度，空间复杂度的理解！如何计算！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对数据结构的理解！有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对栈、队列的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对链表的理解！常见的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对集合的理解！常见的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对树的理解！相关的操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对堆的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对图的理解！相关操作有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说常见的排序算法有哪些！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对冒泡排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对选择排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对插入排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对归并排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对快速排序的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对二分查找的理解！如何实现！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对分而治之、动态规划的理解！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对贪心算法、回溯算法的理解！应用场景！"],"tags":["编程/数据结构"],"content":"算法与数据结构\n\n说说你对算法的理解！应用场景！\n说说你对算法中时间复杂度，空间复杂度的理解！如何计算！\n说说你对数据结构的理解！有哪些！区别！\n说说你对栈、队列的理解！应用场景！\n说说你对链表的理解！常见的操作有哪些！\n说说你对集合的理解！常见的操作有哪些！\n说说你对树的理解！相关的操作有哪些！\n说说你对堆的理解！如何实现！应用场景！\n说说你对图的理解！相关操作有哪些！\n说说常见的排序算法有哪些！区别！\n说说你对冒泡排序的理解！如何实现！应用场景！\n说说你对选择排序的理解！如何实现！应用场景！\n说说你对插入排序的理解！如何实现！应用场景！\n说说你对归并排序的理解！如何实现！应用场景！\n说说你对快速排序的理解！如何实现！应用场景！\n说说你对二分查找的理解！如何实现！应用场景！\n说说你对分而治之、动态规划的理解！区别！\n说说你对贪心算法、回溯算法的理解！应用场景！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/组件中的-data-为什么是一个函数！":{"title":"组件中的 data 为什么是一个函数！","links":[],"tags":["编程/FE/Vue"],"content":"一、实例和组件定义data的区别\nvue实例的时候定义data属性既可以是一个对象，也可以是一个函数\nconst app = new Vue({\n    el:&quot;#app&quot;,\n    // 对象格式\n    data:{\n        foo:&quot;foo&quot;\n    },\n    // 函数格式\n    data(){\n        return {\n             foo:&quot;foo&quot;\n        }\n    }\n})\n组件中定义data属性，只能是一个函数\n如果为组件data直接定义为一个对象\nVue.component(&#039;component1&#039;,{\n    template:`&lt;div&gt;组件&lt;/div&gt;`,\n    data:{\n        foo:&quot;foo&quot;\n    }\n})\n则会得到警告信息\n\n\n\n                  \n                  技巧💡 \n                  \n                \n警告说明：返回的 data 应该是一个函数在每一个组件实例中\n\n二、组件data定义函数与对象的区别\n上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？\n在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例\n这里我们模仿组件构造函数，定义data属性，采用对象的形式\nfunction Component(){\n \n}\nComponent.prototype.data = {\n\tcount : 0\n}\n创建两个组件实例\nconst componentA = new Component()\nconst componentB = new Component()\n\n修改componentA组件data属性的值，componentB中的值也发生了改变\nconsole.log(componentB.data.count)  // 0\ncomponentA.data.count = 1\nconsole.log(componentB.data.count)  // 1\n产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响\n如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）\nfunction Component(){\n\tthis.data = this.data()\n}\nComponent.prototype.data = function (){\n    return {\n   \t\tcount : 0\n    }\n}\n修改componentA组件data属性的值，componentB中的值不受影响\nconsole.log(componentB.data.count)  // 0\ncomponentA.data.count = 1\nconsole.log(componentB.data.count)  // 0\nvue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染\n三、原理分析\n首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象\n源码位置：/vue-dev/src/core/instance/state.js\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === &#039;function&#039;\n    ? getData(data, vm)\n    : data || {}\n    ...\n}\ndata既能是object也能是function，那为什么还会出现上文警告呢？\n别急，继续看下文\n组件在创建的时候，会进行选项的合并\n源码位置：/vue-dev/src/core/util/options.js\n自定义组件会进入mergeOptions进行选项合并\nVue.prototype._init = function (options?: Object) {\n    ...\n    // merge options\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    ...\n  }\n定义data会进行数据校验\n源码位置：/vue-dev/src/core/instance/init.js\n这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示\nstrats.data = function (\n  parentVal: any,\n  childVal: any,\n  vm?: Component\n): ?Function {\n  if (!vm) {\n    if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) {\n      process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;\n        warn(\n          &#039;The &quot;data&quot; option should be a function &#039; +\n            &quot;that returns a per-instance value in component &quot; +\n            &quot;definitions.&quot;,\n          vm\n        );\n \n      return parentVal;\n    }\n    return mergeDataOrFn(parentVal, childVal);\n  }\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n四、结论\n\n根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况\n组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象\n\n\n\n                  \n                  提示💡 \n                  \n                \n当组件被多次复用时，会创建多个实例，其实，这些实例使用的都是同一个构造函数。由于对象是引用数据类型，如果 data 是对象的话，当数据改动时就会影响到所有的实例，可能会造成一些数据的冲突。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/网络八股文":{"title":"网络八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说地址栏输入-URL-敲下回车后发生了什么！","C-Knowledge/前端/编程基础/网络/说说HTTP-常见的状态码有哪些，适用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-HTTP-常见的请求头有哪些！-作用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说TCP为什么需要三次握手和四次挥手！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解OSI七层模型！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/HTTP1-and-HTTP1.1、HTTP2、HTTP3各自解决的问题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/TLS-and-SSL","C-Knowledge/前端/开发技术/JavaScript/说说对WebSocket的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是HTTP！-HTTP-和-HTTPS-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么说HTTPS比HTTP安全！-HTTPS是如何保证安全的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解UDP-和-TCP！-区别！-应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解TCP-and-IP协议！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一下-GET-和-POST-的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/AJAX-原理！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何理解CDN！说说实现原理！","HTTP请求和TCP链接的对应关系","C-Knowledge/前端/职业规划/前端面试宝典/八股文/DNS协议-是什么！说说DNS-完整的查询过程！"],"tags":["编程/网络/HTTP"],"content":"重点\n\n说说地址栏输入 URL 敲下回车后发生了什么！\n说说HTTP 常见的状态码有哪些，适用场景！\n说说 HTTP 常见的请求头有哪些！ 作用！\n说说TCP为什么需要三次握手和四次挥手！\n如何理解OSI七层模型！\nHTTP1&amp;HTTP1.1、HTTP2、HTTP3各自解决的问题\nTLS&amp;SSL\n说说对WebSocket的理解！应用场景！\n什么是HTTP！ HTTP 和 HTTPS 的区别！\n\n八股文\n核心概念\n\n什么是HTTP！ HTTP 和 HTTPS 的区别！\n为什么说HTTPS比HTTP安全！ HTTPS是如何保证安全的！\n如何理解UDP 和 TCP！ 区别！ 应用场景！\n如何理解OSI七层模型！\n如何理解TCP&amp;IP协议！\nHTTP1&amp;HTTP1.1、HTTP2、HTTP3各自解决的问题\nTLS&amp;SSL\n说一下 GET 和 POST 的区别！\n说说对WebSocket的理解！应用场景！\n\n底层原理\n\nAJAX 原理！\n如何理解CDN！说说实现原理！\nHTTP请求和TCP链接的对应关系\nDNS协议 是什么！说说DNS 完整的查询过程！\n说说HTTP 常见的状态码有哪些，适用场景！\n说说 HTTP 常见的请求头有哪些！ 作用！\n说说地址栏输入 URL 敲下回车后发生了什么！\n说说TCP为什么需要三次握手和四次挥手！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/视频播放-Seek-的基本原理":{"title":"视频播放 Seek 的基本原理","links":[],"tags":["编程/FE/音视频"],"content":"首先了解一下NAL包结构，如下图所示为NAL的包头结构，其中unit_type占用5个bit，表示帧类型如下表所示，其中IDR图像对应的unit_type数值为5，因此可以通过包头信息判断流数据是否为IDR图像。\n\n\n下面开始介绍视频播放Seek的基本原理，如下图所示，为视频文件播放时间轴示意图，Start为开始播放视频的，End为视频播放结束，IDR帧为立即刷新帧所对应的播放时刻，Seek为拖动播放条时刻。\n\n若正常播放到Seek点时，视频一帧一帧逐帧解码播放；\n若直接拖动播放条到Seek点，则只需比对NAL包头判断是否为IDR帧以及计算是否接近Seek时间点即可。若判断数据包的时间点不在Seek附近或者不是IDR帧，则不用解码忽略此数据包；若判断收包时间点在Seek附近并且为IDR帧（图中黄色圆圈位置）则再进行解码，从而达到快速响应Seek的效果。\n\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解决canvas图片getImageData,toDataURL跨域问题":{"title":"解决canvas图片getImageData,toDataURL跨域问题","links":[],"tags":["编程/Canvas"],"content":"一、首先，图片服务器需要配置Access-Control-Allow-Origin\n一般团队都会有一个专门域名放置静态资源，例如腾讯是gtimg.com，百度是bdimg.com；或者很多团队使用的是腾讯云或者阿里云的服务。\n而主页面所在域名往往不一样，当需要需要对canvas图片进行getImageData()或toDataURL()操作的时候，跨域问题就出来了，而且跨域问题还不止一层。\n首先，第一步，图片服务器需要配置Access-Control-Allow-Origin信息，例如：\n如PHP添加响应头信息，*通配符表示允许任意域名：\nheader(&quot;Access-Control-Allow-Origin: *&quot;);\n或者指定域名：\nheader(&quot;Access-Control-Allow-Origin: www.zhangxinxu.com&quot;);\n此时，Chrome浏览器就不会有Access-Control-Allow-Origin相关的错误信息了，但是，还会有其他的跨域错误信息。\n二、canvas图片getImageData cross-origin跨域问题\n对于跨域的图片，只要能够在网页中正常显示出来，就可以使用canvas的drawImage() API绘制出来。但是如果你想更进一步，通过getImageData()方法获取图片的完整的像素信息，则多半会出错。\n举例来说，使用下面代码获取github上的自己头像图片信息：\nvar canvas = document.createElement(&#039;canvas&#039;);\nvar context = canvas.getContext(&#039;2d&#039;);\n \nvar img = new Image();\nimg.onload = function () {\n    context.drawImage(this, 0, 0);\n    context.getImageData(0, 0, this.width, this.height);\n};\nimg.src = &#039;avatars3.githubusercontent.com/u/496048#039;;&#039;;\n结果在Chrome浏览器下显示如下错误：\n\nUncaught DOMException: Failed to execute ‘getImageData’ on ‘CanvasRenderingContext2D’: The canvas has been tainted by cross-origin data.\n\n\nFirefox浏览器错误为：\n\nSecurityError: The operation is insecure.\n\n如果使用的是canvas.toDataURL()方法，则会报：\n\nFailed to execute ‘toDataURL’ on　’HTMLCanvasElement’: Tainted canvased may not be exported\n\n原因其实都是一样的，跨域导致。\n那有没有什么办法可以解决这个问题呢？\n可以试试crossOrigin属性。\n三、HTML crossOrigin属性解决资源跨域问题\n在HTML5中，有些元素提供了支持CORS(Cross-Origin Resource Sharing)（跨域资源共享）的属性，这些元素包括&lt;img&gt;，&lt;video&gt;，&lt;script&gt;等，而提供的属性名就是crossOrigin属性。\n因此，上面的跨域问题可以这么处理：\nvar canvas = document.createElement(&#039;canvas&#039;);\nvar context = canvas.getContext(&#039;2d&#039;);\n \nvar img = new Image();\nimg.crossOrigin = &#039;&#039;;\nimg.onload = function () {\n    context.drawImage(this, 0, 0);\n    context.getImageData(0, 0, this.width, this.height);\n};\nimg.src = &#039;avatars3.githubusercontent.com/u/496048#039;;&#039;;\n增加一个img.crossOrigin = &#039;&#039;即可，虽然JS代码这里设置的是空字符串，实际上起作用的属性值是anonymous。\ncrossOrigin可以有下面两个值：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n关键字释义anonymous元素的跨域资源请求不需要凭证标志设置。use-credentials元素的跨域资源请求需要凭证标志设置，意味着该请求需要提供凭证。\n其中，只要crossOrigin的属性值不是use-credentials，全部都会解析为anonymous，包括空字符串，包括类似&#039;abc&#039;这样的字符。\n例如：\nimg.crossOrigin = &#039;abc&#039;;\nconsole.log(img.crossOrigin);    // 结果是&#039;anonymous&#039;\n\n另外还有一点需要注意，那就是虽然没有crossOrigin属性，和设置crossOrigin=&quot;use-credentials&quot;在默认情况下都会报跨域出错，但是性质上却不一样，两者有较大区别。\ncrossOrigin兼容性\nIE11+(IE Edge)，Safari，Chrome，Firefox浏览器均支持，IE9和IE10会报SecurityError安全错误，如下截图：\n\n四、crossOrigin属性为什么可以解决资源跨域问题？\ncrossOrigin=anonymous相对于告诉对方服务器，你不需要带任何非匿名信息过来。例如cookie，因此，当前浏览器肯定是安全的。\n就好比你要去别人家里拿一件衣服，crossOrigin=anonymous相对于告诉对方，我只要衣服，其他都不要。如果不说，可能对方在衣服里放个窃听器什么的，就不安全了，浏览器就会阻止。\n五、IE10浏览器不支持crossOrigin怎么办？\n我们请求图片的时候，不是直接通过new Image()，而是借助ajax和URL.createObjectURL()方法曲线救国。\n代码如下：\nvar xhr = new XMLHttpRequest();\nxhr.onload = function () {\n    var url = URL.createObjectURL(this.response);\n    var img = new Image();\n    img.onload = function () {\n        // 此时你就可以使用canvas对img为所欲为了\n        // ... code ...\n        // 图片用完后记得释放内存\n        URL.revokeObjectURL(url);\n    };\n    img.src = url;\n};\nxhr.open(&#039;GET&#039;, url, true);\nxhr.responseType = &#039;blob&#039;;\nxhr.send();\n此方法不仅IE10浏览器OK，原本支持crossOrigin的诸位浏览器也是支持的。\n也就多走一个ajax请求，还可以！\n根据，根据实践发现，在IE浏览器下，如果请求的图片过大，几千像素那种，图片会加载失败，我猜是超过了blob尺寸限制。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的中间件(Middleware)机制。如何使用和创建中间件！":{"title":"解释一下Express.js中的中间件(Middleware)机制。如何使用和创建中间件！","links":[],"tags":["编程/Node/Express"],"content":"中间件(Middleware)是Express.js中一个重要的概念，它是在请求和响应之间执行的函数。中间件函数可以访问请求对象(req)和响应对象(res)，并且可以修改它们、执行特定的任务，或将控制权传递给下一个中间件。\n在Express.js中，可以通过app.use()或app.METHOD()方法使用中间件。app.use()方法可以将中间件应用到每个请求，而app.METHOD()方法则将其应用到特定的HTTP方法的请求上。\n以下是使用中间件的示例：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 自定义中间件函数\nconst myMiddleware = (req, res, next) =&gt; {\n  // 执行某些特定的任务\n  console.log(&#039;执行中间件任务&#039;);\n  \n  // 修改请求对象\n  req.customProperty = &#039;自定义属性&#039;;\n  \n  // 将控制权传递给下一个中间件\n  next();\n}\n \n// 应用全局中间件\napp.use(myMiddleware);\n \n// 应用特定路径的中间件\napp.get(&#039;/users&#039;, myMiddleware, (req, res) =&gt; {\n  // 访问中间件修改后的请求对象\n  console.log(req.customProperty);\n  \n  // 返回响应\n  res.send(&#039;用户列表&#039;);\n});\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动&#039;);\n});\n在上面的例子中，我们创建了一个名为myMiddleware的自定义中间件函数。我们使用app.use()方法将该中间件应用到每个请求上。然后，我们使用app.get()方法定义了一个特定路径的请求处理程序，并将myMiddleware作为第二个参数传递给app.get()，以将中间件应用到该特定请求上。\n在myMiddleware中，我们执行了一些特定的任务，例如打印消息、修改请求对象，然后通过调用next()函数将控制权传递给下一个中间件或请求处理程序。\n通过这种方式，您可以创建和使用自己的中间件，可以在其中执行各种任务，例如身份验证、日志记录、错误处理等。使用中间件的好处是可以将代码逻辑分解成可重用的模块，并实现请求的预处理和后处理。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的视图引擎(View-Engine)。如何配置和使用视图引擎！":{"title":"解释一下Express.js中的视图引擎(View Engine)。如何配置和使用视图引擎！","links":[],"tags":["编程/Node/Express"],"content":"在Express.js中，视图引擎(View Engine)是一种模板引擎，用于将动态内容渲染为HTML页面，并将其发送到客户端。视图引擎通过使用动态数据和模板文件来生成最终的HTML页面，这样可以轻松地将动态数据呈现给用户。\nExpress.js支持多种视图引擎，如EJS、Pug（之前的Jade）、Handlebars等。下面以EJS视图引擎为例来说明如何配置和使用视图引擎：\n首先，安装EJS视图引擎：\nnpm install ejs\n然后，在Express应用程序中通过app.set()方法配置视图引擎和视图文件夹的路径。例如，将EJS视图引擎设置为默认的视图引擎，并将视图文件放置在名为views的文件夹中：\nconst express = require(&#039;express&#039;);\nconst app = express();\n \n// 配置视图引擎\napp.set(&#039;view engine&#039;, &#039;ejs&#039;);\napp.set(&#039;views&#039;, &#039;views&#039;);\n \n// 定义路由\napp.get(&#039;/&#039;, (req, res) =&gt; {\n  res.render(&#039;index&#039;, { title: &#039;Express.js with EJS&#039; });\n});\n \n// 启动服务器\napp.listen(3000, () =&gt; {\n  console.log(&#039;服务器已启动&#039;);\n});\n在上述代码中，通过app.set()方法将视图引擎设置为EJS，并将视图文件夹设置为views。这意味着在渲染视图时，Express将会在views文件夹中查找对应的视图文件。\n接下来，在路由中使用res.render()方法来渲染视图。res.render()方法接受两个参数，第一个参数是视图文件的名称，第二个参数是要传递给视图的数据对象。在上述例子中，将渲染名为index.ejs的视图文件，并将一个包含title属性的数据对象传递给视图。\n最后，当访问根URL路径时，res.render()方法将会渲染index.ejs视图文件，生成最终的HTML响应，并将其发送到客户端。\n通过这种方式，您可以使用各种视图引擎在Express应用程序中动态生成HTML页面，并将其呈现给用户。视图引擎使得处理动态数据和HTML页面分离变得更加简单。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Express.js中的重定向(Redirect)和路由保护(Route-protection)。":{"title":"解释一下Express.js中的重定向(Redirect)和路由保护(Route protection)。","links":[],"tags":["编程/Node/Express"],"content":"重定向\n在Express.js中，重定向(Redirect)是一种通过改变浏览器请求的URL来将用户导航到不同的页面的行为。这通常用于将用户从一个URL重定向到另一个URL，例如在用户成功登录后将其重定向到仪表板页面。可以使用res.redirect方法来实现重定向，只需提供要重定向到的URL作为参数。\n例如，以下代码将使用Express路由来处理用户的登录请求，并在认证成功后将其重定向到/ dashboard页面：\napp.post(&#039;/login&#039;, (req, res) =&gt; {\n  // 在这里进行用户认证逻辑\n  if (userAuthenticated) {\n    // 重定向到仪表板页面\n    res.redirect(&#039;/dashboard&#039;);\n  } else {\n    // 认证失败\n    res.redirect(&#039;/login&#039;);\n  }\n});\n路由保护\n路由保护(Route protection)是一种在访问某个URL之前验证用户身份的机制。这是为了确保只有经过身份验证的用户可以访问一些受保护的页面或资源。在Express.js中，可以使用中间件来实现路由保护。中间件是在请求到达路由处理程序之前执行的功能函数。\n\n下面是一个示例，展示了如何使用中间件来保护某个URL并验证用户是否经过身份验证：\n\nfunction isAuthenticated(req, res, next) {\n  // 在这里验证用户是否经过身份验证，例如检查session或JWT\n  if (userAuthenticated) {\n    // 用户经过身份验证，继续到下一个处理程序\n    next();\n  } else {\n    // 用户未经过身份验证，重定向到登录页面\n    res.redirect(&#039;/login&#039;);\n  }\n}\n \napp.get(&#039;/dashboard&#039;, isAuthenticated, (req, res) =&gt; {\n  // 在这里返回仪表板页面的内容\n});\n在上面的例子中，isAuthenticated函数是一个中间件，用于验证用户是否经过身份验证。如果用户被认证，则请求将继续到下一个处理程序；否则，用户将被重定向到登录页面。这样可以保护/dashboard路由，只有经过身份验证的用户才能访问这个页面。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的中间件(Middleware)机制。如何使用和创建中间件！":{"title":"解释一下Koa.js中的中间件(Middleware)机制。如何使用和创建中间件！","links":[],"tags":["编程/Node/Koa"],"content":"在 Koa.js 中，中间件 (Middleware) 是一种函数，用于处理请求和响应。它可以在请求到达路由之前或响应返回给客户端之前对请求和响应进行修改。Koa.js 的中间件机制非常灵活，可以串联多个中间件，并且可以动态添加或删除中间件。\n下面是使用和创建中间件的一般步骤：\n\n创建中间件函数：一个中间件函数是一个接受三个参数的异步函数，通常命名为 next。这三个参数分别是 ctx (上下文对象)、next (下一个中间件函数) 和异步函数的返回值。例如：\n\nconst middleware = async (ctx, next) =&gt; {\n// 执行中间件操作\nawait next(); // 调用下一个中间件\n};\n\n使用中间件：在 Koa.js 应用程序中使用中间件函数，可以通过 app.use() 方法，将中间件添加到应用程序的中间件队列中。例如：\n\nconst Koa = require(&#039;koa&#039;);\nconst app = new Koa();\n \napp.use(middleware);\n可以添加多个中间件函数，它们按照添加的顺序依次执行。\n\n\n中间件的执行顺序：在中间件队列中，使用 await next() 调用下一个中间件函数。这使得控制权移交给下一个中间件，并且执行顺序按照中间件添加的顺序进行。如果没有 await next() 调用，则请求不会传递给后续的中间件，从而中断了中间件链。\n\n\n修改请求和响应：在中间件函数中，可以通过修改 ctx 对象来处理请求和响应。例如，可以修改请求头、读取请求体、设置响应状态码、设置响应头等。\n\n\n错误处理中间件：在中间件链中，可以定义一个专门处理错误的中间件函数。这个中间件函数接受一个 err 参数，用于处理发生的错误。可以使用 try/catch 结构捕获同步和异步代码中的错误，并将错误传递给错误处理中间件。例如：\n\n\napp.use(async (ctx, next) =&gt; {\ntry {\nawait next();\n} catch (err) {\n// 错误处理操作\n}\n});\n通过这样的方式，可以对错误进行统一处理，而不会导致应用程序崩溃。\n总结起来，Koa.js 的中间件机制通过添加和串联中间件函数来处理请求和响应。通过控制中间件执行顺序、修改请求和响应，以及处理错误，可以灵活地构建功能丰富的应用程序。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的异步中间件和中间件洋葱模型。":{"title":"解释一下Koa.js中的异步中间件和中间件洋葱模型。","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中，中间件是用来处理请求和相应的函数。中间件函数可以是同步的，也可以是异步的。异步中间件是指在处理函数中使用异步操作（如Promise、async/await等）的中间件。\n\n中间件洋葱模型是Koa.js中的一种设计模式，它允许开发者在请求的过程中按顺序执行一系列的中间件函数。每个中间件函数都可以在请求前后执行前置和后置操作。\n中间件洋葱模型的执行顺序是由Koa.js框架决定的。当一个请求到达时，它会从第一个中间件函数开始执行，然后依次执行下一个中间件函数，直到到达最后一个中间件函数。然后，控制权会从最后一个中间件函数中向上层中间件函数回溯，依次执行前置操作。\n下面是一个使用中间件洋葱模型的示例：\nconst Koa = require(&#039;koa&#039;);\nconst app = new Koa();\n \napp.use(async (ctx, next) =&gt; {\n  console.log(&#039;Middleware 1 - Before&#039;);\n  await next();\n  console.log(&#039;Middleware 1 - After&#039;);\n});\n \napp.use(async (ctx, next) =&gt; {\n  console.log(&#039;Middleware 2 - Before&#039;);\n  await next();\n  console.log(&#039;Middleware 2 - After&#039;);\n});\n \napp.use(async (ctx, next) =&gt; {\n  console.log(&#039;Middleware 3 - Before&#039;);\n  await next();\n  console.log(&#039;Middleware 3 - After&#039;);\n});\n \napp.listen(3000);\n在上面的示例中，当一个请求到达服务器时，它会依次经过Middleware 1、Middleware 2和Middleware 3。首先，Middleware 1会执行前置操作并调用next()来传递控制权给下一个中间件函数。接着，Middleware 2又会执行前置操作并传递控制权给Middleware 3。最后，当所有中间件函数都执行完毕后，控制权会回到Middleware 3，然后再回溯到Middleware 2和Middleware 1，执行后置操作。\n中间件洋葱模型让开发者能够灵活地在请求的各个阶段执行特定操作，使代码结构清晰、可组合和可扩展。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Koa.js中的重定向(Redirect)和路由保护(Route-protection)。":{"title":"解释一下Koa.js中的重定向(Redirect)和路由保护(Route protection)。","links":[],"tags":["编程/Node/Koa"],"content":"在Koa.js中，重定向（Redirect）是将请求从一个URL自动重定向到另一个URL的过程。重定向通常在以下情况下使用：\n\n路由重定向：在路由处理程序中，你可以使用ctx.redirect(url)方法将用户重定向到另一个URL。这通常在用户需要进行身份验证或者请求的资源已经移动到其他URL时使用。\n\nrouter.get(&#039;/admin&#039;, ctx =&gt; {\n  if (!ctx.isAuthenticated()) {\n    ctx.redirect(&#039;/login&#039;); // 如果未经过身份验证，将用户重定向到登录页面\n  } else {\n    // 处理管理员页面的逻辑\n  }\n});\n\n路由保护：在某些情况下，你可能希望对特定的路由进行保护，只有经过身份验证的用户才能访问。可以使用中间件来实现路由保护。在中间件中，你可以检查用户的身份验证状态，并根据需要进行重定向。\n\nfunction authMiddleware(ctx, next) {\n  if (!ctx.isAuthenticated()) {\n    ctx.redirect(&#039;/login&#039;); // 如果未经过身份验证，将用户重定向到登录页面\n    return; // 阻止后续的中间件和路由处理程序执行\n  }\n  return next(); // 继续执行下一个中间件或路由处理程序\n}\n \nrouter.get(&#039;/admin&#039;, authMiddleware, ctx =&gt; {\n  // 只有经过身份验证的用户才能执行此处理程序\n  // 处理管理员页面的逻辑\n});\n上述示例中，authMiddleware中间件会在访问/admin路由时检查用户的身份验证状态，如果未经过身份验证，用户将被重定向到登录页面。只有经过身份验证的用户才能访问被保护的路由。\n重定向和路由保护是在Koa.js应用程序中实现身份验证和访问控制的常见技术。通过使用重定向和中间件，你可以轻松地保护需要身份验证的路由，并将用户引导到适当的位置。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的中间件(Middleware)和路由(Routing)。":{"title":"解释一下Node.js中的中间件(Middleware)和路由(Routing)。","links":[],"tags":["编程/Node"],"content":"在 Node.js 中，中间件 (Middleware) 和路由 (Routing) 是构建 Web 应用程序的重要概念。\n\n\n                  \n                  中间件 \n                  \n                \n中间件是一个函数或一组函数，它们在处理 HTTP 请求和响应之间进行处理。它们可以在请求被路由处理之前或之后进行一些操作，例如身份验证、日志记录、数据解析等。中间件函数通常拥有 req (请求对象)、res (响应对象) 和 next (传递到下一个中间件函数的回调) 这三个参数。\n\n中间件可以使用 app.use 或 router.use 方法来添加到应用程序或路由器实例中。例如：\napp.use((req, res, next) =&gt; {\n  // 在路由处理之前进行一些操作\n  next();\n});\n \napp.get(&#039;/home&#039;, (req, res) =&gt; {\n  // 处理 &#039;/home&#039; 路由\n});\n在这个例子中，中间件函数被添加到应用程序实例中，它会在处理 /home 路由之前执行。\n\n\n                  \n                  路由 \n                  \n                \n路由是确定请求应该如何被处理和响应的机制。您可以使用 app.get、app.post 等方法定义不同的路由，它们对应于 HTTP 请求的不同方法。路由可以包含动态参数和处理程序函数。\n\napp.get(&#039;/users/:id&#039;, (req, res) =&gt; {\n  const userId = req.params.id; // 获取动态参数\n  // 根据 userId 做一些操作\n  res.send(&#039;User details&#039;);\n});\n在这个例子中，/users/:id 是一个带有动态参数的路由。当用户请求这个路由时，请求对象的 params 属性中将包含动态参数的值。\n通过使用中间件和路由，您可以创建灵活和可扩展的 Web 应用程序。中间件可以帮助您实现共享逻辑和处理公共任务，而路由定义了请求的处理方式。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的流(Stream)和管道(Pipe)。":{"title":"解释一下Node.js中的流(Stream)和管道(Pipe)。","links":[],"tags":["编程/Node"],"content":"流（Stream）\n在Node.js中，流（Stream）是用于处理数据的抽象接口，可以在读取和写入数据时以逐块（chunk）的方式进行操作。流可以分为可读流和可写流两种类型。\n可读流（Readable Stream）用于从数据源（比如文件、网络请求、标准输入等）读取数据，可以以可控的方式一次读取一小块数据，而不是一次性读取整个文件或数据流。这样可以有效地节省内存，特别适用于处理大型数据。\n可写流（Writable Stream）用于将数据写入目标位置（比如文件、网络响应、标准输出等），也是逐块写入的方式，可以分多次写入数据。\n通过使用流，可以在数据处理过程中实时地读取和写入数据，而不需要等到整个数据都准备好后再进行处理。\n管道（Pipe）\n管道（Pipe）是一种将可读流和可写流连接起来的机制。通过创建一个管道，可以将数据从一个可读流传输到一个可写流，从而实现数据的传输和转换。在管道中，数据会以流式的方式通过数据管道，直到全部数据被传输完毕。\n管道可以通过pipe()方法来建立，将源可读流作为参数传递给目标可写流的pipe()方法，从而将数据从源流传输到目标流。\n下面是一个使用管道的例子：\nconst fs = require(&#039;fs&#039;);\n \n// 创建可读流\nconst readableStream = fs.createReadStream(&#039;input.txt&#039;);\n \n// 创建可写流\nconst writableStream = fs.createWriteStream(&#039;output.txt&#039;);\n \n// 将可读流的数据通过管道传输到可写流\nreadableStream.pipe(writableStream);\n在上面的例子中，我们通过createReadStream和createWriteStream分别创建了一个可读流readableStream和一个可写流writableStream。然后，我们通过pipe()方法将可读流的数据传输到可写流中，实现了数据的复制和传输。\n通过使用流和管道，我们可以实现高效的数据处理和传输，特别适用于处理大型文件或网络请求。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Node.js中的缓存(Cache)和性能优化。":{"title":"解释一下Node.js中的缓存(Cache)和性能优化。","links":[],"tags":["编程/Node"],"content":"在Node.js中，缓存和性能优化是提高应用性能和响应速度的关键概念。以下是关于Node.js中缓存和性能优化的详细解释：\n1. 缓存（Cache）:\n\n内存缓存：Node.js提供了一个内置的内存缓存对象（Cache），它允许开发人员在应用程序中临时存储数据。内存缓存适合存储频繁使用的数据，避免重复计算或数据库查询。\n模块缓存：当您在Node.js中引入一个模块时，Node.js会缓存已加载的模块。这样，在后续的引入中，Node.js将直接返回缓存的模块，而不是再次加载它。这可以提高应用程序的启动速度和性能。\n数据缓存：通过缓存来自数据库、外部API或其他耗时操作的数据，可以避免频繁的数据库查询或网络请求，提高应用程序响应速度。\n\n\n2. 性能优化:\n\n非阻塞I/O：Node.js是基于事件驱动和非阻塞I/O模型的，这意味着它可以同时处理大量的并发请求。通过使用回调函数和事件监听器，Node.js可以在等待I/O操作完成时继续处理其他请求，从而提高性能和吞吐量。\n异步编程：利用JavaScript的异步编程能力，可以通过使用异步API、Promise和async/await等技术，避免阻塞操作，提高代码的执行效率和响应能力。\n多进程和集群：使用Node.js的集群模块（例如cluster模块）可以创建多个工作进程，以利用多核处理器和额外的计算资源，提高性能和负载均衡能力。\n代码优化：优化Node.js应用程序的代码结构和算法，避免不必要的计算和复杂度高的操作，以提高代码的执行效率和响应速度。\n使用高效的库和工具：选择高效的第三方库和工具，如Express.js、Fastify、Redis等，它们可以提供更好的性能和更高的吞吐量。\n\n\n以上是一些常见的Node.js缓存和性能优化的概念和技术。根据您的具体应用需求和性能要求，您可能还需要深入学习和实践其他相关的优化技术。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的DevServer是什么！如何配置用于开发环境的Webpack-DevServer！":{"title":"解释一下Webpack的DevServer是什么！如何配置用于开发环境的Webpack DevServer！","links":[],"tags":["编程/Webpack"],"content":"Webpack DevServer是一个基于Express的开发服务器，它可以提供实时重新加载（live reloading）和热模块替换（Hot Module Replacement）等功能，以提高开发效率。\n配置Webpack DevServer需要进行以下步骤：\n\n安装webpack-dev-server：首先，确保在项目中安装了webpack-dev-server，可以使用以下命令进行安装：\n\nnpm install --save-dev webpack-dev-server\n\n配置Webpack：在Webpack的配置文件中添加如下配置来启动DevServer：\n\nconst path = require(&#039;path&#039;);\n \nmodule.exports = {\n  // ...\n  devServer: {\n    contentBase: path.join(__dirname, &#039;dist&#039;), // 指定DevServer提供静态文件的目录\n    compress: true, // 启用gzip压缩\n    port: 9000, // 指定DevServer监听的端口号\n    hot: true, // 启用热模块替换\n    open: true // 自动打开浏览器\n  }\n};\n在上述配置中，contentBase选项指定了DevServer提供静态文件的目录，可以是一个绝对路径或相对路径；compress选项启用了gzip压缩，可以减小传输文件的大小；port选项指定了DevServer监听的端口号；hot选项启用了热模块替换，它会在代码修改后自动更新页面而不刷新整个页面；open选项启动DevServer时会自动打开默认浏览器。\n\n启动DevServer：在package.json文件中的scripts中添加一个命令来启动DevServer，例如：\n\n{\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;webpack-dev-server --open&quot;\n  }\n}\n上述命令将使用配置文件中的配置启动DevServer，并自动打开默认浏览器。\n完成上述配置后，运行npm start命令，Webpack DevServer将会在指定的端口号上启动，并且你可以在开发过程中实时查看修改的效果。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的动态导入（Dynamic-Imports）和预加载（Preloading）的区别！":{"title":"解释一下Webpack的动态导入（Dynamic Imports）和预加载（Preloading）的区别！","links":[],"tags":["编程/Webpack"],"content":"Webpack的动态导入（Dynamic Imports）和预加载（Preloading）是两种不同的优化技术，它们在加载和使用模块时的行为有所不同。\n动态导入是指在代码运行时根据需要动态加载模块。通过将模块的导入语句放在条件语句、循环语句或函数中，可以根据特定条件或事件触发动态加载相应的模块。这种方式可以延迟加载模块，减少初始加载时间和资源占用。使用动态导入可以将打包的代码分割成更小的文件，实现按需加载。\n预加载是指在主要代码加载完成之后，利用浏览器的空闲时间提前加载一些未来可能需要的资源。通过添加&lt;link rel=&quot;preload&quot;&gt;标签或使用import(/* webpackPrefetch: true */ &#039;module&#039;)语法，可以告诉浏览器预加载某个资源。预加载可以提前获取资源，以提高后续页面的加载速度，但可能会增加一些额外的网络请求。\n总而言之，动态导入适用于延迟加载模块以减少初始加载时间和资源占用，而预加载则适用于提前获取未来可能需要的资源以提高页面的加载速度。两者可以结合使用，根据具体的业务需求和场景来选择合适的优化方式。\n好的，下面是用表格归纳Webpack的动态导入和预加载的区别：\n\n通过以上表格，你可以更清楚地了解动态导入和预加载的区别和适用场景。根据具体的业务需求和场景，选择合适的优化方式来提高文件加载效率。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。":{"title":"解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。","links":["C-Knowledge/前端/技术书籍/前端面试之道/浏览器缓存机制"],"tags":["编程/Webpack"],"content":"Webpack的文件指纹（file fingerprint）机制是指在打包生成静态资源时，为每个文件生成唯一的标识码。这个标识码通常是通过对文件内容进行 hash 计算得到的。一旦文件内容发生改变，其文件指纹也会发生改变，从而防止浏览器在缓存过期前使用旧的文件。\n文件指纹有以下几种常见的类型：\n\nHash：每次打包时，Webpack 会给每个输出的文件生成一个 hash 值。只要文件内容发生变化，其 hash 值也会发生变化。\nChunkhash：根据不同的入口文件进行依赖关系解析后，Webpack 会为每个 chunk 生成一个 hash 值。只有当前 chunk 内容发生变化时，其 hash 值才会发生变化。\nContenthash：采用文件内容的 hash 值作为文件指纹，只有文件内容发生变化时，其 hash 值才会发生变化。适用于样式文件、图片文件等。\n\n缓存机制是指浏览器在加载页面时，会将静态资源（如 JS、CSS、图片等）保存在本地，以便下次加载相同资源时可以直接使用缓存副本，从而提高网页加载速度。缓存机制分为强缓存和协商缓存两种方式。\n\n强缓存：通过设置 Response Header 中的 Cache-Control 或 Expires 字段，告诉浏览器静态资源的有效期。在有效期内，浏览器会直接从缓存获取资源，无需向服务器发起请求。\n协商缓存：通过设置 Response Header 中的 Last-Modified 和 ETag 字段，告诉浏览器静态资源的版本信息。在请求资源时，如果浏览器的缓存仍然有效，则会发送一个请求到服务器，服务器会根据请求中的 If-Modified-Since 和 If-None-Match 字段进行验证，返回 304 状态码，并告诉浏览器可以使用缓存，从而减少数据传输。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释一下Webpack的模块化（Module-Federation）是什么，它解决了什么问题！":{"title":"解释一下Webpack的模块化（Module Federation）是什么，它解决了什么问题！","links":[],"tags":["编程/Webpack"],"content":"Webpack的模块化（Module Federation）是一种技术，可以帮助开发者将应用程序拆分为多个独立的模块，并将这些模块在不同的应用程序之间共享和加载。\nModule Federation解决了多个独立应用程序之间的依赖管理和模块共享的问题。传统上，如果我们有多个独立的应用程序，它们可能会使用相同的代码或依赖。在没有模块化的情况下，开发者可能会复制相同的代码到不同的应用程序中，并将依赖以静态方式添加到这些应用程序中。这样做会导致代码冗余，并使得维护和更新变得困难。\nModule Federation允许我们通过动态地将模块加载到应用程序中，实现模块的共享和动态的依赖管理。这样，我们可以将应用程序拆分为更小的模块，使得每个模块可以独立开发和部署。同时，每个模块都可以以相互独立的方式加载和运行，从而提高了代码的可维护性和可扩展性。\n通过模块化，我们可以更好地组织和管理应用程序的代码，减少代码冗余，并更好地支持多个独立应用程序之间的模块共享和协作。这对于大型和复杂的应用程序尤为重要，因为它可以提高开发效率并降低维护成本。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释什么是Canvas合成操作（Composition）！如何使用合成操作创建复杂的绘图效果！":{"title":"解释什么是Canvas合成操作（Composition）！如何使用合成操作创建复杂的绘图效果！","links":[],"tags":["编程/Canvas"],"content":"Canvas合成操作（Composition）是指在绘制过程中使用不同的合成模式将新的绘图操作与已有的图像进行组合。使用合成操作，你可以创建复杂的绘图效果，例如混合（blending）、遮罩（masking）、合并（merging）等。\nCanvas提供了globalCompositeOperation属性来设置当前的合成模式。该属性的默认值是source-over，表示新的绘图操作会覆盖已有的图像，但你可以通过设置不同的合成模式来实现不同的效果。以下是一些常用的合成模式示例：\n\nsource-over（默认）：新的绘图操作通过覆盖已有的图像来绘制。\nsource-in：新的绘图操作只在已有图像的非透明部分绘制。\nsource-out：新的绘图操作只在已有图像的透明部分绘制。\nsource-atop：新的绘图操作在已有图像的上方绘制，但只在两者重叠的部分绘制。\ndestination-over：新的绘图操作在已有图像的下方绘制。\ndestination-in：新的绘图操作只在已有图像与当前绘图操作的重叠部分绘制。\ndestination-out：新的绘图操作只在已有图像的非重叠部分绘制。\ndestination-atop：新的绘图操作在已有图像的下方绘制，但只在两者重叠的部分绘制。\nlighter：新的绘图操作与已有图像进行叠加，产生更亮的颜色效果。\ndarker：新的绘图操作与已有图像进行叠加，产生更暗的颜色效果。\nxor：新的绘图操作与已有图像进行异或运算，产生特定的颜色效果。\ncopy：新的绘图操作完全替换已有的图像。\n\n\n以下是一个示例代码，展示如何使用合成操作创建复杂的绘图效果：\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n \n// 绘制一个矩形\nctx.fillStyle = &#039;blue&#039;;\nctx.fillRect(50, 50, 200, 200);\n \n// 设置合成模式为source-out\nctx.globalCompositeOperation = &#039;source-out&#039;;\n \n// 绘制一个圆形\nctx.fillStyle = &#039;red&#039;;\nctx.beginPath();\nctx.arc(150, 150, 100, 0, 2 * Math.PI);\nctx.fill();\n \n// 设置合成模式为destination-over\nctx.globalCompositeOperation = &#039;destination-over&#039;;\n \n// 绘制一个矩形\nctx.fillStyle = &#039;green&#039;;\nctx.fillRect(100, 100, 200, 200);\n在这个示例中，我们首先绘制一个蓝色的矩形。然后，我们将合成模式设置为source-out，并绘制一个红色的圆形。由于合成模式的设置，红色的圆形只在与矩形重叠的部分绘制，而非重叠部分则是透明的。接下来，我们将合成模式设置为destination-over，并绘制一个绿色的矩形。由于合成模式的设置，绿色的矩形出现在已有图像的下方，但只在两者重叠的部分绘制。最终，这些绘图操作相互叠加，产生了复杂的绘图效果。\n通过合理选择合成模式，并结合绘制不同的形状和路径，你可以创造出各种独特的图像效果和视觉效果。请根据具体需求来选择和组合合成操作，以实现你想要的绘图效果。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/解释什么是Canvas的坐标系统！如何在Canvas中调整和使用坐标！":{"title":"解释什么是Canvas的坐标系统！如何在Canvas中调整和使用坐标！","links":[],"tags":["编程/Canvas"],"content":"Canvas的坐标系统是一个二维坐标系，用于确定Canvas上元素的位置。Canvas坐标系统以左上角为原点，水平方向向右增加，垂直方向向下增加。x轴表示水平位置，从左到右递增，y轴表示垂直位置，从上到下递增。\n在Canvas中，可以使用坐标系统来确定绘图元素的位置，例如点、线、图形等。可以通过以下方法在Canvas中调整和使用坐标：\n\n获取Canvas元素的引用和上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n设置Canvas的尺寸（可选）：\n\ncanvas.width = 500; // 设置Canvas的宽度\ncanvas.height = 300; // 设置Canvas的高度\n\n使用绘图上下文的方法来绘制元素，通常使用的方法包括：\n\n\nctx.moveTo(x, y)：将绘图游标移动到指定的坐标点(x, y)。\nctx.lineTo(x, y)：从当前绘图位置绘制一条直线到指定的坐标点(x, y)。\nctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)：绘制一段圆弧路径，以坐标(x, y)为圆心，radius为半径，从startAngle开始到endAngle结束，anticlockwise表示是否逆时针绘制。\nctx.fillRect(x, y, width, height)：绘制一个填充色的矩形，以坐标(x, y)为左上角，width为宽度，height为高度。\n\n通过调整这些方法的参数，可以在Canvas中自由地移动、绘制和放置元素，从而实现所需的效果。\n\n\n                  \n                  注意❗ \n                  \n                \n请注意，Canvas 的坐标系统是相对于 Canvas 元素本身的，因此如果使用 CSS 对 Canvas 元素进行缩放、移动或旋转等变换，也会影响到 Canvas 的坐标系统。要进行复杂的变换操作，可以使用绘图上下文的变换方法（如 ctx.translate，ctx.scale，ctx.rotate 等）。这些方法可以在绘图前或绘图过程中修改坐标系统，以实现更复杂的图形操作。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/设计模式八股文":{"title":"设计模式八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对设计模式的理解！常见的设计模式有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对单例模式的理解！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对工厂模式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对策略模式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对代理模式的理解！应用场景！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对发布订阅、观察者模式的理解！区别！"],"tags":["编程/设计模式"],"content":"设计模式\n\n说说对设计模式的理解！常见的设计模式有哪些！\n说说你对单例模式的理解！如何实现！\n说说你对工厂模式的理解！应用场景！\n说说你对策略模式的理解！应用场景！\n说说你对代理模式的理解！应用场景！\n说说你对发布订阅、观察者模式的理解！区别！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack-proxy工作原理！为什么能解决跨域！":{"title":"说说webpack proxy工作原理！为什么能解决跨域！","links":["C-Knowledge/前端/编程基础/网络/Node中间件代理(两次跨域)"],"tags":["编程/Webpack"],"content":"一、是什么\nwebpack proxy，即webpack提供的代理服务\n基本行为就是接收客户端发送的请求后转发给其他服务器\n其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）\n想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server\nwebpack-dev-server\nwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起\n目的是为了提高开发者日常的开发效率，只适用在开发阶段\n关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下：\n// ./webpack.config.js\nconst path = require(&#039;path&#039;)\n \nmodule.exports = {\n    // ...\n    devServer: {\n        contentBase: path.join(__dirname, &#039;dist&#039;),\n        compress: true,\n        port: 9000,\n        proxy: {\n            &#039;/api&#039;: {\n                target: &#039;api.github.com&#039;\n            }\n        }\n        // ...\n    }\n}\ndevServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配\n属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下：\n\ntarget：表示的是代理到的目标地址\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址\n\n二、工作原理\nproxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器\n举个例子：\n在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中\nconst express = require(&#039;express&#039;);\nconst proxy = require(&#039;http-proxy-middleware&#039;);\n \nconst app = express();\n \napp.use(&#039;/api&#039;, proxy({target: &#039;www.example.org&#039;, changeOrigin: true}));\napp.listen(3000);\n \n// http://localhost:3000/api/foo/bar -&gt; www.example.org/api/foo/bar\n三、跨域\n在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost的一个端口上，而后端服务又是运行在另外一个地址上\n所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题\n通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者\n当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地\n\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据\n\n\n                  \n                  注意❗ \n                  \n                \n注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制\n\n参考文献\n\nwebpack.docschina.org/configuration/dev-server/#devserverproxy\n\n\n\nNode中间件代理(两次跨域)\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack中常见的Plugin！解决了什么问题！":{"title":"说说webpack中常见的Plugin！解决了什么问题！","links":[],"tags":["编程/Webpack"],"content":"一、是什么\nPlugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能\n是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据\nwebpack中的plugin也是如此，plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期\n\n目的在于解决loader 无法实现的其他事\n配置方式\n这里讲述文件的配置方式，一般情况，通过配置文件导出对象中plugins属性传入new实例对象。如下所示：\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;); // 通过 npm 安装\nconst webpack = require(&#039;webpack&#039;); // 访问内置的插件\nmodule.exports = {\n  ...\n  plugins: [\n    new webpack.ProgressPlugin(),\n    new HtmlWebpackPlugin({ template: &#039;./src/index.html&#039; }),\n  ],\n};\n二、特性\n其本质是一个具有apply方法javascript对象\napply 方法会被 webpack compiler调用，并且在整个编译生命周期都可以访问 compiler对象\nconst pluginName = &#039;ConsoleLogOnBuildWebpackPlugin&#039;;\n \nclass ConsoleLogOnBuildWebpackPlugin {\n  apply(compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) =&gt; {\n      console.log(&#039;webpack 构建过程开始！&#039;);\n    });\n  }\n}\n \nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\ncompiler hook 的 tap方法的第一个参数，应是驼峰式命名的插件名称\n关于整个编译生命周期钩子，有如下：\n\nentry-option ：初始化 option\nrun\ncompile： 真正开始的编译，在创建 compilation 对象之前\ncompilation ：生成好了 compilation 对象\nmake 从 entry 开始递归分析依赖，准备对每个模块进行 build\nafter-compile： 编译 build 过程结束\nemit ：在将内存中 assets 内容写到磁盘文件夹之前\nafter-emit ：在将内存中 assets 内容写到磁盘文件夹之后\ndone： 完成所有的编译过程\nfailed： 编译失败的时候\n\n三、常见的 Plugin\n常见的plugin有如图所示：\n\n下面介绍几个常用的插件用法：\nHtmlWebpackPlugin\n在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的js 模块引⼊到该 html 中\nnpm install --save-dev html-webpack-plugin\n// webpack.config.js\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\nmodule.exports = {\n ...\n  plugins: [\n     new HtmlWebpackPlugin({\n       title: &quot;My App&quot;,\n       filename: &quot;app.html&quot;,\n       template: &quot;./src/html/index.html&quot;\n     }) \n  ]\n};\n&lt;!--./src/html/index.html--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n在 html 模板中，可以通过 &lt;%=htmlWebpackPlugin.options.XXX%&gt; 的方式获取配置的值\n更多的配置可以自寻查找\nclean-webpack-plugin\n删除（清理）构建目录\nnpm install --save-dev clean-webpack-plugin\nconst {CleanWebpackPlugin} = require(&#039;clean-webpack-plugin&#039;);\nmodule.exports = {\n ...\n  plugins: [\n    ...,\n    new CleanWebpackPlugin(),\n    ...\n  ]\n}\nmini-css-extract-plugin\n提取 CSS 到一个单独的文件中\nnpm install --save-dev mini-css-extract-plugin\nconst MiniCssExtractPlugin = require(&#039;mini-css-extract-plugin&#039;);\nmodule.exports = {\n ...,\n  module: {\n   rules: [\n    {\n     test: /\\.s[ac]ss$/,\n     use: [\n      {\n       loader: MiniCssExtractPlugin.loader\n     },\n          &#039;css-loader&#039;,\n          &#039;sass-loader&#039;\n        ]\n   }\n   ]\n },\n  plugins: [\n    ...,\n    new MiniCssExtractPlugin({\n     filename: &#039;[name].css&#039;\n    }),\n    ...\n  ]\n}\nDefinePlugin\n允许在编译时创建配置的全局对象，是一个webpack内置的插件，不需要安装\nconst { DefinePlugun } = require(&#039;webpack&#039;)\n \nmodule.exports = {\n ...\n    plugins:[\n        new DefinePlugin({\n            BASE_URL:&#039;&quot;./&quot;&#039;\n        })\n    ]\n}\n这时候编译template模块的时候，就能通过下述形式获取全局对象\n&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;\ncopy-webpack-plugin\n复制文件或目录到执行区域，如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中\nnpm install copy-webpack-plugin -D\nnew CopyWebpackPlugin({\n    parrerns:[\n        {\n            from:&quot;public&quot;,\n            globOptions:{\n                ignore:[\n                    &#039;**/index.html&#039;\n                ]\n            }\n        }\n    ]\n})\n复制的规则在patterns属性中设置：\n\nfrom：设置从哪一个源中开始复制\nto：复制到的位置，可以省略，会默认复制到打包的目录下\nglobOptions：设置一些额外的选项，其中可以编写需要忽略的文件\n\n总结\n在Webpack中，插件（plugin）是用来扩展和定制构建过程的工具，可以用于处理和优化资源、自动化任务、注入变量等。\n插件一般是一个具有apply方法的JavaScript对象，通过在Webpack的配置中配置插件，可以在构建过程中执行额外的操作。\n以下是一些常用的Webpack插件及其作用：\n\nHtmlWebpackPlugin：用于自动生成HTML文件，并将打包生成的所有资源（如CSS、JS文件）自动注入到生成的HTML文件中。\nMiniCssExtractPlugin：用于将CSS代码从打包生成的JS文件中提取出来，创建一个单独的CSS文件，可以实现CSS的异步加载和浏览器缓存优化。\nTerserWebpackPlugin：用于对JS代码进行压缩和混淆，减小文件体积，提高加载速度。\nOptimizeCSSAssetsWebpackPlugin：用于对提取出的CSS进行压缩和优化。\nCleanWebpackPlugin：用于在构建之前清空输出目录，避免旧文件的干扰。\nCopyWebpackPlugin：用于将静态文件从源目录复制到输出目录，例如将图片、字体等文件复制到打包后的文件夹中。\nDefinePlugin：用于定义全局变量，可以在代码中直接使用这些变量，例如配置环境变量、区分开发环境和生产环境等。\nHotModuleReplacementPlugin：用于启用模块热更新，实现在开发过程中无需刷新页面即可看到最新变更的效果。\nCompressionWebpackPlugin：用于对打包生成的文件进行gzip压缩，减小文件体积，提升网络传输速度。\nProvidePlugin：用于自动加载模块，当代码中使用到某个模块时，会自动将模块引入，无需手动import。\n\n这只是一小部分常用的Webpack插件，实际上还有很多其他的插件可以根据需要进行使用和定制。使用合适的插件可以大大提高Webpack的功能和效率，以及优化构建过程和最终生成的资源文件。\n参考文献\n\nwebpack.docschina.org/concepts/plugins/\nbaike.baidu.com/item/Plugin\nsegmentfault.com/a/1190000018695134\nvue3js.cn/interview\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的构建流程！":{"title":"说说webpack的构建流程！","links":[],"tags":["编程/Webpack"],"content":"一、运行流程\nwebpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来\n在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好\n从启动到结束会依次执行以下三大步骤：\n\n初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\n编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\n\n\n初始化流程\n从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n配置文件默认下为webpack.config.js，也或者通过命令的形式指定配置文件，主要作用是用于激活webpack的加载项和插件\n关于文件配置内容分析，如下注释：\nvar path = require(&#039;path&#039;);\nvar node_modules = path.resolve(__dirname, &#039;node_modules&#039;);\nvar pathToReact = path.resolve(node_modules, &#039;react/dist/react.min.js&#039;);\n \nmodule.exports = {\n  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。\n  entry: &#039;./path/to/my/entry/file.js&#039;，\n  // 文件路径指向(可加快打包过程)。\n  resolve: {\n    alias: {\n      &#039;react&#039;: pathToReact\n    }\n  },\n  // 生成文件，是模块构建的终点，包括输出文件与输出路径。\n  output: {\n    path: path.resolve(__dirname, &#039;build&#039;),\n    filename: &#039;[name].js&#039;\n  },\n  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: &#039;babel&#039;,\n        query: {\n          presets: [&#039;es2015&#039;, &#039;react&#039;]\n        }\n      }\n    ],\n    noParse: [pathToReact]\n  },\n  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n  ]\n};\nwebpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的 plugins\n完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack声明周期，不执行具体的任务，只是进行一些调度工作\nclass Compiler extends Tapable {\n    constructor(context) {\n        super();\n        this.hooks = {\n            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),\n            compile: new SyncHook([&quot;params&quot;]),\n            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),\n            make: new AsyncParallelHook([&quot;compilation&quot;]),\n            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])\n            // 定义了很多不同类型的钩子\n        };\n        // ...\n    }\n}\n \nfunction webpack(options) {\n  var compiler = new Compiler();\n  ...// 检查options,若watch字段为true,则开启watch线程\n  return compiler;\n}\n...\nCompiler 对象继承自 Tapable，初始化时定义了很多钩子函数\n编译构建流程\n根据配置中的 entry 找出所有的入口文件\nmodule.exports = {\n  entry: &#039;./src/file.js&#039;\n}\n初始化完成后会调用Compiler的run来真正启动webpack编译构建流程，主要流程如下：\n\ncompile 开始编译\nmake 从入口点分析模块及其依赖的模块，创建这些模块对象\nbuild-module 构建模块\nseal 封装构建结果\nemit 把各个chunk输出到结果文件\n\ncompile 编译\n执行了run方法后，首先会触发compile，主要是构建一个Compilation对象\n该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象\nmake 编译模块\n当完成了上述的compilation对象后，就开始从Entry入口文件开始读取，主要执行_addModuleChain()函数，如下：\n_addModuleChain(context, dependency, onModule, callback) {\n   ...\n   // 根据依赖查找对应的工厂函数\n   const Dep = /** @type {DepConstructor} */ (dependency.constructor);\n   const moduleFactory = this.dependencyFactories.get(Dep);\n   \n   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象\n   moduleFactory.create({\n       dependencies: [dependency]\n       ...\n   }, (err, module) =&gt; {\n       ...\n       const afterBuild = () =&gt; {\n        this.processModuleDependencies(module, err =&gt; {\n         if (err) return callback(err);\n         callback(null, module);\n           });\n    };\n       \n       this.buildModule(module, false, null, null, err =&gt; {\n           ...\n           afterBuild();\n       })\n   })\n}\n过程如下：\n_addModuleChain中接收参数dependency传入的入口依赖，使用对应的工厂函数NormalModuleFactory.create方法生成一个空的module对象\n回调中会把此module存入compilation.modules对象和dependencies.module对象中，由于是入口文件，也会存入compilation.entries中\n随后执行buildModule进入真正的构建模块module内容的过程\nbuild module 完成模块编译\n这里主要调用配置的loaders，将我们的模块转成标准的JS模块\n在用Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack后面对代码的分析\n从配置的入口模块开始，分析其 AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系\n输出流程\nseal 输出资源\nseal方法主要是要生成chunks，对chunks进行一系列的优化操作，并生成要输出的代码\nwebpack 中的 chunk ，可以理解为配置在 entry 中的模块，或者是动态引入的模块\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表\nemit 输出完成\n在确定好输出内容后，根据配置确定输出的路径和文件名\noutput: {\n    path: path.resolve(__dirname, &#039;build&#039;),\n        filename: &#039;[name].js&#039;\n}\n在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会\n从而webpack整个打包过程则结束了\n小结\n\n1、初始化参数：从配置文件和 Shell语句中读取与合并参数，得出最终的参数\n2、开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\n3、确定入口：根据配置中的 entry 找出所有的入口文件\n4、编译模块：从入口文件出发，调用所有配置的Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n5、完成模块编译：在经过第四步使上loader 翻译完所有模块后，得到了每个模块被编译后的最终内容以及它们之间的依赖关系\n6、输出资源：根据入口和模块之间的依赖关系，组装成一个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统，\n\n在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用Webpack 提供的 API 改变 Webpack 的运行结果。\n\n面试题高频-webpack的构建流程\n参考文献\n\ngithub.com/Cosen95/blog/issues/48\ndeveloper.aliyun.com/article/61047\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说webpack的热更新是如何做到的！原理是什么！":{"title":"说说webpack的热更新是如何做到的！原理是什么！","links":[],"tags":["编程/Webpack"],"content":"一、是什么\nHMR全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用\n例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失\n如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用\n在webpack中配置开启热模块也非常的简单，如下代码：\nconst webpack = require(&#039;webpack&#039;)\nmodule.exports = {\n  // ...\n  devServer: {\n    // 开启 HMR 特性\n    hot: true\n    // hotOnly: true\n  }\n}\n通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中\n但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块\n所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作\n我们需要去指定哪些模块发生更新时进行HRM，如下代码：\nif(module.hot){\n    module.hot.accept(&#039;./util.js&#039;,()=&gt;{\n        console.log(&quot;util.js更新了&quot;)\n    })\n}\n二、实现原理\n首先来看看一张图，如下：\n\n\nWebpack Compile：将 JS 源代码编译成 bundle.js\nHMR Server：用来将热更新的文件输出给 HMR Runtime\nBundle Server：静态资源文件服务器，提供文件访问路径\nHMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化\nbundle.js：构建输出的文件\n在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化\n\n上面图中，可以分成两个阶段：\n\n启动阶段为上图 1 - 2 - A - B\n\n在编写未经过webpack打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle文件，传输给Bundle Server 静态资源服务器\n\n更新阶段为上图 1 - 2 - 3 - 4\n\n当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的 hash 值，这个**hash 值** 用来作为下一次热更新的标识\n根据变化的内容生成两个补丁文件：manifest（包含了 hash 和 chundId，用来说明变化的内容）和chunk.js 模块\n由于socket服务器在HMR Runtime 和 HMR Server之间建立 websocket链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，作为下一次热更细的标识\n\n在浏览器接受到这条消息之前，浏览器已经在上一次socket 消息中已经记住了此时的hash 标识，这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件\nmainfest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性\n浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程，实现局部模块更新\n\n小结\n关于webpack热模块更新的总结如下：\n\n通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务\nexpress server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）\nsocket server 是一个 websocket 的长连接，双方可以通信\n当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）\n通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）\n浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新\n\nWebpack的热更新（Hot Module Replacement，简称HMR）是指在应用程序运行时，无需刷新整个页面，只更新发生更改的模块。HMR的原理如下：\n\n当开发者启用HMR功能并运行Webpack时，Webpack会在输出的包中添加一些HMR运行时代码。这些代码负责与开发服务器建立WebSocket连接，并接收来自服务器的更新通知。\n当开发者修改了一个模块时，Webpack会生成一个更新补丁（update patch）。这个补丁包含了模块发生更改的详细信息。\nHMR运行时代码会接收到更新补丁，并通过Webpack的模块系统应用更新。它会找到发生更改的模块，替换旧的模块，并触发相应的回调函数。\n在处理完模块的更改后，HMR运行时代码会通知Webpack完成热更新过程。Webpack会通知开发服务器将更新发送给浏览器客户端。\n浏览器客户端接收到更新后，使用新的模块来替换页面中发生更改的部分，从而实现热更新，而不需要刷新整个页面。\n\n总结来说，Webpack的热更新通过在开发服务器和浏览器客户端之间建立WebSocket连接，将模块更改的信息传递给浏览器，并在浏览器中实现局部更新，提高开发效率。\n三、总结\n热重载（Hot Module Replacement，HMR）是Webpack提供的一项功能，它允许在开发过程中，无需刷新整个页面，即可实时更新修改的模块。\n通过热重载，可以提高开发效率，快速查看代码变化的结果，并保持应用的状态（如表单数据）。\n要配置实现热更新，需要进行以下步骤：\n\n在Webpack配置文件中启用热模块替换。可通过配置devServer.hot选项为true来启用HMR：\n\n// webpack.config.js\n \nmodule.exports = {\n  // ...\n  devServer: {\n    hot: true,\n  },\n};\n\n在入口文件中添加对HMR的支持。在入口文件中，需要添加HMR的逻辑以监听模块的变化，并告诉Webpack如何处理更新。\n\n// index.js\n \nif (module.hot) {\n  module.hot.accept();\n}\n\n配置Webpack插件。HMR需要搭配相应的插件使用，常用的是webpack.HotModuleReplacementPlugin。\n\n// webpack.config.js\nconst webpack = require(&#039;webpack&#039;);\n \nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    // ...其他插件\n  ],\n};\n完成上述配置后，运行Webpack开发服务器时，Webpack会在文件发生变化时将更新的模块代码发送给浏览器，浏览器会在不刷新整个页面的情况下，替换掉相应的模块。\n\n\n                  \n                  注意❗ \n                  \n                \n请注意，热重载只适用于开发环境，并不能直接用于生产环境。在生产环境中，需要使用Webpack生成的静态文件进行部署。\n\n热重载可以提高开发效率，但在某些情况下可能会遇到一些问题，如状态丢失、事件绑定问题等。因此，对于某些情况下，可能需要手动刷新页面来确保正确的状态。\n参考文献\n\nzhuanlan.zhihu.com/p/138446061\ngithub.com/Jocs/jocs.github.io/issues/15\njuejin.cn/post/6844904134697549832\nvue3js.cn/interview/\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对Git的理解！":{"title":"说说你对Git的理解！","links":["C-Knowledge/前端/开发技术/Git/Git指令"],"tags":["编程/Git"],"content":"一、是什么\ngit，是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计\n分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复\n\n项目开始，只有一个原始版仓库，别的机器可以clone这个原始版本库，那么所有clone的机器，它们的版本库其实都是一样的，并没有主次之分\n所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库clone一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交\ngithub实际就可以充当这个服务器角色，其是一个开源协作社区，提供Git仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目\n前端开发中的作用\nGit是一个分布式版本控制系统，用于跟踪文件和项目的变化。它可以记录每个文件的修改历史，并允许开发者在不同的分支上进行并行开发和合并工作。\n在前端开发中，Git起着至关重要的作用。它可以帮助开发者轻松地管理代码，跟踪文件的修改、添加和删除，并记录每个提交的详细信息。\n以下是Git在前端开发中的一些主要作用：\n\n\n版本控制：Git允许开发者跟踪代码的版本历史，可以回溯到任何时刻的代码状态。这对于调试、修复错误以及恢复代码都非常有用。\n\n\n分支管理：Git支持创建多个分支，使得团队成员可以并行地开发不同的功能和修复不同的bug。每个分支都可以独立地进行开发和测试，最后再将分支合并到主分支上。\n\n\n合作开发：多人协作开发时，Git可以协助团队成员共享和合并代码。它提供了远程仓库的功能，使得团队成员可以将代码推送到共享仓库并进行同步。\n\n\n撤销和回退：Git允许开发者撤销之前的提交，回退到之前的版本。这对于修复错误或不需要的更改非常有用。\n\n\n快速部署：Git可以轻松部署代码到生产环境。通过创建发布分支或打标签，开发者可以准确地控制代码的部署版本。\n\n\n\n二、工作原理\n当我们通过git init创建或者git clone一个项目的时候，项目目录会隐藏一个.git子目录，其作用是用来跟踪管理版本库的\nGit 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，git能够知道\nGit用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：\n24b9da6552252987aa493b52f8696cd6d3b00373\n\n当我们修改文件的时候，git就会修改文件的状态，可以通过git status进行查询，状态情况如下：\n\n已修改（modified）：表示修改了文件，但还没保存到数据库中。\n已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n已提交（committed）：表示数据已经安全的保存在本地数据库中。\n\n文件状态对应的，不同状态的文件在Git中处于不同的工作区域，主要分成了四部分：\n\n工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本\n暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中\n本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库\n远程仓库：远程的仓库，如 github\n\n\n三、命令\n从上图可以看到，git日常简单的使用就只有上图6个命令：\n\nadd\ncommit\npush\npull\nclone\ncheckout\n\n但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力\n参考文献\n\nzh.wikipedia.org/wiki/Git\nwww.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\n\n\nGit指令\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对slot的理解！slot使用场景有哪些！":{"title":"说说你对slot的理解！slot使用场景有哪些！","links":[],"tags":["编程/FE/Vue"],"content":"一、slot是什么\n在HTML中 slot 元素 ，作为 Web Components 技术套件的一部分，是Web组件内的一个占位符\n该占位符可以在后期使用自己的标记语言填充\n举个栗子\n&lt;template id=&quot;element-details-template&quot;&gt;\n  &lt;slot name=&quot;element-name&quot;&gt;Slot template&lt;/slot&gt;\n&lt;/template&gt;\n&lt;element-details&gt;\n  &lt;span slot=&quot;element-name&quot;&gt;1&lt;/span&gt;\n&lt;/element-details&gt;\n&lt;element-details&gt;\n  &lt;span slot=&quot;element-name&quot;&gt;2&lt;/span&gt;\n&lt;/element-details&gt;\ntemplate不会展示到页面中，需要用先获取它的引用，然后添加到DOM中，\ncustomElements.define(&#039;element-details&#039;,\n  class extends HTMLElement {\n    constructor() {\n      super();\n      const template = document\n        .getElementById(&#039;element-details-template&#039;)\n        .content;\n      const shadowRoot = this.attachShadow({mode: &#039;open&#039;})\n        .appendChild(template.cloneNode(true));\n  }\n})\n在Vue中的概念也是如此\nSlot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口\n可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容）\n放张图感受一下 \n二、使用场景\n通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理\n如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情\n通过slot插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用\n比如布局组件、表格列、下拉选、弹框显示内容等\n三、分类\nslot可以分来以下三种：\n\n默认插槽\n具名插槽\n作用域插槽\n\n默认插槽\n子组件用&lt;slot&gt;标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面\n父组件在使用的时候，直接在子组件的标签内写入内容即可\n子组件Child.vue\n&lt;template&gt;\n    &lt;slot&gt;\n      &lt;p&gt;插槽后备的内容&lt;/p&gt;\n    &lt;/slot&gt;\n&lt;/template&gt;\n父组件\n&lt;Child&gt;\n  &lt;div&gt;默认插槽&lt;/div&gt;  \n&lt;/Child&gt;\n\n具名插槽\n子组件用name属性来表示插槽的名字，不传为默认插槽\n父组件中在使用时在默认插槽的基础上加上slot属性，值为子组件插槽name属性值\n子组件Child.vue\n&lt;template&gt;\n    &lt;slot&gt;插槽后备的内容&lt;/slot&gt;\n  &lt;slot name=&quot;content&quot;&gt;插槽后备的内容&lt;/slot&gt;\n&lt;/template&gt;\n父组件\n&lt;child&gt;\n    &lt;template v-slot:default&gt;具名插槽&lt;/template&gt;\n    &lt;!-- 具名插槽⽤插槽名做参数 --&gt;\n    &lt;template v-slot:content&gt;内容...&lt;/template&gt;\n&lt;/child&gt;\n作用域插槽\n子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上\n父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用\n子组件Child.vue\n&lt;template&gt; \n  &lt;slot name=&quot;footer&quot; testProps=&quot;子组件的值&quot;&gt;\n          &lt;h3&gt;没传footer插槽&lt;/h3&gt;\n    &lt;/slot&gt;\n&lt;/template&gt;\n父组件\n&lt;child&gt; \n    &lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;\n    &lt;template v-slot:default=&quot;slotProps&quot;&gt;\n      来⾃⼦组件数据：{{slotProps.testProps}}\n    &lt;/template&gt;\n    &lt;template #default=&quot;slotProps&quot;&gt;\n      来⾃⼦组件数据：{{slotProps.testProps}}\n    &lt;/template&gt;\n&lt;/child&gt;\n小结：\n\nv-slot属性==只能在&lt;template&gt;上使用==，但在只有默认插槽时可以在组件标签上使用\n默认插槽名为default，可以省略default直接写v-slot\n缩写为#时不能不写参数，写成#default\n可以通过解构获取v-slot={user}，还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = &#039;默认值&#039;}&quot;\n\n四、原理分析\nslot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过template -&gt; render function -&gt; VNode -&gt; DOM 过程，这里看看slot如何实现：\n编写一个buttonCounter组件，使用匿名插槽\nVue.component(&#039;button-counter&#039;, {\n  template: &#039;&lt;div&gt; &lt;slot&gt;我是默认内容&lt;/slot&gt;&lt;/div&gt;&#039;\n})\n使用该组件\nnew Vue({\n    el: &#039;#app&#039;,\n    template: &#039;&lt;button-counter&gt;&lt;span&gt;我是slot传入内容&lt;/span&gt;&lt;/button-counter&gt;&#039;,\n    components:{buttonCounter}\n})\n获取buttonCounter组件渲染函数\n(function anonymous(\n) {\nwith(this){return _c(&#039;div&#039;,[_t(&quot;default&quot;,[_v(&quot;我是默认内容&quot;)])],2)}\n})\n_v表示穿件普通文本节点，_t表示渲染插槽的函数\n渲染插槽函数renderSlot（做了简化）\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  // 得到渲染插槽内容的函数    \n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  // 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回\n  // 否则使用默认值\n  nodes = scopedSlotFn(props) || fallback;\n  return nodes;\n}\nname属性表示定义插槽的名字，默认值为default，fallback表示子组件中的slot节点的默认值\n关于this.$scopredSlots是什么，我们可以先看看vm.slot\nfunction initRender (vm) {\n  ...\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  ...\n}\nresolveSlots函数会对children节点做归类和过滤处理，返回slots\nfunction resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i &lt; l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &amp;&amp;\n        data &amp;&amp; data.slot != null\n      ) {\n        // 如果slot存在(slot=&quot;header&quot;) 则拿对应的值作为key\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        // 如果是tempalte元素 则把template的children添加进数组中，这也就是为什么你写的template标签并不会渲染成另一个标签到页面\n        if (child.tag === &#039;template&#039;) {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        // 如果没有就默认是default\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n}\n_render渲染函数通过normalizeScopedSlots得到vm.$scopedSlots\nvm.$scopedSlots = normalizeScopedSlots(\n  _parentVnode.data.scopedSlots,\n  vm.$slots,\n  vm.$scopedSlots\n);\n作用域插槽中父组件能够得到子组件的值是因为在renderSlot的时候执行会传入props，也就是上述_t第三个参数，父组件则能够得到子组件传递过来的值\n参考文献\n\njuejin.cn/post/6844903817746628615#heading-4\ndeveloper.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots\nvue3js.cn/docs/zh\nsegmentfault.com/a/1190000019492734\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对vue的mixin的理解，有什么应用场景！":{"title":"说说你对vue的mixin的理解，有什么应用场景！","links":[],"tags":["编程/FE/Vue"],"content":"一、mixin是什么\nMixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类\nMixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂\nVue中的mixin\n先来看一下官方定义\n\nmixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。\n\n本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等\n我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来\n在Vue中我们可以局部混入跟全局混入\n局部混入\n定义一个mixin对象，有组件options的data、methods属性\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log(&#039;hello from mixin!&#039;)\n    }\n  }\n}\n组件通过mixins属性调用mixin对象\nVue.component(&#039;componentA&#039;,{\n  mixins: [myMixin]\n})\n该组件在使用的时候，混合了mixin里面的方法，在自动执行created生命钩子，执行hello方法\n全局混入\n通过Vue.mixin()进行全局的混入\nVue.mixin({\n  created: function () {\n      console.log(&quot;全局混入&quot;)\n    }\n})\n使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）\n\n\n                  \n                  注意❗ \n                  \n                \nPS：全局混入常用于插件的编写\n\n注意事项：\n当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项\n但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子\n二、使用场景\n在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立\n这时，可以通过Vue的mixin功能将相同或者相似的代码提出来\n举个例子\n定义一个modal弹窗组件，内部通过isShowing来控制显示\nconst Modal = {\n  template: &#039;#modal&#039;,\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n定义一个tooltip提示框，内部通过isShowing来控制显示\nconst Tooltip = {\n  template: &#039;#tooltip&#039;,\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了\n首先抽出共同代码，编写一个mixin\nconst toggle = {\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n两个组件在使用上，只需要引入mixin\nconst Modal = {\n  template: &#039;#modal&#039;,\n  mixins: [toggle]\n};\n \nconst Tooltip = {\n  template: &#039;#tooltip&#039;,\n  mixins: [toggle]\n}\n\n通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用\n三、源码分析\n首先从Vue.mixin入手\n源码位置：/src/core/global-api/mixin.js\nexport function initMixin (Vue: GlobalAPI) {\n  Vue.mixin = function (mixin: Object) {\n    this.options = mergeOptions(this.options, mixin)\n    return this\n  }\n}\n主要是调用merOptions方法\n源码位置：/src/core/util/options.js\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n \nif (child.mixins) { // 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并\n    for (let i = 0, l = child.mixins.length; i &lt; l; i++) {\n    parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n}\n \n  const options = {} \n  let key\n  for (key in parent) {\n    mergeField(key) // 先遍历parent的key 调对应的strats[XXX]方法进行合并\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) { // 如果parent已经处理过某个key 就不处理了\n      mergeField(key) // 处理child中的key 也就parent中没有处理过的key\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key) // 根据不同类型的options调用strats中不同的方法进行合并\n  }\n  return options\n}\n从上面的源码，我们得到以下几点：\n\n优先递归处理 mixins\n先遍历合并parent 中的key，调用mergeField方法进行合并，然后保存在变量options\n再遍历 child，合并补上 parent 中没有的key，调用mergeField方法进行合并，保存在变量options\n通过 mergeField 函数进行了合并\n\n下面是关于Vue的几种类型的合并策略\n\n替换型\n合并型\n队列型\n叠加型\n\n替换型:  props 、methods、inject、` computed\n替换型合并有props、methods、inject、computed\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal: ?Object,\n  childVal: ?Object,\n  vm?: Component,\n  key: string\n): ?Object {\n  if (!parentVal) return childVal // 如果parentVal没有值，直接返回childVal\n  const ret = Object.create(null) // 创建一个第三方对象 ret\n  extend(ret, parentVal) // extend方法实际是把parentVal的属性复制到ret中\n  if (childVal) extend(ret, childVal) // 把childVal的属性复制到ret中\n  return ret\n}\nstrats.provide = mergeDataOrFn\n同名的props、methods、inject、computed会被后来者代替\n合并型：data\n和并型合并有：data\nstrats.data = function(parentVal, childVal, vm) {    \n    return mergeDataOrFn(\n        parentVal, childVal, vm\n    )\n};\n \nfunction mergeDataOrFn(parentVal, childVal, vm) {    \n    return function mergedInstanceDataFn() {        \n        var childData = childVal.call(vm, vm) // 执行data挂的函数得到对象\n        var parentData = parentVal.call(vm, vm)        \n        if (childData) {            \n            return mergeData(childData, parentData) // 将2个对象进行合并                                 \n        } else {            \n            return parentData // 如果没有childData 直接返回parentData\n        }\n    }\n}\n \nfunction mergeData(to, from) {    \n    if (!from) return to    \n    var key, toVal, fromVal;    \n    var keys = Object.keys(from);   \n    for (var i = 0; i &lt; keys.length; i++) {\n        key = keys[i];\n        toVal = to[key];\n        fromVal = from[key];    \n        // 如果不存在这个属性，就重新设置\n        if (!to.hasOwnProperty(key)) {\n            set(to, key, fromVal);\n        }      \n        // 存在相同属性，合并对象\n        else if (typeof toVal ==&quot;object&quot; &amp;&amp; typeof fromVal ==&quot;object&quot;) {\n            mergeData(toVal, fromVal);\n        }\n    }    \n    return to\n}\nmergeData函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：\n\n当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set方法其实就是一些合并重新赋值的方法）\n当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性\n\n队列性: 生命周期和 `watch\n队列性合并有：全部生命周期和watch\nfunction mergeHook (\n  parentVal: ?Array&lt;Function&gt;,\n  childVal: ?Function | ?Array&lt;Function&gt;\n): ?Array&lt;Function&gt; {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n \nLIFECYCLE_HOOKS.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n \n// watch\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox&#039;s Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent &amp;&amp; !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行\n叠加型（原型链）: component、directives、`filters\n叠加型合并有：component、directives、filters\nstrats.components=\nstrats.directives=\n \nstrats.filters = function mergeAssets(\n    parentVal, childVal, vm, key\n) {    \n    var res = Object.create(parentVal || null);    \n    if (childVal) { \n        for (var key in childVal) {\n            res[key] = childVal[key];\n        }   \n    } \n    return res\n}\n叠加型主要是通过原型链进行层层的叠加\n小结\n\n替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数。（唯一性）\n合并型策略是data, 通过set方法进行合并和重新赋值。（数据源）\n队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行。（执行）\n叠加型有component、directives、filters，通过原型链进行层层的叠加。（工具）\n\n参考文献\n\nzhuanlan.zhihu.com/p/31018570\njuejin.cn/post/6844904015495446536#heading-1\njuejin.cn/post/6844903846775357453\nvue3js.cn/docs/zh\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对webpack的理解！解决了什么问题！":{"title":"说说你对webpack的理解！解决了什么问题！","links":["C-Knowledge/前端/技术书籍/从-0-到-1-落地前端工程化/从-0-到-1-落地前端工程化-模块化规范"],"tags":["编程/Webpack","编程"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n模块化、高级特性（向后兼容）、热更新、压缩。\n\n一、背景\nWebpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源\n模块化\n最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的JS 文件中\n约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后调用模块化的成员\n&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;\n但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题\n项目一旦变大，上述问题会尤其明显\n随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中\nwindow.moduleA = {\n  method1: function () {\n    console.log(&#039;moduleA#method1&#039;)\n  }\n}\n这种方式也并没有解决第一种方式的依赖等问题\n再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下\n// module-a.js\n(function ($) {\n  var name = &#039;module-a&#039;\n \n  function method1 () {\n    console.log(name + &#039;#method1&#039;)\n    $(&#039;body&#039;).animate({ margin: &#039;200px&#039; })\n  }\n \n  window.moduleA = {\n    method1: method1\n  }\n})(jQuery)\n上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过script标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦\n理想的解决方式是，在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载进来\n除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是 CommonJS、ES Modules\n二、问题\n从后端渲染的JSP、PHP，到前端原生JavaScript，再到jQuery开发，再到目前的三大框架Vue、React、Angular\n开发方式，也从javascript到后面的es5、es6、7、8、9、10，再到typescript，包括编写CSS的预处理器less、scss等\n现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：\n\n需要通过模块化的方式来开发\n使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码\n监听文件的变化来并且反映到浏览器上，提高开发的效率\nJavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题\n开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化\n\n而webpack恰巧可以解决以上问题\n三、是什么\nwebpack 是一个用于现代JavaScript应用程序的静态模块打包工具\n\n静态模块\n\n这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进bundle.js的资源）\n当 webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle\n\nwebpack 的能力：\n编译代码能力，提高效率，解决浏览器兼容问题 \n \n模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题 \n\n万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 \n\n总结\nWebpack是一个前端模块打包工具。它可以将多个模块按照依赖关系进行静态分析，并生成一个或多个打包后的文件。Webpack的主要功能包括：\n1. 模块打包\n将项目中的所有模块（JavaScript、CSS、图片等）当作一个整体，通过依赖关系将它们打包成一个或多个静态资源文件。\n2. 依赖管理\nWebpack可以分析模块之间的依赖关系，根据配置的入口文件找出所有依赖的模块，并将其整合到打包结果中。\n3. 文件转换\nWebpack本身只能处理JavaScript模块，但通过加载器（Loader）的使用，可以将其他类型的文件（如CSS、LESS、图片等）转换为有效的模块，使其能够被打包到最终的结果中。\n4. 代码拆分\nWebpack支持将代码拆分成多个模块，按需加载，实现按需加载和提升应用性能。\n5. 插件系统\nWebpack提供了丰富的插件系统，可以通过插件实现各种功能的扩展，例如压缩代码、自动生成HTML文件等。\n总之，Webpack的主要功能是将项目中的多个模块打包成一个或多个静态资源文件，并提供了丰富的功能和插件系统来满足前端开发的需求。\n\n参考文献\n\nwebpack.docschina.org/concepts/\nzhuanlan.zhihu.com/p/267875652\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！":{"title":"说说你对函数式编程的理解！优缺点！","links":["C-Knowledge/前端/开发技术/JavaScript/高阶函数","Web-Clip/@简明-JavaScript-函数式编程——入门篇---知乎","Web-Clip/@函数式编程初探---阮一峰的网络日志","Web-Clip/@函数式编程入门教程---阮一峰的网络日志","Web-Clip/@函数柯里化：三行代码实现-add(1)(2)(3)---掘金"],"tags":["编程/JavaScript"],"content":"一、是什么\n函数式编程是一种”编程范式”（programming paradigm），一种编写程序的方法论\n主要的编程范式有三种：命令式编程，声明式编程和函数式编程\n相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程\n举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下\n// 命令式编程\nvar array = [0, 1, 2, 3]\nfor(let i = 0; i &lt; array.length; i++) {\n    array[i] = Math.pow(array[i], 2)\n}\n \n// 函数式方式\n[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2))\n简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果\n即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值\n\n可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合\n二、概念\n纯函数\n函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数\n纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变\n\n举一个简单的例子\nlet double = value=&gt;value*2;\n特性：\n\n函数内部传入指定的值，就会返回确定唯一的值\n不会造成超出作用域的变化，例如修改全局变量或引用传递的参数\n\n优势：\n\n使用纯函数，我们可以产生可测试的代码\n\ntest(&#039;double(2) 等于 4&#039;, () =&gt; {\n  expect(double(2)).toBe(4);\n})\n\n不依赖外部环境计算，不会产生副作用，提高函数的复用性\n可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读\n可以组装成复杂任务的可能性。符合模块化概念及单一职责原则\n\n高阶函数\n在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数\n编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示\n\n在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数\n通过高阶函数抽象过程，注重结果，如下面例子\nconst forEach = function(arr,fn){\n    for(let i=0;i&lt;arr.length;i++){\n        fn(arr[i]);\n    }\n}\nlet arr = [1,2,3];\nforEach(arr,(item)=&gt;{\n    console.log(item);\n})\n上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么\n高阶函数存在缓存的特性，主要是利用闭包作用\nconst once = (fn)=&gt;{\n    let done = false;\n    return function(){\n        if(!done){\n            fn.apply(this,fn);\n        }else{\n            console.log(&quot;该函数已经执行&quot;);\n        }\n        done = true;\n    }\n}\n柯里化\n柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程\n一个二元函数如下：\nlet fn = (x,y)=&gt;x+y;\n转化成柯里化函数如下：\nconst curry = function(fn){\n    return function(x){\n        return function(y){\n            return fn(x,y);\n        }\n    }\n}\nlet myfn = curry(fn);\nconsole.log(myfn(1)(2));\n上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况\n// 多参数柯里化；\nconst curry = function(fn){\n    return function curriedFn(...args){\n        if(args.length&lt;fn.length){\n            return function(){\n                return curriedFn(...args.concat([...arguments]));\n            }\n        }\n        return fn(...args);\n    }\n}\nconst fn = (x,y,z,a)=&gt;x+y+z+a;\nconst myfn = curry(fn);\nconsole.log(myfn(1)(2)(3)(1));\n关于柯里化函数的意义如下：\n\n让纯函数更纯，每次接受一个参数，松散解耦\n惰性执行\n\n组合与管道\n组合函数，目的是将多个函数组合成一个函数\n举个简单的例子：\nfunction afn(a){\n    return a*2;\n}\nfunction bfn(b){\n    return b*3;\n}\nconst compose = (a,b)=&gt;c=&gt;a(b(c));\nlet myfn =  compose(afn,bfn);\nconsole.log( myfn(2));\n可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -&gt; afn 的流水线\n下面再来看看如何实现一个多函数组合：\nconst compose = (...fns)=&gt;val=&gt;fns.reverse().reduce((acc,fn)=&gt;fn(acc),val);\ncompose执行是从右到左的。而管道函数，执行顺序是从左到右执行的\nconst pipe = (...fns)=&gt;val=&gt;fns.reduce((acc,fn)=&gt;fn(acc),val);\n组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑\n三、优缺点\n优点\n\n更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况\n更简单的复用：固定输入→固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响\n更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性\n隐性好处。减少代码量，提高维护性\n\n缺点：\n\n性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销\n资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式\n递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作\n\n总结\n\n函数式编程是一种编程范式，它是声明式编程的子集\n避免使用状态、异变对象，最小化副作用\n基于 lambda 演算，函数可以作为入参和出参\n\n扩展阅读\n\n@简明 JavaScript 函数式编程——入门篇 - 知乎\n@函数式编程初探 - 阮一峰的网络日志\n@函数式编程入门教程 - 阮一峰的网络日志\n@函数柯里化：三行代码实现 add(1)(2)(3) - 掘金\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对数据结构的理解！有哪些！区别！":{"title":"说说你对数据结构的理解！有哪些！区别！","links":["C-Knowledge/前端/技术书籍/数据结构手册/数据结构手册"],"tags":["编程/数据结构"],"content":"一、是什么\n数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合\n前面讲到，一个程序 = 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率\n数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：\n\n集合结构：该结构的数据元素间的关系是“属于同一个集合”\n线性结构：该结构的数据元素之间存在着一对一的关系\n树型结构：该结构的数据元素之间存在着一对多的关系\n图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构\n\n由于数据结构种类太多，逻辑结构可以再分成为：\n\n线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的\n非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联\n\n\n二、有哪些\n常见的数据结构有如下：\n\n数组\n栈\n队列\n链表\n树\n图\n堆\n散列表\n\n数组\n在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组\n栈\n一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据\n先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据\n队列\n跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作\n链表\n是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成\n一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\n树\n树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点\n图\n一种线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系\n堆\n堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆\n散列表\n若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上，不需比较便可直接取得所查记录\n三、区别\n上述的数据结构，之前的区别可以分成线性结构和非线性结构：\n\n线性结构有：数组、栈、队列、链表等\n非线性结构有：树、图、堆等\n\n扩展阅读\n\nzh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\nbaike.baidu.com/item/数据结构/1450\n数据结构手册\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法中时间复杂度，空间复杂度的理解！如何计算！":{"title":"说说你对算法中时间复杂度，空间复杂度的理解！如何计算！","links":[],"tags":["编程/算法"],"content":"一、前言\n算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别\n衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：\n\n时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。\n空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述\n\n通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的\n一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况\n最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差\n二、时间复杂度\n\n\n                  \n                  提示💡 \n                  \n                \nMax(执行次数*嵌套层数 )\n\n时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否\n一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多\n算法的复杂度通常用大O符号表述，定义为T(n) = O(f(n))，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：\n![](C Knowledge/前端/职业规划/前端面试宝典/八股文/attachments/ecb52e074d1b18661dbcf5859efda7cd_MD5.webp)\n从上述可以看到，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：\nΟ(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)\n\n\n\n                  \n                  注意❗ \n                  \n                \n注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长\n\n关于如何计算时间复杂度，可以看看如下简单例子：\nfunction process(n) {\n  let a = 1\n  let b = 2\n  let sum = a + b\n  for(let i = 0; i &lt; n; i++) {\n    sum += i\n  }\n  return sum\n}\n该函数算法需要执行的运算次数用输入大小n的函数表示，即 T(n) = 2 + n + 1，那么时间复杂度为O(n + 3)，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为O(n)\n又比如下面的例子：\nfunction process(n) {\n let count = 0\n  for(let i = 0; i &lt; n; i++){\n    for(let i = 0; i &lt; n; i++){\n      count += 1\n    }\n  }\n}\n循环里面嵌套循环，外面的循环执行一次，里面的循环执行n次，因此时间复杂度为 O(n*n*1 + 2) = O(n^2)\n对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：\nfunction process(n) {\n  let sum = 0\n  for(let i = 0; i &lt; n; i++) {\n    sum += i\n  }\n  for(let i = 0; i &lt; n; i++){\n    for(let i = 0; i &lt; n; i++){\n      sum += 1\n    }\n  }\n  return sum\n}\n上述第一部分复杂度为O(n)，第二部分复杂度为O(n^2)，总复杂度为max(O(n^2), O(n)) = O(n^2)\n又如下一个例子：\nfunction process(n) {\n  let i = 1; // ①\n  while (i &lt;= n) {\n     i = i * 2; // ②\n  }\n}\n循环语句中以2的倍数来逼近n，每次都乘以2。如果用公式表示就是1 * 2 * 2 * 2 … * 2 ⇐n，也就是说2的x次方小于等于n时会执行循环体，==记作2^x &lt;= n==，于是得出x&lt;=logn\n因此循环在执行logn次之后，便结束，因此时间复杂度为O(logn)\n同理，如果一个O(n)循环里面嵌套O(logn)的循环，则时间复杂度为O(nlogn)，像O(n^3)无非也就是嵌套了三层O(n)循环\n三、空间复杂度\n空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量\n除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间\n下面给出空间复杂度为O(1)的示例，如下\nlet a = 1\nlet b = 2\nlet c = 3\n上述代码的临时空间不会随着n的变化而变化，因此空间复杂度为O(1)\nlet arr []\nfor(i=1; i&lt;=n; ++i){\n  arr.push(i)\n}\n上述可以看到，随着n的增加，数组的占用的内存空间越大\n通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为O(1)，一个一维数组a[n]，空间复杂度O(n)，二维数组为O(n^2)\n参考文献\n\njuejin.cn/post/6844904167824162823#heading-7\nzhuanlan.zhihu.com/p/50479555\ncloud.tencent.com/developer/article/1769988\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对算法的理解！应用场景！":{"title":"说说你对算法的理解！应用场景！","links":[],"tags":["编程/算法"],"content":"一、是什么\n算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制\n也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出\n如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题\n一个程序=算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割\n因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构\n针对上述，可以得出一个总结：不同的算法可能用不同的时间、空间或效率来完成同样的任务\n二、特性\n关于算法的五大特性，有如下：\n\n有限性（Finiteness）：一个算法必须保证执行有限步之后结束\n确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义\n输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件\n输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义\n可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）\n\n三、应用场景\n在前端领域中，数据结构与算法无法不在，例如现在的vue或者react项目，实现[[什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路|虚拟DOM]]或者[[说说对Fiber架构的理解！解决了什么问题！|Fiber结构]]，本质就是一种数据结构，如下一个简单的虚拟DOM：\n{\n  type: &#039;div&#039;,\n    props: {\n      name: &#039;lucifer&#039;\n    },\n      children: [{\n        type: &#039;span&#039;,\n        props: {},\n        children: []\n      }]\n}\nvue与react都能基于基于对应的数据结构实现diff算法，提高了整个框架的性能以及拓展性\n包括在前端javascript编译的时候，都会生成对应的抽象语法树AST，其本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法，也是babel， PostCSS, prettier， typescript\n除了这些框架或者工具底层用到算法与数据结构之外，日常业务也无处不在，例如实现一个输入框携带联想功能，如下：\n\n如果我们要实现这个功能， 则可以使用前缀树，如下：\n\n包括前端可能会做一些对字符串进行相似度检测，例如”每日一题”和”js每日一题”两个字符串进行相似度对比，这种情况可以通过“最小编辑距离”算法，如果a和b的编辑距离越小，我们认为越相似\n日常在编写任何代码的都需要一个良好的算法思维，选择好的算法或者数据结构，能让整个程序效率更高\n参考文献\n\nbaike.baidu.com/item/%E7%AE%97%E6%B3%95/209025\nlucifer.ren/blog/2019/09/18/algorthimn-fe-1/\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说如何借助webpack来优化前端性能！":{"title":"说说如何借助webpack来优化前端性能！","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/前端性能优化"],"tags":["编程/Webpack"],"content":"一、背景\n随着前端的项目逐渐扩大，必然会带来的一个问题就是性能\n尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃\n一般项目在完成后，会通过webpack进行打包，利用webpack对前端项目性能优化是一个十分重要的环节\n二、如何优化\n通过webpack优化前端的手段有：\n\nJS代码压缩\nCSS代码压缩\nHtml文件代码压缩\n文件大小压缩\n图片压缩\nTree Shaking\n代码分离\n内联 chunk\n\nJS 代码压缩\nterser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小\n在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下：\nconst TerserPlugin = require(&#039;terser-webpack-plugin&#039;)\nmodule.exports = {\n    ...\n    optimization: {\n        minimize: true,\n        minimizer: [\n            new TerserPlugin({\n                parallel: true // 电脑cpu核数-1\n            })\n        ]\n    }\n}\n属性介绍如下：\n\nextractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释\nparallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1\nterserOptions：设置我们的terser相关的配置：\ncompress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true\nmangle：设置丑化相关的选项，可以直接设置为true\ntoplevel：底层变量是否进行转换\nkeep_classnames：保留类的名称\nkeep_fnames：保留函数的名称\n\nCSS 代码压缩\nCSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等\nCSS的压缩我们可以使用另外一个插件：css-minimizer-webpack-plugin\nnpm install css-minimizer-webpack-plugin -D\n配置方法如下：\nconst CssMinimizerPlugin = require(&#039;css-minimizer-webpack-plugin&#039;)\nmodule.exports = {\n    // ...\n    optimization: {\n        minimize: true,\n        minimizer: [\n            new CssMinimizerPlugin({\n                parallel: true\n            })\n        ]\n    }\n}\nHtml文件代码压缩\n使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化\nmodule.exports = {\n    ...\n    plugin:[\n        new HtmlwebpackPlugin({\n            ...\n            minify:{\n                minifyCSS:false, // 是否压缩css\n                collapseWhitespace:false, // 是否折叠空格\n                removeComments:true // 是否移除注释\n            }\n        })\n    ]\n}\n设置了minify，实际会使用另一个插件html-minifier-terser\n文件大小压缩\n对文件的大小进行压缩，减少http传输过程中宽带的损耗\nnpm install compression-webpack-plugin -D\nnew ComepressionPlugin({\n    test:/\\.(css|js)$/,  // 哪些文件需要压缩\n    threshold:500, // 设置文件多大开始压缩\n    minRatio:0.7, // 至少压缩的比例\n    algorithm:&quot;gzip&quot;, // 采用的压缩算法\n})\n图片压缩\n一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要\n配置方法如下：\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: [\n        {\n          loader: &#039;file-loader&#039;,\n          options: {\n            name: &#039;[name]_[hash].[ext]&#039;,\n            outputPath: &#039;images/&#039;,\n          }\n        },\n        {\n          loader: &#039;image-webpack-loader&#039;,\n          options: {\n            // 压缩 jpeg 的配置\n            mozjpeg: {\n              progressive: true,\n              quality: 65\n            },\n            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭\n            optipng: {\n              enabled: false,\n            },\n            // 使用 imagemin-pngquant 压缩 png\n            pngquant: {\n              quality: &#039;65-90&#039;,\n              speed: 4\n            },\n            // 压缩 gif 的配置\n            gifsicle: {\n              interlaced: false,\n            },\n            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n            webp: {\n              quality: 75\n            }\n          }\n        }\n      ]\n    },\n  ]\n} \nTree Shaking\nTree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）\n在webpack实现Trss shaking有两种不同的方案：\n\nusedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的\nsideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n\n两种不同的配置方案， 有不同的效果\nusedExports\n配置方法也很简单，只需要将usedExports设为true\nmodule.exports = {\n    ...\n    optimization:{\n        usedExports\n    }\n}\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码\n如下面sum函数没被用到，webpack打包会添加注释，terser在优化时，则将该函数去掉\n\nsideEffects\nsideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性\n如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports\n如果有些文件需要保留，可以设置为数组的形式\n&quot;sideEffecis&quot;:[\n    &quot;./src/util/format.js&quot;,\n    &quot;*.css&quot; // 所有的css文件\n]\n上述都是关于javascript的tree shaking，css同样也能够实现tree shaking\ncss tree shaking\ncss进行tree shaking优化可以安装PurgeCss插件\nnpm install purgecss-plugin-webpack -D\nconst PurgeCssPlugin = require(&#039;purgecss-webpack-plugin&#039;)\nmodule.exports = {\n    ...\n    plugins:[\n        new PurgeCssPlugin({\n            path:glob.sync(`${path.resolve(&#039;./src&#039;)}/**/*`), {nodir:true}// src里面的所有文件\n            satelist:function(){\n                return {\n                    standard:[&quot;html&quot;]\n                }\n            }\n        })\n    ]\n}\n\npaths：表示要检测哪些目录下的内容需要被分析，配合使用glob\n默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性\n\n代码分离\n将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件\n默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度\n代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能\n这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可\n默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all\nmodule.exports = {\n    ...\n    optimization:{\n        splitChunks:{\n            chunks:&quot;all&quot;\n        }\n    }\n}\nsplitChunks主要属性有如下：\n\nChunks，对同步代码还是异步代码进行处理\nminSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分\nmaxSize： 将大于maxSize的包，拆分为不小于minSize的包\nminChunks：被引入的次数，默认是1\n\n内联chunk\n可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的\nconst InlineChunkHtmlPlugin = require(&#039;react-dev-utils/InlineChunkHtmlPlugin&#039;)\nconst HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;)\nmodule.exports = {\n    ...\n    plugin:[\n        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\\.js/]\n}\n三、总结\n关于webpack对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化，以下是一些方面需要注意并采取最佳实践的建议：\n1. 减小文件体积\n\n通过Code Splitting将应用程序拆分为多个代码块，并按需加载它们。\n压缩代码使用Webpack插件（如UglifyJsPlugin）来删除未使用的代码。\n使用Tree Shaking来删除未使用的代码，可在Webpack中通过配置optimization.usedExports和optimization.sideEffects来实现。\n将图片、字体等静态资源进行压缩和优化，比如使用url-loader和file-loader。\n\n2. 加快构建速度\n\n使用缓存提高构建速度，可以通过配置devtool: &#039;cheap-module-source-map&#039;启用sourcemap的快速构建版本。\n设置合适的resolve.extensions和resolve.modules来减少模块解析的时间。\n使用Webpack的resolve.alias配置项将常用的模块路径映射到简短的别名，加快模块的查找速度。\n限制loader的作用范围，只对需要处理的文件使用特定的loader。\n使用HappyPack或thread-loader等工具以并行方式在多个子进程中处理任务，加速构建过程。\n\n3. 优化打包输出\n\n配置output.filename和output.chunkFilename使用较短的文件名、hash值等。\n使用Webpack的optimization.splitChunks来提取和共享共同的代码块，避免重复加载的代码。\n为要提取的代码块设置合适的缓存策略，通过配置optimization.runtimeChunk选项来为包含运行时代码的块设置不同的缓存策略。\n\n4. 其他优化建议\n\n在开发环境中禁用一些不必要的优化配置，如关闭UglifyJsPlugin等。\n使用Webpack Bundle Analyzer工具来分析和可视化打包后的代码结构，找出优化的潜力。\n使用Webpack Dev Server来提供开发服务器，提供快速的热更新和热替换能力。\n\n通过遵循以上最佳实践，你可以优化Webpack的性能，提高构建速度和应用程序的加载速度。\n参考文献\n\nzhuanlan.zhihu.com/p/139498741\nvue3js.cn/interview/\n\n\n\n前端性能优化\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说对-Node-中的-Buffer-的理解！应用场景！":{"title":"说说对 Node 中的 Buffer 的理解！应用场景！","links":[],"tags":["编程/Node"],"content":"一、是什么\n在Node应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而Buffer就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据\n在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量\n如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理\n这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 RAM 中\n简单来讲，Nodejs不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在Buffer中，即在RAM中，直至将它们发送完毕\n上面讲到了Buffer是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：00000000，也就是一个字节\n例如：\nconst buffer = Buffer.from(&quot;why&quot;)\n其存储过程如下图所示：\n\n二、使用方法\nBuffer 类在全局作用域中，无须require导入\n创建Buffer的方法有很多种，我们讲讲下面的两种常见的形式：\n\nBuffer.from()\nBuffer.alloc()\n\nBuffer.from()\nconst b1 = Buffer.from(&#039;10&#039;);\nconst b2 = Buffer.from(&#039;10&#039;, &#039;utf8&#039;);\nconst b3 = Buffer.from([10]);\nconst b4 = Buffer.from(b3);\n \nconsole.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;\nBuffer.alloc()\nconst bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区\nconst bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节\nconsole.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\nconsole.log(bAlloc2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;\n在上面创建buffer后，则能够toString的形式进行交互，默认情况下采取utf8字符编码形式，如下\nconst buffer = Buffer.from(&quot;你好&quot;);\nconsole.log(buffer);\n// &lt;Buffer e4 bd a0 e5 a5 bd&gt;\nconst str = buffer.toString();\nconsole.log(str);\n// 你好\n如果编码与解码不是相同的格式则会出现乱码的情况，如下：\nconst buffer = Buffer.from(&quot;你好&quot;,&quot;utf-8 &quot;);\nconsole.log(buffer);\n// &lt;Buffer e4 bd a0 e5 a5 bd&gt;\nconst str = buffer.toString(&quot;ascii&quot;);\nconsole.log(str); \n// d= e%=\n当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：\nconst buf = Buffer.from(&#039;Node.js 技术栈&#039;, &#039;UTF-8&#039;);\n \nconsole.log(buf)          // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;\nconsole.log(buf.length)   // 17\n \nconsole.log(buf.toString(&#039;UTF-8&#039;, 0, 9))  // Node.js �\nconsole.log(buf.toString(&#039;UTF-8&#039;, 0, 11)) // Node.js 技\n所支持的字符集有如下：\n\nascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的\nutf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8\nutf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）\nucs2，utf16le 的别名\nbase64：Base64 编码\nlatin：一种把 Buffer 编码成一字节编码的字符串的方式\nbinary：latin1 的别名，\nhex：将每个字节编码为两个十六进制字符\n\n三、应用场景\nBuffer的应用场景常常与流的概念联系在一起，例如有如下：\n\nI/O操作\n加密解密\nzlib.js\n\nI/O操作\n通过流的形式，将一个文件的内容读取到另外一个文件\nconst fs = require(&#039;fs&#039;);\n \nconst inputStream = fs.createReadStream(&#039;input.txt&#039;); // 创建可读流\nconst outputStream = fs.createWriteStream(&#039;output.txt&#039;); // 创建可写流\n \ninputStream.pipe(outputStream); // 管道读写\n加解密\n在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 string 或 Buffer 类型\nzlib.js\nzlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能\n参考文献\n\nnodejs.cn/api/buffer.html\nsegmentfault.com/a/1190000019894714\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述Canvas中的路径（Path）是什么，以及如何使用路径绘制复杂的形状！":{"title":"请描述Canvas中的路径（Path）是什么，以及如何使用路径绘制复杂的形状！","links":[],"tags":["编程/Canvas"],"content":"在Canvas中，路径（Path）是由一系列的线段、曲线和子路径组成的图形形状。可以通过使用路径来绘制复杂的形状，例如多边形、曲线、闭合图形等。\n要使用路径绘制复杂的形状，可以按照以下步骤进行操作：\n\n在HTML页面中创建一个Canvas元素：\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n\n使用JavaScript获取Canvas元素的引用并获取绘图上下文：\n\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n\n开始路径：\n\nctx.beginPath();\n\n绘制路径的各个部分：\n\n\n使用ctx.moveTo(x, y)将绘图游标移动到指定的坐标点(x, y)，用于确定起始点。\n使用ctx.lineTo(x, y)从当前绘图位置绘制一条直线到指定的坐标点(x, y)。可以多次调用lineTo来绘制直线段，从而组成图形的各个边。\n使用曲线绘制方法如ctx.arcTo、ctx.quadraticCurveTo、ctx.bezierCurveTo等来绘制曲线段，用于创建圆角、二次贝塞尔曲线和三次贝塞尔曲线等复杂形状。\n可以多次使用上述方法，组合绘制各个部分形成复杂的路径。\n\n\n闭合路径（可选）：\n\n\n使用ctx.closePath()将路径的最后一个点与起始点连接，形成闭合路径。\n\n\n设置路径的样式：\n\n\n使用ctx.fillStyle设置填充颜色。\n使用ctx.strokeStyle设置描边颜色。\n使用ctx.lineWidth设置描边线条的宽度。\n\n\n绘制路径：\n\n\n使用ctx.fill()填充路径内部区域。\n使用ctx.stroke()描绘路径的线条。\n\n以下是一个绘制一个五角星形状的示例代码：\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n \nctx.beginPath();\nctx.moveTo(200, 50);\nctx.lineTo(250, 150);\nctx.lineTo(350, 150);\nctx.lineTo(275, 215);\nctx.lineTo(325, 325);\nctx.lineTo(200, 260);\nctx.lineTo(75, 325);\nctx.lineTo(125, 215);\nctx.lineTo(50, 150);\nctx.lineTo(150, 150);\nctx.closePath();\n \nctx.fillStyle = &#039;yellow&#039;;\nctx.strokeStyle = &#039;black&#039;;\nctx.lineWidth = 2;\n \nctx.fill();\nctx.stroke();\n\n这段代码使用路径的连续线段来描述五角星的形状，然后使用fill()方法填充形状内部，使用stroke()方法描绘形状的线条。你可以根据需要修改路径的顶点坐标、样式和色彩等参数，创建并绘制其他复杂的形状。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的协作开发流程，包括分支管理和代码合并的步骤。":{"title":"请描述一下Git的协作开发流程，包括分支管理和代码合并的步骤。","links":[],"tags":["编程/Git"],"content":"Git 的协作开发流程包括以下步骤：\n\n创建本地分支：您需要创建一个本地分支来开始您的开发工作。在命令行中，使用 git branch 命令创建一个新分支，例如：\n\ngit branch    \n\n创建远程分支：您需要将本地分支推送到远程仓库中，以便其他开发人员可以访问它。在命令行中，使用 git push 命令将本地分支推送到远程仓库中，例如：\n\ngit push origin main    \n\n共享代码：您需要将您的代码推送到远程仓库中，以便其他开发人员可以访问它。在命令行中，使用 git push 命令将您的代码推送到远程仓库中，例如：\n\ngit push origin main    \n\n合并代码：您需要合并您的代码到远程分支中。在命令行中，使用 git pull 命令从远程仓库中拉取最新的代码，并使用 git merge 命令将其与当前分支合并，例如：\n\ngit merge origin main    \n\n提交更改：您需要提交您的更改到远程仓库中。在命令行中，使用 git commit 命令创建一个新的提交，并包含您的更改，例如：\n\ngit commit -m &quot;Initial commit&quot;    \n\n推送到远程分支：您需要将您的更改推送到远程分支中。在命令行中，使用 git push 命令将您的更改推送到远程分支中，例如：\n\ngit push origin main    \n\n审查代码：其他开发人员可以审查您的代码，并提供反馈和建议。您可以选择在本地分支上进行修改，并再次提交更改到远程分支中。\n\n以上是 Git 的协作开发流程，包括分支管理和代码合并的步骤。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的工作流程。":{"title":"请描述一下Git的工作流程。","links":[],"tags":["编程/Git"],"content":"Git的工作流程通常包括以下几个步骤：\n\n\n克隆（Clone）：首先，通过克隆一个远程仓库到本地，创建一个本地仓库的副本。这样可以在本地进行开发和修改。\n\n\n添加和修改（Add and Modify）：在本地仓库中进行代码的添加和修改。开发者可以通过添加新文件、修改现有文件或删除文件来进行开发工作。\n\n\n暂存（Stage）：将修改的文件添加到暂存区（也称为索引），准备提交到版本库。暂存区相当于一个缓冲区，用于存放即将提交的修改。\n\n\n提交（Commit）：将暂存区的修改提交到版本库。每次提交都会生成一个唯一的提交记录，包含了修改的详细信息，如作者、时间戳和提交消息。\n\n\n推送（Push）：将本地的提交推送到远程仓库，与团队成员共享代码。推送操作将本地的提交同步到远程仓库，使得其他人可以看到和使用这些修改。\n\n\n拉取（Pull）：从远程仓库拉取最新的代码更新到本地仓库。当其他人推送了新的修改到远程仓库时，开发者可以通过拉取操作获取这些更新。\n\n\n合并（Merge）：将不同分支的修改合并到一起。当开发者在不同的分支上进行并行开发时，可以使用合并操作将分支的修改合并到主分支或其他分支上。\n\n\n冲突解决（Conflict Resolution）：当多个分支对同一文件进行了不同的修改时，可能会发生冲突。开发者需要手动解决这些冲突，选择保留哪些修改或进行修改的合并。\n\n\n这些步骤构成了Git的基本工作流程。通过这个工作流程，开发者可以有效地管理代码的版本、协作开发和跟踪修改历史。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请描述一下Git的标签（tag）是什么，以及如何创建和使用标签！":{"title":"请描述一下Git的标签（tag）是什么，以及如何创建和使用标签！","links":[],"tags":["编程/Git"],"content":"在Git中，标签（tag）是用于标记特定提交的静态引用。 它们通常用于标记项目的版本号或重要的里程碑。\n创建标签的方法有两种：\n\n轻量标签（Lightweight Tags）：使用git tag &lt;tag_name&gt;命令创建轻量标签，例如git tag v1.0.0。轻量标签只是一个指向特定提交的引用，不包含额外的信息。\n注释标签（Annotated Tags）：使用git tag -a &lt;tag_name&gt; -m &quot;&lt;tag_message&gt;&quot;命令创建注释标签，例如git tag -a v1.0.0 -m &quot;Release version 1.0.0&quot;。注释标签包含标签名称、标签信息、标签作者和创建日期等额外的信息。\n\n使用标签的主要目的是在特定的提交上创建一个易于识别和引用的标记。可以使用以下命令来使用标签：\n\n查看标签：使用git tag命令可以列出所有的标签。\n切换到标签：使用git checkout &lt;tag_name&gt;命令可以切换到指定的标签，查看标签所对应的代码状态。\n推送标签：使用git push origin &lt;tag_name&gt;命令可以将指定的标签推送到远程仓库。\n删除标签：使用git tag -d &lt;tag_name&gt;命令可以删除本地的标签。\n\n\n需要注意的是，标签是与提交相关联的，而不是与分支相关联。因此，在切换到标签时，会进入一个“分离头指针”的状态，不会自动创建分支。如果需要在标签上进行开发或修改，建议创建一个新的分支来工作。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简要说明Canvas是什么，以及它在前端开发中的作用。":{"title":"请简要说明Canvas是什么，以及它在前端开发中的作用。","links":[],"tags":["编程/Canvas"],"content":"Canvas是HTML5提供的一种绘图API，它可以通过JavaScript在网页上绘制图形、图像和动画。\nCanvas提供了一个类似画布的区域，可以在其中动态绘制图形。\n\n它是一种基于像素的绘图技术，可以通过一系列的API方法来操作像素数据，创建并操纵图形元素。\n\n在前端开发中，Canvas具有广泛的应用。\n\n创建交互式的数据可视化\n绘制图表\n图像编辑工具\n游戏和动画效果\n…\n\n\nCanvas提供了丰富的绘图函数和配置选项，使开发者能够灵活地绘制各种形状、渲染图像、处理用户输入事件等。通过使用Canvas，开发者可以在网页上实现复杂有效的可视化效果，提升用户体验，并且可以与其他Web技术（如CSS和JavaScript）进行深度集成，实现更丰富的交互和动态效果。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请简述一下uni-app的定义和特点。":{"title":"请简述一下uni-app的定义和特点。","links":[],"tags":["编程/uniapp"],"content":"\nuni-app是一款基于Vue.js框架开发的跨平台开发工具，它可以用于快速构建同时运行在多个平台（包括iOS、Android、Web以及小程序）的应用程序。uni-app实现了一套代码，多端运行的目标，通过一套代码编写，可以生成多个平台的应用程序，开发者无需针对不同平台进行独立开发，极大地提高了开发效率。\nuni-app具有以下几个特点：\n\n跨平台：uni-app可以将一个代码库同时编译为多个平台的应用程序，包括iOS、Android、Web以及小程序。这样开发者只需编写一次代码，即可在不同平台上运行。\n性能优秀：uni-app通过原生渲染和跨平台性能优化，保证了应用程序的性能表现。\n开发便捷：基于Vue.js框架，使用熟悉的Vue语法进行开发，减少了学习成本和开发难度。\n多端共享：uni-app支持多端组件和API共享，开发者可以共享大部分代码和逻辑，减少了重复开发的工作量。\n生态丰富：uni-app生态中拥有丰富的插件和扩展，可以方便地集成第三方功能和服务。\n更新迭代：uni-app团队保持着良好的更新迭代节奏，不断优化和改进开发体验和功能。\n\n\n通过这些特点，uni-app提供了一种高效、便捷的方式，让开发者能够快速构建跨平台应用，降低开发成本，提高开发效率。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释Canvas中的渐变（Gradient）是什么，以及如何使用渐变填充或描边！":{"title":"请解释Canvas中的渐变（Gradient）是什么，以及如何使用渐变填充或描边！","links":[],"tags":["编程/Canvas"],"content":"在Canvas中，渐变（Gradient）是一种用于创建平滑过渡效果的特殊样式。它可以用作填充或描边的颜色，允许你在形状上应用从一个颜色到另一个颜色的平滑过渡。\nCanvas提供了两种类型的渐变：线性渐变（Linear Gradient）和径向渐变（Radial Gradient）。\n\n线性渐变（Linear Gradient）：在两个指定点之间创建一个线性的颜色过渡。\n\n\n创建线性渐变对象：\n\nconst gradient = ctx.createLinearGradient(x1, y1, x2, y2);\nx1、y1 是起始点的坐标，x2、y2 是结束点的坐标。\n\n添加颜色停止点（Color Stops）：\n\ngradient.addColorStop(offset, color);\noffset 是 0.0（起始点）到 1.0（结束点）之间的值，表示颜色过渡的位置。\n\n应用渐变样式：\n\nctx.fillStyle = gradient;\n或\nctx.strokeStyle = gradient;\n\n径向渐变（Radial Gradient）：以一个中心点为基准，在两个圆之间创建一个径向的颜色过渡。\n\n\n创建径向渐变对象：\n\nconst gradient = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);\nx1、y1 是起始圆的中心坐标，r1 是起始圆的半径。x2、y2 是结束圆的中心坐标，r2 是结束圆的半径。\n\n添加颜色停止点（Color Stops）：\n\ngradient.addColorStop(offset, color);\noffset 是 0.0（起始圆）到 1.0（结束圆）之间的值，表示颜色过渡的位置。\n\n应用渐变样式：\n\nctx.fillStyle = gradient;\n或\nctx.strokeStyle = gradient;\n以下是一个使用线性渐变填充矩形的示例代码：\nconst canvas = document.getElementById(&#039;myCanvas&#039;);\nconst ctx = canvas.getContext(&#039;2d&#039;);\n \n// 创建线性渐变对象\nconst gradient = ctx.createLinearGradient(0, 0, 400, 0);\n \n// 添加颜色停止点\ngradient.addColorStop(0, &#039;red&#039;);\ngradient.addColorStop(0.5, &#039;yellow&#039;);\ngradient.addColorStop(1, &#039;blue&#039;);\n \n// 应用渐变样式\nctx.fillStyle = gradient;\n \n// 绘制矩形\nctx.fillRect(50, 50, 300, 150);\n\n在这个示例中，我们创建了一个从红色到黄色再到蓝色的线性渐变，然后将渐变应用为矩形的填充样式，通过fillRect方法绘制矩形区域。\n你可以根据需要调整渐变的起始点和结束点、添加多个颜色停止点，以及将渐变应用于填充或描边样式，以实现更多有趣的效果。类似地，你可以使用径向渐变对象来创建径向渐变并应用样式。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的三个基本状态：已修改（modified）、已暂存（staged）和已提交（committed）。":{"title":"请解释一下Git的三个基本状态：已修改（modified）、已暂存（staged）和已提交（committed）。","links":[],"tags":["编程/Git"],"content":"Git的三个基本状态是：\n\n\n已修改（modified）：指的是文件在上次提交后发生了修改，但还没有被保存到Git数据库中。\n\n\n已暂存（staged）：指的是将已修改的文件标记为准备提交的状态。通过使用git add命令，可以将修改的文件添加到暂存区。\n\n\n已提交（committed）：指的是将已暂存的文件永久保存到Git数据库中。通过使用git commit命令，可以将暂存区的文件提交到本地仓库。\n\n\n\n这三个状态是Git版本控制系统中的关键概念，它们帮助我们管理文件的修改和提交历史。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的合并（merge）和重置（reset）的区别。":{"title":"请解释一下Git的合并（merge）和重置（reset）的区别。","links":[],"tags":["编程/Git"],"content":"当您在 Git 中提交更改时，有时您需要合并或重置已提交的更改。虽然这两个命令非常相似，但它们的作用是不同的。\n\n\n重置（reset）命令用于返回 Git 仓库的当前状态，它将撤销或丢弃最近提交的所有更改，并将其恢复到未提交的状态。使用 reset 命令时，Git 将告诉您哪些更改已准备好合并，您可以选择保留或删除这些更改。\n\n\n合并（merge）命令将两个或更多个分支的更改合并到另一个分支上。使用 merge 命令时，Git 将提示您选择要合并的分支和要保存合并后的分支。您可以选择在合并过程中指定分支名称，也可以选择使用默认名称。在合并成功后，Git 将创建一个新的提交，其中包含两个或多个分支的更改。\n\n\n因此，重置是将 Git 仓库恢复到未提交的状态，而合并是将两个或多个分支的更改合并到另一个分支上。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的忽略文件（.gitignore）是用来做什么的，以及如何配置它！":{"title":"请解释一下Git的忽略文件（.gitignore）是用来做什么的，以及如何配置它！","links":[],"tags":["编程/Git"],"content":".gitignore文件用于指定哪些文件或目录应该被Git忽略，不进行版本控制。通常，这些文件是一些临时文件、编译生成的文件、日志文件、依赖库等，它们不属于项目源代码，并且在每次提交时不需要被包括进来。\n配置.gitignore文件非常简单，按照以下步骤进行操作：\n\n\n在项目的根目录下创建一个名为.gitignore的文件。你可以使用命令行或者图形界面工具创建该文件。\n\n\n在.gitignore文件中，每一行表示一个要被忽略的模式规则。模式规则可以是文件路径、文件夹路径或通配符，例如:\n\n忽略某个特定文件： file.txt\n忽略某个文件夹：folder/\n忽略特定类型的文件：*.log\n忽略特定文件名开头或结尾的文件：/tmp_* 或 *~\n\n\n\n可以使用斜杠(”/“)来指定路径，该路径可以是相对于.gitignore文件所在目录的相对路径，也可以是绝对路径。可以使用斜杠(”/“)开头，表示匹配于项目根目录。\n\n\n除了直接指定特定的路径和文件外，还可以通过通配符来进行匹配，如*（匹配零个或多个字符），?（匹配一个字符），[ ]（匹配括号内的任意一个字符）等。\n\n\n字符!可以用来取反，表示不忽略匹配到的文件。例如，你已经添加了某个文件的模式规则（如*.txt），但你又希望特定的.txt文件被纳入版本控制，那么就可以在该行前加上!。\n\n\n注释可以用#开头，可以在任何地方使用。注释行会被Git忽略。\n\n\n可以在.gitignore文件中使用glob模式匹配（例如**/folder/*.txt），但这需要确保你的Git版本支持此功能。\n\n\n配置好.gitignore文件后，Git将自动忽略符合规则的文件和目录，不进行版本控制。你可以通过git status命令查看Git的状态，并确认被忽略的文件是否正确。请注意，如果一个文件已经被Git跟踪并提交到历史记录中，那么即使在.gitignore文件中添加了对应规则，该文件仍然会在Git中继续被跟踪。\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意的是，每个项目都可以有独立的.gitignore文件，在不同的分支中可以有不同的配置。这样可以根据项目的特点和需求灵活地配置哪些文件需要被忽略。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/请解释一下Git的远程仓库是什么，以及如何与远程仓库进行交互！":{"title":"请解释一下Git的远程仓库是什么，以及如何与远程仓库进行交互！","links":[],"tags":["编程/Git"],"content":"Git的远程仓库是存储在网络上的Git仓库，可以用来共享和协作开发项目。 它可以位于本地网络或远程服务器上，允许多个开发者通过网络访问和管理同一个代码库。\n与远程仓库进行交互的主要操作包括：\n\n克隆远程仓库：使用git clone命令可以将远程仓库完整地复制到本地，得到一个本地的工作副本。\n推送到远程仓库：使用git push命令可以将本地的提交推送到远程仓库，实现代码的共享和备份。\n拉取远程仓库：使用git pull命令可以将远程仓库的更新拉取到本地，保持本地代码与远程仓库同步。\n添加远程仓库：使用git remote add命令可以将一个远程仓库添加到本地仓库的远程仓库列表中，方便进行交互操作。\n查看远程仓库：使用git remote命令可以查看本地仓库关联的远程仓库列表，包括远程仓库的名称和URL。\n\n通过这些操作，我们可以方便地与远程仓库进行交互，实现代码的共享、备份和协作开发。"},"C-Knowledge/前端/职业规划/前端面试宝典/八股文/音视频八股文":{"title":"音视频八股文","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/直方图在图像处理里面最重要的作用是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/AAC和PCM的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常见的音视频格式有哪些！","C-Knowledge/前端/技术书籍/多媒体前端手册/TS,-M3U8","C-Knowledge/前端/技术书籍/多媒体前端手册/FLV","C-Knowledge/前端/职业规划/前端面试宝典/八股文/播放器暂停、快进快退、seek、逐帧、变速怎么实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/html-video标签是如何播放视频的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么video标签出来这么久，视频网站直到最近几年才全面铺开h5播放器！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么巨大的原始视频可以编码成很小的视频呢！-这其中的技术是什么呢！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/怎么做到直播秒开优化！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/数字图像滤波有哪些方法！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/图像可以提取的特征有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/衡量图像重建好坏的标准有哪些！怎样计算！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/H264存储的两个形态！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/FFMPEG：图片如何合成视频","请指出“1080p”的意义？","请解释颜色的本质及其数字记录原理，并说出几个你所知道的色域。","请解释“矢量图”和“位图”的区别？","请从“光圈”“快门速度”“感光度”“白平衡”“景深”中任选2个进行叙述？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/视频分量YUV的意义及数字化格式！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/在MPEG标准中图像类型有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/列举一些音频编解码常用的实现方案！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请叙述MPEG视频基本码流结构！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/sps和pps的区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/请叙述AMR基本码流结构！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一说ffmpeg的数据结构！","说一说AVFormatContext-和-AVInputFormat之间的关系？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一说视频拼接处理步骤！（细节处理，比如分辨率大小不一，时间处理等等）","NV21如何转换成I420？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/影响视频清晰度的指标有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/如何降低延迟！如何保证流畅性！如何解决卡顿！解决网络抖动！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/预测编码的基本原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要有YUV这种数据出来！（YUV相比RGB来说的优点）","C-Knowledge/前端/职业规划/前端面试宝典/八股文/H264-and-H265有什么区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/视频或者音频传输，你会选择TCP协议还是UDP协议！为什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/平时说的软解和硬解，具体是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/何为直播！何为点播！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/简述推流、拉流的工作流程！","如何在直播中I帧间隔设置、与帧率分辨率选定？","直播推流中推I帧与推非I帧区别是什么？","常见的直播协议有哪些？之间有什么区别？","点播中常见的数据传输协议主要有哪些？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/RTMP、HLS协议各自的默认端口号是！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/简述RTMP协议，如何封装RTMP包！","m3u8构成是？直播中m3u8、ts如何实时更新？","何为音视频同步，音视频同步是什么标准？","说说你平时在播放过程中做的优化工作？","你研究过哪些具体的流媒体服务器，是否做过二次开发？","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是GOP！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/音频测试的测试点,音频时延如何测试！","美颜的实现原理，具体实现步骤","C-Knowledge/前端/职业规划/前端面试宝典/八股文/为什么要用FLV！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/何为homebrew！你用它安装过什么！常用命令有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/当前主流视频网站直播，点播都用的什么技术！"],"tags":["编程/FE/音视频"],"content":"重点\n\n直方图在图像处理里面最重要的作用是什么！\nAAC和PCM的区别！\n常见的音视频格式有哪些！\nTS, M3U8\nFLV\n播放器暂停、快进快退、seek、逐帧、变速怎么实现！\nhtml video标签是如何播放视频的！\n为什么video标签出来这么久，视频网站直到最近几年才全面铺开h5播放器！\n\n八股文\n\n为什么巨大的原始视频可以编码成很小的视频呢！ 这其中的技术是什么呢！\n怎么做到直播秒开优化！\n直方图在图像处理里面最重要的作用是什么！\n数字图像滤波有哪些方法！\n图像可以提取的特征有哪些！\n衡量图像重建好坏的标准有哪些！怎样计算！\nAAC和PCM的区别！\nH264存储的两个形态！\nFFMPEG：图片如何合成视频\n常见的音视频格式有哪些！\n请指出“1080p”的意义？\n请解释颜色的本质及其数字记录原理，并说出几个你所知道的色域。\n请解释“矢量图”和“位图”的区别？\n请从“光圈”“快门速度”“感光度”“白平衡”“景深”中任选2个进行叙述？\n视频分量YUV的意义及数字化格式！\n在MPEG标准中图像类型有哪些！\n列举一些音频编解码常用的实现方案！\n请叙述MPEG视频基本码流结构！\nsps和pps的区别！\n请叙述AMR基本码流结构！\n说一说ffmpeg的数据结构！\n说一说AVFormatContext 和 AVInputFormat之间的关系？\n说一说视频拼接处理步骤！（细节处理，比如分辨率大小不一，时间处理等等）\nNV21如何转换成I420？\n影响视频清晰度的指标有哪些！\n如何降低延迟！如何保证流畅性！如何解决卡顿！解决网络抖动！\n预测编码的基本原理是什么！\n为什么要有YUV这种数据出来！（YUV相比RGB来说的优点）\nH264&amp;H265有什么区别！\n视频或者音频传输，你会选择TCP协议还是UDP协议！为什么！\n平时说的软解和硬解，具体是什么！\n何为直播！何为点播！\n简述推流、拉流的工作流程！\n如何在直播中I帧间隔设置、与帧率分辨率选定？\n直播推流中推I帧与推非I帧区别是什么？\n常见的直播协议有哪些？之间有什么区别？\n点播中常见的数据传输协议主要有哪些？\nRTMP、HLS协议各自的默认端口号是！\n简述RTMP协议，如何封装RTMP包！\nm3u8构成是？直播中m3u8、ts如何实时更新？\n何为音视频同步，音视频同步是什么标准？\n播放器暂停、快进快退、seek、逐帧、变速怎么实现！\n说说你平时在播放过程中做的优化工作？\n你研究过哪些具体的流媒体服务器，是否做过二次开发？\n什么是GOP！\n音频测试的测试点,音频时延如何测试！\n美颜的实现原理，具体实现步骤?\n为什么要用FLV！\n何为homebrew！你用它安装过什么！常用命令有哪些！\n\n前端多媒体\nVideo 标签\n\nhtml video标签是如何播放视频的！\n为什么video标签出来这么久，视频网站直到最近几年才全面铺开h5播放器！\n当前主流视频网站直播，点播都用的什么技术！\n「完全理解」video 标签到底能播放什么\n\n\n\n面试官常问的音视频技术点！\n前端音视频入门详解（涵盖点播直播、封装格式、编解码等）\n"},"C-Knowledge/前端/职业规划/前端面试宝典/前端面试宝典":{"title":"前端面试宝典","links":["C-Knowledge/前端/职业规划/前端面试宝典/面试经验/面试经验","C-Knowledge/前端/技术书籍/前端面试之道/前端面试之道","C-Knowledge/前端/职业规划/前端面试宝典/八股文/八股文","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/算法题","C-Knowledge/前端/职业规划/前端面试宝典/手写题/手撕代码","D-Unsorted/怎么写技术简历"],"tags":["场景/面试"],"content":"\n面试经验\nweb前端面试题及答案\n前端面试之道\nall-of-frontend\n剑指Offer\n八股文\n算法题\n手撕代码\n怎么写技术简历\n"},"C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：栈":{"title":"手写题：栈","links":[],"tags":["编程/数据结构","编程/手写"],"content":"\nStack的特点是后进先出(last in first out)。生活中常见的Stack的例子比如一摞书，你最后放上去的那本你之后会最先拿走;又比如浏览器的访问历史，当点击返回按钮，最后访问的网站最先从历史记录中弹出。\n\nStack一般具备以下方法：\npush：将一个元素推入栈顶\npop：移除栈顶元素，并返回被移除的元素\npeek：返回栈顶元素\nlength：返回栈中元素的个数\n\n使用数组\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n \n  /**\n   * 添加一个（或几个）新元素到栈顶\n   * @param {*} element 新元素\n   */\n  push(element) {\n    this.items.push(element)\n  }\n \n  /**\n   * 移除栈顶的元素，同时返回被移除的元素\n   */\n  pop() {\n    return this.items.pop()\n  }\n \n  /**\n   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）\n   */\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n \n  /**\n   * 如果栈里没有任何元素就返回true,否则返回false\n   */\n  isEmpty() {\n    return this.items.length === 0\n  }\n \n  /**\n   * 移除栈里的所有元素\n   */\n  clear() {\n    this.items = []\n  }\n \n  /**\n   * 返回栈里的元素个数。这个方法和数组的length属性很类似\n   */\n  size() {\n    return this.items.length\n  }\n}\n手动实现\nJavascript的Array天生具备了Stack的特性，但我们也可以从头实现一个 Stack类：\nfunction Stack() { \n  this.count = 0; \n  this.storage = {}; \n \n  this.push = function (value) { \n    this.storage[this.count] = value; \n    this.count++; \n  } \n \n  this.pop = function () { \n    if (this.count === 0) { \n      return undefined; \n    } \n    this.count--; \n    var result = this.storage[this.count]; \n    delete this.storage[this.count]; \n    return result; \n  } \n \n  this.peek = function () { \n    return this.storage[this.count - 1]; \n  } \n \n  this.size = function () { \n    return this.count; \n  } \n} "},"C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：节流、防抖":{"title":"手写题：节流、防抖","links":["C-Knowledge/前端/职业规划/前端面试宝典/面试经验/Js中的+new-Date()-表示什么意思","C-Knowledge/前端/开发技术/JavaScript/什么是防抖和节流！有什么区别！如何实现！"],"tags":["编程/JavaScript","编程/手写"],"content":"防抖\n\n\n                  \n                  提示💡 \n                  \n                \n需要一个定时器 timer 。\n\n// 防抖函数  \nfunction debounce(func, wait) {  \n\tlet timeout;  \n\treturn function (...args) {  \n\t  const context = this;  \n\t  clearTimeout(timeout);  \n\t  timeout = setTimeout(() =&gt; func.apply(context, args), wait);  \n\t};  \n}  \n// func是用户传入需要防抖的函数\n// wait是等待时间\nconst debounce = (func, wait = 50) =&gt; {\n  // 缓存一个定时器id\n  let timer = 0\n  // 这里返回的函数是每次用户实际调用的防抖函数\n  // 如果已经设定过定时器了就清空上一次的定时器\n  // 开始一个新的定时器，延迟执行用户传入的方法\n  return function(...args) {\n    if (timer) clearTimeout(timer)\n    timer = setTimeout(() =&gt; {\n      func.apply(this, args)\n    }, wait)\n  }\n}\n节流\n使用 setTimeout 实现\n\n\n                  \n                  提示💡 \n                  \n                \n需要一个标志器 inThrottle 。\n\n// 节流函数  \nfunction throttle(func, limit) {\n  let inThrottle;\n  return function (...args) {\n    const context = this;\n    if (inThrottle) return;\n    func.apply(context, args);\n    inThrottle = true;\n    setTimeout(() =&gt; (inThrottle = false), limit);\n  };\n}\n下面是测试代码：\nsetInterval(\n  throttle(() =&gt; {\n    console.log(1);\n  }, 2000),\n  1\n);\n使用 new Date() 实现\n\n\n                  \n                  提示💡 \n                  \n                \n需要一个标志器 lastTime 。\n\n// func是用户传入需要防抖的函数\n// wait是等待时间\nconst throttle = (func, wait = 50) =&gt; {\n  // 上一次执行该函数的时间\n  let lastTime = 0\n  return function(...args) {\n    // 当前时间\n    let now = +new Date()\n    // 将当前时间和上一次执行函数时间对比\n    // 如果差值大于设置的等待时间就执行函数\n    if (now - lastTime &gt; wait) {\n      lastTime = now\n      func.apply(this, args)\n    }\n  }\n}\n下面是测试代码：\nsetInterval(\n  throttle(() =&gt; {\n    console.log(1)\n  }, 500),\n  1\n)\n\n\n                  \n                  提示💡 \n                  \n                \nJs中的+new Date() 表示什么意思\n\n扩展阅读\n\n什么是防抖和节流！有什么区别！如何实现！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：链表":{"title":"手写题：链表","links":[],"tags":["编程/数据结构","编程/手写"],"content":"\n\n                  \n                  提示💡 \n                  \n                \n\n\n维护一个 头结点、尾结点、链表长度；\n\n\n维护尾结点，尾结点可 O(1) 复杂度插入；\n\n\n\nclass LinkNode {\n    val: number;\n    next: LinkNode | null;\n    constructor(val: number, next: LinkNode) {\n        this.val = val;\n        this.next = next;\n    }\n}\n \nclass MyLinkedList {\n    size: number;\n    head: LinkNode | null;\n    tail: LinkNode | null;\n \n    constructor() {\n        this.head = null; // head节点\n        this.tail = null; // 尾节点\n        this.size = 0; // 长度\n    }\n \n    getNode(index: number): LinkNode {\n        let cur = new LinkNode(0, this.head); // 哨兵节点\n        while (index-- &gt;= 0) cur = cur.next;\n        return cur;\n    }\n \n    get(index: number): number {\n        if (index &lt; 0 || index &gt;= this.size) return -1;\n        return this.getNode(index).val;\n    }\n \n    addAtHead(val: number): void {\n        let node = new LinkNode(val, this.head);\n        this.head = node;\n        this.size++;\n \n        // 没有尾结点，说明只有一个 node 节点，记录尾结点\n        if (!this.tail) this.tail = node;\n    }\n \n    addAtTail(val: number): void {\n        let node = new LinkNode(val, null);\n        this.size++;\n        // 有尾结点\n        if (this.tail) {\n            // 更新尾结点\n            this.tail.next = node;\n            this.tail = node;\n            return;\n        }\n        // 没有尾结点，说明只有一个节点\n        this.tail = node;\n        this.head = node;\n    }\n \n    addAtIndex(index: number, val: number): void {\n        if (index &gt; this.size) return;\n \n        if (index &lt;= 0) {\n            this.addAtHead(val);\n            return;\n        }\n \n        if (index === this.size) {\n            this.addAtTail(val);\n            return;\n        }\n \n        // 其他情况\n        let node = this.getNode(index - 1);\n        node.next = new LinkNode(val, node.next);\n        this.size++;\n    }\n \n    deleteAtIndex(index: number): void {\n        if (index &lt; 0 || index &gt;= this.size) return;\n \n        // 删除头结点\n        if (index === 0) {\n            this.head = this.head.next;\n            this.size--;\n            return;\n        }\n \n        // 删除中间、尾节点\n        let node = this.getNode(index - 1);\n        node.next = node.next.next;\n \n        // 如果 index 是尾结点，更新尾结点\n        if (index === this.size - 1) {\n            this.tail = node;\n        }\n        this.size--;\n    }\n}"},"C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：队列":{"title":"手写题：队列","links":[],"tags":["编程/数据结构","编程/手写"],"content":"\nQueue和Stack有一些类似，不同的是Stack是先进后出，而Queue是先进先出。Queue在生活中的例子比如排队上公交，排在第一个的总是最先上车;又比如打印机的打印队列，排在前面的最先打印。\n\nQueue一般具有以下常见方法：\nenqueue：入列，向队列尾部增加一个元素\ndequeue：出列，移除队列头部的一个元素并返回被移除的元素\nfront：获取队列的第一个元素\nisEmpty：判断队列是否为空\nsize：获取队列中元素的个数\n\n数组实现\nJavascript中的Array已经具备了Queue的一些特性，所以我们可以借助Array实现一个Queue类型：\nfunction Queue() { \n  var collection = []; \n \n  this.print = function () { \n    console.log(collection); \n  } \n \n  this.enqueue = function (element) { \n    collection.push(element); \n  } \n \n  this.dequeue = function () { \n    return collection.shift(); \n  } \n \n  this.front = function () { \n    return collection[0]; \n  } \n \n  this.isEmpty = function () { \n    return collection.length === 0; \n  } \n \n  this.size = function () { \n    return collection.length; \n  } \n} \n简单实现\nclass Queue {\n    constructor() {\n        this.list = []\n        this.frontIndex = 0\n        this.tailIndex = 0\n    }\n    enqueue(item) {\n        this.list[this.tailIndex++] = item\n    }\n    unqueue() {\n        const item  = this.list[this.frontIndex]\n        this.frontIndex++        \n        return item\n    }\n}\n循环队列\n\n\n                  \n                  提示💡 \n                  \n                \n\n\n定义循环变量 front 和 rear：\n\nfront 指向队列头部第 1 个有效数据的位置；\nrear 指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置；\n\n\n\n为了避免「队列为空」和「队列为满」的判别条件冲突，有意浪费了一个位置：\n\n判别队列为空的条件是：front == rear；\n判别队列为满的条件是：(rear + 1) % capacity == front；可以这样理解，当 rear 循环到数组的前面，要从后面追上 front，还差一格的时候，判定队列为满；\n\n\n\n因为有循环的出现，要特别注意处理数组下标可能越界的情况；指针后移的时候 下标 +1 ，并且为了防止数组下标越界要取模；\n\n\n\n\nclass Queue {\n  constructor(size) {\n    this.size = size + 1; // 长度需要限制, 来达到空间的利用, 代表空间的长度\n    this.list = [];\n    this.font = 0; // 指向首元素\n    this.rear = 0; // 指向准备插入元素的位置\n  }\n  enQueue(value) {\n    if (this.isFull() == true) {\n      return false;\n    }\n    this.list[this.rear] = value;\n    this.rear = (this.rear + 1) % this.size;\n    return true;\n  }\n  deQueue() {\n    if (this.isEmpty()) {\n      return false;\n    }\n    this.font = (this.font + 1) % this.size;\n    return true;\n  }\n  isEmpty() {\n    return this.font === this.rear;\n  }\n  isFull() {\n    return (this.rear + 1) % this.size === this.font;\n  }\n  toString() {\n    console.log(this.list.slice(this.font, this.rear));\n  }\n}\n测试代码\nconst queue = new Queue(5);\nqueue.enQueue(1);\nqueue.enQueue(3);\nqueue.toString();\nPriority Queue(优先队列)\nQueue还有个升级版本，给每个元素赋予优先级，优先级高的元素入列时将排到低优先级元素之前。区别主要是enqueue方法的实现：\nfunction PriorityQueue() { \n \n  ... \n \n  this.enqueue = function (element) { \n    if (this.isEmpty()) { \n      collection.push(element); \n    } else { \n      var added = false; \n      for (var i = 0; i &lt; collection.length; i++) { \n        if (element[1] &lt; collection[i][1]) { \n          collection.splice(i, 0, element); \n          added = true; \n          break; \n        } \n      } \n      if (!added) { \n        collection.push(element); \n      } \n    } \n  } \n} \n测试代码\nvar pQ = new PriorityQueue(); \n \npQ.enqueue([&#039;gannicus&#039;, 3]); \npQ.enqueue([&#039;spartacus&#039;, 1]); \npQ.enqueue([&#039;crixus&#039;, 2]); \npQ.enqueue([&#039;oenomaus&#039;, 4]); \n \npQ.print(); \n结果为：\n[ \n  [ &#039;spartacus&#039;, 1 ], \n  [ &#039;crixus&#039;, 2 ], \n  [ &#039;gannicus&#039;, 3 ], \n  [ &#039;oenomaus&#039;, 4 ] \n] \n扩展阅读\n\n数组实现的循环队列\n"},"C-Knowledge/前端/职业规划/前端面试宝典/手写题/手撕代码":{"title":"手撕代码","links":["C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：节流、防抖","C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：手动实现call(),-apply(),-bind()","C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：instanceof","C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：new操作符","C-Knowledge/前端/技术书籍/前端面试之道/手写题：深拷贝","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：Promise","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：websocket建立过程","C-Knowledge/前端/技术书籍/前端面试之道/手写题：set-方法的实现","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：SPA","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：删除升序链表中重复出现的所有节点1,2,3,3,4,4,5-=-1,2,5","C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：数组随机排序，写两种方案(自己写了三种)","C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：栈","C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：队列"],"tags":["编程/算法"],"content":"大前端\n基础\n\n手写题：节流、防抖\n手写题：手动实现call(), apply(), bind()\n手写题：instanceof\n手写题：new操作符\n手写题：深拷贝\n手写题：Promise\n手写题：websocket建立过程\n\n进阶\n\n手写题：set 方法的实现\n手写题：SPA\n手写题：删除升序链表中重复出现的所有节点1,2,3,3,4,4,5 = 1,2,5\n手写题：数组随机排序，写两种方案(自己写了三种)\n\n计算机基础\n数据结构\n\n手写题：栈\n手写题：队列\n"},"C-Knowledge/前端/职业规划/前端面试宝典/算法题/二叉树的中序遍历":{"title":"二叉树的中序遍历","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对树的理解！相关的操作有哪些！"],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n给定一个二叉树的根节点 root ，返回 它的中序遍历。\n示例 1：\n\n输入： root = [1,null,2,3]\n输出：[1,3,2]\n示例 2：\n输入： root = []\n输出：[]\n示例 3：\n输入： root = [1]\n输出：[1]\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n方法一:  递归\n\n\n前、中、后序遍历都是基于DFS，节点的访问顺序如上图所示，每个节点有三个不同的驻留阶段，即每个节点会被经过三次：\n\n在递归它的左子树之前。\n在递归完它的左子树之后，在递归它的右子树之前。\n在递归完它的右子树之后。\n\nconst inorderTraversal = (root) =&gt; {\n    const res = [];\n    const inorder = (root) =&gt; {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left); // 先递归左子树\n        res.push(root.val); // 将当前节点值推入res\n        inorder(root.right); // 再递归右子树\n    };\n    inorder(root);\n    return res;\n};\n方法二： 中序遍历的迭代实现\n\nconst inorderTraversal = (root) =&gt; {\n  const res = [];\n  const stack = [];\n \n  while (root) {        // 能压栈的左子节点都压进来\n    stack.push(root);\n    root = root.left;\n  }\n  while (stack.length) {\n    let node = stack.pop(); // 栈顶的节点出栈\n    res.push(node.val);     // 在压入右子树之前，处理它的数值部分（因为中序遍历）\n    node = node.right;      // 获取它的右子树\n    while (node) {          // 右子树存在，执行while循环    \n      stack.push(node);     // 压入当前root\n      node = node.left;     // 不断压入左子节点\n    }\n  }\n  return res;\n};"},"C-Knowledge/前端/职业规划/前端面试宝典/算法题/有效的括号":{"title":"有效的括号","links":[],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n给定一个只包括 &#039;(&#039;，&#039;)&#039;，&#039;{&#039;，&#039;}&#039;，&#039;[&#039;，&#039;]&#039; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\n输入： s = ”()”\n**输出：**true\n示例 2：\n输入： s = ”()[]{}”\n**输出：**true\n示例 3：\n输入： s = ”(]”\n**输出：**false\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 仅由括号 &#039;()[]{}&#039; 组成\n\n\n方法一\n\n\n\n                  \n                  解题思路 \n                  \n                \n遍历字符串，如果遇到{、[、( 就进行压栈，否则就进行出栈，并比对是否闭合，不闭合直接返回 false 。最后栈为空，则为有效括号。\n\nlet isValid = function(s) {\n    let stack = [], length = s.length;\n    if(length % 2) return false;\n    for(let item of s){\n        switch(item){\n            case &quot;{&quot;:\n            case &quot;[&quot;:\n            case &quot;(&quot;:\n                stack.push(item);\n                break;\n            case &quot;}&quot;:\n                if(stack.pop() !== &quot;{&quot;) return false;\n                break;\n            case &quot;]&quot;:\n                if(stack.pop() !== &quot;[&quot;) return false;\n                break;\n            case &quot;)&quot;:\n                if(stack.pop() !== &quot;(&quot;) return false;\n                break;\n        }\n    }\n    return !stack.length;\n};\n下面使用Map来存储一对括号。\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    const n = s.length\n    // 不是偶数\n    if (n % 2 === 1) {\n        return false\n    }\n    let stack = []\n    let pairs = new Map([\n        [&#039;)&#039;, &#039;(&#039;],\n        [&#039;]&#039;, &#039;[&#039;],\n        [&#039;}&#039;, &#039;{&#039;]\n    ])\n    s.split(&#039;&#039;).forEach(ch =&gt; {\n        if (pairs.has(ch)) {\n            // 出栈并比较\n            if (!stack.length || stack[stack.length - 1] != pairs.get(ch)) return false\n            stack.pop()\n        } else {\n            // 压栈\n            stack.push(ch)\n        }\n    })\n    return !stack.length\n}"},"C-Knowledge/前端/职业规划/前端面试宝典/算法题/矩阵置零":{"title":"矩阵置零","links":[],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n给定一个 _m_ x _n_ 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。**\n示例 1：\n\n输入： matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n示例 2：\n\n输入： matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n提示：\n\nm == matrix.length\nn == matrix[0].length\n1 &lt;= m, n &lt;= 200\n-231 &lt;= matrix[i][j] &lt;= 231 - 1\n\n进阶：\n\n一个直观的解决方案是使用  O(_m__n_) 的额外空间，但这并不是一个好的解决方案。\n一个简单的改进方案是使用 O(_m_ + _n_) 的额外空间，但这仍然不是最好的解决方案。\n你能想出一个仅使用常量空间的解决方案吗？\n\n\n方法一\n\n\n                  \n                  解题思路 \n                  \n                \n先遍历一遍，记录需要归零的行和列，可以使用set去重，避免不必要的循环。\n\n/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function (matrix) {\n    const row = matrix.length;\n    const col = matrix[0].length;\n \n    const rows = new Set();\n    const cols = new Set();\n \n    for (let i = 0; i &lt; row; i++) {\n        for (let j = 0; j &lt; col; j++) {\n            if (matrix[i][j] === 0) {\n                rows.add(i);\n                cols.add(j)\n            }\n        }\n    }\n \n \n    for (let i of rows.values()) {\n        for (let j = 0; j &lt; col; j++) {\n            matrix[i][j] = 0;\n        }\n    }\n \n    for  (let i of cols.values())  {\n        for (let j = 0; j &lt; row; j++) {\n            matrix[j][i] = 0;\n        }\n    }\n    return matrix;\n};"},"C-Knowledge/前端/职业规划/前端面试宝典/算法题/螺旋矩阵":{"title":"螺旋矩阵","links":[],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：\n\n**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n示例 2：\n\n**输入：**matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n提示：\n\nm == matrix.length\nn == matrix[i].length\n1 &lt;= m, n &lt;= 10\n-100 &lt;= matrix[i][j] &lt;= 100\n\n\n方法一\n\n\n\n\n                  \n                  提示💡 \n                  \n                \n\n如果一条边从头遍历到底，则下一条边遍历的起点随之变化\n选择不遍历到底，可以减小横向、竖向遍历之间的影响\n一轮迭代结束时，4条边的两端同时收窄 1\n一轮迭代所做的事情变得很清晰：遍历一个“圈”，遍历的范围收缩为内圈\n一层层向里处理，按顺时针依次遍历：上、右、下、左。\n不再形成“环”了，就会剩下：一行或一列，然后单独判断\n\n\nvar spiralOrder = function (matrix) {\n    if (matrix.length === 0) return []\n    const res = []\n    let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1\n    while (top &lt; bottom &amp;&amp; left &lt; right) {\n        for (let i = left; i &lt; right; i++) res.push(matrix[top][i])   // 上层\n        for (let i = top; i &lt; bottom; i++) res.push(matrix[i][right]) // 右层\n        for (let i = right; i &gt; left; i--) res.push(matrix[bottom][i])// 下层\n        for (let i = bottom; i &gt; top; i--) res.push(matrix[i][left])  // 左层\n        right--\n        top++\n        bottom--\n        left++  // 四个边界同时收缩，进入内层\n    }\n    if (top === bottom) // 剩下一行，从左到右依次添加\n        for (let i = left; i &lt;= right; i++) res.push(matrix[top][i])\n    else if (left === right) // 剩下一列，从上到下依次添加\n        for (let i = top; i &lt;= bottom; i++) res.push(matrix[i][left])\n    return res\n};\n方法二\n\n\n\n                  \n                  提示💡 \n                  \n                \n\n循环的条件改为： top &lt;= bottom &amp;&amp; left &lt;= right\n每遍历一条边，下一条边遍历的起点被“挤占”，要更新相应的边界\n注意到，可能在循环途中，突然不再满足循环的条件，即top &gt; bottom或left &gt; right，其中一对边界彼此交错了\n这意味着所有项都遍历完了，要break了，如果没有及时 break ，就会重复遍历\n\n\n按照从上右下左的顺序一圈一圈的打印，循环终止条件为任意边界交错。\n\n每遍历完一条边，更新相应的边界后，都加上一句if (top &gt; bottom || left &gt; right) break;，避免因没有及时退出循环而导致重复遍历。\n且，“遍历完成”这个时间点，要么发生在遍历完“上边”，要么发生在遍历完“右边”\n所以只需在这两步操作之后，加 if (top &gt; bottom || left &gt; right) break 即可\n\nvar spiralOrder = function (matrix) {\n  if (matrix.length == 0) return []\n  const res = []\n  let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1\n  while (top &lt;= bottom &amp;&amp; left &lt;= right) {\n    for (let i = left; i &lt;= right; i++) res.push(matrix[top][i])\n    top++\n    for (let i = top; i &lt;= bottom; i++) res.push(matrix[i][right])\n    right--\n    if (top &gt; bottom || left &gt; right) break\n    for (let i = right; i &gt;= left; i--) res.push(matrix[bottom][i])\n    bottom--\n    for (let i = bottom; i &gt;= top; i--) res.push(matrix[i][left])\n    left++\n  }\n  return res\n};\n换一种条件判断方式，按照从上右下左的顺序一圈一圈的打印，循环终止条件为 res.length === size 矩阵元素总和。\n\n遍历完所有项时，res 数组构建完毕。我们可以用 res 数组的长度 等于 矩阵的项的个数，作为循环的结束条件\n不等于就继续遍历，等于就 break\n\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function (matrix) {\n    const row = matrix.length, col = matrix[0].length, size = row * col, res = []\n    let top = 0, rigth = col - 1, bottom = row - 1, left = 0 //上右下左四个方向的指针\n    while (res.length !== size) {\n        // 从左到右, 行不变列变\n        for (let i = left; i &lt;= rigth; i++) res.push(matrix[top][i]);\n        top++;\n        // 从上到下，列不变行变\n        for (let i = top; i &lt;= bottom; i++) res.push(matrix[i][rigth]);\n        rigth--;\n        // 检查是否越界\n        if (res.length === size) break;\n        // 从右到左，行不变列变\n        for (let i = rigth; i &gt;= left; i--) res.push(matrix[bottom][i]);\n        bottom--;\n        // 从下到上，行变列不变\n        for (let i = bottom; i &gt;= top; i--) res.push(matrix[i][left]);\n        left++\n    }\n    return res\n};"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/Js中的+new-Date()-表示什么意思":{"title":"Js中的+new Date() 表示什么意思","links":[],"tags":["编程/JavaScript"],"content":"JavaScript中可以在某个元素前使用  ’+’  号，这个操作是将该元素转换成Number类型，如果转换失败，那么将得到 NaN\n+new Date() 将会调用 Date.prototype 上的 valueOf() 方法，根据MDN，Date.prototype.value方法等同于Date.prototype.getTime()\n下面的代码效果相同：\nconsole.log(+new Date());  \nconsole.log(new Date().getTime());\nconsole.log(new Date().valueOf());\nconsole.log(new Date() * 1);"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/上海二三四五网络科技有限公司":{"title":"上海二三四五网络科技有限公司","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/React八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vite八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Git八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Webpack八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/NodeJS八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/前端性能优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说React服务端渲染怎么做！原理是什么！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/SSR-解决了什么问题！有做过-SSR-吗！你是怎么做的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/浏览器样式兼容","C-Knowledge/前端/职业规划/前端面试宝典/八股文/常见的兼容性问题","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/算法题","C-Knowledge/前端/职业规划/前端面试宝典/八股文/图形学八股文","C-Knowledge/前端/职业规划/前端面试宝典/八股文/uni-app八股文","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/播放器秒开优化丨音视频工业实战","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/减少服务器压力，减少带宽成本？","C-Knowledge/前端/职业规划/前端面试宝典/手写题/手写题：节流、防抖","C-Knowledge/前端/职业规划/前端面试宝典/八股文/手写题：手动实现call(),-apply(),-bind()"],"tags":["场景/面试"],"content":"工作职责\n\n\nVue八股文\nReact八股文\nVite八股文\nGit八股文\nWebpack八股文\nNodeJS八股文\n前端性能优化\n说说React服务端渲染怎么做！原理是什么！，SSR 解决了什么问题！有做过 SSR 吗！你是怎么做的！\n浏览器样式兼容，常见的兼容性问题\n算法题\n图形学八股文\nuni-app八股文\n\n面试\n自我介绍\n\n2 年全栈开发经验，有 3 年的小程序、Vue 开发经验，分别有 3 个上线项目和微信小程序有 4 个 Demo 项目，有使用 uniapp，进行多端开发的经验。了解计算机图形学，最近学习了 docker 和 webrtc。\n作为开发负责人负责播放器项目技术选型工作，从 0 到 1为公司搭建了前端播放器。注重前端标准化，在部门内部推行前端规范的落地。\n拥有自己的知识库和命令行工具（Node. js)，用于沉淀最佳实践，提高提高开发效率。\n\n反问\n技术相关\n\n你觉得我的技术有什么问题？下一步应该怎么学习？ JS深入了解，手写题节流是一种思想，思维的解决方案。储备图形学人才。\n~~咱们公司的技术栈是什么？~~老项目使用 Vue，新项目使用React 。\n岗位的任务和团队的风格？  进入公司，负责的内容？\n技术团队规模？技术团队100人，前端10人。\n晋升路线。年中（7月份）一次，团队提申请，人员比例。\n~~目标用户、用户体量，产品优势，怎么盈利？~~压缩在做鸿蒙化。\n\nHR（没问）\n\n~~工作时间？~~9点，弹性工作制度。\n现在加班的强度？适度加班。周末加班调休。\n请问公司的调薪是怎么样的呢？ 一次\n几轮面试？，两轮，一面，视频面试，二面，现场面试。面试结果3-5个工作日。\n\n面试内容\n\n自我介绍\n空窗期2年全职考研，是怎么想的呢？会继续考吗？\n上海电影学院这方面比较不错吗？\n播放器是独立完成还是几个人一起做的？承担的职责？产生的价值，和市面上的播放器有业务和设计上的不同？是从零到一参与到吗？\n播放器有哪些得意之处？能快速的响应需求。\n怎么实现的圈点画？\n下一份工作有什么期待？大一点公司，好一点的团队，能学习到更多东西，并能更好的发挥自己的能力。\n现在有合适的公司吗？面试了哪些公司？哪些地方准备不太充分？\n抖音一样的播放列表，播放不黑屏？减少服务器压力，减少带宽成本？\n2-3分钟的视频是选择m3u8还是选择mp4呢？\nH264和H265，它们之间的区别？是使用多个播放源吗？微信小程序不支持加解密处理m3u8？。\n手写题，函数节流和bind函数实现。\n\n// 节流：固定时间执行一次\nconst th = (callback, dalay) =&gt; {\n  let timer = setTimeout(() =&gt; {\n    callback();\n  }, dalay);\n  return function () {\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() =&gt; {\n      callback();\n    }, dalay);\n  };\n};\n \nth(() =&gt; console.log(&quot;节流&quot;), 1000);\n \n// 返回一个执行函数，绑定当前作用域\nconst bind = () =&gt; {\n  return ;\n};\n \nconst test = function () {\n  console.log(this);\n};\n \ntest.bind(this);\n \n复盘\n这次面试不足的点是手写题和图形学的知识没有理解清楚。接下来的重点是手写题、算法题进行练习。"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/减少服务器压力，减少带宽成本？":{"title":"减少服务器压力，减少带宽成本？","links":["C-Knowledge/前端/职业规划/前端面试宝典/面试经验/负载均衡"],"tags":["编程/性能"],"content":"视频缓解服务器压力的方法有以下几种：\n第一，使用内容分发网络（CDN），将视频内容分布到全球各地的服务器节点上。这样可以将视频内容就近分发给用户，减少了对原始服务器的访问压力。\n第二，使用流媒体服务器，将视频内容进行实时传输。流媒体服务器能够根据用户的需求，实时地将视频内容分割为小的数据流，并且根据网络状况动态调整传输速率，以最大程度地减少服务器的负载。\n第三，对视频内容进行压缩和优化处理。通过使用先进的视频编码算法和压缩技术，可以减小视频文件的大小，节省带宽和存储空间，从而降低服务器的负载。同时，对视频内容进行适当的优化，如去掉冗余数据、优化编码设置等，也能够提高视频的播放性能，并减少服务器的压力。\n第四，使用 负载均衡技术和集群技术。将多台服务器组成一个服务器集群，通过负载均衡技术将用户的请求均衡地分发到各个服务器上，从而分摊服务器的负载压力。同时，集群技术还能够提供高可用性，保证视频服务的稳定性和可靠性。\n第五，优化服务器的硬件配置和网络环境。增加服务器的处理能力、存储容量和带宽，能够提高服务器的吞吐量和并发处理能力，降低响应时间，从而缓解服务器的压力。同时，优化网络环境，减少网络延迟和丢包，也能够提高视频传输的质量和效率。"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/字典序排数":{"title":"字典序排数","links":[],"tags":["编程/算法"],"content":"字符串排序\nvar lexicalOrder = function(n) {\n    return Array(n).fill(null).map((v, i) =&gt; v = &quot;&quot; + (i + 1)).sort()\n};\n深度优先搜索\nvar lexicalOrder = function(n) {\n    const ret = [];\n    let number = 1;\n    for (let i = 0; i &lt; n; i++) {\n        ret.push(number);\n        if (number * 10 &lt;= n) {\n            number *= 10;\n        } else {\n            while (number % 10 === 9 || number + 1 &gt; n) {\n                number = Math.floor(number / 10);\n            }\n            number++;\n        }\n    }\n    return ret;\n};"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/成都盯潮科技有限公司":{"title":"成都盯潮科技有限公司","links":[],"tags":["面试"],"content":""},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：Promise":{"title":"手写题：Promise","links":["C-Knowledge/前端/技术书籍/前端面试之道/5、前端面试之道-手写-Promise"],"tags":["编程/JavaScript","编程/手写"],"content":"手写代码\nPromise . all\n\n\n                  \n                  原生的 Promise. all 有什么特点？ \n                  \n                \n\n特点1：接收一个可迭代对象\n特点2：传入的数据中可以是普通数据，也可以是Promise对象\n特点3：可迭代对象的promise是并行执行的\n特点4：保持输入数组的顺序和输出数组的顺序一致\n特点5：传入数组中只要有一个reject，立即返回reject\n特点6：所有数据resolve之后返回结果\n\n\nfunction myPromiseAll(iterable) {\n    return new Promise((resolve,reject) =&gt; {\n        const promises = Array.from(iterable);\n        // 定义Promise对象resolve的数组\n        const result = [];\n        // 定义一个计数器用来判断是否所有的promise执行完毕\n        let count = 0;\n        // 并发执行每一个promise\n        for (let i = 0; i &lt; promises.length; i++) {\n            Promise.resolve(promises[i]).then(res =&gt; {\n                result[i] = res;\n                count++;\n                if (count === promises.length) {\n                    resolve(result);\n                }\n            }).catch(err =&gt; reject(err))\n        }\n    })\n}\nPromise.race\n function myPromiseRace(promises) {\n    return new Promise(function (resolve, reject) {\n      for (let i = 0; i &lt; promises.length; i++) {\n        Promise.resolve(promises[i]).then(function (value) {\n          return resolve(value)\n        }, function (reason) {\n          return reject(reason)\n        })\n      }\n    })\n  }\n测试代码：\nconst p1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(&#039;p1&#039;), 1000)\n})\n \nconst p2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(&#039;p2&#039;), 5000)\n})\n \nPromise.race([p1, p2]).then(ret =&gt; {\n   console.log(ret) // &#039;p1&#039;\n})\n手写 promise\n核心代码\n// 记录 Promise 的三种状态\nconst PENDING = &#039;pending&#039;;\nconst FULFILLED = &#039;fulfilled&#039;;\nconst REJECTED = &#039;rejected&#039;;\n \n/**\n * 运行一个微队列任务\n * 把传递的函数放到微队列中（模拟 vue 实现）\n * @param {Function} callback\n */\nfunction runMicroTask(callback) {\n  // 判断 node 环境\n  // 为了避免「变量未定义」的错误，这里最好加上前缀 globalThis\n  // globalThis 是一个关键字，指代全局对象，浏览器环境为 window，node 环境为 global\n  if (globalThis.process &amp;&amp; globalThis.process.nextTick) {\n    // node\n    process.nextTick(callback);\n  } else if (globalThis.MutationObserver) {\n    // 高版本浏览器\n    const p = document.createElement(&#039;p&#039;);\n    const observer = new MutationObserver(callback); // 可以做成单例，提高效率，这里简单实现\n    observer.observe(p, {\n      childList: true, // 观察该元素内部的变化\n    });\n    p.innerHTML = &#039;1&#039;;\n  } else {\n    // 低版本浏览器\n    setTimeout(callback, 0);\n  }\n}\n \n/**\n * 判断一个数据是否是 Promise 对象\n * @param {any} obj\n * @returns\n */\nfunction isPromise(obj) {\n  // 必须是一个对象 &amp;&amp; 必须有 then 函数\n  return !!(obj &amp;&amp; typeof obj === &#039;object&#039; &amp;&amp; typeof obj.then === &#039;function&#039;);\n}\n \nclass MyPromise {\n  /**\n   * 创建一个 Promise\n   * @param {Function} executor 任务执行器，立即执行\n   */\n  constructor(executor) {\n    this._state = PENDING; // 状态\n    this._value = undefined; // 数据\n    this._handlers = []; // 处理函数形成的队列\n \n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this));\n    } catch (error) {\n      // 处理错误\n      this._reject(error);\n      console.error(error);\n    }\n  }\n \n  /**\n   * 向处理队列中添加一个函数\n   * @param {Function} executor 添加的函数\n   * @param {String} state 该函数什么状态下执行\n   * @param {Function} resolve 让 then 函数返回的 Promise 成功\n   * @param {Function} reject 让 then 函数返回的 Promise 失败\n   */\n  _pushHandler(executor, state, resolve, reject) {\n    this._handlers.push({ executor, state, resolve, reject });\n  }\n \n  /**\n   * 根据实际情况，执行队列\n   */\n  _runHandlers() {\n    if (this._state === PENDING) {\n      // 目前任务仍在挂起\n      return;\n    }\n    while (this._handlers[0]) {\n      const handler = this._handlers[0];\n      this._runOneHandler(handler);\n      this._handlers.shift();\n    }\n  }\n \n  /**\n   * 处理一个 handler（）\n   * @param {Object} handler\n   */\n  _runOneHandler({ executor, state, resolve, reject }) {\n    // 处理与当前状态 _state 相同的微任务\n    runMicroTask(() =&gt; {\n      if (this._state !== state) {\n        // 状态不一致，不处理\n        return;\n      }\n \n      if (typeof executor !== &#039;function&#039;) {\n        // 传递后续处理并非一个函数，与之前的状态保持一致\n        this._state === FULFILLED ? resolve(this._value) : reject(this._value);\n        return;\n      }\n \n      try {\n        const result = executor(this._value); // 返回结果有可能是 promise\n        if (isPromise(result)) {\n          result.then(resolve, reject);\n        } else {\n          resolve(result);\n        }\n      } catch (error) {\n        reject(error);\n        console.error(error);\n      }\n    });\n  }\n \n  /**\n   * Promise A+ 规范的 then\n   * @param {Function} onFulfilled\n   * @param {Function} onRejected\n   */\n  then(onFulfilled, onRejected) {\n    return new MyPromise((resolve, reject) =&gt; {\n      this._pushHandler(onFulfilled, FULFILLED, resolve, reject);\n      this._pushHandler(onRejected, REJECTED, resolve, reject);\n      this._runHandlers(); // 执行队列（用户可能直接在 new Promise 中执行 resolve 或 reject，此时状态变化，需要立即执行队列）\n    });\n  }\n \n  /**\n   * 更改任务状态\n   * @param {String} newState 新状态\n   * @param {any} value 相关数据\n   */\n  _changeState(newState, value) {\n    if (this._state !== PENDING) {\n      // 目前状态已经更改\n      return;\n    }\n \n    this._state = newState;\n    this._value = value;\n    this._runHandlers(); // 状态变化，执行队列\n  }\n \n  /**\n   * 标记当前任务完成\n   * @param {any} data 任务完成的相关数据\n   */\n  _resolve(data) {\n    this._changeState(FULFILLED, data);\n  }\n \n  /**\n   * 标记当前任务失败\n   * @param {any} reason 任务失败的相关数据\n   */\n  _reject(reason) {\n    this._changeState(REJECTED, reason);\n  }\n}\n测试代码\n// ------ 测试 1 ------\nlet pro1 = new MyPromise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(&#039;失败&#039;);\n  }, 1000);\n});\n \nlet pro2 = pro1.then(function A1() { }, undefined);\nsetTimeout(() =&gt; {\n  console.log(pro1);\n  console.log(pro2);\n}, 1500);\n// 值穿透\n// MyPromise { _state: &#039;rejected&#039;, _value: &#039;失败&#039;, _handlers: [] }\n// MyPromise { _state: &#039;rejected&#039;, _value: &#039;失败&#039;, _handlers: [] }\n \n \n// ------ 测试 2 ------\nlet pro3 = new MyPromise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(&#039;成功&#039;);\n  }, 1000);\n});\n \nlet pro4 = pro3.then(function A1(data) {\n  console.log(data);\n  return new MyPromise((resolve, reject) =&gt; {\n    resolve(1);\n  });\n});\nsetTimeout(() =&gt; {\n  console.log(pro4);\n}, 1500);\n// 成功\n// MyPromise { _state: &#039;fulfilled&#039;, _value: 1, _handlers: [] }\n \n \n// ------ 测试 3（与官方 promise 互操作） ------\nfunction delay(duraton) {\n  return new MyPromise((resolve) =&gt; {\n    setTimeout(resolve, duraton);\n  });\n}\n(async function () {\n  console.log(&#039;start&#039;);\n  await delay(2000);\n  console.log(&#039;end&#039;);\n})();\n \n// ------ 测试 4（与官方 promise 互操作） ------\nconst pro5 = new MyPromise((resolve) =&gt; {\n  resolve(1);\n});\n \npro5.then((data) =&gt; {\n  console.log(data);\n  return new Promise((resolve) =&gt; {\n    resolve(2);\n  })\n}).then(data =&gt; {\n  console.log(data);\n});\n完整代码\n// 记录 Promise 的三种状态\nconst PENDING = &#039;pending&#039;;\nconst FULFILLED = &#039;fulfilled&#039;;\nconst REJECTED = &#039;rejected&#039;;\n \n/**\n * 运行一个微队列任务\n * 把传递的函数放到微队列中（模拟 vue 实现）\n * @param {Function} callback\n */\nfunction runMicroTask(callback) {\n  // 判断 node 环境\n  // 为了避免「变量未定义」的错误，这里最好加上前缀 globalThis\n  // globalThis 是一个关键字，指代全局对象，浏览器环境为 window，node 环境为 global\n  if (globalThis.process &amp;&amp; globalThis.process.nextTick) {\n    // node\n    process.nextTick(callback);\n  } else if (globalThis.MutationObserver) {\n    // 高版本浏览器\n    const p = document.createElement(&#039;p&#039;);\n    const observer = new MutationObserver(callback); // 可以做成单例，提高效率，这里简单实现\n    observer.observe(p, {\n      childList: true, // 观察该元素内部的变化\n    });\n    p.innerHTML = &#039;1&#039;;\n  } else {\n    // 低版本浏览器\n    setTimeout(callback, 0);\n  }\n}\n \n/**\n * 判断一个数据是否是 Promise 对象\n * @param {any} obj\n * @returns\n */\nfunction isPromise(obj) {\n  return !!(obj &amp;&amp; typeof obj === &#039;object&#039; &amp;&amp; typeof obj.then === &#039;function&#039;);\n}\n \nclass MyPromise {\n  /**\n   * 创建一个 Promise\n   * @param {Function} executor 任务执行器，立即执行\n   */\n  constructor(executor) {\n    this._state = PENDING; // 状态\n    this._value = undefined; // 数据\n    this._handlers = []; // 处理函数形成的队列\n \n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this));\n    } catch (error) {\n      // 处理错误\n      this._reject(error);\n      console.error(error);\n    }\n  }\n \n  /**\n   * 向处理队列中添加一个函数\n   * @param {Function} executor 添加的函数\n   * @param {String} state 该函数什么状态下执行\n   * @param {Function} resolve 让 then 函数返回的 Promise 成功\n   * @param {Function} reject 让 then 函数返回的 Promise 失败\n   */\n  _pushHandler(executor, state, resolve, reject) {\n    this._handlers.push({ executor, state, resolve, reject });\n  }\n \n  /**\n   * 根据实际情况，执行队列\n   */\n  _runHandlers() {\n    if (this._state === PENDING) {\n      // 目前任务仍在挂起\n      return;\n    }\n    while (this._handlers[0]) {\n      const handler = this._handlers[0];\n      this._runOneHandler(handler);\n      this._handlers.shift();\n    }\n  }\n \n  /**\n   * 处理一个 handler（）\n   * @param {Object} handler\n   */\n  _runOneHandler({ executor, state, resolve, reject }) {\n    // 处理与当前状态 _state 相同的微任务\n    runMicroTask(() =&gt; {\n      if (this._state !== state) {\n        // 状态不一致，不处理\n        return;\n      }\n \n      if (typeof executor !== &#039;function&#039;) {\n        // 传递后续处理并非一个函数，与之前的状态保持一致\n        this._state === FULFILLED ? resolve(this._value) : reject(this._value);\n        return;\n      }\n \n      try {\n        const result = executor(this._value); // 返回结果有可能是 promise\n        if (isPromise(result)) {\n          result.then(resolve, reject);\n        } else {\n          resolve(result);\n        }\n      } catch (error) {\n        reject(error);\n        console.error(error);\n      }\n    });\n  }\n \n  /**\n   * Promise A+ 规范的 then\n   * @param {Function} onFulfilled\n   * @param {Function} onRejected\n   */\n  then(onFulfilled, onRejected) {\n    return new MyPromise((resolve, reject) =&gt; {\n      this._pushHandler(onFulfilled, FULFILLED, resolve, reject);\n      this._pushHandler(onRejected, REJECTED, resolve, reject);\n      this._runHandlers(); // 执行队列（用户可能直接在 new Promise 中执行 resolve 或 reject，此时状态变化，需要立即执行队列）\n    });\n  }\n \n  /**\n   * 仅处理失败的场景\n   * @param {Function} onRejected\n   */\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n \n  /**\n   * 无论成功还是失败都会执行回调\n   * @param {Function} onSettled\n   */\n  finally(onSettled) {\n    return this.then(\n      (data) =&gt; {\n        onSettled();\n        return data;\n      },\n      (reason) =&gt; {\n        onSettled();\n        throw reason;\n      }\n    );\n  }\n \n  /**\n   * 更改任务状态\n   * @param {String} newState 新状态\n   * @param {any} value 相关数据\n   */\n  _changeState(newState, value) {\n    if (this._state !== PENDING) {\n      // 目前状态已经更改\n      return;\n    }\n \n    // 下面这个判断是为了处理value为Promise的情况\n    // 这一段代码课程中没有涉及，特此注释说明\n    if (isPromise(value)) {\n      value.then(this._resolve.bind(this), this._reject.bind(this));\n      return;\n    }\n \n    this._state = newState;\n    this._value = value;\n    this._runHandlers(); // 状态变化，执行队列\n  }\n \n  /**\n   * 标记当前任务完成\n   * @param {any} data 任务完成的相关数据\n   */\n  _resolve(data) {\n    this._changeState(FULFILLED, data);\n  }\n \n  /**\n   * 标记当前任务失败\n   * @param {any} reason 任务失败的相关数据\n   */\n  _reject(reason) {\n    this._changeState(REJECTED, reason);\n  }\n \n  /**\n   * 返回一个已完成的 Promise\n   * 特殊情况：\n   * 1. 传递的 data 本身就是 ES6 的 Promise 对象\n   * 2. 传递的 data 是 PromiseLike（Promise A+），返回新的 Promise，状态和其保持一致即可\n   * @param {any} data\n   */\n  static resolve(data) {\n    if (data instanceof MyPromise) {\n      return data;\n    }\n    return new MyPromise((resolve, reject) =&gt; {\n      if (isPromise(data)) {\n        data.then(resolve, reject);\n      } else {\n        resolve(data);\n      }\n    });\n  }\n \n  /**\n   * 得到一个被拒绝的 Promise\n   * @param {any}} reason\n   */\n  static reject(reason) {\n    return new MyPromise((resolve, reject) =&gt; {\n      reject(reason);\n    });\n  }\n \n  /**\n   * 得到一个新的 Promise\n   * 该 Promise 的状态取决于 proms 的执行\n   * proms 是一个迭代器，包含多个 Promise\n   * 全部 Promise 成功，则返回的 Promise 成功，数据为所有 Promise 成功的数据，并且顺序是按照传入的顺序排列\n   * 只要有一个 Promise 失败，则返回的 Promise 失败，原因是第一个失败的 Promise 的原因\n   * @param {iterator} proms\n   */\n  static all(proms) {\n    return new MyPromise((resolve, reject) =&gt; {\n      try {\n        const results = [];\n        let count = 0; // Promise 的总数，利用索引向 results 中放入结果，这样 results 里面的结果是有顺序的\n        let fulfilledCount = 0; // 已完成的数量\n \n        for (const p of proms) {\n          let i = count;\n          count++;\n          MyPromise.resolve(p).then( // MyPromise.resolve(p) 包裹一下，p有可能不是 promise\n            (data) =&gt; {\n              fulfilledCount++;\n              results[i] = data;\n              if (fulfilledCount === count) {\n                // 当前是最后一个 Promise 完成了\n                resolve(results);\n              }\n            },\n            reject\n          );\n        }\n \n        if (count === 0) {\n          resolve(results);\n        }\n      } catch (error) {\n        reject(error);\n        console.error(error);\n      }\n    });\n  }\n \n  /**\n   * 等待所有的 Promise 有结果之后\n   * 该方法返回的 Promise 完成\n   * 并且按照顺序将所有结果汇总\n   * @param {iterator} proms\n   */\n  static allSettled(proms) {\n    const ps = [];\n    for (const p of proms) {\n      ps.push(\n        // p.then： p 有可能不是 promise，所以用 MyPromise.resolve(p) 包裹一下\n        MyPromise.resolve(p).then(\n          (value) =&gt; ({\n            status: FULFILLED,\n            value,\n          }),\n          (reason) =&gt; ({\n            status: REJECTED,\n            reason,\n          })\n        )\n      );\n    }\n    return MyPromise.all(ps);\n  }\n \n  /**\n   * 返回的Promise与第一个有结果的一致\n   * @param {iterator} proms\n   */\n  static race(proms) {\n    return new MyPromise((resolve, reject) =&gt; {\n      for (const p of proms) {\n        MyPromise.resolve(p).then(resolve, reject);\n      }\n    });\n  }\n}\n源码\n//Promise 完整的实现\nclass Promise {\n  callbacks = [];\n  state = &#039;pending&#039;;//增加状态\n  value = null;//保存结果\n  constructor(fn) {\n    fn(this._resolve.bind(this), this._reject.bind(this));\n  }\n  then(onFulfilled, onRejected) {\n    return new Promise((resolve, reject) =&gt; {\n      this._handle({\n        onFulfilled: onFulfilled || null,\n        onRejected: onRejected || null,\n        resolve: resolve,\n        reject: reject\n      });\n    });\n  }\n  catch(onError) {\n    return this.then(null, onError);\n  }\n  finally(onDone) {\n    if (typeof onDone !== &#039;function&#039;) return this.then();\n \n    let Promise = this.constructor;\n    return this.then(\n      value =&gt; Promise.resolve(onDone()).then(() =&gt; value),\n      reason =&gt; Promise.resolve(onDone()).then(() =&gt; { throw reason })\n    );\n  }\n  static resolve(value) {\n    if (value &amp;&amp; value instanceof Promise) {\n      return value;\n    } else if (value &amp;&amp; typeof value === &#039;object&#039; &amp;&amp; typeof value.then === &#039;function&#039;) {\n      let then = value.then;\n      return new Promise(resolve =&gt; {\n        then(resolve);\n      });\n \n    } else if (value) {\n      return new Promise(resolve =&gt; resolve(value));\n    } else {\n      return new Promise(resolve =&gt; resolve());\n    }\n  }\n  static reject(value) {\n    if (value &amp;&amp; typeof value === &#039;object&#039; &amp;&amp; typeof value.then === &#039;function&#039;) {\n      let then = value.then;\n      return new Promise((resolve, reject) =&gt; {\n        then(reject);\n      });\n \n    } else {\n      return new Promise((resolve, reject) =&gt; reject(value));\n    }\n  }\n  static all(promises) {\n    return new Promise((resolve, reject) =&gt; {\n      let fulfilledCount = 0\n      const itemNum = promises.length\n      const rets = Array.from({ length: itemNum })\n      promises.forEach((promise, index) =&gt; {\n        Promise.resolve(promise).then(result =&gt; {\n          fulfilledCount++;\n          rets[index] = result;\n          if (fulfilledCount === itemNum) {\n            resolve(rets);\n          }\n        }, reason =&gt; reject(reason));\n      })\n \n    })\n  }\n  static race(promises) {\n    return new Promise(function (resolve, reject) {\n      for (let i = 0; i &lt; promises.length; i++) {\n        Promise.resolve(promises[i]).then(function (value) {\n          return resolve(value)\n        }, function (reason) {\n          return reject(reason)\n        })\n      }\n    })\n  }\n  _handle(callback) {\n    if (this.state === &#039;pending&#039;) {\n      this.callbacks.push(callback);\n      return;\n    }\n \n    let cb = this.state === &#039;fulfilled&#039; ? callback.onFulfilled : callback.onRejected;\n \n    if (!cb) {//如果then中没有传递任何东西\n      cb = this.state === &#039;fulfilled&#039; ? callback.resolve : callback.reject;\n      cb(this.value);\n      return;\n    }\n \n    let ret;\n \n    try {\n      ret = cb(this.value);\n      cb = this.state === &#039;fulfilled&#039; ? callback.resolve : callback.reject;\n    } catch (error) {\n      ret = error;\n      cb = callback.reject\n    } finally {\n      cb(ret);\n    }\n \n  }\n  _resolve(value) {\n    if(this.state !== &#039;pending&#039;) return\n    if (value &amp;&amp; (typeof value === &#039;object&#039; || typeof value === &#039;function&#039;)) {\n      var then = value.then;\n      if (typeof then === &#039;function&#039;) {\n        then.call(value, this._resolve.bind(this), this._reject.bind(this));\n        return;\n      }\n    }\n \n    this.state = &#039;fulfilled&#039;;//改变状态\n    this.value = value;//保存结果\n    this.callbacks.forEach(callback =&gt; this._handle(callback));\n  }\n  _reject(error) {\n    if(this.state !== &#039;pending&#039;) return\n    this.state = &#039;rejected&#039;;\n    this.value = error;\n    this.callbacks.forEach(callback =&gt; this._handle(callback));\n  }\n}\n扩展阅读\n\n5、前端面试之道-手写 Promise\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：SPA":{"title":"手写题：SPA","links":[],"tags":["编程/手写"],"content":"hash\n// 定义 Router  \nclass Router {  \n    constructor () {  \n        this.routes = {}; // 存放路由path及callback  \n        this.currentUrl = &#039;&#039;;  \n          \n        // 监听路由change调用相对应的路由回调  \n        window.addEventListener(&#039;load&#039;, this.refresh, false);  \n        window.addEventListener(&#039;hashchange&#039;, this.refresh, false);  \n    }  \n      \n    route(path, callback){  \n        this.routes[path] = callback;  \n    }  \n      \n    push(path) {  \n        this.routes[path] &amp;&amp; this.routes[path]()  \n    }  \n}  \n  \n// 使用 router  \nwindow.miniRouter = new Router();  \nminiRouter.route(&#039;/&#039;, () =&gt; console.log(&#039;page1&#039;))  \nminiRouter.route(&#039;/page2&#039;, () =&gt; console.log(&#039;page2&#039;))  \n  \nminiRouter.push(&#039;/&#039;) // page1  \nminiRouter.push(&#039;/page2&#039;) // page2  \nhistory\n// 定义 Router  \nclass Router {  \n    constructor () {  \n        this.routes = {};  \n        this.listerPopState()  \n    }  \n      \n    init(path) {  \n        history.replaceState({path: path}, null, path);  \n        this.routes[path] &amp;&amp; this.routes[path]();  \n    }  \n      \n    route(path, callback){  \n        this.routes[path] = callback;  \n    }  \n      \n    push(path) {  \n        history.pushState({path: path}, null, path);  \n        this.routes[path] &amp;&amp; this.routes[path]();  \n    }  \n      \n    listerPopState () {  \n        window.addEventListener(&#039;popstate&#039; , e =&gt; {  \n            const path = e.state &amp;&amp; e.state.path;  \n            this.routers[path] &amp;&amp; this.routers[path]()  \n        })  \n    }  \n}  \n  \n// 使用 Router  \n  \nwindow.miniRouter = new Router();  \nminiRouter.route(&#039;/&#039;, ()=&gt; console.log(&#039;page1&#039;))  \nminiRouter.route(&#039;/page2&#039;, ()=&gt; console.log(&#039;page2&#039;))  \n  \n// 跳转  \nminiRouter.push(&#039;/page2&#039;)  // page2  "},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：websocket建立过程":{"title":"手写题：websocket建立过程","links":["C-Knowledge/前端/开发技术/JavaScript/说说对WebSocket的理解！应用场景！"],"tags":["编程/网络"],"content":"\n\n说说对WebSocket的理解！应用场景！\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/搜索旋转排序数组":{"title":"搜索旋转排序数组","links":[],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n**输入：**nums = [4,5,6,7,0,1,2], target = 0\n**输出：**4\n示例 2：\n**输入：**nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n示例 3：\n**输入：**nums = [1], target = 0\n输出：-1\n提示：\n\n1 &lt;= nums.length &lt;= 5000\n-104 &lt;= nums[i] &lt;= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 &lt;= target &lt;= 104\n\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/播放器秒开优化丨音视频工业实战":{"title":"播放器秒开优化丨音视频工业实战","links":[],"tags":["编程/FE/音视频"],"content":"视频播放时的画面打开速度是播放体验中一个非常重要的指标，如果视频画面打开速度太慢，用户失去耐心可能就直接划走不看了。如果视频速度打开够快，甚至可以带来业务上的收益，字节跳动就曾给出过一份数据：对一部分型号的 Android 手机，播放首帧时长从平均 170ms 优化到 100ms，带来了 0.6% 左右的用户播放时长提升。\n对于视频播放时的画面打开速度，我们可以用下面的指标来衡量：\n\n播放秒开率，指的是播放器开始初始化到视频第一帧画面渲染出来的时间不超过 1s 的次数在总的播放次数中的比例。\n播放平均首帧时长，指的是播放器开始初始化到视频第一帧画面渲染出来的平均耗时。\n\n拆解播放器请求视频并播放的过程，我们大致可以分为下面几个阶段：\n\n业务侧结合优化\nDNS 解析\nTCP 连接\nHTTP 响应\n音视频探测\n媒体封装格式探测\n\n音频编码格式探测（要创建解码器）\n视频编码格式探测（要创建解码器）\n\n\n音视频解码\n缓冲和起播策略\n渲染\n\n我们就结合开源播放器 IJKPlayer[1]，从这几个阶段来分别聊一聊视频秒开的优化思路。\n1、业务侧结合优化\n1.1、客户端业务侧提前获取流地址\n说到优化，首先要看客户端上进入直播间的业务场景是什么样的？一般而言，都是从一个直播列表页面，点击某一个直播卡片（Cell）即进入直播间。这个过程中，数据流是怎么走的呢？最简单的做法是，从直播列表页点击某个直播卡片到直播间后，从服务器请求直播流地址以及各种直播间信息（主播信息、聊天信息、点赞信息、礼物信息等等），拿到直播流地址后，交给播放器播放。\n在这个过程中，我们可以看到播放器必须等到进入直播间请求到直播流地址后才能开始播放，这个时间点其实是可以提前的：我们可以在直播列表页就拿到每个直播间对应的直播流地址，在进入直播间时直接传过去，这样一进入直播间播放器就可以拿着直播流地址开始播放了，省去了从服务器请求直播流地址的时间（虽然这个时间可能没多少）。\n甚至，我们可以在直播列表页当滑到一个卡片就让播放器拿着直播流地址预加载，进入直播间时则直接展示画面。\n业务侧提前获取流地址\n另外，客户端业务侧还可以在进入直播间之前通过 HTTPDNS 来选择网络情况最好的 CDN 节点，在进入直播间时从最好的节点拉取直播流播放从而优化网络加载的时间，加快首屏渲染。\n1.2、使用 URL 替代 VID 方式\n传统的 VID 播放方式，视频在播放时，客户端播放器拿到是 VID，还需要再去服务端请求到视频 URL 才能真正启动播放，这样多了一次请求等待时间，降低了视频打开速度。如果将视频 URL 封装在 model 中直接给播放器就可以省下一次请求 URL 的时间了。\n1.3、上下滑短视频场景提前加载播放器\n现在大部分短视频消费侧的业务 UI 和交互形态都是类似抖音那样的全屏上下滑形式。常见的处理方式是等待滑动结束时加载下一个坑位的播放器进行视频的切换，这里其实可以优化为：在滑动开始时就加载下一个坑位的播放器启动视频播放。不过，这里需要做到的是播放器要有异步加载的能力，否则可能会造成 UI 线程卡顿。在这个基础上，再配合上播放器实例复用、预加载、预渲染优化就可以大大提高视频打开体验。\n1.4、封面图清晰度降级\n在短视频业务实现中，我们通常会加载一张视频首帧的封面图作为占位图，等待播放器完成视频首帧渲染时隐藏掉这张封面图完成画面衔接给用户一种流畅的体验。\n当视频首帧优化做的比较好时，这张封面图反过来可能成为了无用的成本和负担。比如，当我们已经可以通过预加载、预渲染较快的用播放器完成后面坑位视频首帧的渲染，这时候还去加载对应的封面图，就既抢了带宽，又浪费了流量。\n这时候可以对封面清晰度进行降级，比如原来 720P 的封面图可以降级到 540P。甚至，我们可以优先做预加载、预渲染，兜底情况才加载封面图。\n2、DNS 解析\n2.1、优化 DNS 解析过程\nDNS 解析是网络请求的第一步，在我们用基于 FFmpeg 实现的播放器 ffplay 中，所有的 DNS 解析请求都是 FFmpeg 调用 getaddrinfo 方法来获取的。\n我们如何在 FFmpeg 中统计 DNS 耗时呢？\n可以在 libavformat/tcp.c 文件中的 tcp_open 方法中，按以下方法统计：\nint64_t start = av_gettime();\nif (!hostname[0])\n    ret = getaddrinfo(NULL, portstr, &amp;hints, &amp;ai);\nelse\n    ret = getaddrinfo(hostname, portstr, &amp;hints, &amp;ai);\nint64_t end = av_gettime();\n如果在没有缓存的情况下，实测发现一次域名的解析会花费至少 300ms 左右的时间，有时候更长，如果本地缓存命中，耗时很短，几个 ms 左右，可以忽略不计。缓存的有效时间是在 DNS 请求包的时候，每个域名会配置对应的缓存 TTL 时间，这个时间不确定，根据各域名的配置，有些长有些短，不确定性比较大。\n为什么 DNS 的请求这么久呢？一般理解，DNS 包的请求，会先到附近的运营商的 DNS 服务器上查找，如果没有，会递归到根域名服务器，这个耗时就很久。一般如果请求过一次，这些服务器都会有缓存，而且其他人也在不停的请求，会持续更新，下次再请求的时候就会比较快。\n在测试 DNS 请求的过程中，有时候通过抓包发现每次请求都会去请求 A 和 AAAA 查询，这是去请求 IPv6 的地址，但由于我们的域名没有 IPv6 的地址，所以每次都要回根域名服务器去查询。为什么会请求 IPV6 的地址呢，因为 FFmpeg 在配置 DNS 请求的时候是按如下配置的：\nhints.ai_family = AF_UNSPEC;\n它是一个兼容 IPv4 和 IPv6 的配置，如果修改成 AF_INET，那么就不会有 AAAA 的查询包了。通过实测发现，如果只有 IPv4 的请求，即使是第一次，也会在 100ms 内完成，后面会更短。这里是一个优化点，但是要考虑将来兼容 IPv6 的问题。\nDNS 的解析一直以来都是网络优化的首要问题，不仅仅有时间解析过长的问题，还有小运营商 DNS 劫持的问题。采用 HTTPDNS 是优化 DNS 解析的常用方案，不过 HTTPDNS 在部分地区也可能存在准确性问题，综合各方面可以采用 HTTPDNS 和 LocalDNS 结合的方案，来提升解析的速度和准确率。大概思路是，App 启动的时候就预先解析我们指定的域名，因为拉流域名是固定的几个，所以完全可以先缓存在 App 本地。然后会根据各个域名解析的时候返回的有效时间，过期后再去解析更新缓存。至于 DNS 劫持的问题，如果 LocalDNS 解析出来的 IP 无法正常使用，或者延时太高，就切换到 HTTPDNS 重新解析。这样就保证了每次真正去拉流的时候，DNS 解析的耗时几乎为 0，因为可以定时更新缓存池，使每次获得的 DNS 都是来自缓存池。\n那么怎么去实现 HTTPDNS 呢？\n方案一：IP 直连。\n假设原直播流的 URL 是：www.example.com/abc.flv。假设从 HTTPDNS 服务获取的 www.example.com 这个 Host 对应的 IP 是：192.168.1.1。那么处理后的 URL 是：http://192.168.1.1/abc.mp4。如果直接用这个 URL 去发起 HTTP 请求，有些情况可以成功，但很多情况是不行的。如果这个 IP 的机器只部署了 www.example.com 对应的服务，就能解析出来，如果有多个域名的服务，CDN 节点就无法正确的解析。这个时候一般需要设置 HTTP 请求的 header 里面的 Host 字段。\nAVDictionary **dict = ffplayer_get_opt_dict(ffplayer, opt_category);\nav_dict_set(dict, &quot;headers&quot;, &quot;Host: www.example.com&quot;, 0);\n但是这个方案有两个问题：\n1）服务端采用 302/307 跳转的方式调度资源，则 IP 直连会有问题。\n如果在客户端发出请求（如：www.example.com/abc.flv）的时候，服务端是通过 302/307 调度方式返回直播资源的真实地址（如：www.realservice.com/abc.flv），这时 IP 直连会有问题。因为客户端并不知道跳转逻辑，而客户端做了 IP 直连，用的是 www.example.com 获取到的直连 IP 并替换成了 http://192.168.1.1/abc.mp4，这个请求到达服务器，服务器又没有对应的资源，则会导致错误。这种情况可以让服务端采用不下发 302 跳转的方式，但这样就不通用了，会给将来留下隐患。所以常见的做法是做一层播控服务，客户端请求播控服务获取到实际的播放地址以及各种其他的信息，然后再走 IP 直连就没问题。\n还可以参考：iOS 302 等重定向业务场景 IP 直连方案说明[2]。\n2）使用 HTTPS 时，IP 直连会有问题。\n这种方案在使用 HTTPS 时，是会失败的。因为 HTTPS 在证书验证的过程，会出现 domain 不匹配导致 SSL/TLS 握手不成功。这时候的方案参考 HTTPS（含 SNI）业务场景 IP 直连方案说明[3] 和 iOS HTTPS SNI 业务场景IP直连方案说明[4]。\n方案二：替换 FFmpeg 的 DNS 实现。\n另一种方案是替换原来的 DNS 解析的实现。在 FFmpeg 中即替换掉 tcp.c 中 getaddreinfo 方法，这个方法就是实际解析 DNS 的方法，比如下面代码：\nif (my_getaddreinfo) {\n    ret = my_getaddreinfo(hostname, portstr, &amp;hints, &amp;ai);\n} else {\n    ret = getaddrinfo(hostname, portstr, &amp;hints, &amp;ai);\n \n}\n在 my_getaddreinfo 中可以自己实现 HTTPDNS 的解析逻辑从而优化原来的 DNS 解析速度。\n总体来说，DNS 优化后，直播首屏时间能减少 100ms～300ms 左右，特别是针对很多首次打开，或者 DNS 本地缓存过期的情况下，能有很好的优化效果。\n2.2、提升 HTTP DNS 的有效率\n在使用 HTTP DNS 做 IP 直连时可能会发生解析到的 IP 失效的情况。比如：\n\n播放视频或直播时，网络发生切换（比如 WIFI 切到 4G），播放器刷新连接，这时候如果用的还是在之前网络环境下取得的 IP，那这个 IP 很大可能是失效的。\n在上下滑的场景，业务层如果提前获取还未展示的视频或直播对应的 HTTP DNS IP，那用户滑到对应的内容时，这个 IP 也可能是失效的。\n播放器在内部做一些刷新操作时，如果复用了当前的 HTTP DNS IP，这个 IP 也可能是失效的。\n\n要提升 HTTP DNS 的有效率，可以做一个轮询模块，参考 HTTP DNS IP 的过期时间来定时轮询并缓存新 IP 这样来保持 IP 的有效性，同时也要处理各种网络切换或内部刷新时更新 IP 的情况。\n3、TCP 连接\n3.1、优化 TCP 建连耗时\nTCP 建连耗时在这里即调用 Socket 的 connect 方法建立连接的耗时，它是一个阻塞方法，它会一直等待 TCP 的三次握手完成。它直接反应了客户端到 CDN 服务器节点的点对点延时情况，实测在一般的 WIFI 网络环境下耗时在 50ms 以内，它的时间反应了客户端的网络情况或者客户端到节点的网络情况。\n要统计这段耗时，可以在 libavformat/tcp.c 文件中的 tcp_open 方法中，按以下方法统计：\nint64_t start = av_gettime();\nif ((ret = ff_listen_connect(fd, cur_ai-&gt;ai_addr, cur_ai-&gt;ai_addrlen,\n                             s-&gt;open_timeout / 1000, h, !!cur_ai-&gt;ai_next)) &lt; 0) {\n    if (ret == AVERROR_EXIT)\n        goto fail1;\n    else\n        goto fail;\n}\nint64_t end = av_gettime();\nTCP 连接耗时可优化的空间主要是针对建连节点链路的优化，主要受限于三个因素影响：用户自身网络条件、用户到 CDN 边缘节点中间链路的影响、CDN 边缘节点的稳定性。因为用户网络条件有比较大的不可控性，所以优化主要会在后面两个点。可以结合着用户所对应的城市、运营商的情况，同时结合优化服务端的 CDN 调度体系，结合 HTTPDNS 给用户分配更优的连接链路（比如就近接入），从而优化建连耗时。\n3.2、通过 TCP Fast Open 优化 TCP 建连时长\n我们通常提到的 TCP 建立连接的三次握手过程和断开连接的四次挥手过程如下图所示：\n\nTCP 三次握手和四次挥手\nTFO(TCP Fast Open) 是用来加速连续 TCP 连接的数据交互的 TCP 协议扩展，是对 TCP 握手过程的一种简化。它的原理是：在 TCP 三次握手的过程中，当用户首次访问 Server 时，发送 SYN 包，Server 根据用户 IP 生成 Cookie（已加密），并与 SYN-ACK 一同发回 Client；当 Client 随后重连时，在 SYN 包携带 TCP Cookie；如果 Server 校验合法，则在用户回复 ACK 前就可以直接发送数据；否则按照正常三次握手进行。\nTFO 由 Google 于 2011 年的论文 TCP Fast Open 中提出，IPV4 的 TFO 已经合入 Linux Kernel Mainline，Client 内核版本为 3.6，Server 内核版本为 3.7。\nGoogle 研究发现 TCP 三次握手是页面延迟时间的重要组成部分，所以他们提出了 TFO：在 TCP 握手期间交换数据，这样可以减少一次 RTT。根据测试数据，TFO 可以减少 15% 的 HTTP 传输延迟，全页面的下载时间平均节省 10%，最高可达 40%。\nTCP Fast Open 流程图如图：\n\nTCP Fast Open 流程\nRequesting Fast Open Cookie in connection 1:\n \nTCP A (Client)                                      TCP B (Server)\n______________                                      ______________\nCLOSED                                                      LISTEN\n \n#1 SYN-SENT       ----- &lt;SYN,CookieOpt=NIL&gt;  ----------&gt;  SYN-RCVD\n \n#2 ESTABLISHED    &lt;---- &lt;SYN,ACK,CookieOpt=C&gt; ----------  SYN-RCVD\n(caches cookie C)\n \nPerforming TCP Fast Open in connection 2:\n \nTCP A (Client)                                      TCP B (Server)\n______________                                      ______________\nCLOSED                                                      LISTEN\n \n#1 SYN-SENT       ----- &lt;SYN=x,CookieOpt=C,DATA_A&gt; ----&gt;  SYN-RCVD\n \n#2 ESTABLISHED    &lt;---- &lt;SYN=y,ACK=x+len(DATA_A)+1&gt; ----  SYN-RCVD\n \n#3 ESTABLISHED    &lt;---- &lt;ACK=x+len(DATA_A)+1,DATA_B&gt;----  SYN-RCVD\n \n#4 ESTABLISHED    ----- &lt;ACK=y+1&gt;--------------------&gt; ESTABLISHED\n \n#5 ESTABLISHED    --- &lt;ACK=y+len(DATA_B)+1&gt;----------&gt; ESTABLISHED\nTFO 的流程如下：\n\n1、Client 向 Server 发送 SYN 包并请求 TFO Cookie。\n2、Server 根据 Client 的 IP 加密生成 Cookie，随 SYN+ACK 发给 Client。\n3、Client 储存 TFO Cookie。\n\n当连接断掉，重连后的流程如下：\n\n1、Client 向 Server 发送 SYN 包（携带 TCP Cookie），同时附带请求和数据。\n2、Server 校验 Cookie（解密 Cookie 以及比对 IP 地址或者重新加密 IP 地址以和接收到的 Cookie 进行对比）。如果验证成功，Server 向 Client 发送 SYN+ACK。\n\n\n如果验证失败，则丢弃 Client 在步骤 1 中 TFO 请求携带的数据，回复 SYN+ACK，后续完成正常的三次握手。\n\n如果步骤 1 中 Cookie 在网络传输的过程中被丢弃，Client 在 RTO 后，发起普通的 TCP 连接，流程如图：\n\n\n\n\n\nCookie 被丢弃情况\n\n3、如果在步骤 2 验证成功，那么 Server 在发送 SYN+ACK 后，在收到 Client 的 ACK 之前就可以回复该请求的响应报文，发送数据。\n4、Client 发送 ACK 回复步骤 2 中 Server 的 SYN。\n5、Client 发送 ACK 回复步骤 3 中 Server 的 SYN。\n6、随后的操作和普通的 TCP 连接一致。\n\n建立了 TFO 连接而又没有完成 TCP 连接的请求在 Server 端被称为 pending TFO connection，当 pending 的连接超过上限值，Server 会关闭 TFO，后续的请求会按正常的三次握手处理。\n如果一个带有 TFO 的 SYN 请求如果在一段时间内没有收到回应，用户会重新发送一个标准的 SYN 请求，不带任何其他数据。\n参考：\n\nTCP Fast Open 实践笔记[5]\nTCP Fast Open 的概念、作用以及实现[6]\nTCP 的那些事 | TCP Fast Open[7]\n\n3.3、通过 TCP 预连接和连接复用优化建连时长\n在网络连接层做一个缓存模块，这个缓存会以 IP 为 key 缓存当前的 socket 连接，并设置超时时间。这样一来，就可以提供接口给业务层做 TCP 预连接。\n比如在直播间上下滑的场景，业务层可以对下一个直播间的流做预连接，预连接的过程是使用域名做 HTTPDNS 或 LocalDNS 得到 IP 来做连接。当真正开始拉流时，网络层根据 HTTPDNS 或者 LocalDNS 得到的 IP 发现已经有 socket 连接的缓存，就复用这个连接，这样就节省了重新建连的时间。\n为了提高预连接的命中率，还可以对高频使用的域名做持续预连接，当预连接超时后就再重新连接。需要注意的是，当网络发生切换时，需要刷新预连接缓存池，比如从 WIFI 切到 4G 对应的服务端节点是需要切换的。\n3.4、避免首帧网络带宽争抢\n在短视频上下滑场景中，有时候会遇到用户快速滑动的情况，这时候我们对后面坑位的视频做了预连接、预加载反而可能会适得其反。因为预加载的视频被用户快速滑走了，并没有被用到，这就浪费了带宽，并且由于预加载视频数据还会抢占后面其他视频加载首帧的带宽从而导致黑屏。\n所以当检测到用户是快速滑动时，可以及时中断预连接的 Socket，避免网络带宽争抢。\n4、HTTP 响应\n4.1、优化 HTTP 响应耗时\nHTTP 响应耗时是指客户端发起一个 HTTP Request 请求，然后等待 HTTP 响应的 Header 返回这部分耗时。直播拉流 HTTP-FLV 协议也是一个 HTTP 请求，客服端发起请求后，服务端会先将 HTTP 的响应头部返回，不带音视频流的数据，响应码如果是 200，表明视频流存在，紧接着就开始下发音视频数据。HTTP 响应耗时非常重要，它直接反应了 CDN 服务节点处理请求的能力。它与 CDN 节点是否有缓存这条流有关，如果在请求之前有缓存这条流，节点就会直接响应客户端，这个时间一般也在 50ms 左右，最多不会超过 200ms，如果没有缓存，节点则会回直播源站拉取直播流，耗时就会很久，至少都在 200ms 以上，大部分时间都会更长，所以它反应了这条直播流是是冷流还是热流，以及 CDN 节点的缓存命中情况。\n如果需要统计它的话，可以在 libavformat/http.c 文件中的 http_open 方法：\nint64_t start = av_gettime();\nret = http_open_cnx(h, options);\nint64_t end = av_gettime();\n4.2、提升 CDN 边缘节点命中率\n通常 CDN 的缓存命中策略是与访问资源的 URL 有关。如果命中策略是 URL 全匹配，那么就要尽量保证 URL 的变化性较低。 比如：尽量不要在 URL 的参数中带上随机性的值，这样会造成 CDN 缓存命中下降，从而导致不断回源，这样访问资源耗时也就增加了。当然这样就失去了一些灵活性。\nCDN 方面其实可以提供一些配置策略，比如：根据域名可配置对其缓存命中策略忽略掉某些参数。这样就能保证一定的灵活性了。\n客户端还可以和 CDN 配合来实现对 CDN 边缘节点命中率的埋点。通常做法是让 CDN 厂商在 HTTP 请求的 response header 里面带上是否命中边缘节点的字段，客户端在收到响应时解析这个字段来实现埋点。\n此外，还可以对服务端对热门的内容进行监控，对热门的资源进行预热，使之尽可能缓存到边缘节点，从而提高边缘节点的命中率。\n4.3、优化短视频第一次 Get 请求\n在播放器请求短视频时，通常会先发起一次 Get 请求来获取短视频的文件长度，然后再根据文件长度来获取数据内容。\n如果我们提前获取短视频的文件长度，通过设置 HTTP 请求的 Range 则可以省去第一次 Get 请求来优化首帧时长。\n5、音视频探测\n5.1、优化音视频流探测耗时\n当我们做直播业务时，播放端需要一个播放器来播放视频流，当一个播放器支持的视频格式有很多种时，问题就来了。一个视频流来了，播放器是不清楚这个视频流是什么格式的，所以它需要去探测到一定量的视频流信息，去检测它的格式并决定如何去处理它。这就意味着在播放视频前有一个数据预读过程和一个分析过程。但是对于我们的直播业务来说，我们的提供的直播方案通常是固定的，这就意味着视频流的格式通常是固定的，所以一些数据预读和分析过程是不必要的。在直播流协议格式固定的情况下，只需要读取固定的信息即可开始播放。这样就缩短了数据预读和分析的时间，使得播放器能够更快地渲染出首屏画面。\n\n音视频探测\n基于 FFmpeg 实现的播放器，在播放视频时都会调用到一个 avformat_find_stream_info(libavformat/utils.c) 函数，该函数的作用是读取一定长度的码流数据，来分析码流的基本信息，为视频中各个媒体流的 AVStream 结构体填充好相应的数据。这个函数中做了查找合适的解码器、打开解码器、读取一定的音视频帧数据、尝试解码音视频帧等工作，基本上完成了解码的整个流程。这时一个同步调用，在不清楚视频数据的格式又要做到较好的兼容性时，这个过程是比较耗时的，从而会影响到播放器首屏秒开。\n可以在 ijkplayer 的工程中 ff_ffplay.c 文件中的 read_thread 方法统计其耗时：\nint64_t start = av_gettime();\navformat_find_stream_info(ic, opts);\nint64_t end = av_gettime();\n在外部可以通过设置 probesize 和 analyzeduration 两个参数来控制该函数读取的数据量大小和分析时长为比较小的值来降低 avformat_find_stream_info 的耗时，从而优化播放器首屏秒开。但是，需要注意的是这两个参数设置过小时，可能会造成预读数据不足，无法解析出码流信息，从而导致播放失败、无音频或无视频的情况。所以，在服务端对视频格式进行标准化转码，从而确定视频格式，进而再去推算 avformat_find_stream_info 分析码流信息所兼容的最小的 probesize 和 analyzeduration，就能在保证播放成功率的情况下最大限度地区优化首屏秒开。\n在我们能控制视频格式达到标准化后，我们可以直接修改 avformat_find_stream_info 的实现逻辑，针对该视频格式做优化，进而优化首屏秒开。\n在 FFmpeg 中的 utils.c 文件中的函数实现中有一行代码是 int fps_analyze_framecount = 20;，这行代码的大概用处是，如果外部没有额外设置这个值，那么 avformat_find_stream_info 需要获取至少 20 帧视频数据，这对于首屏来说耗时就比较长了，一般都要 1s 左右。而且直播还有实时性的需求，所以没必要至少取 20 帧。你可以试试将这个值初始化为 0 看看效果。在开发中，我们可以去掉这个条件来实现优化：\nav_dict_set_int(&amp;ffp-&gt;format_opts, &quot;fpsprobesize&quot;, 0, 0);\n这样，avformat_find_stream_info 的耗时就可以缩减到 100ms 以内。\n甚至，我们可以进一步直接去掉 avformat_find_stream_info 这个过程，自定义完成解码环境初始化。参见：VLC 优化（1）avformat_find_stream_info 接口延迟降低[8] 和 FFmpeg avformat_find_stream_info 替换[9]。\n对 avformat_find_stream_info 代码的分析，还可以看看这里：FFmpeg 源代码简单分析：avformat_find_stream_info()[10]。\n5.2、短视频前置 moov box\n播放器在网络点播场景下去请求 MP4 视频数据，需要先获取到文件的 moov box，解析出该文件的编码、帧率等信息后才能开始边下边播。如果 MP4 的 moov box 被放在文件尾部，这种情况会导致播放器只有下载完整个文件后才能成功解析并播放这个视频。对于这种视频，我们最好能够在服务端将其重新编码，将 moov box 转移到靠近文件头部的位置，保证播放器在线请求时能较快播放。比如 FFmpeg 的下列命令就可以支持这个操作：\nffmpeg -i bad.mp4 -movflags faststart good.mp4\n5.3、提前创建解码器\n我们还可以在服务端下发业务层数据时就带上直播流或者视频的封装和编码相关信息，基于这些信息，我们可以跳过音视频探测阶段并直接提前创建解码器。\n比如，在直播场景服务端可以下发 VideoHeader（包括 SPS、PPS、VPS 等数据）信息，客户端提前初始化解码器。\n6、音视频解码\n6.1、提前创建解码器\n播放器可以创建一个解码器复用池，当解码参数一致时，可以复用解码器。这样一来，业务也可以透传给播放器码流相关的信息，让播放器提前创建解码器来降低播放器首帧渲染时间。\n解码器需要的信息通常包括：SPS、PPS、VPS(H.265)。\n6.2、优化解码器刷新操作\nIJKPlayer 播放器在完成音视频探测后，开始进行解码时，如果使用硬解，解码器会在开始做一次刷新解码器的操作，这个操作其实没有必要，但是会有一定的耗时，影响首包到渲染时长。去除这一次刷新操作，首帧时长收益 10-20ms。\n7、缓冲和起播策略\n7.1、优化 Buffer 填充耗时\n缓冲耗时是指播放器的缓冲的数据达到了预先设定的阈值，可以开始播放视频了。这个值是可以动态设置的，所以不同的设置给首屏带来的影响是不一样的。\n缓冲耗时的统计方法，不像前面几个那么简单，因为它涉及到的代码有多处，所以需要在多个地方计时。开始计时可以直接从 avformat_find_stream_info 后面开始，结束计时可以在第一帧视频渲染出来的时候结束。\navformat_find_stream_info(ic, opts);\nstart = av_gettime();\n \n...\n \nif (!ffp-&gt;first_video_frame_rendered) {\n    ffp-&gt;first_video_frame_rendered = 1;\n    ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);\n    end = av_gettime();\n}\n优化一：调整 BUFFERING_CHECK_PER_MILLISECONDS 设置。\n缓冲区填充耗时跟播放器里面的一个设置 BUFFERING_CHECK_PER_MILLISECONDS 值有关，因为播放器 check 缓冲区的数据是否达到目标值不是随意检测的，因为 check 本身会有一定的浮点数运算，所以 ijkplayer 最初给他设置了 500ms 时间间隔去定时检查，这个时间明显比较大，所以会对缓冲耗时有比较大的影响。可以把这个值改小一些。\n#define BUFFERING_CHECK_PER_MILLISECONDS        (500)\n这个值会在 ijkplayer 工程中 ff_ffplay.c 文件中的 read_thread 方法中用到：\nif (ffp-&gt;packet_buffering) {\n    io_tick_counter = SDL_GetTickHR();\n    if (abs((int)(io_tick_counter - prev_io_tick_counter)) &gt; BUFFERING_CHECK_PER_MILLISECONDS){\n        prev_io_tick_counter = io_tick_counter;\n        ffp_check_buffering_l(ffp);\n    }\n}\n从这个代码逻辑中可以看出，每次调用 ffp_check_buffering_l 去检查 buffer 是否满足条件的时间间隔是 500ms 左右，如果刚好这次只差一帧数据就满足条件了，那么还需要再等 500ms 才能再次检查了。这个时间，对于直播来说太长了。我们当前的做法是降低到 50ms，从实测效果来看平均可以减少 200ms 左右。\n优化二：调整 MIN_MIN_FRAMES 设置。\n另外一个跟缓冲区相关的设置是 MIN_MIN_FRAMES，其对应的使用逻辑在 ffp_check_buffering_l(ffp) 函数中：\n#define MIN_MIN_FRAMES      10\n \nif (is-&gt;buffer_indicator_queue &amp;&amp; is-&gt;buffer_indicator_queue-&gt;nb_packets &gt; 0) {\n    if (   (is-&gt;audioq.nb_packets &gt; MIN_MIN_FRAMES || is-&gt;audio_stream &lt; 0 || is-&gt;audioq.abort_request)\n        &amp;&amp; (is-&gt;videoq.nb_packets &gt; MIN_MIN_FRAMES || is-&gt;video_stream &lt; 0 || is-&gt;videoq.abort_request)) {\n        printf(&quot;ffp_check_buffering_l buffering end \\n&quot;);\n        ffp_toggle_buffering(ffp, 0);\n    }\n}\n这里大概的意思需要缓冲的数据至少要有 11 帧视频和 11 个音频数据包，才能离开缓冲区开始播放。音频数据很容易满足条件，因为如果采样率是 44.1k 的音频，那么 1s 的数据平均有 44 个音频包，0.25s 的数据就能达到 11 个音频包。但对于视频，如果是 24 帧的帧率，至少需要 0.4s 左右的数据才能达到 11 帧。如果视频采集的编码帧率较低（美颜、AR 情况下由于处理消耗较大可能采集的帧率较低），只有 10-15，那就需要接近 1s 的数据才能达到 11 帧，缓冲区需要这么多数据才能开始播放，这个时长太大。\n缓冲区里达到这么多数据时，实际上播放器已经下载了多少数据呢？我们深入 ff_ffplay.c源码可以看到视频解码后会放到一个 frame_queue 里面，用于渲染数据。可以看到视频数据的流程是这样的：下载缓冲区 -&gt; 解码 -&gt; 渲染缓冲区 -&gt; 渲染。其中渲染的缓冲区就是 frame_queue。下载的数据会先经过解码线程将数据输出到 frame_queue 中，然后等 frame_queue 队列满了，才开始渲染。在 ff_ffplay.c 中，可以找到如下代码：\n#define VIDEO_PICTURE_QUEUE_SIZE_MIN        (3)\n#define VIDEO_PICTURE_QUEUE_SIZE_MAX        (16)\n#define VIDEO_PICTURE_QUEUE_SIZE_DEFAULT    (VIDEO_PICTURE_QUEUE_SIZE_MIN)\n \nffp-&gt;pictq_size = VIDEO_PICTURE_QUEUE_SIZE_DEFAULT; // option\n \n/* start video display */\nif (frame_queue_init(&amp;is-&gt;pictq, &amp;is-&gt;videoq, ffp-&gt;pictq_size, 1) &lt; 0)\n    goto fail;\n所以目前来看，如果设置 MIN_MIN_FRAMES 为 10，播放器开始播放时至少有 14 帧视频。对于低帧率的视频来说，也相当大了。在实践中我们把它调整到 5，首屏时间减少了 300ms 左右，并且卡顿率只上升了 2 个百分点左右。\n优化三：以 audio 缓冲区水位线驱动起播。\n有时候会遇到 video packet duration 会有为空的情况，而 IJKPlayer 是以 video 缓冲区水位线来驱动起播的，这样由于有点 video packet 的 duration 为空，会导致为了累积足够的水位下载了实际时长超过水位线的视频数据才开播，这就导致起播较慢，对于这个问题，可以改为：以 audio 缓冲区水位线驱动起播，因为 audio packet 的 duration 通常都是正常的，这样可以优化起播速度。\n7.2、流媒体服务器侧 GOP 缓存\n除了客户端业务侧的优化外，我们还可以从流媒体服务器侧进行优化。我们都知道直播流中的图像帧分为：I 帧、P 帧、B 帧，其中只有 I 帧是能不依赖其他帧独立完成解码的，这就意味着当播放器接收到 I 帧它能马上渲染出来，而接收到 P 帧、B 帧则需要等待依赖的帧而不能立即完成解码和渲染，这个期间就是「黑屏」了。\n所以，在服务器端可以通过缓存 GOP（在 H.264 中，GOP 是封闭的，是以 I 帧开头的一组图像帧序列），保证播放端在接入直播时能先获取到 I 帧马上渲染出画面来，从而优化首屏加载的体验。\n这里有一个 IDR 帧的概念需要讲一下，所有的 IDR 帧都是 I 帧，但是并不是所有 I 帧都是 IDR 帧，IDR 帧是 I 帧的子集。I 帧严格定义是帧内编码帧，由于是一个全帧压缩编码帧，通常用 I 帧表示「关键帧」。IDR 是基于 I 帧的一个扩展，带了控制逻辑，IDR 图像都是 I 帧图像，当解码器解码到 IDR 图像时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃。重新查找参数集，开始一个新的序列。这样如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。在 H.264 编码中，GOP 是封闭式的，一个 GOP 的第一帧都是 IDR 帧。\nGOP 缓存\n通常我们可以在 CDN 的边缘节点做 GOP 缓存。\n7.3、服务端快速下发策略\n快速启动优化则是会在 GOP 缓存基本上根据播放器缓冲区大小设定一定的 GOP 数量用于填充播放器缓冲区。\n这个优化项并不是客户端播放器来控制的，而是在 CDN 服务端来控制下发视频数据的带宽和速度。因为缓冲区耗时不仅跟缓冲需要的帧数有关，还跟下载数据的速度优化，以网宿 CDN 为例，他们可以配置快速启动后，在拉取直播流时，服务端将以 5 倍于平时带宽的速度下发前面缓存的 1s 的数据，这样的效果除了首屏速度更快以外，首屏秒开也会更稳定，因为有固定 1s 的缓存快速下发。这个优化的效果可以使首屏秒开速度提升 100ms 左右。\n7.4、提升 HLS 的播放秒开\nHLS 的播放秒开分为「直接开播」和「开播 seek」的情况。\n1）直接开播\n对于「直接开播」的场景，播放起播速度跟播放器的策略有很大的关系。比如 iOS 的 AVPlayer 可能需要下载 3 个 ts 切片才会开始播放。IJKPlayer 则使用水位线策略下载到一定量的数据就能开播，这样相对起播会更快一些。\n2）开播 seek\n通常我们会用 HLS 来保存直播的回放文件，由于一场直播的时间通常较长，在观看回放时，通常需要 seek 到某一个位置来定位到用户感兴趣的内容。\n对于一般的播放器，可能需要先初始化播放器并从头加载播放内容，再由业务做 seek 操作，这样会比较慢。IJKPlayer 有 seek-at-start 能力，直接去下载目前位置的数据，不用从头加载再 seek，优化开播就 seek 的速度。\n一般 HLS 的 ts 切片是按照直播的 GOP 来切片的，如果 seek 到某个 ts 切片的中间位置，会需要从这个 ts 切片的开始位置下载数据并解码，再计算 seek 到的位置来展示画面，这样的 seek 过程会比较慢。对于这个问题，服务端可以根据直播内容打点将一场直播切成多个 m3u8，不再是整场内容只使用一个 m3u8，而是一个内容段对应一个 m3u8。这样可以尽量保证用户点击内容锚点时，是直接从头播放一个 m3u8，不用 seek，从而优化响应速度。\n如果用户自己拖动进度来 seek，这时候就是实实在在的需要对 seek 进行优化了，这里我们在使用 IJKPlayer 时有一个优化点：有时候会遇到 video packet duration 会有为空的情况，而 IJKPlayer 是以 video 缓冲区水位线来驱动起播的，这样由于有点 video packet 的 duration 为空，会导致为了累积足够的水位下载了实际时长超过水位线的视频数据才开播，这就导致 seek 较慢，对于这个问题，可以改为：以 audio 缓冲区水位线驱动起播，因为 audio packet 的 duration 通常都是正常的，这样可以优化 seek 速度。\n我们还遇到过 HLS seek 黑屏的问题。主要是启动就 seek 时，seek_position = stream.start_time + seek_duration，stream 的 first_timestamp 未正确初始化，导致无法找到 seek 的位置，seek 失败。\n此外，IJKPlayer 支持 EXT-X-DISCONTINUITY 标签有问题，需要解决跨断层 ts seek 的问题。seek 位置解析到的 pts 如果有断层，要加上断层前的所有 ts 的时长。\n7.5、优化 IJKPlayer 在设置 Surface 时重置解码器的等待时长\n在 Android 的实现上，如果 Surface 没有提前创建，IJKPlayer 会先创建一个空转的解码器，解码器会有一个取 buffer 的操作，这个过程有锁，同时会有一个 sleep 时长 100ms。当 Surface 被设置后，IJKPlayer 需要重新配置解码器，这个操作也需要获得前面那个锁，这时候则需要最多等间隔时长 100ms。此外，重新配置解码器也需要几十毫秒。后面解码器创建成功后去从 buffer 取数据时，也会受到前面锁的影响，这时候又需要最多等间隔时长 100ms。\n根据这个情况，可以在没有设置 Surface 时，解码器空转的情况下，让线程直接等待，而不进入取 buffer 的操作，防止进入到加锁逻辑，这样可以避免当 Surface 被设置后因为等待锁而造成的延时。\n7.6、视频预加载\n视频预加载是一种常见的首帧优化措施，原理就是提前下载一部分视频数据来达到快速起播。\n原理很简单，但是想要取得好的优化结果则需要考虑诸多因素：什么时候开始预加载、预加载多少数据、并行预加载的数量等等。\n并且，针对不同的场景，同样的策略可能结果也不一样，所以要做好预加载需要结合业务场景使用实验来调试出最合适的策略参数。\n7.7、视频本地缓存\n加载视频进行播放时，还可以再开一路存储任务，将视频数据缓存到本地，这样当视频下一次再被播放时就可以直接从本地缓存请求数据，一方面可以节省带宽，另一方面可以提升数据加载的速度，从而提升首帧秒开速度。\n当然这里的本地缓存需要考虑到如何对视频数据进行分片管理以及当缓存过大时如何对缓存进行清理。\n8、渲染\n8.1、播放器预渲染\n通过预加载视频数据，可以将网络请求的耗时给优化掉，但是播放器还是需要经历解封装、解码、渲染的过程，这个在中低端机器上也会有 100-200ms 的耗时。我们可以通过预渲染来把这些耗时给优化掉。\n预渲染是播放器在拿到视频 URL 后就可以开始进行 prepare，在这个过程中会开始读取数据进行解封装、解码和渲染，当首帧渲染处理后就等待后续的 play 指令再进行播放。\n预渲染对 CPU、GPU 有额外的消耗，可能会导致 UI 帧率下降，这时候要根据机型性能选择性开启。\n此外，预渲染和预加载同时开启时，也要进行策略优化。\n8.2、预渲染首帧代替封面图\n当完成了预渲染的能力，其实可以使用播放器预渲染的首帧代替封面图，这样可以节省封面图下载的流量，也可以降低下载封面图导致的带宽争抢。\n但是最终还是要有一个兜底策略，比如：当预渲染未完成时，应该在什么时机选择继续加载封面图。"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/旋转图像":{"title":"旋转图像","links":["D-Unsorted/交换变量的值","C-Knowledge/前端/技术书籍/JavaScript教程/Array-对象"],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例 1：\n\n输入： matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n示例 2：\n\n输入： matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n提示：\n\nn == matrix.length == matrix[i].length\n1 &lt;= n &lt;= 20\n-1000 &lt;= matrix[i][j] &lt;= 1000\n\n\n\n\n                  \n                  解题思路 \n                  \n                \n\n先转置矩阵。然后按行进行翻转。\n\n\n\n/**\n * 先转置矩阵，然后翻转每一行。\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    const n = matrix.length\n    // 转置矩阵\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = i; j &lt; n; j++) {\n            const temp = matrix[i][j]\n            matrix[i][j] = matrix[j][i]\n            matrix[j][i] = temp\n        }\n    } \n    // 翻转每一行\n    for (let i = 0; i &lt; n; i++) {\n        // 翻转一行\n        for (let j = 0; j &lt; n / 2; j++) {\n            const temp = matrix[i][j]\n            matrix[i][j] = matrix[i][n - j - 1]\n            matrix[i][n - j - 1] =  temp\n        }\n    }\n};\n下面是更简化版本，使用逻辑运算符交换变量的值并使用reverse()进行翻转。\nvar rotate = function(matrix) {\n    for (let x = 0; x &lt; matrix.length; x++) {\n        for (let y = x; y &lt; matrix.length; y++) {\n            if (x === y) continue;\n \n            // swap without third party\n            matrix[x][y] = matrix[x][y] ^ matrix[y][x];\n            matrix[y][x] = matrix[x][y] ^ matrix[y][x];\n            matrix[x][y] = matrix[x][y] ^ matrix[y][x];\n        }\n    }\n \n    for (let x = 0; x &lt; matrix.length; x++) {\n        matrix[x].reverse();\n    }\n};"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/杭州小码教育科技有限公司":{"title":"杭州小码教育科技有限公司","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6中-Promise的！使用场景！","D-Unsorted/async-函数","C-Knowledge/前端/什么是链式调用！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说你对函数式编程的理解！优缺点！","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/手写题：Promise"],"tags":["场景/面试"],"content":"面试\n自我介绍\n\n2 年全栈开发经验，有 3 年的小程序、Vue 开发经验，分别有 3 个上线项目和微信小程序有 4 个 Demo 项目，有使用 uniapp，进行多端开发的经验。了解计算机图形学，最近学习了 docker 和 webrtc。\n作为开发负责人负责播放器项目技术选型工作，从 0 到 1为公司搭建了前端播放器。注重前端标准化，在部门内部推行前端规范的落地。\n拥有自己的知识库和命令行工具（Node. js)，用于沉淀最佳实践，提高提高开发效率。\n\n反问\n技术相关\n\n你觉得我的技术有什么问题？下一步应该怎么学习？\n咱们公司的技术栈是什么？主要是 React、然后是 Vue 、小程序和客户端。\n岗位的任务和团队的风格？  进入公司，负责的内容？\n技术团队规模？技术30多人前端8人。\n晋升路线。\n目标用户、用户体量，产品优势，怎么盈利？给低龄孩子图形化的编程。提供编辑器和直播上课使用声网的工具。\n\nscratch ： 少儿趣味编程\n\n\n\nHR相关\n\n工作时间？9点～10点，弹性工作制。\n现在加班的强度？双休、加班调休。\n请问公司的调薪是怎么样的呢？ 业务盈利状态和贡献度（积极性和克服了多少问题）\n几轮面试？2～3轮，线上+现场面试\n\n面试内容\n\n自我介绍\n重庆和上海的工作经历，长远想呆的地方？\n自己有写过相关的React项目吗？\n前端的性能优化你知道那些方法吗？\n预加载和懒加载有什么区别？\n列表中加加字段key？\n你是怎么理解ES6中 Promise的！使用场景！\n事件循环，发送结果给面试、async 函数：\n\nasync function async1() {\n  console.log(&quot;a&quot;);\n  const res = await async2();\n  console.log(&quot;b&quot;);\n}\n﻿\nasync function async2() {\n  console.log(&quot;c&quot;);\n  return 2;\n}\n﻿\nconsole.log(&quot;d&quot;);\n﻿\nsetTimeout(() =&gt; {\n  console.log(&quot;e&quot;);\n}, 0);\n﻿\nasync1().then((res) =&gt; {\n  console.log(&quot;f&quot;);\n});\n﻿\nnew Promise((resolve) =&gt; {\n  console.log(&quot;g&quot;);\n  resolve();\n}).then(() =&gt; {\n  console.log(&quot;h&quot;);\n});\nconsole.log(&quot;i&quot;);\n输出为：dacgibhfe\n\n什么是链式调用！、什么是函数式编程？:add(1)(2)(3)\nPromise的原理和源码？Promise的race方法，实现的思路。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/查找多个字符串中最长公共前缀":{"title":"查找多个字符串中最长公共前缀","links":[],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n样例输入：strs = [‘abcdef’, ‘abdefw’, ‘abc’]\n输出：‘ab’，若没有找到公共前缀则输出空字符串\n\nconst findCommonPrefix = arr =&gt; {\n    let str = &#039;&#039;;\n    const n = arr.map(item =&gt; item.length).sort()[0];\n    for (let i = 0; i &lt; n; i++) {\n        str += arr[0][i];\n        if (arr.some(item =&gt; !item.startsWith(str)) {\n            return str.slice(0, str.length - 1);\n        }\n    }\n    return str;\n}\n\n\n最长公共前缀\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/生命游戏":{"title":"生命游戏","links":["C-Knowledge/前端/技术书籍/JavaScript教程/二进制位运算符"],"tags":["编程/算法"],"content":"\n\n                  \n                  问题 \n                  \n                \n根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n\n如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n\n下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。\n示例 1：\n\n输入： board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n示例 2：\n\n**输入：**board = [[1,1],[1,0]]\n输出：[[1,1],[1,1]]\n提示：\n\nm == board.length\nn == board[i].length\n1 &lt;= m, n &lt;= 25\nboard[i][j] 为 0 或 1\n\n进阶：\n\n你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n\n\n方法一\n\n\n                  \n                  解题思路 \n                  \n                \n\n构建board副本数组\n统计副本数组中每个细胞周围的其他细胞（未更新）状态\n更新每个细胞的状态，即一次更新后的细胞（board数组）\n\n\n副本构造\n// 数组副本\nconst CopyBoard = board.map(ary =&gt; {\n    // 值是基础类型（Number），不存在引用问题，直接解构比较方便\n    return [...ary];\n});\n状态统计\n在之前的“每日一题”活动中，这类的问题非常常见，比如车的可用捕获量，一般常见的做法，都是利用坐标数组进行遍历，提高解题的灵活性。\n首先，将board抽象成由X（行）和Y（列）组成，则X（行）设定为西——&gt;东方向，Y（列）设定为北——&gt;南方向。即上北，下南，左西，右东，则x表示在X上的位置，y表示在Y上的位置。\n很轻易地可以总结出：\n\n(0 + x, 1 + y)：x坐标不变，y前进一格，则是由西向东移动。\n(1 + x, 0 + y)：x坐标前进一格，y不变，则是由北向南移动。\n(0 + x, -1 + y)：x坐标不变，y后退一格，则是由东向西移动。\n(-1 + x, 0 + y)：x坐标后退一格，y不变，则是由南向北移动。\n(-1 + x, -1 + y)：x，y各后退一格，即向西北方向的对角线移动。\n(-1 + x, 1 + y)：x坐标后退一格，y坐标前进一格，即向东北方向的对角线移动。\n(1 + x, 1 + y)：x，y各前进一格，即向东南方向的对角线移动。\n(1 + x, -1 + y)：x坐标前进一格，y坐标后退一格，即向西南方向的对角线移动。\n\n把上述的坐标由上到下，将加号“+”视为分割线，你会发现，x的位置移动，由数组[0, 1, 0, -1, -1, -1, 1, 1]构成，y的位置移动，由[1, 0, -1, 0, 1, -1, 1, -1]构成，这样一来，方向坐标就确立了。\n方向数组的确定，给解题带来极大的便利，无需手动判断八个位置，只需要遍历坐标数组一次，就可以统计出坐标(i, j)细胞周边的细胞存活量。\n// 方向数组\nconst idx = [0, 1, 0, -1, -1, -1, 1, 1];\nconst jdx = [1, 0, -1, 0, 1, -1, 1, -1];\n \n// 利用双重循环保证每个细胞都走一遍\nfor(let i = 0; i &lt; CopyBoard.length; i++) {\n    for(let j = 0; j &lt; CopyBoard[i].length; j++) {\n        \n        // 遍历方向坐标数组\n        for(let index = 0; index &lt; 8; index++) {\n            let x = i + idx[index];\n            let y = j + jdx[index];\n            ...\n        }\n    }\n}  \n细胞状态更新\n// 该位置细胞死活状态决策\nif(liveAmount &lt; 2 || liveAmount &gt; 3) {\n    board[i][j] = 0;\n} else if (liveAmount &lt;= 3 &amp;&amp; CopyBoard[i][j]) {\n    board[i][j] = 1;\n} else if (liveAmount === 3 &amp;&amp; !CopyBoard[i][j]) {\n    board[i][j] = 1;\n}\n代码实现\n/**\n * @param {number[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar gameOfLife = function(board) {\n    // 八个方向的偏移量\n    const idx = [0, 1, 0, -1, -1, -1, 1, 1];\n    const jdx = [1, 0, -1, 0, 1, -1, 1, -1];\n \n    // 数组副本\n    const CopyBoard = board.map(ary =&gt; {\n        // 值是基础类型（Number），不存在引用问题，直接解构比较方便\n        return [...ary];\n    });\n \n \n    // 遍历每个细胞\n    for(let i = 0; i &lt; CopyBoard.length; i++) {\n        for(let j = 0; j &lt; CopyBoard[i].length; j++) {\n            \n            // 周边活细胞统计\n            let liveAmount = 0;\n \n            // 八个方向都走一遍\n            for(let index = 0; index &lt; 8; index++) {\n                let x = i + idx[index];\n                let y = j + jdx[index];\n \n                // 边界规避\n                if(x &lt; 0 || y &lt; 0 || x &gt;= CopyBoard.length || y &gt;= CopyBoard[i].length) continue;\n                \n                // 活细胞则计数加1\n                liveAmount += CopyBoard[x][y] ? 1 : 0;\n            }\n \n            // 该位置细胞死活决策\n            if(liveAmount &lt; 2 || liveAmount &gt; 3) {\n                board[i][j] = 0;\n            } else if (liveAmount &lt;= 3 &amp;&amp; CopyBoard[i][j]) {\n                board[i][j] = 1;\n            } else if (liveAmount === 3 &amp;&amp; !CopyBoard[i][j]) {\n                board[i][j] = 1;\n            }\n        }\n    }\n};\n方法二： 哈希表\n\n\n                  \n                  解题思路 \n                  \n                \n\n直接改board，会影响后续判断。用哈希表h存改动过的位置。取值时，如果该位置被改动过取反\n取值时，越界返回0。活细胞数量判断时，只关心能改变细胞状态的条件。改动位置存哈希表\n本题只需一次双循环遍历二维数组。根据是否有改动，有改动重复双循环，还可求解最终稳定状态\n\n\nvar gameOfLife = function(board) {\n    var v = (i, j) =&gt; board[i] ? (h[i + &#039;,&#039; + j] ? board[i][j] ^ 1 : board[i][j] || 0) : 0, h = {}\n    for (var i = 0; i &lt; board.length; i++) \n        for (var j = 0; j &lt; board[i].length; j++) {\n            var alive = v(i, j - 1) + v(i - 1, j - 1) + v(i - 1, j) + v(i - 1, j + 1) +\n                        v(i, j + 1) + v(i + 1, j - 1) + v(i + 1, j) + v(i + 1, j + 1) \n                if (alive &lt; 2 || alive &gt; 3) {\n                    if (board[i][j] === 1) board[i][j] = 0, h[i + &#039;,&#039; +j] = 1\n                } else if (alive === 3) {\n                    if (board[i][j] === 0) board[i][j] = 1, h[i + &#039;,&#039; +j] = 1\n                }\n        }\n};\n\n\n                  \n                  注意❗ \n                  \n                \n需要注意 ^ 为 异或运算符 中的异或运算符，若两个二进制位不相同，则结果为1，否则为0。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/算法题":{"title":"算法题","links":["C-Knowledge/前端/职业规划/前端面试宝典/算法题/螺旋矩阵","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/生命游戏","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/旋转图像","C-Knowledge/前端/职业规划/前端面试宝典/算法题/矩阵置零","C-Knowledge/前端/职业规划/前端面试宝典/算法题/有效的括号","C-Knowledge/前端/职业规划/前端面试宝典/算法题/二叉树的中序遍历","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/查找多个字符串中最长公共前缀","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/字符串解码","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/字典序排数","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/搜索旋转排序数组","C-Knowledge/前端/链式调用等待方法"],"tags":["编程/算法"],"content":"矩阵\n\n螺旋矩阵\n生命游戏\n旋转图像\n矩阵置零\n\n栈\n\n有效的括号\n二叉树的中序遍历\n\n字符串\n\n查找多个字符串中最长公共前缀\n字符串解码\n字典序排数\n搜索旋转排序数组\n\n队列\n\n链式调用等待方法\n\n\n\n2024 春招冲刺百题计划\n尊享面试 100 题\nLeetCode 热题 100\n面试经典 150 题\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/职业规划":{"title":"职业规划","links":["C-Knowledge/前端/职业规划/前端面试宝典/面试经验/兼职网站","D-Unsorted/怎么写技术简历","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/我的简历"],"tags":["场景/职业"],"content":"前景\n\n我换工作了，聊下关于图像互动技术前景思考\n前端之未来\n兼职网站\n\n简历\n\n怎么写技术简历\n我的简历\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/腾讯北极光工作室":{"title":"腾讯北极光工作室","links":["C-Knowledge/前端/开发技术/音视频/MSE","C-Knowledge/前端/链式调用等待方法"],"tags":["场景/面试"],"content":"公司背景\n北极光工作室群\n北极光工作室群（Aurora Studios），于2007年底在上海成立，是腾讯最早成立的自研大型工作室之一。北极光工作室群一线员工来自育碧、Epic等国际游戏大厂，下辖A1工作室、A2工作室、A3工作室三大研发工作室，并拥有自主研发游戏引擎QuicksilverX。\n北极光工作室群长期坚持精品游戏研发战略，致力于制作高品质、多元化、高口碑游戏大作并全球化发行，成功自主研发《天涯明月刀》系列、《轩辕传奇》系列、《光与夜之恋》手游、《无限法则》（Ring of Elysium）等游戏。\n\n腾讯旗下五大工作室\n【谈谈腾讯四大工作室（光子，天美，魔方，北极光）的运营风格（个人见解不喜勿喷）】 \n\n工作职责\n\nHR 面试\n\n期望工资： 15k～20k\n\n面试\n自我介绍\n\n2 年全栈开发经验，有 3 年的小程序、Vue 开发经验，分别有 3 个上线项目和微信小程序有 4 个 Demo 项目，有使用 uniapp，进行多端开发的经验。了解计算机图形学，最近学习了 docker 和 webrtc、进一步学习了 three. js。\n作为开发负责人负责播放器项目技术选型工作，从 0 到 1为公司搭建了前端播放器，注重前端标准化，在部门内部推行前端规范的落地。\n拥有自己的知识库和命令行工具（Node. js)，用于沉淀最佳实践，提高提高开发效率。\n\n反问\n技术相关\n\n你觉得我的技术有什么问题？下一步应该怎么学习？\n\n将自己感兴趣和使用的内容底层原理弄清楚。\nWebRTC 视频直播平台，在线教育。\n使用库满足当前的业务复杂度，从库中找到兼容性解决方案。\n\n\n咱们公司的技术栈是什么？  Vue，React、WebGL（Shader）、three. js 、node. js\n岗位的任务和团队的风格？  进入公司，负责的内容？\n~~技术团队规模？~~10 个人并正在扩张。\n晋升路线。 腾讯的晋升路线\n目标用户、用户体量，产品优势，怎么盈利？ 游戏、B 端客户\n\nHR（没问）\n\n工作时间？，8 小时弹性工作制度，不晚于 10 点半。\n现在加班的强度？  ，有时会加班\n请问公司的调薪是怎么样的呢？ ，一年一次，职级。\n几轮面试？\n\n面试内容\n\n自我介绍\n播放器大概大概的功能？用户怎么使用播放器（功能）？\n\n评论和标记\n视频裁切\n多屏幕\n\n\n播放器支持哪些视频格式？\n\nflv、m3u8、使用 hls. js 接口、加密。\n\n\n怎么加密，怎么解密？加解密过程。\nhls. js 是使用什么能力实现的播放？原生实现视频播放的功能，编解码的视频格式 H265？\n\n读取视频流，进行重组排序。\n\n\n视频流协议有了解过吗（MSE）？\n影视飓风视频格式？视频设置跳转需要加载的原因？怎么解决？\n\nI、B 、P关键帧\n通过帧率计算出关键帧位置，然后将时间设置到前一关键帧。\n提前传输关键帧。\n\n\n手写题（没有认真听面试官说的内容，可以简单实现）：实现任务队列，链式调用等待方法。场景：前面加载结果影响后面的加载结果。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/负载均衡":{"title":"负载均衡","links":[],"tags":["编程/性能"],"content":"负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/重庆天籁教育科技有限公司（兼职1个月）":{"title":"重庆天籁教育科技有限公司（兼职1个月）","links":["C-Knowledge/前端/职业规划/前端面试宝典/八股文/大文件上传如何做断点续传！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/css中，有哪些方式可以隐藏页面元素！区别！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是响应式设计！响应式设计的基本原理是什么！如何做！","D-Unsorted/数组去重","C-Knowledge/前端/职业规划/前端面试宝典/八股文/你是怎么理解ES6新增Set、Map两种数据结构的！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/==-、-===--和-Object.is()-的区别是什么！分别在什么情况使用","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Javascript本地存储的方式有哪些！区别及应用场景！","D-Unsorted/说说-JavaScript-中内存泄漏的几种情况！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/深拷贝浅拷贝的区别！如何实现一个深拷贝！","D-Unsorted/CORS-通信","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue2-的生命周期有哪些","C-Knowledge/前端/职业规划/前端面试宝典/八股文/生命周期的区别","C-Knowledge/前端/开发技术/JavaScript/什么是防抖和节流！有什么区别！如何实现！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue组件之间的通信方式都有哪些！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/Vue-的双向数据绑定是如何实现的","C-Knowledge/前端/职业规划/前端面试宝典/八股文/vue3有了解过吗！能说说跟vue2的区别吗！","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是虚拟DOM！如何实现一个虚拟DOM！说说你的思路","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说说-Real-DOM-和-Virtual-DOM-的区别！优缺点！","C-Knowledge/前端/开发技术/Vue/事件处理","C-Knowledge/前端/职业规划/前端面试宝典/八股文/说一说-Vue-的性能优化","C-Knowledge/前端/职业规划/前端面试宝典/八股文/与webpack类似的工具还有哪些！区别！"],"tags":["场景/面试"],"content":"工作职责\n\n面试\n自我介绍\n\n2 年全栈开发经验，有 3 年的小程序、Vue 开发经验，分别有 3 个上线项目和微信小程序有 4 个 Demo 项目，有使用 uniapp，进行多端开发的经验。了解计算机图形学，最近学习了 docker 和 webrtc。\n作为开发负责人负责播放器项目技术选型工作，从 0 到 1为公司搭建了前端播放器。注重前端标准化，在部门内部推行前端规范的落地。\n拥有自己的知识库和命令行工具（Node. js)，用于沉淀最佳实践，提高提高开发效率。\n\n反问\n技术相关\n\n~~咱们公司的技术栈是什么？~~使用 Vue3进行开发。\n~~产品是什么？主要负责的内容？~~PC网页端（用户端+后台）。\n~~工作强度和模式？~~早九晚六，大（周一和周日）小（周日）周。\n~~合同是怎么签署？~~兼职合同\n\nHR 相关\n\n~~签合同？~~兼职合同\n五险一金？没有\n~~税后还是税前？~~税后\n~~吃住，找房子？~~800左右\n\n面试内容\n\n自我介绍\n为什么想学计算机图形学？\n说一下自己最熟悉的一个项目？将媒体资源上传到平台进行查看，评论和分享。\n为什么不直接使用video标签？要自己封装播放器？\n直播是怎么做的？整体流程讲一下？直播录制是怎么处理的？\n为什么要使用M3u8而不适应MP4?UDP有什么特点？\n上传失败后怎么继续上传？\n视频裁切是怎么实现的？\n隐藏元素的方式\n怎么实现响应式布局\n去重的方式有哪些？\n你是怎么理解ES6新增Set、Map两种数据结构的！ 可以使用null 做为键吗？\n双等和三等的区别？\n本地存储的方式有哪些？\nJS什么情况下会出现内存泄露\n深拷贝和浅拷贝的区别\n先发起option请求是为什么？\nVue的生命周期有哪些？、生命周期的区别\n了解防抖和节流吗？\nVue组件的通讯方式有哪些？\nVue双向绑定实现的原理、订阅-发布模式。\nvue3有了解过吗？\n虚拟DOM的优缺点、说说 Real DOM 和 Virtual DOM 的区别！优缺点！\nVue的事件处理\nVue的性能优化\nWebpack和Vite差异\n\n反思和总结\n\n面试不知道就是不知道，问啥答啥，适当扩展。\n"},"C-Knowledge/前端/职业规划/前端面试宝典/面试经验/面试经验":{"title":"面试经验","links":["D-Unsorted/大疆","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/小米","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/招商银行","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/去哪儿网","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/完美世界","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/成都速普云科技","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/阿里大文娱","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/爱竞","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/小红书","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/重庆观度科技股份有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/北京彩彻区明科技有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/腾讯北极光工作室","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/上海懿天网络科技有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/成都盯潮科技有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/上海二三四五网络科技有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/杭州小码教育科技有限公司","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/重庆天籁教育科技有限公司（兼职1个月）","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/蚂蚁金服Richlab"],"tags":["场景/面试"],"content":"招聘网站\n\n京东\nB 站\n美团\n腾讯\n字节跳动\n阿里\n\n阿里云\n淘天\n饿了么\n高德\n阿里国际\n菜鸟\n大文娱\n钉钉\n阿里健康\n\n\n小米\n\n已投递\n\n大疆\n小米\n招商银行\n去哪儿网\n完美世界\n\n已面试\n\n成都速普云科技：视频面试\n阿里大文娱：语音面试\n爱竞：视频面试\n小红书：视频面试\n重庆观度科技股份有限公司：现场面试\n北京彩彻区明科技有限公司: 4 月 15 日，腾讯会议语音面试\n腾讯北极光工作室：4 月 17 日，腾讯会议视频面试\n上海懿天网络科技有限公司： 4 月 18 日\n成都盯潮科技有限公司： 未面试\n上海二三四五网络科技有限公司: 4月28日，腾讯视频面试\n杭州小码教育科技有限公司: 4月29日，钉钉语音面试\n重庆天籁教育科技有限公司（兼职1个月）： 4月30日，现场面试\n蚂蚁金服Richlab\n"},"C-Knowledge/前端/计算机科学":{"title":"计算机科学","links":["C-Knowledge/前端/开发工具/开发工具","C-Knowledge/前端/个人项目","C-Knowledge/学习进化/技术博客","C-Knowledge/前端/开发技术/大前端","C-Knowledge/前端/编程思想","C-Knowledge/前端/职业规划/前端面试宝典/前端面试宝典","D-Unsorted/在线练习","C-Knowledge/学习进化/学习路线图","D-Unsorted/网络","C-Knowledge/前端/编程基础/算法/算法","C-Knowledge/前端/开发技术/编程学习资源","C-Knowledge/前端/技术书籍/技术书籍📚","C-Knowledge/前端/职业规划/前端面试宝典/面试经验/职业规划"],"tags":["场景/导航"],"content":"\n开发工具\n个人项目\n技术博客\n大前端\n编程思想\n前端面试宝典\n在线练习\n学习路线图\n网络\n算法\n编程学习资源\n技术书籍📚\n职业规划\n"},"C-Knowledge/学习进化/CLashX":{"title":"CLashX","links":[],"tags":["Apps/ClashX"],"content":"安装\nWindows\n\n添加配置文件\n\n\n\n查看节点\n\n\n\n开启代理\n\n\n问题解决\n科学上网总是断线问题\n"},"C-Knowledge/学习进化/Templater":{"title":"Templater","links":[],"tags":["Apps/Obsidian"],"content":""},"C-Knowledge/读书笔记/《人生元编程》":{"title":"《人生元编程》","links":[],"tags":["编程/书籍"],"content":"MacTalk·人生元编程-池建强-微信读书\n趣谈个人建站\n常用的shell有这么几种：sh、bash、csh、zsh等。\n◆wget。命令行下载工具，安装时输入sudo apt-get install wget，使用方式后面会介绍。\n◆tmux。一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台，而无需再“浪费”多余的终端来连接这台远程主机。好吧，这句话有点绕，简单说就是用tmux打开的会话可以一直驻留在服务器上，下次去看时还是上次来的样子。就像你是某个酒店的VIP客户，住完之后不会人走茶凉，也不会断电，下次去时茶还热着，灯也亮着，就这样。\n安装方式sudo apt-get install tmux，对使用方式感兴趣的读者去查一下吧，中文介绍很多，记住，热键是ctrl+b。\n◆Vim。在Linux上少不了要编辑文件，我推荐Vim和Emacs，一个是编辑器之神，一个是神的编辑器（或者是伪装成操作系统的编辑器），我是“Vim党”，目前在学习Emacs。本书中有一个Vim系列，有兴趣的可以去看，从原理到配置、使用都有非常详细的介绍。\nNginx是一款高性能的HTTP服务器软件，由俄罗斯的一位大牛Igor Sysoev开发的，源代码以类BSD许可证的形式发布。Nginx的设计非常轻量级，由内核和模块组成，内核微小简洁，模块功能强大，静态编译。Nginx做的事情简单来说就是：接收客户端（浏览器）的HTTP请求，然后通过映射机制把不同类型的请求交给不同的模块去处理，比如HTML、图片、CSS等可以交给静态资源模块处理，还可以做压缩、缓存等，PHP、Python等类型的请求则交给FastCGI模块去处理，完成业务逻辑。\n什么是FastCGI呢？这玩意就等于是HTTP服务器和动态脚本语言通信的接口，就像一个粘合剂一样把HTTP请求和动态脚本处理整合在一起，顾名思义，处理速度非常Fast！\n当然，在Nginx未涉足江湖之前，这个领域的大哥叫做Apache，那时候几乎所有的HTTP Server都是清一色的Apache，一时之间风头无量。\nNginx的所有模块都是全静态编译的，启动Nginx后，Nginx的模块被自动加载，静态库执行效率更高。\nNginx支持epoll（Linux系列）和kqueue（BSD系列）的I/O事件通知机制。完了，又出现两个名词！这让人情何以堪、文何以完啊？简单说说epoll吧。epoll是Linux2.6正式引入的提高网络I/O的处理方法，它的几个优点是：单一进程打开的FD（文件描述符）数量仅受限于操作系统，1GB内存的机器上大约是10万左右，这一点大大提升了处理海量请求的能力；采用共享内存的模式避免内存拷贝；随着打开FD的数量增加，I/O效率不会线性下降。总之，大家知道epoll很牛就是了。\nNginx支持多进程的工作方式，启动后会有一个master进程，多个worker进程。worker进程一般对应服务器的CPU数量，你有个8核的CPU，最好把worker设置为8。master负责接收外界信号，并向worker发送信号，监控worker的运行状况，当worker挂掉的时候，启动新的worker。\n尤其是Nginx的不中断重启机制，当系统配置变化需要重新启动Nginx时，我们就给地主（master）发个消息，说这批长工（worker）太老了，都得换掉，你看着办。地主收到消息后就开始偷偷雇佣新的长工（worker），然后假惺惺地告诉老长工，把手头的活干完就行了，别太累了，啊。这时候如果有新的请求，就会交给新长工干，等所有的老长工把活都干完了，就直接fire，绝不留情。\n#安装 \nsudo apt-get install nginx\n#启动 \nsudo service nginx start"},"C-Knowledge/读书笔记/《什么样的爱值得勇敢一次》":{"title":"《什么样的爱值得勇敢一次》","links":["tags/场景/恋爱💕"],"tags":["场景/恋爱💕"],"content":"什么样的爱值得勇敢一次-沈奕斐-微信读书\n书摘\n\n进入爱情\n四种途径\n爱的本质是给予的快乐。\n当大家都习惯于被爱，而缺乏主动去爱的能力时，爱情由此而变得非常困难。\n一见钟情\n我们还要学会欣赏别人的外貌，包括主动接受男性的性魅力，这样才能提高一见钟情的概率。\n发自本能的喜欢太难得，一旦遇到这样的机会，请好好珍惜，勇敢一点，不管成功还是失败，至少这段感情会特别独特。\n我们的目标是具备更好地享受当下生活的能力，而不是一定要和某个人在一起。\n日久生情\n爱情三角理论包含亲密关系、性唤醒和承诺三个方面，如果拿掉性唤醒和承诺，剩下的亲密关系也可以是友谊，所以友谊和爱情的区别主要在于有没有激情。\n当我们不再把友谊和爱情对立起来时，我们不仅能更好地理解亲密关系，也解决了另一个重要问题：爱一个人并不意味着占有。\n爱情或者任何一种亲密关系中，你都不可能完全拥有一棵树，因为每棵树都是独立的，你无非是跟这棵树形成了连理枝，这并不影响你去享受阳光雨露，也不影响你去欣赏整片森林的美。\n对亲密的概念界定能让我们既打开世界，拥抱整片森林，又享受彼此之间有安全感的爱情。\n对这部分人来说，首先要做的是打开对亲密关系的想象力，先学会交朋友。\n爱情需要我们对他人有好奇心：我想要去了解你，我想要来帮助你，我想要跟你形成联结。在这一过程中，我们遇到了那个不论是思想还是身体都想靠近的人，这时候自然而然产生了爱情。所以爱情是结果而不是目标。\n我们在交朋友时，首先关注的是这个人的特性，而不是他／她的性别。\n日久生情是自然而然又非常难得的结果，所以放轻松，多交朋友，学会联结，期待奇迹。\n相亲\n我们在进入爱情之前，肯定希望结识更多人，相亲其实就是帮我们拓展朋友圈，给我们提供了一个从互惠型模式走入爱情的机会。\n如果要提高相亲的效率，请记得每一次都是去结交一位新朋友，带着好奇心去了解对方，对对方感兴趣。但如果觉得没有进一步了解的欲望，这也是正常的，没有好坏，只有适合与否。很多时候，无法成为恋人，但交到了一个不错的朋友，也是一种收获。\n网恋\n网络也只是一种中介，先认识一个人而已，线下才是你们感情真正开始的地方，见面时可以稍微把自己的想象放一放，去认识一个真实的人，判断这个人能不能成为朋友，然后再考虑关系能否更长久。\n不要一开始就用爱情模式的框架局限了发展的可能性，要看到那个具体的人，也让别人看到具体的你。用更开放的心态接受更为多元的亲密关系的开始，这样才能回到感情的本质：人与人的吸引。\n任何一段感情都可以从淡到浓一步步发展，我们没有必要把友谊、合作伙伴跟爱情统统对立起来。很多时候，我们欠缺的不是进入爱情的能力，而是常规意义上的交友能力。学习进入爱情，在本质上是学习怎样和世界、和他人更好地相处。爱情教我们怎么去跟别人沟通，一方面要坚持自我，另一方面也要不断更新自我。爱情给了我们和外部世界深度碰撞的机会。\n排除Mr.Wrong\n弗洛姆跟我有类似的观点，他说人们常常觉得爱很简单，找到对的人，爱情就开始了，但实际上这是错的，爱是一种能力，你遇到一个人，甚至遇到好几个人，选择其中一个，我们互相学习如何去爱，爱情才会变得美好。\n为什么女生对男生一无所知就是纯情，男生对女生一无所知就是“直男”甚至“直男癌”？也就是说，男性不被女性了解不仅不是一个缺点，甚至还是一个优点。\n文化有滞后性，女性虽然独立自主了，但爱情旧脚本的浪漫气息还滞留在心中，我们仍旧特别希望遇到一个懂我们的Mr.Right，帮我们做正确的决策，降低做决策的风险。\n你真正要做的，不是找到Mr. Right，而是排除掉Mr.Wrong。理清你的底线，排除Mr. Wrong，要比寻找Mr. Right更能给自己机会。\n第一个方法，三条底线原则。\n你可以想象你未来的伴侣，他身上有哪三个问题是你绝不能忍受的？\n你吃饭不好好吃，以后你喜欢的姑娘长得比你高，那怎么办呢？没问题啊，你看王祖蓝就找了个比他高很多的老婆。\n\n拿出一张纸，在纸上列出所有你找对象时非常在意的点。\n想象你现在遇到的人或多或少都有你写的那些缺点，划去那些相较而言能接受的缺点。\n强迫自己最后只留下三个在意的点，作为你的底线。\n\n底线是你不能忍受的问题，而不是你希望的特点。\n第二个方法，每一段感情经历都是我们更新Mr. Wrong清单的机会。\n人在年轻时并不知道自己的底线是什么，我们需要不断地经历一些事情才会更了解自己。\n关心和控制是没有严格界限的，你需要它的时候就是关心，不需要它的时候就是控制。\n每一段恋情其实都是在帮助我们成长，成功也好，失败也好，我们都会从中逐渐发现自己的底线，哪些是真的不能接受的，哪些只是自以为不能接受的。\n当出现一条新的底线的时候，务必要和原来的底线做比较，看看是不是更难接受，只有更难接受才能替换原来的底线。\n第三个方法，不要总是纠结于应该选谁，而是多问问自己为何不能选谁。\nA有什么让你难以接受的？B有哪些让你不能选他的原因？这样思考过后的决策往往更贴近现实。\n排除掉Mr. Wrong以后，你再去找一个让你觉得快乐的或者让你觉得有益的人进入更深的关系里。\n为什么说爱情是个体成长的路径之一？就是因为在这一过程中，我们慢慢学着了解自己，明白自己到底最在乎什么，这是需要一个过程的。\n在恋爱中，我们慢慢成长，也慢慢影响我们的爱人。在时间的打磨下，那个一开始看上去不是Mr. Right的人，到最后会成为你的Mr. Right。这个专为你定制的恋人，他并不见得适合别人，也不是别人眼里所谓的最好的那一个，但他却是最适合你的。\n\n底线题涉及“我们”的重要事宜，这些问题最好在初期关系中双方能达成一致。如果双方找到了底线一致的人，未来面临的冲突就不会那么剧烈，需要做结构性调整的可能性也会变得更小。\n关键题是指那些对关系很重要，但并非要求答案一致的题目，只要能协商出一个双方都能接受的方案就可以。\n差异题是指那些在初期关系和长期关系中会有不同影响的特征或问题，能打开大家对差异的想象。\n开放题是指那些拓展亲密关系边界，但一致与否并不重要的题目。我们希望通过这些题目能帮助每个人去探索自己和关系中的底线。\n\n其实在和任何一个人交往的过程中，也需要确立一些行为底线来保护自己的利益。\n当我们既有Mr. Wrong的三条底线，又有行为的三条底线的时候，我们就能在保障自己安全和利益的前提下，展开交友之旅。你要相信，总有一天我们会遇到一个渴望和他／她形成更亲密联结的人。\n预防风险的逻辑和追求幸福的逻辑是不同的两种逻辑。排除Mr. Wrong是预防风险的逻辑，把除感情以外的其他风险首先排除掉，然后我们学着信任他人，尝试和他人形成联结，进而找到一个人变成“我们”，幸福就慢慢展开了。\n主动追求爱\n当年，我先生向我表白，我立马说好的好的。\n我一直坚定地认为，对两性关系乃至所有人际关系来说，坦诚和真实是基础，所有的小心机、小功利到最后都会让你付出大代价。\n故弄玄虚的矜持引发两个问题。第一，容易产生误解，对方不知道你说的“是”和“不”究竟是什么意思。第二，容易破坏信任，不断被考验、被测试的感觉相当不舒服，优秀的男性会认为你凭什么要来测试我？\n一个女性说“不”时，她真的是在说“不”，如果说“不”的力量被削弱，那我们说“是”的力量也会被削弱。故作矜持常常让“是”和“不”都失去力量，所以在爱情脚本中，这是需要更新的理念。\n当爱情成为一种竞争关系的时候，维护爱情就成为很艰难的一件事，因为你我是对手，而非合作伙伴。我们如何共同做好一件事？\n他认为人们在人际交往的过程中都会追寻自尊感，别人对我的正向反馈越多，我的自尊感就越强。\n今天，男性也在追求自己的自尊感，所以很多成年男性不再追求女性了。第一，怕麻烦，他们根本搞不懂女性那些似是而非的心理。第二，恋爱的替代品很多，宅在家里看片、打游戏，都能给他同样的快乐。第三，恋爱的开销实在太大，要花时间、金钱、精力，还要考虑买房子等现实问题，想想就令人头大，索性放弃了。第四，有些男性认为儿女情长阻碍了事业发展，一不小心还会成为“舔狗”或“备胎”，待到事业有成那天，自会有人来追求——男性也希望被追求，也在追求自尊。\n我的建议是：勇敢点，不要（上尸下从）。\n发起者优势\n在爱情中，如果你首先去接近别人，你往往会选择接近比自己条件更好的人，并设法跟对方保持长期的良性互动。德里克的研究鼓励不论男女，都勇敢一点，首先发起关系联结，开启一份你想要的爱情。\n在现代社会，我们的择偶选择权在自己手上，当然要找一个你很爱他、他也很爱你的人。\n德里克的研究强调“发起者优势”，但并不是让女性看到理想型，就马上跑上去说：“我喜欢你，我们能交往吗？”很多男性可能还处在爱情旧脚本中，这么做很可能会把他吓跑。你可以等到两人的关系到了“隔层纱”的时候再挑明。\n一是给对方接近自己的机会，二是创造“第二空间”，三是主动肯定。\n第一个方法，给对方接近自己的机会。\n当你有心仪的人时，你得释放信号：我有时间，我希望你再往我这边靠近一步。\n\n第一，留意谁的眼光总是在你身上停留。\n第二，留意谁愿意接你的话头，愿意和你交流，或者虽然不接你的话，但是会用点头等方式表示自己在认真倾听。\n第三，也是最重要的，留意对方是否在缩小和你的身体距离。\n\n第二个方法，创造“第二空间”，这个概念是我自创的。\n男女主角既是师生关系，又是邻居关系，有更多的条件可以在一起。“第二空间”让男女关系产生特殊性。\n“第二空间”既可以是物理空间，也可以是虚拟空间，比如玩游戏时在同一个队里。如果你觉得某人很好，不如先尝试和对方建立“第二空间”，既能找到共同爱好，又能使关系产生特殊性，一举两得。\n第三个方法，主动肯定。\n我鼓励大家主动肯定他人，但并不鼓励很快主动表白。因为今天的爱情和自我价值紧密相连，无论做多好的心理建设，被拒绝总是不好受的。恋爱💕\n我发现你在调焦时特别有耐心，你很喜欢在选景时做多种尝试，我觉得这真的很棒。\n在这个孤独的社会里，每个人都希望得到别人的关注，这种肯定能带来能量，也是交朋友的重要前提。\n什么时候表白\n第一种是你做了很多努力，可你们的关系并没有升温，总是保持一开始的状态，那你失败的可能性是很大的。对方没有给你足够的回应，常常是因为他没有和你同等的热情。\n第二种是你们的关系虽然一直在升温，你也给了他几次机会，尤其是身边的朋友都经常起哄，但是他一直没有利用这些机会。你需要去判断他是真傻还是装傻。有时候，他会有自己的疑虑，可以通过其他人去了解他到底在犹豫什么。\n有时候，错过也就错过了。好的感情需要天时、地利、人和，所以暂时的放弃没什么大不了的，不要把错过看作错误，有时候仅仅是双方都还没有勇敢起来而已。\n如果你不想错过，就勇敢一点，即使被拒绝也没关系，只是时间和人不匹配而已，而不是失败或自己不够好。\n别人的追求是对我们的肯定；但如果你喜欢上一个很好的人，对方不接受你，并不意味着你不够优秀，恰恰相反，你能看到别人的优秀，说明你是有鉴赏力的，同样也很棒。\n我一直觉得独特的自我不等于孤独的自我，**与社会建立更紧密的联结，有利于提高我们生活方方面面的质量。**与更多的人形成联结，去看见他人，主动肯定他人，这不仅仅是为了进入爱情，也是为了让我们的生活本身变得更丰富多彩。\n当你遇到理想的对象，应该勇敢点。\n走出原生家庭\n过去发生的任何事对未来都没有绝对影响，关键在于你如何赋予你的经验以不同意义。\n创伤可能是你无法前进的原因，但也可能是让你成长得更快的挑战，就如同感冒、发烧可能会让你处于不健康状态，但也可能提高身体免疫力，让未来的你更健康。\n所谓的成长其实就是不断更新对社会的认识，而社会是在下一代人跳出上一代人的制约中不断发展起来的。\n如果你现在适应得很好，活得很开心，那你很幸运，需要感谢父母。但如果你现在经常感到力不从心，觉得生活跟想象中的不同，那也不要怨恨，绝大部分的父母并不是故意要来伤害你或捆绑你，他们只是受时代的限制，给了你一套他们自认为正确的逻辑体系。\n重新赋予那些可能的创伤或挫折以积极意义，调整不适应今天社会规范的部分，积极主动地应对变化，不断更新自己，不断走向成熟。\n生活在某种文化中的人，要对自己的文化有自知之明，你要知道它是怎么来的，怎么形成的，是如何在生活的方方面面起作用的。\n第一，你要有意识地认识自己的文化，不要认为日常生活中所有的文化行为都是理所当然的。第二，要根据所处环境的不同，对原有文化进行取舍。第三，要对新文化进行取舍。最后你会形成一套完整的逻辑体系——哪些要遵守，哪些要改变。\n为什么说爱情是自我成长的途径？就是因为爱情给了你一个机会，走出原生家庭的脚本。只有跟真实的人碰撞，你才知道边界在哪里，知道什么样的选择会带来什么样的后果。在实践爱的过程中，你的认知就有机会得到真正的改变。\n核心情结\n当我们和一般朋友交往的时候，往往不会触及这些深层的核心情结，但是它往往容易在亲密关系中被引爆。\n相对的，亲密关系最大的益处，是我们有了很多宝贵的机会去发掘、认识这些潜藏在心底的核心情结，我们得以更深入地了解自己与伴侣，从潜意识的主宰状态中解脱出来，用更为健康的行为模式来重塑我们的爱情和婚姻，而伴侣给我们的爱是非常重要的支持力量。\n抛弃全世界，去一意孤行，哪怕只换回那个一知半解的自己。\n爱情给了我们一个机会，通过跟别人发生碰撞，看到原生家庭所赋予的社会化如何压抑了自己，看到过去规范的不适用，从而给了我们勇气和机会来重新发展自我，重新找到和他人联结的方式。关键在于你有没有抓住爱情这个机会让自己成长。如果你能抓住机会，认真了解哪些是你无法忍受的，哪些是值得你珍惜的，那这就是一份有价值的爱情。\n爱情里所有的关系首先是你和自己的关系，爱情给了我们一个看见自己的契机。\n只要你的内心告诉你，对方是让你更舒服的那个人就可以了。剩下的问题，可以两个人一起解决！\n我们通过爱情不断地去和他人发生碰撞，思考自己想要的爱到底是什么。在这个过程中，我们学习倾听别人的需求，真实地表达自己的想法，同时争取自己想要的东西。\n成长最重要的力量源于自己，而爱情就是一次能借助他人力量的宝贵机会，别错过它。"},"C-Knowledge/读书笔记/《卡片笔记写作法》":{"title":"《卡片笔记写作法》","links":["tags/Learning/Input","tags/Areas/实用技能","tags/场景/写作"],"tags":["Learning/Input","Areas/实用技能","场景/写作"],"content":"卡片笔记写作法：如何实现从阅读到写作-申克·阿伦斯-微信读书\n书摘\n卡片笔记\n\n知识块，原子化，独立，方便组合。\n\n\n添加标签\n来源\n双向链接\n想法\n\n卡片盒子是什么？\n\n前方的道路并不拥挤，因为坚持的人并不。\n积累知识的复利。\n你应该像管理金融投资组合一样来管理知识。\n重要的不是更好地记录，而是更好地思考。\n不写，就无法思考。\n\n卡片盒子只是帮助我们思考，卡片盒子是积累知识的一种好的方式。\n卡片盒子只是在头脑外部建立的一个索引库（不断的维护这个索引库），并非一个档案库，档案库应该是想法所对应的书籍。\n卡片盒子不光可以用于写作的学习，用于技术的学习同样适用。\n卡片盒子可以让老的观点和新的观点进行碰撞💥，产生新的见解。（以前是只能和别人交流才能碰撞，现在是老旧思想之间可以进行碰撞）。\n集中管理而不进行分类，才能对观点进行重组，碰撞新的火花。\n因为信息而引发的思考比信息本身重要。\n写作是什么？\n写作其实分为输入和输出两个部分。\n输入包括阅读书籍、文章以及观看视频，一旦有想法就可以记闪念笔记或者文献笔记。最后将闪念笔记和文献笔记规整为永久笔记，归纳如笔记盒中。输入过程讲究自下而上，不断积累，然后形成集群，最后产出。\n输出主要包括排版、写文章、校验。三个步骤循环往复，呈螺旋形上升。输出过程讲究至上而下，先确定主题，然后寻找论据。\n输入是输出的基础，所以写作不能临时抱佛脚，得提前未雨绸缪，从积累卡片开始。\n输入和输出是两个完全不同的过程，而obsidian更多的是保证输入，自然生长，而语雀属于输出，需要结构化的管理和存储。\n如何将文字转换为流程图？（开启新的读书方式）\n\n记闪念笔记\nWhen\n你手边需要随时有记笔记的工具，以捕捉脑海中闪现的每一个想法。\nWhat\n仅仅是你脑海中想法的备忘。\nHow\n使用格志、微信读书想法、小记随时记录自己的想法。\n记文献笔记\nWhen\n无论你读什么，都要做笔记。\nHow\n\n写下你不想忘记的内容，或者你认为可能会在自己的思考或写作中使用的内容。\n文献笔记要非常简短，精心选择，并使用自己语言记录，对引文要格外挑剔，不要只是抄写，而不去真正理解其含义。\n把这些笔记和参考书目的细节一起保存在你的文献管理系统中。\n\n记永久笔记\nWhat\n\n为了衍生想法、论点和讨论。\n新的信息是否与你卡片盒里或脑海里已有的信息相互矛盾、相互一致、相互印证或相互补充？\n是否能把已有的想法结合起来产生新的想法？\n这些想法又引发了什么问题？\n\nWhen\n最好每天一次，以及在你开始遗忘为什么记它之前。\nHow\n\n现在打开你的卡片盒，仔细阅读你在第一步或第二步所做的笔记。\n思考它们与你自己的研究、思考或兴趣所在的相关内容有何关联。\n你可以为每一个想法准确地写下一条笔记，并像为别人写作一样，使用完整的句子，标注来源，提供参考资料，并尽量做到精确、清晰和简短。\n扔掉第一步的闪念笔记，把第二步的文献笔记放入你的文献管理系统。\n待所有重要的内容都进入卡片盒后，你就可以忘记它们了。\n\n将永久笔记添加到卡片盒中\n\n把每一条笔记都归档在一个或多个相关的笔记后面。看新笔记与哪条笔记直接相关，如果还没有与其他笔记直接相关，就把它放在最后一条笔记之后。\n给相关笔记添加链接。\n这样做是为了确保你以后能够找到这条笔记，可以从索引页链接到它，也可以在你用来作为某个讨论或话题的切入点的笔记上做一个链接。\n\n从系统内部自下而上发展主题、问题和研究课题。\n\n看看目前有什么，缺什么，出现了什么问题。\n通过广泛阅读来挑战和加强自己的论点，并根据了解到的新信息改变和发展自己的论点。\n多做笔记，进一步发展思路，看看事情的发展方向。\n自己跟着兴趣走，一直选择有望获得最深刻见解的那条路。\n\n从零开始搭建卡片盒\n\n因为你的脑海里已经有了需要检验的想法、需要挑战的观点和需要回答的问题。\n不要为一个主题进行头脑风暴，而是要看一下卡片盒，看看哪里已经形成了笔记链，哪里已经建立了想法群；\n\n如果另一个更有希望的想法已经成型，就不要执着于前一个想法。\n你对某件事情越感兴趣，就会阅读得越多，思考得越多，进而收集的笔记越多，最终越有可能从中提出问题和想法。\n\n它可能正是你一开始就感兴趣的东西，但更有可能是你的兴趣已经发生了变化，这就是洞见的作用。\n\n一段时间后，会积攒到足够多的想法去确定一个写作主题\n你的主题是基于你所拥有的素材，而不是基于即将阅读的文献可能提供的未知想法。\n思考一下这个主题的内在联系，收集所有与之相关的笔记（大部分的相关笔记已经有了一定顺序），把它们复制到大纲软件中[3]，并把它们按顺序排列好。\n看看哪些还不够，哪些是多余的。\n不要等着所有的东西都集齐，而是要积极思考，给自己足够的时间去阅读和记笔记，以改进你的想法、论点和架构。\n把你的笔记变成初稿。不要简单地把笔记复制到手稿里，要把它们转化成连贯的内容，并将它们嵌入到你论点的上下文中，同时从笔记中得出你的论点。\n检查论点中的漏洞，想办法完善或改变论点。\n编辑、校对你的稿子。拍拍自己的肩膀，然后开始写下一篇文稿。\n让工作推动你前进\n\n用自己的语言去表达我理解的内容。\n区分文本中重要内容和不重要的内容。\n\n用文字表达能让自己清楚是否真的理解。\n\n如果知识既不是被孤立地保存，也不是被孤立地学习，而是聚集在一个思想网络中，或者说是“思维模型的网格”中（M unger,1994），那么理解新的信息就变得更容易了。\n\n将新知识和原有知识建立联系。\n\n在1968年的美国总统大选期间，平均声音片段（候选人不间断演讲的所有镜头）超过40秒，但在80年代末（Hallin,1994）已降至不到10秒，2000年甚至降至7.8秒（Lichter, 2001），而这一下降趋势在过去的历次选举中依旧没有改变。究竟是媒体适应了我们不断减少的注意力，还是媒体造成了这种现象，还不好判断，[1]但是无论如何，很明显，我们正被越来越多的干扰因素包围着，并且提升注意力的机会也更少了。\n\n抖音是不是在很大程度上降低了人们的注意，这个可能比电视还严重，而读书和写作是练习注意力的不错方式。\n将写作和校对分开，先把想法写下来，然后再去不断完善。写作需要漂浮的注意力，而校对需要专注的注意力。\n写作是一个螺旋上升的过程，在拟稿、校对、提纲中不断循环，不断完善。\n以后读书的时候就创建一个文档，在读的过程不断写下对文章的理解，最后再对这些理解进行归类整理。\n读不同的书籍注意力也是不一样的，读一本书的不同部分需要的注意力是不一样的，有些文本需要精读，而有些文本只需要略读，可以灵活的调整阅读速度和方法。\n\n把训练轮骑坏了就学会了。\n\n学习一项技能就是不断实践、不断的练习，不断犯错，不断成长。骑车如此、写作如此，爱情也是如此。\n\n根据德雷福斯的模型理论[4]，正确运用学习到的规则，可以使你成为一个称职的“胜任者”（位于5层级模型中的第3层级），但它不会使你成为“精通者”（第4层级），当然也不会使你变成“专家”（第5层级）。\n\n\n直觉不是指某种神秘的力量，而是一种融入了过去的经验，通过无数次成功或失败的反馈循环，深入学习、反复实践的沉淀。\n\n专家是内化了必要的专业知识，并且有经验，靠直觉做出判断。\n\n记住规则（函数）比记住数字本身容易，有了规则就可以当场推导。\n\n\n我们所理解的事物都是有联系的，或是通过规则、理论、描述，或是通过纯逻辑、心理模型或解释。而卢曼卡片盒的目的就是专门建立这类有意义的联系。\n\n\n写作的每一步都伴随着如下问题：这个事实如何与我的某个想法相对应？这个现象如何用那个理论来解释？这两个观点是矛盾的还是相辅相成的？这个论点不是和那个论点类似吗？难道我以前没有听说过这个吗？尤其是像“X对Y意味着什么？”\n\n使用老的东西解释新的东西，新的东西就存储到我门现有的记忆里面了。\n\n我们想尽可能长久地记住一些事情，而不想让无关的信息塞满我们的大脑。所以，我们组织日常信息的方式既会对长期记忆产生很大的影响，也会对短期记忆产生很大影响。\n\n将脑中的信息都建立关联性。\n不让未完成的任务占据我们大脑的方式是写下来。\n要想写好论文，你只需要对一篇好的草稿加以修改；要想写出好草稿，你只需要把一系列的笔记变成连贯的文字；为了获得连贯的文字，你只需要重新整理卡片盒里已有的笔记；所以，你真正要做的就是在阅读的时候手里有一支笔。\n读懂之后然后再加入到自己的思维系统中，然后做成笔记添加到卡片盒中。\n制作每一条有意义的笔记。然后打草稿的时候提取这些笔记。\n\n每当我们探索一个新的、陌生的主题时，我们的笔记往往会比平常更多，不必为此而紧张，因为这是对理解能力的刻意练习，是一个不可或缺的环节。\n\n当我们了解了一个主题之后就能用简洁的话表达出作者的观点。\n我想我再复读那年就有了这种习惯，但之前没有用理论的方法总结出来。\n之前做笔记就是听老师讲，并理解之后写在书上，但还没有像书中讲的一样讲笔记在整理一次到卡片系统中，融入自己的思想中。\n关键词记录法。\n只有去做才能学。\n教育是门了不起的学问，需要学习心理学。\n\n当我们在知道如何回答一个问题之前就尝试回答，即使我们的尝试失败了，以后也会更好地记住答案（Arnold and McDermott,2013）。\n\n先自己回答一下问题，然后再看答案，这样能更好的记住答案，之前做作业就是这样的，先自己解题，不会了再答案。\n简要描述文本的主要观点，而不是收集引文。\n如果你不敢希望每年出的书籍数量和卢曼一样多，可以试试将目标设定为每天记3条笔记，或每年不超过一本书，这样仍然可以在合理的时间内积累大量的想法。\n在大脑之外思考\n做永久笔记\n不如说是在写作过程中进行的思考，是与卡片盒内已有笔记的对话。\n将思考外化出来。将文字写下来，并且不断的修改和完善它。\n\n不写作，就不可能系统性地进行思考（Luhmann,1992）。\n\n在纸上思考。\n将环境和知识一切记忆更容易记住，可以通过环境唤醒，手势唤醒，PPT唤醒。\n\n对于真正的、有用的学习来说真正有帮助的是将一条信息与尽可能多的有意义的上下文联系起来，就像我们将卡片盒中的笔记相互联系起来的做法一样。刻意地建立这些联系意味着建立了一个由相互联系的想法和事实组成的自我支持的网络，这些思想和事实互为线索，相互提示。\n\n学习就是将新知识和更多的上下文建立联系。\n记忆的诀窍是给信息赋予一定的含义，并且以一种有意义的方式和已有的知识网络相连。\n只有真正理解了我们学的东西才能真正掌握它。阐述我们学习的内容，并且将他应用到其他语境中。只有当人能移接一个信息，才说明他真正掌握了。\n理解之后才能记住。\n\n卡片盒迫使我们提出许多阐述性的问题：它意味着什么？它与某事有什么联系？它与某事有什么区别？它与什么相似？卡片盒没有按主题分类，这是积极建立笔记之间联系的前提条件。\n\n卡片盒的作用是帮助我们理解。用已有的知识去阐述，去理解，去联系就知识，从而达到学习到目的。\n变化和对于有利于学习。之前只认为对比有利于学习，现在学习到变化也可以。\n如何添加到卡片盒中：\n\n添加到当前笔记中提及的笔记中。\n添加到笔记末尾，并添加编号。\n或者再另建一个分支。\n\n链接笔记。\n信息越多信息钩子就越多，就越容易抓住新的信息。\n学以致用才能掌握。\n阅读过程中不断修正自己的看法。\n\n建议在返航飞机都没有被击中的地方加装装甲。忽略了没飞回来的飞机，它们正是因为被击中了需要额外保护的关键部位（比如油箱）才没能返航。\n\n只看到了现象，却没看到本质。从已有的解决方案中发现问题。\n股票的上涨和下跌只是价格上的波动，我们应该看到的是当前股票的价值，如果股票的价值高就值得长期买入。\n将文献中的文字浓缩然后加入到卡片盒中。\n\n减少选择不仅可以提高生产力，还可以增加我们的自由，甚至让我们更容易融入当下、享受当下（Schwartz,2007）。\n\n提供预设方案减少选择。《稀缺》\n书让自己拥有更多的思维模型。\n\n二进制代码的限制比字母表还要大，只有0和1两种状态，却能开启一系列前所未有的创造。\n\n世界的底层是不是也是又二进制构成的呢？比如正负\n\n我们的工作之所以能不断推进，靠的不是事先计划，而是过程中的试错。\n\n之所以当下写不出内容来是因为我们没有提前准备，未雨绸缪。\n\n我们越能控制自己的工作，引导我们的工作向着我们认为有趣的、相关的方向发展，就越不需要调用意志力去强迫自己完成这件事情。\n\n将工作按照我们期望的方向发展。\n\n我们在阅读和写作的过程中，也不可避免会产生很多意想不到的副产品，即使它们与我们当前的项目并不直接相关，我们也可以将它们用在以后的其他相关项目上。\n\n阅读和写作过程中也会有副产品。\n如果遇到困难就先暂时放一放。\n\n需要对计划持普遍的怀疑态度，尤其是当计划仅仅关注结果，而不关注实际工作和实现目标所需的步骤。\n\n不要只盯着结果，而是要专注于过程，每一步都走好了，结果自然不会差。\n\n不是说我们无法从经验中获得成长，而是说只有获得即时反馈的经验才能让我们得到成长，并且可能需要不止一次的经验。\n\n在做的过程中需要不断的反馈，然后不断的修正，让自己成长。\n将一个长期任务拆分成一次性任务，更有利于我们完成。《稀缺》《卡片盒子写作法》\n草稿就是草稿，草稿就需要不断的修改、删减、增加。将需要删除的内容复制到一个新的地方，更能让人接受。\n好的文章是不不断修改出来的，好的代码也是。\n\n蔡格尼克效应的存在（Zeigarnik,1927），即如果任务没有被完成（或被写下来），就会一直停留在我们的大脑里。\n\n将未完成事情写下来否则它会一直停留在我们的大脑中。《卡片盒子写作法》\n意图决定行为。（决定论）《被讨厌的勇气》《卡片盒子写作法》\n\n阅读的时候在语雀上建立一个空白文档，并将最重要和最有趣的内容记录下来（包括自己的思考）。\n然后将这些发现转换为永久笔记，并与卡片盒里的其他笔记联系起来。\n\n科技、接受问题。集装箱\n\n书中介绍的以自己的理解和兴趣为导向的、长期的、跨主题的笔记结构，与大学里模块化、分门别类、自上而下的课程组织方式有很大的区别。\n学校的教育仍然在教大家通过复习去学习，而不是鼓励学生通过独立地在异质化的信息之间建立网络来学习。\n\n翁天信作为一个自学者完全通过兴趣去学习，然后建立了自己完整的知识图谱，我觉得这是值得借鉴的地方。《卡片盒子写作法》\n\n学习、思考和写作不应该是为了积累知识，而是要让自己成为一个具有不同思维方式的人，这就要求我们要根据新的经验和事实，对自己的思维习惯提出质疑。\n\n不断质疑，不断革新，不断成长，形成多种不同的思维模式，然后用不同的思维模式去看待这个世界。\n\n学习者不应该是学习的中心点，卡片笔记写作法的工作流程也不会把学习者作为学习的中心。相反，我们鼓励学习者将自己的思考分散到其他想法所组成的知识网络中。\n\n学习者不应该以自己为中心，而是应该站在一个更高的角度（上帝视角）去审视整个学习的过程，并从多角度思考作者文章中提到的观点。\n\n线性的学习方法和以学习者为中心的学习方法，还让人们对卡片笔记写作法存在一个常见的误解，认为它只是一个单纯的工具，在使用它时，不需要改变以往的工作流程。\n\n学习不是一个线性的过程，写作也不是一个至上而下的过程，而是一个自下而上，只有通过卡片盒子积累了更多的观点之后才能形成自己的文章。\n写作绝对不是一个临时抱佛脚的过程，而是不断积累，未雨绸缪的过程。（为退休提前存储）《卡片盒子写作法》\n\n如果希望能够有所改变，那么解决方案必须得看起来简单。\n\n不管设计软件还是设计接口或者是代码规范都应该尽量简单，才能让别人改变。\n\n有时候一本书，或者一套思想体系，会改变一个人的命运。\n\n我想《卡片盒子写作法》对于写作的展示了一个全新的视角，对我影响很大，能让我用新的方式组织我的想法。\n\n像原子样的笔记，一次一件事。这样既能快速掌握事情的全部，也方便在不同的话题间建立联系。记录太宽泛很难聚焦，太零碎又会让连接模糊。\n\n卡片如何的大小如何定义更合适？\n\n其中原因之一在于，我们只是看到了信息，却没有将其用自己的语言表述出来、转化为自己的知识。\n\n将文中的信息，用自己的语言表达出来就可以形成自己的知识。\n\n吸收知识更像是神经回路不断被加强/减弱的过程，收集之后会慢慢地生长出结构，宛如植物生长一般。\n我们不断消费信息，并对其进行理解、贴上标签、建立连接，最后内化为知识。\n\n设计是输出而学习是输入，设计讲究规范标准，结构清晰，而学习讲究自然生长。\n\n时间是一把非常好的尺子，当我们不断回顾的时候，一方面能看到某些内容是否能经得起时间的考验，另一方面也能看到自己思维的变化。\n\n不断输出自己的成长，将思考写下来，后面再看的时候就能看到自己成长的路径。\n学习和成长的过程是值得分享的，能帮助别人打开视角，然后从中学习到更高效的学习和生活方式。\n事情不可能按照预定的方式进行。《被讨厌的勇气》\n想纠正别人本身就是错误的，不要做自动抬杠机（ETC）。你只有知道什么是主观看法，什么实事，所以不必争论。\n如何改变自己的回报思想？\n想法里面的 闪念笔记可以整理成永久笔记并加入到卡片中。\n只有写下来大脑才能停止工作。\n扩展阅读\n《卡片笔记写作法》\n卢曼卡片盒笔记法介绍\nIntroduction to the Zettelkasten Method • Zettelkasten Method\n\nInput 实用技能  写作\n\n来自：原文地址\n"},"C-Knowledge/读书笔记/《技术写作指南-张鑫旭》读后整理":{"title":"《技术写作指南-张鑫旭》读后整理","links":["tags/Learning/Input","tags/Areas/实用技能","tags/场景/写作"],"tags":["场景/写作","Learning/Input","Areas/实用技能"],"content":"框架搭建\n写作套路\n技术科普\n\n原理剖析\n\n功能实现\n\n使用教程\n\n问题解决\n\n项目总结\n\n会议记录\n\n工具测评\n\n技术人文\n\n职场故事\n\n其他技巧\n1.  不同的账号主体\n同样类型的文章，如果发布的账号主体不同，则文章的结构也会有所不同。\n2. 不同的阅读对象\n同样的主题，给同事看的和给同行看的文章结构也是大不相同。\n内容\n辅助内容\n代码片段\n优先使用代码块功能\n代码需精简\n技术文章中的代码块务必要精简，除非是专门提供给读者复制用的完整代码。\n\n我们日常做事也是如此，你要想做到极致，一定会有很多意想不到的细节工作去做，这些都属于超出预期的精力，很多人就不愿意做，他宁可花大把的时间和精力做十件平庸的事情，也不愿意做一件极致的事情，非常的不理性，典型的用身体上的勤劳来慰藉心理上的懒惰，最终往往一事无成，反而还抱怨世间不公。\n\n辅助图片\n示意图、表情图和视觉图。\n关于截图\n\niShot\n\n自制线框图\n\nFigJam\n\n版权问题\n配图素材不容忽视的一个大问题就是版权问题。\n演示视频\nGIF 录屏或者视频录屏的效果更好。\n录屏工具推荐\n\nscreenToGif\nGIPHY CAPTURE\n\n在线案例\n\n偏视觉、偏交互效果的在线演示\nJS 代码运行\n运行代码依赖于框架或环境\nNode.js 运行\n\n吸引力的内容\n想要文章受到关注和追捧，最核心的是提高你自己的专业技术水平，成为某个领域的专家。\n形式创新\n\n传统故事陈述\n对话体\n剧本杀体\n会议模拟\n聊天记录模拟\n\n角度新颖\n同样一个内容，如果换个角度阐述，味道就会变得有所不同。\n回到技术写作，技术概念要比实物飘渺，凭空思考往往想不出特别的角度，此时，可以拿出纸和笔，勾勾画画，思路很快就会打开的。\n\n在 JS 中，数组遍历方法有很多：for 语句，forEach，for…in 和 for…of 是比较常见的，我们平时选择使用哪个遍历方法的考虑因素是：代码简洁易懂、性能、上下文支持等。\n所以，我们就可以把原来中规中矩的数组遍历方法介绍变成类似下面这样的内容：\n\n以数量为切入角度：我一共知道 12 种数组遍历方法，你知道几个？\n以对比为切入角度：for/for…in 和 for…of 有什么区别？\n以性能为切入角度：常见 JS 数组遍历方法速度测试\n以使用场景为切入角度：日常开发，我该使用哪个数组遍历方法？\n以技术 Tips 为切入角度：forEach 不支持 break？试试使用 some/every 方法进行数组遍历\n\n\n棱角个性\n有两类技术文章是最看不进去的，一类是文档式的，还有一类是论文式的，比这两类还看不进去的就是专利文档。\n什么是有情感的内容呢？\n\n非上帝视角，而是以自己或他人为视角进行描述；\n抒发个人的情绪，表达个人的见解。\n\n\n举例说明：\n上帝视角：\n数组遍历有如下方法：\n1， 2， 3， …\n个人视角与情绪表达：\n我今天才知道，数组遍历原来有这么多方法：\n1， 2， 3…\n\n作用有两个✌️：\n\n枯燥的文章千篇一律，好看的文章各有不同，区分度也意味着新鲜感，文章更有吸引力；\n当这种“独特的情感”不断重复和加强后，会逐渐形成你的标签，有利于品牌的建设。\n\n总而言之一句话：你是什么样的人，就使用什么样的风格！\n换位共情\n面向读者写文章。\n每写一段内容，都进行一次情境模拟——\n\n如果我是小白，这些术语懂吗？\n如果我是读者，好理解吗？\n是不是用个耳熟能详的东西类比下？\n是不是代码要简化下，加上注释？\n是不是这里应该放个图？\n是不是这里应该加个演示？\n\n一个知识点要想深入浅出，前提就是作者本人的理解足够深入。\n内容严谨\n技术文章要想品质好，其中很重要的一点就是你所说的结论务必正确，也就是对每一句话负责。\n技法高明\n\n首先第一个，尽量的口语化，少用那些书面化的词汇，除非你是写技术文档、工作汇报或者专利文档。因为我们写技术文章的目的是传道受业解惑，让别人更容易理解才是我们的目的，而口语化的语言仿佛就是和人在聊天一样，更亲切自然，也更容易理解与接受。\n其次，句式可以灵活多变，语气有强有弱，而不是陈述句一条道走到黑。比如可以适当地使用疑问句或反问句。\n\n\n疑问句：你觉得 for-in 和 for-of 哪个性能更高呢？下面来揭晓答案……反问句：forEach 需要执行 function，性能怎么可能比不产生任何上下文开销的 for 循环还高呢？\n\n可以适当的停顿或重复来表示强调，例如：\n\n注意，注意，注意，重要的事情说三遍，千万不要…\n\n3.善用比喻，学会举例。\n4.最后，可以适当玩梗，或者使用一些网络流行语、谚语、歇后语、诗词等进行点缀。\n保持真心\n推广\n品牌运营与传播\n账号名称与头像\n什么样的账号名称与头像是适合品牌运营的呢？\n\n识别度高；\n与主体关联；\n\n强化文风与措辞\n让别人记住你的一个最简单的方式就是不断重复。\n\n这种重复可以是类型、可以是风格、可以是口头禅，甚至是某个配图、某个特征，都可以。\n\n\n非技术标签\n技术标签\n可以想一个固定且好记的措辞，然后想办法在每篇文章中呈现。\n\n\n灰太狼的“我一定会回来的”。\n\n\n又包括配图，可以使用某个固定的配图。\n\n保持棱角\n防盗技巧\n\n\n\n版权声明\n\n\n\n\n图片水印\n\n\n\n\n内容植入\n\n\n\n\n软安利\n\n\n\n作品价值最大化\n抓住版权\n多平台经营\n内外开花\n文字作品→PPT分享→视频讲解。\n微创作\n\n技术 Tips\n思考想法\n委婉暗示\n\n体系化创作\n所撰写的内容尽可能地体系化创作。\n\n量变产生质变，当你的作品数量积累到一定程度之后，这些作品是可以进一步包装，进行二次销售的。\n\n技术写作指南 - 张鑫旭 - 掘金小册\n\nInput 实用技能  写作\n\n来自：原文地址\n"},"C-Knowledge/读书笔记/《黑客与画家》Paul-Graham·著-阮一峰·译":{"title":"《黑客与画家》Paul Graham·著 阮一峰·译","links":["tags/场景/创业","tags/场景/写作"],"tags":["编程/书籍","场景/创业","场景/写作"],"content":"\n关于本书\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n书名《黑客与画家》作者Paul Graham美国译者阮一峰出版社人民邮电出版社阅读日期2021.02.06我的评分☆☆☆☆☆\n内容简介\n《黑客与画家》是阮一峰翻译的一本书。总的来说这本书写的非常的好而且翻译的也很好，值得反复阅读，文中的很多观点都值得反复品味。这本书涉及的东西很多，有关于创业的、设计的、编程的、财富的、写作的以及对社会的一些思考等等，我也是前后花了两次才把这本书读完，第一次读，读到一半就不知怎么就戛然而止了，第二次读我选择了最感兴趣的一章（如何创造财富）开始阅读，一读起来就一发不可收拾，一直读到了结尾。然后又从头开始阅读。这本书断断续续读了两个周才读完，其中有些观点总是需要停下来反复阅读才能，品味出作者的思想。\n保罗·格雷厄姆本称为硅谷创业之父，文章中非常多的东西都和他本身创业的经历有关，而他关于创业的观点很值的学习和借鉴。\n书摘\n创业创业\n\n运营创业公司，每天都像在战斗；而为大公司工作，就像在窒息中挣扎。\n我们生活中的一切，都正在成为计算机。所以，如果你想理解我们目前的世界以及它的未来动向，那么多了解一些黑客的想法会对你有帮助。\n在科技快速发展、资本不断涌入的大背景下，它使得创业公司规模更小、成本更低、行动更快。\n创业公式是：\n\n（1）搭建原型\n（2）上线运营（别管bug）\n（3）收集反馈\n（4）调整产品\n（5）成长壮大\n\n首先，他鼓励创业公司快速发布产品，因为这样可以尽早知道一个创意是否可行。其次，他认为一定要特别关注用户需要什么，这样才有办法将一个坏项目转变成好项目。\n“Make something people want”（制造用户需要的东西）。\n一方面，创业是最有效的创造财富的方法，对创始人、对投资者、对社会都是如此。另一方面，创业越来越简单了，成本也越来越低。\n太麻烦，不如死”（death before inconvenience）。\n“你的电脑”这个概念正慢慢成为过去时，取而代之的是“你的数据”。你应该可以从任何电脑上获取你的数据。或者更准确地说，在任何终端设备上获取你的数据，终端设备不一定是电脑。\n一般情况是，创业公司要么赢得一切，要么彻底失败。你要么成为富翁，要么一无所获。创业的时候，如果你选择了错误的技术，竞争对手就会一举打败你。\n如果你掌管创业公司，最好做一些独特的事情，否则就会有麻烦。\n我首先会看他们的产品有没有一个试用版，然后就去找他们的招聘职位。\n让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。如果没有用户，谁会关心你选择的“正统”技术是多么令人放心。\n我有一个朋友，他的客户第一次提出某种需求时，他很少理会。因为他知道人们有时候会想要自己并不真正需要的东西。为了避免浪费时间，只有当客户第三次或第四次提出同样的需求时，他才认真对待。这个时候客户可能已经很不高兴了，但是这至少保证他们提出的需求应该就是他们真正需要的东西。\n简单重复同一个信息就能解决这个问题。你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。简单重复同一个信息就能解决这个问题。你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。\n自然成长式会比大爆炸式产生更好的技术，能为创始人带来更多的财富。\n\n生活\n\n当工作的专业程度越来越高时，我们就必须接受更长时间的训练。（如今，只要一个青少年读大学，他就要等到21岁或22岁才开始全职工作。）\n回顾过去，将当代观念与不同时期的古代观念diff一下，你也可以将我们的观念与其他文化的观念diff一下。\n想要做出优秀作品，你需要一个什么问题都能思考的大脑。尤其是那些似乎不应该思考的问题，你的大脑也要养成思考它们的习惯。\n一个好的科学家，并不仅仅是避开传统观点，还要努力打破传统观点。\n智力越高的人，越愿意去思考那些惊世骇俗的思想观点。这不仅仅因为聪明人本身很积极地寻找传统观念的漏洞，还因为传统观念对他们的束缚力很小，很容易摆脱。从他们的衣着上你就可以看出这一点：不受传统观念束缚的人，往往也不会穿流行的衣服。\n在任何有竞争的地方，只要你能看到别人看不到或不敢看的东西，你就有很大的优势。\n训练自己去想那些不能想的事情，你获得的好处会超过所得到的想法本身。\n如果你能“远远地”跳出传统思维，提出让别人一听就脑袋轰一声炸开的惊人观点，那么你就在“小小地”跳出传统思维方面不会有任何困难。\n在心里无所不想，但是不一定要说出来。\n守口如瓶，笑脸相迎。\n如果口无遮拦，你就没时间做正事了。为了与他人论战，你不得不变成一个语言学家，比如诺姆·乔姆斯基。\n讨论一个观点会产生更多的观点，不讨论就什么观点也没有。\n时间就是一种产生距离的简单方法。你不仅要远距离观察人群，更要远距离观察你自己。如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。\n经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。我认为政府的力量也是如此，随着对公民自由的限制不断上升，政府的力量会先增加后减小。\n统计学过滤器。\n很难预测一百年后的人类生活，只有少数几件事是可以确定的。那时，汽车将具备低空飞行能力，城市规划的法规将放宽，大楼可以造到几百层，大街上一天到晚看不见太阳，女性个个都学过防身术。\n父亲教给我什么是怀疑主义，母亲教给我如何发挥想象力。有了这样的母亲，我眼前的世界就从黑白变成了彩色。\n\n设计\n\n喜欢一件东西，却不知道为什么自己喜欢它，原因可能是这件东西是美的，\n好设计是简单的设计。\n\n\n简短的证明往往是更好的证明。\n当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。\n\n\n好设计是永不过时的设计。\n\n\n如果解决方法是丑陋的，那就肯定还有更好的解决方法，只是还没有发现而已。\n以永不过时作为目标是一种帮助自己找到最佳答案的方法：如果你不愿别人的答案取代你的答案，你就只好自己做出最佳答案。\n如果你希望自己的作品对未来的人们有吸引力，方法之一就是让你的作品对上几代人有吸引力。\n\n\n好设计是解决主要问题的设计。\n好设计是启发性的设计。\n\n\n在建筑学和设计学中，这条原则意味着，一幢建筑或一个物品应该允许你按照自己的愿望来使用。举例来说，一幢好的建筑物应该可以充当平台，让你想怎么布置就可以怎么布置，过上自己想过的家庭生活，而不是使得你像执行程序一样只能过上建筑师为你安排的生活。在软件业中，这条原则意味着，你应该为用户提供一些基本模块，使得他们可以随心所欲自由组合，就像玩乐高积木那样。在数学中，这条原则意味着，一个可以成为许多新工作基础的证明要优于一个难度很高、但无助于未来学科发展的证明。在科学领域中，总体上可以把引用次数看作对他人启发性大小的粗略指标。\n\n\n好设计通常是有点趣味性的设计。\n\n\n幽默感是强壮的一种表现，始终拥有幽默感就代表你对厄运一笑了之，而丧失幽默感则表示你被厄运深深伤到。\n强壮的标志（或者至少是特点）就是轻松面对自己的人生。充满自信的人常常像燕子一样，以一种居高临下的姿态轻盈地看待周围的一切。\n\n\n好设计是艰苦的设计。\n\n\n如果你工作得不艰苦，你可能正在浪费时间。\n困难的问题需要艰巨的付出才能解决，高难度的数学证明需要结构非常精细的解决方法（它们往往做起来很有趣），工程学也是如此。\n并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。\n在困难地点或预算不足的条件下，建筑师就只能做出很简练的设计。\n如果开发“功能”非常艰难，那么“形式”将不得不全部都由“功能”决定，因为没有多余的精力再来单独开发“形式”了。人们常常觉得野生动物非常优美，原因就是它们的生活非常艰苦，在外形上不可能有多余的部分了。\n\n\n好设计是看似容易的设计。\n\n\n作家的文章读起来流畅自如，但是背后其实经过了反复修改。\n科学和工程学的一些最重大的发现在形式上往往很简单，会科学和工程学的一些最重大的发现在形式上往往很简单，会使得你觉得自己也想到过。可是，如果它真的那么简单，为什么发现人不是你呢？使得你觉得自己也想到过。可是，如果它真的那么简单，为什么发现人不是你呢？\n在大多数领域，看上去容易的事情，背后都需要大量的练习。练习的作用也许是训练你把刻意为之的事情变成一种自觉的行为。\n\n\n好设计是对称的设计。\n\n\n对称也许只是简洁性的一种表现。\n对称有两种：重复性对称和递归性对称。递归性对称就是指子元素的重复，比如树叶上叶脉的纹路。\n在写作中，你会发现对称无处不在，短语、句子、小说的情节都是如此。音乐和美术也大量使用对称。拼接式的美术作品（还有塞尚的一部分作品）有非常强烈的视觉感染力，原因就是整幅作品由相同的作图元素构成，这也属于对称。在数学和工程学中，递归尤其有用。归纳式证明方法既简洁又美妙。在软件中，能用递归解决的问题通常代表已经找到了最佳解法。巴黎的埃菲尔铁塔如此引人注目，部分原因就是它的外形是递归的，大塔上面还有小塔。\n\n对称的危险在于它可以用来取代思考，在大量使用重复的时候这种危险性更大。\n\n\n好设计是模仿大自然的设计。\n\n\n如果你的设计与大自然很接近，那么它基本上不会很差。\n模仿大自然也是工程学的有效方法。\n\n\n好设计是一种再设计。\n\n\n专家的做法是先完成一个早期原型，然后提出修改计划，最后把早期原型扔掉。\n你应该培养对自己的不满。\n做修改的时候，有一个合适的工具会使得改动更容易。犯错误是很正常的事情。你不要把犯错看成灾难，要勇于承认、勇于改正。\n\n\n好设计是能够复制的设计。\n\n\n最后他会意识到，把事情做对比原创更重要。\n如果你不知道自己的想法从何而来，那么你可能就是在模仿另一个模仿者。\n等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。你的品味就进入了第二阶段，开始自觉地进行原创。\n\n\n好设计常常是奇特的设计。\n\n\n爱因斯坦并不想让相对论变得很奇特，他只想找出真理，是真理本身显得很奇特。\n如果你想做出好作品，不可避免地会采用一种独特的方式，就好像每个人走路的姿势其实都不尽相同。\n唯一达到“奇特”的方法，就是追求做出好作品，完成之后再回过头看。\n\n\n好设计是成批出现的。\n\n\n推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。互相激励比天赋更重要，达·芬奇之所以成为达·芬奇，主要原因不仅仅是他的天赋，更重要的是他生活在当时的佛罗伦萨，而不是米兰。\n在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果。某种程度上，你个人最多可以对趋势产生一定的影响，但是你不可能决定趋势，实际上是趋势决定了你。\n\n\n好设计常常是大胆的设计。\n\n\n如果你想做出伟大的新成果，那就不能对常识与真理不相吻合之处视而不见，反而应该特别注意才对。\n哥白尼对地心说无法解释的事情深感困扰，他的同时代人都觉得这可以忍受，他却认为一定能找到一种更好的解释。\n单单是无法容忍丑陋的东西还不够，只有对这个领域非常熟悉，你才可能发现哪些地方可以动手改进。\n只有在成为某个领域的专家之后，你才会听到心里有一个细微的声音说：“这样解决太糟糕了！一定有更好的选择。”\n优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。\n\n\n设计与研究\n\n\n设计与研究的区别看来就在于，前者追求“好”（good），后者追求“新”（new）。优秀的设计不一定很“新”，但必须是“好”的；优秀的研究不一定很“好”，但必须是“新”的。我认为这两条道路最后会发生交叉：只有应用“新”的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是“好”的难题），才会诞生最佳研究。所以，最终来说，设计和研究都通向同一个地方，只是前进的路线不同罢了。\n优秀的建筑师不会先设计，然后强迫用户接受，而是先研究最终用户的需求，然后做出用户需要的设计。\n我觉得任何一个领域的最佳作品都不可能由对用户言听计从的人做出来。\n让用户满意并不等于迎合用户的一切要求。用户不了解所有可能的选择，也经常弄错自己真正想要的东西。\n做一个好的设计师就像做一个好医生一样。你不能头痛医头，脚痛医脚。病人告诉你症状，你必须找出他生病的真正原因，然后针对病因进行治疗。大多数优秀设计都是这样产生的，它们关注用户，并且以用户为中心。\n我觉得，除非设定目标用户，否则一种设计的好坏根本无从谈起。\n\n财富\n\n允许赚到大钱的人保住自己的财富。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。\n我们大多数人都在为其他人创造财富，然后用创造出来的财富交换金钱，再用金钱交换我们需要的另一种财富。\n如果你需要什么东西，要么你自己做出来，要么做其他东西与需要的人交换金钱，再用金钱去买你想要的东西。\n每个人的技能不同，导致收入不同，这才是贫富分化的主要原因，正如逻辑学的“奥卡姆剃刀”原则所说，简单的解释就是最好的解释。\n一个人的工作具有多少价值不是由政府决定的，而是由市场决定的。\n人与人之间的差别并不是那么稳定的线性关系。\n中产阶级的出现使得财富总量不再是一个固定不变的值，财富的分配也不再是一种零和游戏。\n技术应该会引起收入差距的扩大，但是似乎能缩小其他差距。一百年前，富人过着与普通人截然不同的生活。他们住在大房子里，有许多仆人服侍，穿着华丽但是不舒适的服装，乘着马车旅行（因此还有马厩和马夫）。现在，由于技术的发展，富人的生活与普通人的差距缩小了。\n技术无法使其变得更便宜的唯一东西，就是品牌。\n今天的人们多多少少还是有一些互相隔离的趋势，但主要是因为教育层次的差别，而不是财富的差别。\n你要避免的是绝对贫穷，而不是相对贫穷。\n\n编程\n\n任何一种艺术，不管是否重要，如果你想要在该领域出类拔萃，就必须全身心投入。\n创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。\n你把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样。\n编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。\n大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。\n真正竞争软件设计的战场是新兴领域的市场，这里还没有人建立过防御工事。只要你能做出大胆的设计，由一个人或一批人同时负责设计和实现产品，你就能在这里战胜大公司。\n如果你想赚钱，你可能不得不去干那些很麻烦很讨厌的事情，因为这些事情没人愿意义务来干。价格是由供给和需求共同决定的。好玩的软件的需求量，比不上解决客户麻烦问题的软件的需求量。\n黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。\n一幅画是逐步完成的。通常一开始是一张草图，然后再逐步填入细节。你不能盼望先有一个完美的规格设计，然后再动手编程，这样想是不现实的。\n过早优化（premature optimization）是一件危险的事情。我认为，我们应该对“过早设计”（premature design）也抱有同样的担忧，不要太早决定一个程序应该怎么做。\n最容易修改的语言就是简短的语言。\n坚持一丝不苟，就能取得优秀的成果。\n我对待代码的认真程度远远超过我对待其他事情。\n为了做出优秀的工作，你必须把这种心理周期考虑在内。\n正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。\n现实中，这必然意味着你要做其他人需要的事情，而不是你自己想做的事情。\n为了吸引用户，你必须理解用户需要什么。\n判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。\n源代码也应该可以自己解释自己。\n程序写出来是给人看的，附带能在机器上运行。\n“换位思考”不仅是为了你的用户，也是为了你的读者。这对你是有利的，因为你也会读自己写的东西。\n一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。\n不同的语言适合不同的任务，你应该根据不同场合，挑选最合适的工具。\n软件的发布过程可以分解为一系列的渐进式修改，而不是猛地推出一个大幅变动的版本。\n在发布之前，你应该对修改之处进行测试，避免出现重大的bug。\n解决新代码的bug要比解决历史遗留代码的bug容易。\n有一种编程方法叫做“函数式编程”（functional programming），它对你会有帮助，可以避免一些副作用。\nViaweb的开发人员总是与客服人员保持密切联系。客服人员坐在距离程序员只有9米的地方，知道自己可以随时打断程序员的工作，提交新证实的bug的报告。遇到重大bug，我们就算在开董事会，也会马上回来修改程序。\n我们的这种方法让所有人都感到满意。客户很高兴，拨打厂商服务热线是免费的，而且还被当作通风报信的人，受到郑重对待。客服人员也喜欢这样，因为这使得他们可以帮助用户，而不是对着用户读操作手册；程序员喜欢这样，因为他们能够再现bug，而不是通过模糊不清的二手报告了解bug。\n通过归纳法我们就会知道，唯一洞悉所有语言优劣的人必然是懂得最强大的那种语言的人。\n一个技巧就是（在语言允许的前提下）使用“自下而上”（bottom-up）的编程方法。\n你不是用基础语言（base language）开发应用程序，而是在基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。\n“自下而上”的编程往往也便于修改，因为许多时候你自己添加的中间层根本不需要变化，你只需要修改前端逻辑就可以了。\n编程语言的所谓“业界最佳实践”，实际上不会让你变成最佳，只会让你变得很平常。\n设计一样东西，最重要的一点就是要经常“再设计”，编程尤其如此，再多的修改都不过分。\n\n\n为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。\n在你的大脑中，有一个声音说“千难万险只等闲”，还有一个声音却说“早岁哪知世事艰”。\n你的乐观主义和怀疑倾向分别针对两个不同的对象。你必须对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。\n在创新活动的第一阶段，你不知疲倦地猛攻某个难题，自信一定能够解决它。到了第二阶段，你在清晨的寒风中看到自己已经完成的部分，清楚地意识到存在各种各样的缺陷。\n只要你对自己的怀疑没有超过你对自己的信心，就能够坦然接受这个半成品，心想不管多难我还是可以把剩下的部分做完。\n任何措施，只要能让“再设计”周而复始地进行下去，就都是可取的。文章可以修改到你满意为止，但是软件的修改通常来说可以无休止地进行下去。\n用户是一把双刃剑。他们推动语言的发展，但也使得你不敢对语言进行大规模改造。\n一开始的时候要精心选择用户，避免使用者过快增长。发展用户就像一种优化过程，明智的做法就是放慢速度。\n如果用户数量庞大，修改语言带来的痛苦就将持续很长时间。\n将软件内部的接口设计成垂直接口而不是水平接口。\n软件内部的模块是一个个垂直堆积起来的抽象层，层与层之间的接口完全由其中的一层控制。如果较高的一层使用了较低的一层定义的语言，那么接口就由较低的一层控制；如果较低的一层从属于较高的一层，那么接口就由较高的一层控制。\n为了做出优秀的设计，你必须贴近用户，始终寸步不离，永远站在用户的角度调整自己的构想。\n软件领域，贴近用户的设计思想被归纳为“弱即是强”（Worse is Better）模式。其中有一点是正确的，那就是如果你正在设计某种新东西，就应该尽快拿出原型，听取用户的意见。还有另一种软件设计思想，也许可以被称为“万福玛丽亚”模式。它不要求尽快拿出原型，然后再逐步优化，它的观点是你应该等到完整的成品出来以后再一下子隆重地推向市场，就像圣母玛丽亚降临一样，哪怕整个过程漫长得像橄榄球运动员长途奔袭、达阵得分也没有关系。\n你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。在大多数艺术领域，原型使用的材料与成品的材料一般来说是不一样的。印刷活字先画在纸上，然后才做成铅字。雕塑先用石蜡创作，然后才用青铜浇铸。地毯图案先用墨水画出纸型，然后才织成地毯。建筑物先做出木模型，然后才做成石头建筑。\n软件开发也可以这样做。原型（prototype）并不只是模型（model），不等于将来一定要另起炉灶，你完全能够在原型的基础上直接做出最后的成品。我认为，只要有可能，你就应该这样做。这样的方式使得你可以利用在开发过程中一路产生的新想法。不过更重要的是，这样做有助于鼓舞士气。\n如果你觉得画某样东西很乏味，那么你画出来的东西就会真的很乏味。\n大多数画家都是先画一个草图，然后再逐步加工。\n你每天收工的时候都可以看到整体的效果，不会对最后的成品一点感觉都没有。\n画作永远没有完工的一天，你只是不再画下去而已。\n优秀设计的前提是你自己必须喜欢这种产品，否则你不可能对设计有兴趣，更不要说士气高昂了。\n\n编程语言\n\n一个操作所需的代码越多，就越难避免bug，也越难发现它们。\n程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了。\n你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。\n你应该使用允许你面向对象编程的语言。\n冗余的代码会导致更多冗余的代码。一件垃圾会产生更多的垃圾。\n内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。\n语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问题。\n随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。\n浪费可以分成好的浪费和坏的浪费。我感兴趣的是好的浪费，即用更多的钱得到更简单的设计。\n一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言，哪怕它的效率低下得惊人（至少按我们今天的眼光来看是如此）。\n一种让程序员做无用功的语言才真正称得上很烂。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。\n一种效率低得不可想象的语言遇到了性能强大得不可想象的硬件，会发生什么事。\n根据经验判断，每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。\n自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。\n这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性（reusability）——的最佳路线。\n面向对象编程使得你有办法对面条式代码进行可持续性开发。通过不断地打补丁，它让你将软件一步步做大。\n程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。\n新语言更多地以开源项目的形式出现，而不是以研究性项目的形式出现。\n也许不能说最短的程序就是写起来最省力的程序，但是当你一心想把程序写得简洁而不是松松垮垮时，你就更接近省力这个目标，你的日子也会变得好过得多。\n当你设计语言的时候，心里牢牢记住这个目标是有好处的。学习开车的时候，一个需要记住的原则就是要把车开直，不是通过将车身对齐画在地上的分隔线，而是通过瞄准远处的某个点。即使你的目标只在几米开外，这样做也是正确的。我认为，设计编程语言时，我们也应该这样做。\n为什么Lisp语言很特别\n条件结构\n函数也是一种数据类型。数与整数或字符串一样，也属于数据类型的一种\n递归\n变量的动态类型\n垃圾回收机制\n程序由表达式组成\n符号类型\n代码使用符号和常量组成的树形表示法\n无论什么时候，整个语言都是可用的\n\n\n用一门语言自己的数据结构来表达该语言是非常强大的功能\n思想(8)和思想(9)，意味着你可以写出一种能够自己编程的程序。\n\n\n所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言写出任何一个程序。\n“格林斯潘第十定律”（Greenspun’s Tenth Rule）：\n\n\n任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是bug的、运行速度很慢的Common Lisp实现。\n当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。程序的形式应该仅仅反映它所要解决的问题。代码中其他任何外加的形式都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码通过宏的扩展自动实现。\n\n\n一种语言必须是某一个流行的计算机系统的脚本语言（scripting language），才会变得流行。\n\n\nFortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来的Perl和Python也是如此。Tcl是Tk的脚本语言，Visual Basic是Windows的脚本语言，（某种形式的）Lisp是Emacs的脚本语言，PHP是网络服务器的脚本语言，Java和JavaScript是浏览器的脚本语言。\n“编程”其实是及物动词，黑客一般都是为某个系统编程，在现实中，编程语言总是与它们依附的系统联系在一起的。\n编程语言还应该有在线文档。事实上，在线文档可以当作一本书来写，但是目前它还无法取代实体书。实体书并没有过时，它们读起来很方便，而且出版社对书籍内容的审核是一种很有用的质量保证机制（虽然做得很不完美）。\n黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。\n只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。编程语言的进步很大一部分与函数库有关。函数库的使用应该符合程序员的直觉，让他可以猜得出哪个函数能满足自己的需要。\n\n\n我们在Viaweb搞了一块很大的面板，上面有各种各样的仪表盘，用来显示服务器的状况。\n怎么理解编程语言？你不要把它看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。某种设计使得最后的程序非常漂亮，但是不一定同时具备漂亮的编程过程。\n\n梦寐以求的编程语言\n\n这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。\n这种语言的内核很小，但很强大。各个函数库高度独立，而且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样完美契合，不需要为了兼容性问题放弃或者保留某些功能。\n这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。\n除了一些绝对必要隐藏的东西，这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。\n\n写作\n\n构思这种东西有一个特点，那就是它会导致更多的构思。你有没有注意过，坐下来写东西的时候，一半的构思是写作时产生的？软件也是这样。写作\n拉丁语无助于你找工作（也许古典文学教授的工作除外），但是它可以训练你的思维，帮助你更好地运用母语（比如英语）进行写作。\n最好的文字来自不停的修改。\n\n读后感\n我还没想好。\n永远保持质疑。\n打草稿，使用好 Git。\n按模块划分任务，然后每个模块直接通过接口交互。\n内卷化，限制增长、只能内部竞争。\n分层、分模块、分组件⇒重用。\n经常“再设计”"},"C-Knowledge/项目/开源项目":{"title":"开源项目","links":[],"tags":["场景/职业"],"content":""},"C-Knowledge/项目/技术文章":{"title":"技术文章","links":[],"tags":["场景/职业"],"content":""},"C-Knowledge/项目/文档翻译":{"title":"文档翻译","links":[],"tags":["场景/职业"],"content":"\n\n                  \n                  初心 \n                  \n                \n\n提升影响力\n提升英语水平\n提升技术水平\n\n\n\nhusky中文文档\nQuartz 4.0 中文文档\nTemplater\n\n\n\nreact-three-fiber\nVue中文文档\n"},"D-Unsorted/CORS-通信":{"title":"CORS 通信","links":["C-Knowledge/前端/编程基础/网络/跨域解决-cors"],"tags":["编程/网络/Ajax"],"content":"CORS 是一个 W3C 标准，全称是“跨源资源共享”（Cross-origin resource sharing），或者通俗地称为“跨域资源共享”。它允许浏览器向跨源的服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。\n简介\nCORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。\n整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\n两种请求\nCORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n（1）请求方法是以下三种方法之一。\n\nHEAD\nGET\nPOST\n\n（2）HTTP 的头信息不超出以下几种字段。\n\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。\n这样划分的原因是，表单在历史上一直可以跨源发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。\n简单请求\n基本流程\n对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，==增加一个Origin字段==。\n下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。\nGET /cors HTTP/1.1\nOrigin: api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n上面的头信息中，Origin字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。\n如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\nAccess-Control-Allow-Origin: api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text/html; charset=utf-8\n上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头。\n（1）Access-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n（2）Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，不发送该字段即可。\n（3）Access-Control-Expose-Headers\n该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个服务器返回的基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#039;FooBar&#039;)可以返回FooBar字段的值。\nwithCredentials 属性\n上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定Access-Control-Allow-Credentials字段，告诉浏览器可以发送 Cookie。\nAccess-Control-Allow-Credentials: true\n同时，开发者必须在 AJAX 请求中打开withCredentials属性。\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。\n但是，有的浏览器默认将withCredentials属性设为true。这导致如果省略withCredentials设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭withCredentials。\nxhr.withCredentials = false;\n需要注意的是，如果服务器要求浏览器发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。\n非简单请求\n预检请求\n非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。\n非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨源发出的请求。\n下面是一段浏览器的 JavaScript 脚本。\nvar url = &#039;api.alice.com/cors&#039;;\nvar xhr = new XMLHttpRequest();\nxhr.open(&#039;PUT&#039;, url, true);\nxhr.setRequestHeader(&#039;X-Custom-Header&#039;, &#039;value&#039;);\nxhr.send();\n上面代码中，HTTP 请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。\n浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。\nOPTIONS /cors HTTP/1.1\nOrigin: api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，“预检”请求的头信息包括两个特殊字段。\n（1）Access-Control-Request-Method\n该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是PUT。\n（2）Access-Control-Request-Headers\n该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header。\n预检请求的回应\n服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: api.bob.com\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\n上面的 HTTP 回应中，关键的是Access-Control-Allow-Origin字段，表示api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\nAccess-Control-Allow-Origin: *\n如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。\nOPTIONS api.bob.com HTTP/1.1\nStatus: 200\nAccess-Control-Allow-Origin: notyourdomain.com\nAccess-Control-Allow-Method: POST\n上面的服务器回应，Access-Control-Allow-Origin字段明确不包括发出请求的api.bob.com。\n这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\nXMLHttpRequest cannot load api.alice.com.\nOrigin api.bob.com is not allowed by Access-Control-Allow-Origin.\n服务器回应的其他 CORS 相关字段如下。\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 1728000\n（1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨源请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n浏览器的正常请求和回应\n一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，==会有一个Origin头信息字段==。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n下面是“预检”请求之后，浏览器的正常 CORS 请求。\nPUT /cors HTTP/1.1\nOrigin: api.bob.com\nHost: api.alice.com\nX-Custom-Header: value\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n上面头信息的Origin字段是浏览器自动添加的。\n下面是服务器正常的回应。\nAccess-Control-Allow-Origin: api.bob.com\nContent-Type: text/html; charset=utf-8\n上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。\n与 JSONP 的比较\nCORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持GET请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。\n参考链接\n\nUsing CORS, Monsur Hossain\nHTTP access control (CORS), MDN\nCORS, Ryan Miller\nDo You Really Know CORS?, Grzegorz Mirek\n"},"D-Unsorted/Commit-message":{"title":"Commit message","links":["D-Unsorted/如何用-Husky-和-Shell-脚本自动化代码检查"],"tags":["编程/Git"],"content":"Git 提交规范\n\n\nfeat: 新功能、新特性\nfix: 修改 bug\nperf: 更改代码，以提高性能\nrefactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）\ndocs: 文档修改\nstyle: 代码格式修改, 注意不是 css 修改（例如分号修改）\ntest: 测试用例新增、修改\nbuild: 影响项目构建或依赖项修改\nrevert: 恢复上一次提交\nci: 持续集成相关文件修改\nchore: 其他修改（不在上述类型中的修改）\nrelease: 发布新版本\nworkflow: 工作流相关文件修改\n\ngit commit 提交钩子\n安装 husky 并新增 commit msg 钩子\nnpm install -D husky # 安装husky\nnpx husky install    # 初始化husky\n# 新增commit msg钩子\nnpx husky add .husky/commit-msg &quot;node scripts/verifyCommit.js&quot; \n提交信息校验规则\n// 兼容有subpackage的项目\nconst hasSubpackages = __dirname.includes(&#039;subpackages&#039;);\nconst filePath = [\n  &#039;../../../&#039;,\n  `${hasSubpackages ? &#039;../&#039; : &#039;&#039;}`,\n  &#039;.git/modules/&#039;,\n  `${hasSubpackages ? &#039;subpackages/&#039; : &#039;&#039;}`,\n  &#039;src/ynModules/NPlayer/COMMIT_EDITMSG&#039;,\n].join(&#039;&#039;);\nconsole.log(filePath);\nconst msg = require(&#039;fs&#039;).readFileSync(filePath, &#039;utf-8&#039;).trim();\n \nconst commitRE =\n  /^(revert: )?(feat|fix|docs|dx|style|refactor|perf|test|workflow|build|ci|chore|types|wip|release)(\\(.+\\))?: .{1,50}/;\nconst mergeRe = /^(Merge pull request|Merge branch)/;\nif (!commitRE.test(msg)) {\n  if (!mergeRe.test(msg)) {\n    console.log(&#039;git commit信息校验不通过&#039;);\n \n    console.error(`git commit的信息格式不对, 需要使用 title(scope): desc的格式\n    比如 fix: xxbug\n    feat(test): add new \n    具体校验逻辑看 scripts/verifyCommit.js\n  `);\n    process.exit(1);\n  }\n} else {\n  console.log(&#039;git commit信息校验通过&#039;);\n}\n预校验\nnpx husky add .husky/pre-commit &quot;npm run lint&quot;\n参考地址\n\n如何用 Husky 和 Shell 脚本自动化代码检查\nCommit message 和 Change log 编写指南\ncz-git：使用 OpenAI 生成 git commit 提交信息。\nGithub Code Review 机器人\n\n机器人地址：github.com/apps/cr-gpt\n\n\n"},"D-Unsorted/Git-入门":{"title":"Git 入门","links":[],"tags":["编程/Git"],"content":"Git 安装与✏卸载\nbrew install git\n# 查看安装地址，默认地址 /usr/bin/git\nwhich -a git\n# 移除文件\ncd /usr/bin\nsudo rm -rf git*\n\n\nMac 系统下安装卸载 Git  之心\n\nGit 问题\nM 1  芯片不兼容\n\n\n                  \n                  错误 \n                  \n                \nxcrun: error: unable to load libxcrun (dlopen(/Library/Developer/CommandLineTools/usr/lib/libxcrun.dylib, 0x0005): tried: ‘/Library/Developer/CommandLineTools/usr/lib/libxcrun.dylib’ (mach-o file, but is an incompatible architecture (have ‘x86_64’, need ”)), ‘/System/Volumes/Preboot/Cryptexes/OS/Library/Developer/CommandLineTools/usr/lib/libxcrun.dylib’ (no such file), ‘/Library/Developer/CommandLineTools/usr/lib/libxcrun.dylib’ (mach-o file, but is an incompatible architecture (have ‘x86_64’, need ”))).\n\n\n重新安装 git\n"},"D-Unsorted/Husky":{"title":"Husky","links":[],"tags":["编程/Git"],"content":""},"D-Unsorted/Location-对象，URL-对象，URLSearchParams-对象":{"title":"Location 对象，URL 对象，URLSearchParams 对象","links":["C-Knowledge/前端/技术书籍/ES6-入门教程/ES6-入门教程","Iterator"],"tags":["编程/JavaScript/浏览器"],"content":"URL 是互联网的基础设施之一。浏览器提供了一些原生对象，用来管理 URL。\nLocation 对象\nLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。\n属性\nLocation对象提供以下属性。\n\nLocation.href：整个 URL。\nLocation.protocol：当前 URL 的协议，包括冒号（:）。\nLocation.host：主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口。\nLocation.hostname：主机名，不包括端口。\nLocation.port：端口号。\nLocation.pathname：URL 的路径部分，从根路径/开始。\nLocation.search：查询字符串部分，从问号?开始。\nLocation.hash：片段字符串部分，从#开始。\nLocation.username：域名前面的用户名。\nLocation.password：域名前面的密码。\nLocation.origin：URL 的协议、主机名和端口。\n\n// 当前网址为\n// http://user:passwd@www.example.com:4097/path/a.html#part1\ndocument.location.href\n// &quot;http://user:passwd@www.example.com:4097/path/a.html#part1&quot;\ndocument.location.protocol\n// &quot;http:&quot;\ndocument.location.host\n// &quot;www.example.com:4097&quot;\ndocument.location.hostname\n// &quot;www.example.com&quot;\ndocument.location.port\n// &quot;4097&quot;\ndocument.location.pathname\n// &quot;/path/a.html&quot;\ndocument.location.search\n// &quot;?x=111&quot;\ndocument.location.hash\n// &quot;#part1&quot;\ndocument.location.username\n// &quot;user&quot;\ndocument.location.password\n// &quot;passwd&quot;\ndocument.location.origin\n// &quot;http://user:passwd@www.example.com:4097&quot;\n这些属性里面，只有origin属性是只读的，其他属性都可写。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，如果对 Location.href 写入新的 URL 地址，浏览器会立刻跳转到这个新地址。\n\n// 跳转到新网址\ndocument.location.href = &#039;www.example.com&#039;;\n这个特性常常用于让网页自动滚动到新的锚点。\ndocument.location.href = &#039;#top&#039;;\n// 等同于\ndocument.location.hash = &#039;#top&#039;;\n直接改写location，相当于写入href属性。\ndocument.location = &#039;www.example.com&#039;;\n// 等同于\ndocument.location.href = &#039;www.example.com&#039;;\n另外，Location.href属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的Location.href属性，导致后者的网址跳转。Location的其他属性都不允许跨域写入。\n方法\n（1）Location.assign()\nassign方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。\n// 跳转到新的网址\ndocument.location.assign(&#039;www.example.com&#039;)\n（2）Location.replace()\nreplace方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。\n它与assign方法的差异在于，replace会在浏览器的浏览历史History里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。\n// 跳转到新的网址\ndocument.location.replace(&#039;www.example.com&#039;)\n（3）Location.reload()\nreload方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。\n它接受一个布尔值作为参数。如果参数为true，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即scrollTop === 0）。如果参数是false或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。\n// 向服务器重新请求当前网址\nwindow.location.reload(true);\n（4）Location.toString()\ntoString方法返回整个 URL 字符串，相当于读取Location.href属性。\nURL 的编码和解码\n网页的 URL 只能包含合法的字符。合法字符分成两类。\n\nURL 元字符：分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）\n语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（&#039;），圆括号（()）\n\n除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。\n比如，UTF-8 的操作系统上，www.example.com/q=春节这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成www.example.com/q=%E6%98%A5%E8%8A%82。其中，“春”转成了%E6%98%A5，“节”转成了%E8%8A%82。这是因为“春”和“节”的 UTF-8 编码分别是E6 98 A5和E8 8A 82，将每个字节前面加上百分号，就构成了 URL 编码。\nJavaScript 提供四个 URL 的编码/解码方法。\n\nencodeURI()\nencodeURIComponent()\ndecodeURI()\ndecodeURIComponent()\n\nencodeURI()\nencodeURI()方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。\nencodeURI(&#039;www.example.com/q=春节&#039;)\n// &quot;www.example.com/q=%E6%98%A5%E8%8A%82&quot;\nencodeURIComponent()\nencodeURIComponent()方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。\nencodeURIComponent(&#039;春节&#039;)\n// &quot;%E6%98%A5%E8%8A%82&quot;\nencodeURIComponent(&#039;www.example.com/q=春节&#039;)\n// &quot;http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82&quot;\n上面代码中，encodeURIComponent()会连 URL 元字符一起转义，所以如果转码整个 URL 就会出错。\ndecodeURI()\ndecodeURI()方法用于整个 URL 的解码。它是encodeURI()方法的逆运算。它接受一个参数，就是转码后的 URL。\ndecodeURI(&#039;www.example.com/q=%E6%98%A5%E8%8A%82&#039;)\n// &quot;www.example.com/q=春节&quot;\ndecodeURIComponent()\ndecodeURIComponent()用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。它接受一个参数，就是转码后的 URL 片段。\ndecodeURIComponent(&#039;%E6%98%A5%E8%8A%82&#039;)\n// &quot;春节&quot;\nURL 接口\n浏览器原生提供URL()接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过window.URL可以拿到这个构造函数。\n构造函数\nURL()作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。\nvar url = new URL(&#039;www.example.com/index.html&#039;);\nurl.href\n// &quot;www.example.com/index.html&quot;\n上面示例生成了一个 URL 实例，用来代表指定的网址。\n除了字符串，URL()的参数也可以是另一个 URL 实例。这时，URL()会自动读取该实例的href属性，作为实际参数。\n如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。\nvar url1 = new URL(&#039;index.html&#039;, &#039;example.com&#039;);\nurl1.href\n// &quot;example.com/index.html&quot;\n \nvar url2 = new URL(&#039;page2.html&#039;, &#039;example.com/page1.html&#039;);\nurl2.href\n// &quot;example.com/page2.html&quot;\n \nvar url3 = new URL(&#039;..&#039;, &#039;example.com/a/b.html&#039;)\nurl3.href\n// &quot;example.com/&quot;\n上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是..，表示上层路径。\n实例属性\nURL 实例的属性与Location对象的属性基本一致，返回当前 URL 的信息。\n\nURL.href：返回整个 URL\nURL.protocol：返回协议，以冒号:结尾\nURL.hostname：返回域名\nURL.host：返回域名与端口，包含:号，默认的80和443端口会省略\nURL.port：返回端口\nURL.origin：返回协议、域名和端口\nURL.pathname：返回路径，以斜杠/开头\nURL.search：返回查询字符串，以问号?开头\nURL.searchParams：返回一个==URLSearchParams实例==，该属性是Location对象没有的\nURL.hash：返回片段识别符，以井号#开头\nURL.password：返回域名前面的密码\nURL.username：返回域名前面的用户名\n\nvar url = new URL(&#039;http://user:passwd@www.example.com:4097/path/a.html#part1&#039;);\n \nurl.href\n// &quot;http://user:passwd@www.example.com:4097/path/a.html#part1&quot;\nurl.protocol\n// &quot;http:&quot;\nurl.hostname\n// &quot;www.example.com&quot;\nurl.host\n// &quot;www.example.com:4097&quot;\nurl.port\n// &quot;4097&quot;\nurl.origin\n// &quot;www.example.com:4097&quot;\nurl.pathname\n// &quot;/path/a.html&quot;\nurl.search\n// &quot;?x=111&quot;\nurl.searchParams\n// URLSearchParams {}\nurl.hash\n// &quot;#part1&quot;\nurl.password\n// &quot;passwd&quot;\nurl.username\n// &quot;user&quot;\n这些属性里面，只有origin属性是只读的，其他属性都可写，并且会立即生效。\nvar url = new URL(&#039;example.com/index.html#part1&#039;);\n \nurl.pathname = &#039;index2.html&#039;;\nurl.href // &quot;example.com/index2.html#part1&quot;\n \nurl.hash = &#039;#part2&#039;;\nurl.href // &quot;example.com/index2.html#part2&quot;\n上面代码中，改变 URL 实例的pathname属性和hash属性，都会实时反映在 URL 实例当中。\n静态方法\n（1）URL.createObjectURL()\nURL.createObjectURL()方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。\n// HTML 代码如下\n// &lt;div id=&quot;display&quot;/&gt;\n// &lt;input\n//   type=&quot;file&quot;\n//   id=&quot;fileElem&quot;\n//   multiple\n//   accept=&quot;image/*&quot;\n//   onchange=&quot;handleFiles(this.files)&quot;\n//  &gt;\nvar div = document.getElementById(&#039;display&#039;);\n \nfunction handleFiles(files) {\n  for (var i = 0; i &lt; files.length; i++) {\n    var img = document.createElement(&#039;img&#039;);\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n  }\n}\n上面代码中，URL.createObjectURL()方法用来为上传的文件生成一个 URL 字符串，作为&lt;img&gt;元素的图片来源。\n该方法生成的 URL 就像下面的样子。\nblob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1\n\n\n                  \n                  注意❗ \n                  \n                \n注意，每次使用 URL.createObjectURL() 方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用 URL.revokeObjectURL() 方法释放这个实例。\n\n（2）URL.revokeObjectURL()\nURL.revokeObjectURL()方法用来释放URL.createObjectURL()方法生成的 URL 实例。它的参数就是URL.createObjectURL()方法返回的 URL 字符串。\n下面为上一段的示例加上URL.revokeObjectURL()。\nvar div = document.getElementById(&#039;display&#039;);\n \nfunction handleFiles(files) {\n  for (var i = 0; i &lt; files.length; i++) {\n    var img = document.createElement(&#039;img&#039;);\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n    img.onload = function() {\n      window.URL.revokeObjectURL(this.src);\n    }\n  }\n}\n上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在img.onload回调函数里面，通过URL.revokeObjectURL()方法卸载这个 URL 实例。\nURLSearchParams 对象\n概述\nURLSearchParams对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。\n它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号?有没有都行，也可以是对应查询字符串的数组或对象。\n// 方法一：传入字符串\nvar params = new URLSearchParams(&#039;?foo=1&amp;bar=2&#039;);\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n \n// 方法二：传入数组\nvar params = new URLSearchParams([[&#039;foo&#039;, 1], [&#039;bar&#039;, 2]]);\n \n// 方法三：传入对象\nvar params = new URLSearchParams({&#039;foo&#039; : 1 , &#039;bar&#039; : 2});\nURLSearchParams会对查询字符串自动编码。\nvar params = new URLSearchParams({&#039;foo&#039;: &#039;你好&#039;});\nparams.toString() // &quot;foo=%E4%BD%A0%E5%A5%BD&quot;\n上面代码中，foo的值是汉字，URLSearchParams对其自动进行 URL 编码。\n浏览器向服务器发送表单数据时，可以直接使用URLSearchParams实例作为表单数据。\nconst params = new URLSearchParams({foo: 1, bar: 2});\nfetch(&#039;example.com/api&#039;, {\n  method: &#039;POST&#039;,\n  body: params\n}).then(...)\n上面代码中，fetch命令向服务器发送命令时，可以直接使用URLSearchParams实例。\nURLSearchParams可以与URL()接口结合使用。\nvar url = new URL(window.location);\nvar foo = url.searchParams.get(&#039;foo&#039;) || &#039;somedefault&#039;;\n上面代码中，URL 实例的searchParams属性就是一个URLSearchParams实例，所以可以使用URLSearchParams接口的get方法。\nURLSearchParams 实例有遍历器接口，可以用 for...of 循环遍历（详见《ES6 标准入门》的《Iterator》一章）。\nvar params = new URLSearchParams({&#039;foo&#039;: 1 , &#039;bar&#039;: 2});\n \nfor (var p of params) {\n  console.log(p[0] + &#039;: &#039; + p[1]);\n}\n// foo: 1\n// bar: 2\nURLSearchParams没有实例属性，只有实例方法。\nURLSearchParams.toString()\ntoString方法返回实例的字符串形式。\nvar url = new URL(&#039;example.com#039;);\nvar params = new URLSearchParams(url.search);\n \nparams.toString() // &quot;foo=1&amp;bar=2&#039;\n那么需要字符串的场合，会自动调用toString方法。\nvar params = new URLSearchParams({version: 2.0});\nwindow.location.href = location.pathname + &#039;?&#039; + params;\n上面代码中，location.href赋值时，可以直接使用params对象。这时就会自动调用toString方法。\nURLSearchParams.append()\nappend()方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。\nvar params = new URLSearchParams({&#039;foo&#039;: 1 , &#039;bar&#039;: 2});\nparams.append(&#039;baz&#039;, 3);\nparams.toString() // &quot;foo=1&amp;bar=2&amp;baz=3&quot;\nappend()方法不会识别是否键名已经存在。\nvar params = new URLSearchParams({&#039;foo&#039;: 1 , &#039;bar&#039;: 2});\nparams.append(&#039;foo&#039;, 3);\nparams.toString() // &quot;foo=1&amp;bar=2&amp;foo=3&quot;\n上面代码中，查询字符串里面foo已经存在了，但是append依然会追加一个同名键。\nURLSearchParams.delete()\ndelete()方法用来删除指定的查询参数。它接受键名作为参数。\nvar params = new URLSearchParams({&#039;foo&#039;: 1 , &#039;bar&#039;: 2});\nparams.delete(&#039;bar&#039;);\nparams.toString() // &quot;foo=1&quot;\nURLSearchParams.has()\nhas()方法返回一个布尔值，表示查询字符串是否包含指定的键名。\nvar params = new URLSearchParams({&#039;foo&#039;: 1 , &#039;bar&#039;: 2});\nparams.has(&#039;bar&#039;) // true\nparams.has(&#039;baz&#039;) // false\nURLSearchParams.set()\nset()方法用来设置查询字符串的键值。\n它接受两个参数，第一个是键名，第二个是键值。如果是已经存在的键，键值会被改写，否则会被追加。\nvar params = new URLSearchParams(&#039;?foo=1&#039;);\nparams.set(&#039;foo&#039;, 2);\nparams.toString() // &quot;foo=2&quot;\nparams.set(&#039;bar&#039;, 3);\nparams.toString() // &quot;foo=2&amp;bar=3&quot;\n上面代码中，foo是已经存在的键，bar是还不存在的键。\n如果有多个的同名键，set会移除现存所有的键。\nvar params = new URLSearchParams(&#039;?foo=1&amp;foo=2&#039;);\nparams.set(&#039;foo&#039;, 3);\nparams.toString() // &quot;foo=3&quot;\n下面是一个**替换当前 URL **的例子。\n// URL: example.com\nvar params = new URLSearchParams(location.search.slice(1));\nparams.set(&#039;version&#039;, &#039;2.0&#039;);\n \nwindow.history.replaceState({}, &#039;&#039;, location.pathname + `?` + params);\n// URL: example.com\nURLSearchParams.get()，URLSearchParams.getAll()\nget()方法用来读取查询字符串里面的指定键。它接受键名作为参数。\nvar params = new URLSearchParams(&#039;?foo=1&#039;);\nparams.get(&#039;foo&#039;) // &quot;1&quot;\nparams.get(&#039;bar&#039;) // null\n\n\n                  \n                  注意❗ \n                  \n                \n两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是 null。\n\n如果有多个的同名键，get返回位置最前面的那个键值。\nvar params = new URLSearchParams(&#039;?foo=3&amp;foo=2&amp;foo=1&#039;);\nparams.get(&#039;foo&#039;) // &quot;3&quot;\n上面代码中，查询字符串有三个foo键，get方法返回最前面的键值3。\ngetAll()方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。\nvar params = new URLSearchParams(&#039;?foo=1&amp;foo=2&#039;);\nparams.getAll(&#039;foo&#039;) // [&quot;1&quot;, &quot;2&quot;]\n上面代码中，查询字符串有两个foo键，getAll返回的数组就有两个成员。\nURLSearchParams.sort()\nsort()方法对查询字符串里面的键进行排序，规则是按照Unicode 码点从小到大排列。\n该方法没有返回值，或者说返回值是undefined。\nvar params = new URLSearchParams(&#039;c=4&amp;a=2&amp;b=3&amp;a=1&#039;);\nparams.sort();\nparams.toString() // &quot;a=2&amp;a=1&amp;b=3&amp;c=4&quot;\n上面代码中，如果有两个同名的键a，它们之间不会排序，而是保留原始的顺序。\nURLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()\n这三个方法都返回一个遍历器对象，供for...of循环遍历。它们的区别在于，keys方法返回的是键名的遍历器，values方法返回的是键值的遍历器，entries返回的是键值对的遍历器。\nvar params = new URLSearchParams(&#039;a=1&amp;b=2&#039;);\n \nfor(var p of params.keys()) {\n  console.log(p);\n}\n// a\n// b\n \nfor(var p of params.values()) {\n  console.log(p);\n}\n// 1\n// 2\n \nfor(var p of params.entries()) {\n  console.log(p);\n}\n// [&quot;a&quot;, &quot;1&quot;]\n// [&quot;b&quot;, &quot;2&quot;]\n如果直接对URLSearchParams进行遍历，其实内部调用的就是entries接口。\nfor (var p of params) {}\n// 等同于\nfor (var p of params.entries()) {}\n参考链接\n\nLocation, by MDN\nURL, by MDN\nURLSearchParams, by MDN\nEasy URL Manipulation with URLSearchParams, by Eric Bidelman\n"},"D-Unsorted/Python-学习资源":{"title":"Python 学习资源","links":["Web-Clip/@小学生都开始学-Python-了！"],"tags":["编程/Python","编程/学习资源"],"content":"\n30天 Python 教程\n Python 从入门到深入\nPython 知识手册-v4.1\n\n文章\n\n@小学生都开始学 Python 了！\n"},"D-Unsorted/async-函数":{"title":"async 函数","links":["D-Unsorted/多次重复尝试","D-Unsorted/同时触发","D-Unsorted/继发执行","D-Unsorted/自动执行器","D-Unsorted/按顺序完成异步操作"],"tags":["编程/ES6/async","编程/ES6/Generator"],"content":"含义\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n前文有一个 Generator 函数，依次读取两个文件。\nconst fs = require(&#039;fs&#039;);\n \nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n \nconst gen = function* () {\n  const f1 = yield readFile(&#039;/etc/fstab&#039;);\n  const f2 = yield readFile(&#039;/etc/shells&#039;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n上面代码的函数gen可以写成async函数，就是下面这样。\nconst asyncReadFile = async function () {\n  const f1 = await readFile(&#039;/etc/fstab&#039;);\n  const f2 = await readFile(&#039;/etc/shells&#039;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\nasync函数对 Generator 函数的改进，体现在以下四点。\n（1）内置执行器。\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而**async函数自带执行器**。也就是说，async函数的执行，与普通函数一模一样，只要一行。\nasyncReadFile();\n上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n（2）更好的语义。\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n（3）更广的适用性。\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n（4）返回值是 Promise。\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而**await命令就是内部then命令的语法糖**。\n基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n下面是一个例子。\nasync function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n \ngetStockPriceByName(&#039;goog&#039;).then(function (result) {\n  console.log(result);\n});\n上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。\n下面是另一个例子，指定多少毫秒后输出一个值。\nfunction timeout(ms) {\n  return new Promise((resolve) =&gt; {\n    setTimeout(resolve, ms);\n  });\n}\n \nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n \nasyncPrint(&#039;hello world&#039;, 50);\n上面代码指定 50 毫秒以后，输出hello world。\n由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。\nasync function timeout(ms) {\n  await new Promise((resolve) =&gt; {\n    setTimeout(resolve, ms);\n  });\n}\n \nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n \nasyncPrint(&#039;hello world&#039;, 50);\nasync 函数有多种使用形式。\n// 函数声明\nasync function foo() {}\n \n// 函数表达式\nconst foo = async function () {};\n \n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n \n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open(&#039;avatars&#039;);\n  }\n \n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n \nconst storage = new Storage();\nstorage.getAvatar(&#039;jake&#039;).then(…);\n \n// 箭头函数\nconst foo = async () =&gt; {};\n语法\nasync函数的语法规则总体上比较简单，难点是错误处理机制。\n返回 Promise 对象\nasync函数返回一个 Promise 对象。\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\nasync function f() {\n  return &#039;hello world&#039;;\n}\n \nf().then(v =&gt; console.log(v))\n// &quot;hello world&quot;\n上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\nasync 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。\nasync function f() {\n  throw new Error(&#039;出错了&#039;);\n}\n \nf().then(\n  v =&gt; console.log(&#039;resolve&#039;, v),\n  e =&gt; console.log(&#039;reject&#039;, e)\n)\n//reject Error: 出错了\nPromise 对象的状态变化\nasync函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n下面是一个例子。\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];\n}\ngetTitle(&#039;tc39.github.io/ecma262/&#039;).then(console.log)\n// &quot;ECMAScript 2017 Language Specification&quot;\n上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\nawait 命令\n正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\nasync function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n \nf().then(v =&gt; console.log(v))\n// 123\n上面代码中，await命令的参数是数值123，这时等同于return 123。\n另一种情况是，await命令后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。\nclass Sleep {\n  constructor(timeout) {\n    this.timeout = timeout;\n  }\n  then(resolve, reject) {\n    const startTime = Date.now();\n    setTimeout(\n      () =&gt; resolve(Date.now() - startTime),\n      this.timeout\n    );\n  }\n}\n \n(async () =&gt; {\n  const sleepTime = await new Sleep(1000);\n  console.log(sleepTime);\n})();\n// 1000\n上面代码中，await命令后面是一个Sleep对象的实例。这个实例不是 Promise 对象，但是因为定义了then方法，await会将其视为Promise处理。\n这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。下面给出了一个[[简化的sleep实现]]。\nfunction sleep(interval) {\n  return new Promise(resolve =&gt; {\n    setTimeout(resolve, interval);\n  })\n}\n \n// 用法\nasync function one2FiveInAsync() {\n  for(let i = 1; i &lt;= 5; i++) {\n    console.log(i);\n    await sleep(1000);\n  }\n}\n \none2FiveInAsync();\nawait命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\nasync function f() {\n  await Promise.reject(&#039;出错了&#039;);\n}\n \nf()\n.then(v =&gt; console.log(v))\n.catch(e =&gt; console.log(e))\n// 出错了\n\n\n                  \n                  注意❗ \n                  \n                \n注意，上面代码中，await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。这里如果在 await 前面加上 return，效果是一样的。\n\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。\nasync function f() {\n  await Promise.reject(&#039;出错了&#039;);\n  await Promise.resolve(&#039;hello world&#039;); // 不会执行\n}\n上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\nasync function f() {\n  try {\n    await Promise.reject(&#039;出错了&#039;);\n  } catch(e) {\n  }\n  return await Promise.resolve(&#039;hello world&#039;);\n}\n \nf()\n.then(v =&gt; console.log(v))\n// hello world\n另一种方法是 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。\nasync function f() {\n  await Promise.reject(&#039;出错了&#039;)\n    .catch(e =&gt; console.log(e));\n  return await Promise.resolve(&#039;hello world&#039;);\n}\n \nf()\n.then(v =&gt; console.log(v))\n// 出错了\n// hello world\n错误处理\n如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error(&#039;出错了&#039;);\n  });\n}\n \nf()\n.then(v =&gt; console.log(v))\n.catch(e =&gt; console.log(e))\n// Error：出错了\n上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n防止出错的方法，也是将其放在try...catch代码块之中。\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error(&#039;出错了&#039;);\n    });\n  } catch(e) {\n  }\n  return await(&#039;hello world&#039;);\n}\n如果有多个await 命令，可以统一放在 try...catch 结构中。\nasync function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n \n    console.log(&#039;Final: &#039;, val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n下面的例子使用try...catch结构，实现多次重复尝试。\nconst superagent = require(&#039;superagent&#039;);\nconst NUM_RETRIES = 3;\n \nasync function test() {\n  let i;\n  for (i = 0; i &lt; NUM_RETRIES; ++i) {\n    try {\n      await superagent.get(&#039;google.com/this-throws-an-error&#039;);\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n \ntest();\n上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。\n使用注意点\n第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n \n// 另一种写法\n \nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\nlet foo = await getFoo();\nlet bar = await getBar();\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n \n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n \n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n \n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n上面代码可能不会正常工作，原因是这时三个db.post()操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n \n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n另一种方法是使用数组的reduce()方法。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n \n  await docs.reduce(async (_, doc) =&gt; {\n    await _;\n    await db.post(doc);\n  }, undefined);\n}\n上面例子中，reduce()方法的第一个参数是async函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用await等待它操作结束。另外，reduce()方法返回的是docs数组最后一个成员的async函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上await。\n上面的reduce()的参数函数里面没有return语句，原因是这个函数的主要目的是db.post()操作，不是返回值。而且async函数不管有没有return语句，总是返回一个 Promise 对象，所以这里的return是不必要的。\n如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) =&gt; db.post(doc));\n \n  let results = await Promise.all(promises);\n  console.log(results);\n}\n \n// 或者使用下面的写法\n \nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) =&gt; db.post(doc));\n \n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n第四点，async 函数可以保留运行堆栈。\nconst a = () =&gt; {\n  b().then(() =&gt; c());\n};\n上面代码中，函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。\n现在将这个例子改成async函数。\nconst a = async () =&gt; {\n  await b();\n  c();\n};\n上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。\nasync 函数的实现原理\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\nasync function fn(args) {\n  // ...\n}\n \n// 等同于\n \nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n所有的async函数都可以写成上面的第二种形式，其中的**spawn函数就是自动执行器**。\n下面给出spawn函数的实现，基本就是前文**自动执行器**的翻版。\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n与其他异步处理方法的比较\n我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n首先是 Promise 的写法。\nfunction chainAnimationsPromise(elem, animations) {\n \n  // 变量ret用来保存上一个动画的返回值\n  let ret = null;\n \n  // 新建一个空的Promise\n  let p = Promise.resolve();\n \n  // 使用then方法，添加所有动画\n  for(let anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n \n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n \n}\n虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。\n接着是 Generator 函数的写法。\nfunction chainAnimationsGenerator(elem, animations) {\n \n  return spawn(function*() {\n    let ret = null;\n    try {\n      for(let anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n \n}\n上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。\n最后是 async 函数的写法。\nasync function chainAnimationsAsync(elem, animations) {\n  let ret = null;\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。\n实例：按顺序完成异步操作\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\nPromise 的写法如下。\nfunction logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url =&gt; {\n    return fetch(url).then(response =&gt; response.text());\n  });\n \n  // 按次序输出\n  textPromises.reduce((chain, textPromise) =&gt; {\n    return chain.then(() =&gt; textPromise)\n      .then(text =&gt; console.log(text));\n  }, Promise.resolve());\n}\n上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url =&gt; {\n    const response = await fetch(url);\n    return response.text();\n  });\n \n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。\n顶层 await\n早期的语法规定是，await命令只能出现在 async 函数内部，否则都会报错。\n// 报错\nconst data = await fetch(&#039;api.example.com&#039;);\n上面代码中，await命令独立使用，没有放在 async 函数里面，就会报错。\n从 ES2022 开始，允许在模块的顶层独立使用await命令，使得上面那行代码不会报错了。它的主要目的是使用await解决模块异步加载的问题。\n// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n}\nmain();\nexport { output };\n上面代码中，模块awaiting.js的输出值output，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量output才会有值，否则就返回undefined。\n下面是加载这个模块的写法。\n// usage.js\nimport { output } from &quot;./awaiting.js&quot;;\n \nfunction outputPlusValue(value) { return output + value }\n \nconsole.log(outputPlusValue(100));\nsetTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n上面代码中，outputPlusValue()的执行结果，完全取决于执行的时间。如果awaiting.js里面的异步操作没执行完，加载进来的output的值就是undefined。\n目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。\n// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n上面代码中，awaiting.js除了输出output，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。\n下面是加载这个模块的新的写法。\n// usage.js\nimport promise, { output } from &quot;./awaiting.js&quot;;\n \nfunction outputPlusValue(value) { return output + value }\n \npromise.then(() =&gt; {\n  console.log(outputPlusValue(100));\n  setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n});\n上面代码中，将awaiting.js对象的输出，放在promise.then()里面，这样就能保证异步操作完成以后，才去读取output。\n这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的usage.js又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。\n顶层的await命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。\n// awaiting.js\nconst dynamic = import(someMission);\nconst data = fetch(url);\nexport const output = someProcess((await dynamic).default, await data);\n上面代码中，两个异步操作在输出的时候，都加上了await命令。只有等到异步操作完成，这个模块才会输出值。\n加载这个模块的写法如下。\n// usage.js\nimport { output } from &quot;./awaiting.js&quot;;\nfunction outputPlusValue(value) { return output + value }\n \nconsole.log(outputPlusValue(100));\nsetTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。\n这时，模块的加载会等待依赖模块（上例是awaiting.js）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的output，不会因为加载时机的不同，而得到不一样的值。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，顶层 await 只能用在 ES 6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的 require() 是同步加载，如果有顶层 await，就没法处理加载了。\n\n下面是 [[顶层await的使用场景|顶层await]] 的一些使用场景。\n// import() 方法加载\nconst strings = await import(`/i18n/${navigator.language}`);\n \n// 数据库操作\nconst connection = await dbConnector();\n \n// 依赖回滚\nlet jQuery;\ntry {\n  jQuery = await import(&#039;cdn-a.com/jQuery&#039;);\n} catch {\n  jQuery = await import(&#039;cdn-b.com/jQuery&#039;);\n}\n\n\n                  \n                  注意❗ \n                  \n                \n注意，如果加载多个包含顶层 await 命令的模块，加载命令是同步执行的。\n\n// x.js\nconsole.log(&quot;X1&quot;);\nawait new Promise(r =&gt; setTimeout(r, 1000));\nconsole.log(&quot;X2&quot;);\n \n// y.js\nconsole.log(&quot;Y&quot;);\n \n// z.js\nimport &quot;./x.js&quot;;\nimport &quot;./y.js&quot;;\nconsole.log(&quot;Z&quot;);\n上面代码有三个模块，最后的z.js加载x.js和y.js，打印结果是X1、Y、X2、Z。这说明，z.js并没有等待x.js加载完成，再去加载y.js。\n顶层的await命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。"},"D-Unsorted/交换变量的值":{"title":"交换变量的值","links":[],"tags":["编程/JavaScript"],"content":"\n四则运算\n\nlet [a, b] = [1, 2];\n \na = a + b;\nb = a - b;\na = a - b;\n \nconsole.log(a, b); // 2 1\n \n// 注意：由于 IEEE 754 标准的存在，第一种方法并不是一定安全的，可能会出现精度问题。\n\n异或运算（最快的方式）\n\nlet [a, b] = [1, 2];\n \na = a ^ b;\nb = a ^ b;\na = a ^ b;\n \nconsole.log(a, b); // 2 1\n\n解构\n\nlet [a, b] = [1, 2];\n \n[a, b] = [b, a];\n \nconsole.log(a, b); // 2 1"},"D-Unsorted/取整方法":{"title":"取整方法","links":[],"tags":["编程/JavaScript/运算符"],"content":"~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n\n异或运算\n\n12.9 ^ 0 // 12\nfunction ToInteger(x) {\n  x = Number(x);\n  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);\n}\n \nToInteger(3.2) // 3\nToInteger(3.5) // 3\nToInteger(3.8) // 3\nToInteger(-3.2) // -3\nToInteger(-3.5) // -3\nToInteger(-3.8) // -3"},"D-Unsorted/如何用-Husky-和-Shell-脚本自动化代码检查":{"title":"如何用 Husky 和 Shell 脚本自动化代码检查","links":["D-Unsorted/Husky","C-Knowledge/前端/开发技术/Node/命令行脚本"],"tags":["编程/Git"],"content":"脚手架项目地址（github.com/xun082/create-neat）\nHusky是一个流行的工具，它可以让你轻松地在 Git 钩子中使用脚本，从而在提交（commit）代码前运行诸如代码风格检查、单元测试等任务。这有助于保持代码库的质量和一致性。Husky 的工作原理是在你的项目中创建特定的钩子，当你执行 git 操作（如 commit）时，这些钩子会被触发。\npre-commit 钩子和 commit-msg 钩子\npre-commit 钩子\npre-commit 钩子是 Git 钩子系统中的一个重要部分，用于在提交（commit）操作完成之前执行特定的脚本或任务。这个钩子的主要作用是允许开发者检查即将提交的代码快照（也就是 commit），以确保它符合项目的质量标准和风格指南。如果 pre-commit 钩子中的脚本返回非零状态（即执行失败），Git 将阻止提交。\npre-commit 钩子产用于以下场景：\n\n代码风格检查：运行如 ESLint 或 Prettier 这样的工具，确保代码风格一致性。\n代码质量分析：执行静态代码分析工具，发现潜在的错误或代码异味。\n运行单元测试：确保更改没有破坏现有功能。\n自动格式化代码：在提交前自动格式化代码，以满足代码风格要求。\n\ncommit-msg 钩子\ncommit-msg 钩子是 Git 的一个钩子，它在提交信息（commit message）被提交之前执行。这个钩子主要用于验证提交信息的格式，确保它遵循项目的规范或指南。如果 commit-msg 钩子脚本返回非零状态（即失败），Git 将拒绝提交。\ncommit-msg 钩子常用于以下场景：\n\n验证提交信息格式：确保提交信息遵循特定的模板或风格，例如包含一个特定前缀、遵循某种结构等。\n引用问题追踪器的 ID：要求提交信息包含对应的问题或故障单 ID，以便自动链接到问题追踪系统。\n强制包含更改类型：例如，要求提交信息明确标明是新增功能、修复 bug 还是性能改进等。\n检查提交信息的长度：确保提交信息不太长或不太短，便于阅读和理解。\n\ncommit-msg 文件详解\n接下来我们来看看我们项目中的代码，如下所示：\n#!/bin/sh  \n. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;  \n  \necho &#039;running commit-msg checks ...&#039;  \n  \n./scripts/check_commit_msg.sh &quot;$1&quot;\n这段代码是在 Husky 钩子脚本文件 .husky/commit-msg 的开头常见的一个脚本引导部分。它的作用是为了在执行 Husky 钩子时，设置和加载必要的环境。下面是对这段代码的详细解释：\n\n#!/bin/sh：这是一个 shebang 行，告诉系统这个脚本应该使用哪个解释器来执行。在这个例子中，它指定使用 sh（shell）作为解释器。这确保了脚本在 Unix-like 系统上的兼容性。\n. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;：$0 是当前脚本的路径。dirname 命令用于获取这个路径的目录部分，即去掉文件名，只留下路径。这意味着无论你从哪里运行这个 Husky 钩子，它都能找到正确的目录。/husky.sh 是 Husky 的环境脚本路径，相对于上一步得到的目录。Husky 使用这个脚本来设置一些环境变量和执行必要的初始化操作。\n\n简而言之，这段代码是 Husky 钩子的初始化和环境设置的重要部分，确保了 Husky 钩子的可移植性和正确执行。\n编写自己的 shell 脚本\n既然 commit-msg 是一个 shell 文件，那么我们也可以自定义自己的一些 shell 脚本，并添加到 commit-msg 中让其执行。\n\n\n                  \n                  提示💡 \n                  \n                \n为什么要自定义 shell 脚本？因为我要定义一个脚本，不仅可以在 husky 阶段使用，我也可以在 ci 阶段使用，提取公共配置将其提取到固定目录下统一管理。\n\n我们在和 husky 同级目录下创建一个文件，路径名为 scripts/check_commit_msg.sh 文件，并编写如下代码：\n#!/bin/sh  \n  \n# 获取两个参数：起始SHA和结束SHA  \nstart_sha=$1  \nend_sha=$2  \n  \n# 设置颜色变量  \nRED=&#039;\\033[0;31m&#039;  \nBLUE=&#039;\\033[0;34m&#039;  \nNC=&#039;\\033[0m&#039; # No Color  \n  \n# 定义提交信息规范函数  \ncheck_commit_message() {  \n    commit_msg=&quot;$1&quot;  \n    # 检查提交信息是否以指定的前缀开头  \n    if ! echo &quot;$commit_msg&quot; | grep -qE &quot;^(feat|fix|docs|style|refactor|test|chore|ci):&quot;; then  \n        echo -e &quot;${RED}Inappropriate commit message:&quot; &quot;${NC}$1&quot; &gt;&amp;2  \n        echo -e &quot;${RED}Error:${NC} Commit message format is incorrect. It should start with one of &#039;${BLUE}feat|fix|docs|style|refactor|test|chore|ci:${NC}&#039;.&quot; &gt;&amp;2  \n        exit 1  \n    fi  \n}  \n  \n# workflows传入两个参数，遍历从start_sha到end_sha的所有提交  \nif [ $# -eq 2 ]; then  \nfor sha in $(git rev-list $start_sha..$end_sha); do  \n    commit_msg=$(git show --format=%B -s $sha)  \n    check_commit_message &quot;$commit_msg&quot;  \ndone  \n# huksy触发commit-msg钩子时传入一个参数  \nelif [ $# -eq 1 ]; then  \n   check_commit_message &quot;$(cat $1) &quot;  \nelse  \n   echo -e &quot;${RED} error: Failed to get commit message\\n&quot;  \nfi  \n  \necho -e &quot;${BLUE}Commit message check passed.${NC}\\n&quot;\n在上面的这段代码中，它是一个用于校验 Git 提交信息是否符合规定格式的脚本。它可以在 commit-msg 钩子中，被用来确保提交信息遵循一定的命名规范，从而帮助维护项目的提交历史清晰和一致。\n该脚本它接收两个参数，起始 SHA (start_sha) 和结束 SHA (end_sha)。这两个参数用于指定要检查的提交范围。这对于在 CI/CD 流程中检查一系列提交非常有用，如下图所示：\n\n在函数内部主要使用 grep -qE 命令配合正则表达式来检查提交信息是否以 feat|fix|docs|style|refactor|test|chore|ci: 其中之一开头。这些前缀代表了不同类型的提交，例如新功能（feat）、修复（fix）等。\n如果脚本接收到两个参数，它会使用 git rev-list 命令遍历从 start_sha 到 end_sha 的所有提交，并对每个提交调用 check_commit_message 函数进行检查。\n如果只接收到一个参数（在 commit-msg 钩子场景中），脚本会读取该文件中的提交信息，并对其进行检查。\n如果脚本未能接收到期望的参数数量，它会打印一个错误消息。如果所有检查都通过，脚本会打印“Commit message check passed.”，表示提交信息符合规范。\n这个脚本主要用于确保项目提交遵循一定的格式规范，通过在 Git 钩子中使用这个脚本，团队可以自动化地维护代码仓库的质量和一致性，帮助开发者避免提交包含不规范信息的提交。\n要在 commit-msg 钩子中使用，我们只需要添加如下代码即可：\n./scripts/check_commit_msg.sh &quot;$1&quot;\n当你在 Git 提交操作中触发 commit-msg 钩子时，Git 会将即将提交的消息传递给这个钩子。在钩子中调用 ./scripts/check_commit_msg.sh “$1” 实际上是执行了 check_commit_msg.sh 脚本，并将包含提交信息的文件路径作为参数传递给它。check_commit_msg.sh 脚本会根据其内部逻辑来验证提交信息是否符合项目规定的格式。\n当我们输出了不合适的提交信息，它会报错，如下所示：\n\n通过这种方式可以告知用户输入规范的提交标题。\n总结\n封装一下公用的 shell 脚本到特定目录下，我们可以进行复用，不仅可以使用在 husky 中还可以使用在 ci 环境下，通过集成自定义 shell 脚本到 Shell 脚本到 Husky 的 Git 钩子中，为项目带来了以下几点显著的好处：\n\n自动化流程：自动执行代码检查、测试、格式化等操作，减少人工干预，提高开发效率。\n保证代码质量：在代码提交前强制执行质量控制步骤，确保提交到仓库的代码符合项目标准。\n统一开发标准：通过脚本统一代码提交规范（如提交信息格式），帮助维护项目的一致性和可维护性。\n减少错误：在代码进入仓库之前捕捉和修正问题，减少了后期调试和修复的工作量。\n\n总之，通过 Husky 加入自定义脚本，可以有效地集成和自动化开发流程中的关键步骤，对提升团队的工作效率、保持代码质量和项目的长期健康发展都至关重要。\n最后分享两个我的两个开源项目,它们分别是:\n\n前端脚手架 create-neat\n在线代码协同编辑器\n"},"D-Unsorted/怎么写技术简历":{"title":"怎么写技术简历","links":["D-Unsorted/前端求职面试","D-Unsorted/打造一份网页版简历"],"tags":["场景/职业"],"content":"如何写简历\n独立负责，从零到一, 封装组件库，数据，技术栈。\n技术简介\n技术特点；基础+框架+构建工具（工程化）+小程序（多端）+node处理 Cli koa+HTTP/Git/VSCode\n\n\n项目描述\n\n背景+技术方案+实现+难点+价值\n\n\n\n前端求职面试\n个人简历\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n刘关化​方迎春​罗先生​ 张新丁范翔宇​赵柯宇​Philip Rogers​胡成龙​卢伟​羡辙​赵越​ 何雨晴​ 方绪钰​其他曹慧琳宋楠\n在线简历\n简历主题\n\nHexo简历主题\nResume - Hexo 简历主题\n\n简历模版\n\n前端社招简历模板\n\n\n编辑工具\n\nMarkdown简历排版工具\n简历生成器\n用 JSON 来撰写简历\n老鱼简历\n\n参考链接\n\n程序员简历模板 （简约风）\n程序员简历点评第二期：能吃苦和能吃_哔哩哔哩_bilibili\n如何写一份有效的技术简历？ - 阮一峰的网络日志\n怎样写出杀手级的工程师简历 - OSCHINA - 中文开源技术交流社区\n打造一份网页版简历\n教你写出【直通面试】的程序员简历！学弟靠这招成功进大厂，编程学习必看\n"},"D-Unsorted/数组去重":{"title":"数组去重","links":["Web-Clip/@JS数组去重的方式详细总结（7种）---掘金"],"tags":["编程/JavaScript"],"content":"Set()+Array.from()\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n \ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n// 数组\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)]; // [3, 5, 2]\n \n// 字符串\nlet str = &quot;352255&quot;;\nlet unique = [...new Set(str)].join(&quot;&quot;); // &quot;352&quot;\n利用两层循环+数组的splice方法\n通过两层循环对数组元素进行逐一比较，然后通过splice方法来删除重复的元素。此方法对NaN是无法进行去重的，因为进行比较时NaN !== NaN。\nfunction removeDuplicate(arr) {\n  let len = arr.length\n  for (let i = 0; i &lt; len; i++) {\n    for (let j = i + 1; j &lt; len; j++) {\n      if (arr[i] === arr[j]) {\n        arr.splice(j, 1)\n        len-- // 减少循环次数提高性能\n        j-- // 保证j的值自加后不变\n      }\n    }\n  }\n  return arr\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined, NaN, NaN ]\n利用数组的indexOf方法\n新建一个空数组，遍历需要去重的数组，将数组元素存入新数组中，存放前判断数组中是否已经含有当前元素，没有则存入。此方法也无法对NaN去重。\nfunction removeDuplicate(arr) {\n  const newArr = []\n  arr.forEach(item =&gt; {\n    if (newArr.indexOf(item) === -1) {\n      newArr.push(item)\n    }\n  })\n  return newArr // 返回一个新数组\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined, NaN, NaN ]\n利用数组的includes方法\n此方法逻辑与indexOf方法去重异曲同工，只是用includes方法来判断是否包含重复元素。\nfunction removeDuplicate(arr) {\n  const newArr = []\n  arr.forEach(item =&gt; {\n    if (!newArr.includes(item)) {\n      newArr.push(item)\n    }\n  })\n  return newArr\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined, NaN ]\n\n\n                  \n                  注意❗ \n                  \n                \n为什么includes能够检测到数组中包含NaN，其涉及到includes底层的实现。如下图为includes实现的部分代码，在进行判断是否包含某元素时会调用sameValueZero方法进行比较，如果为NaN，则会使用isNaN()进行转化。\n\nfilter()+indexOf()\nfunction removeDuplicate(arr) {\n  return arr.filter((item, index) =&gt; {\n    return arr.indexOf(item) === index\n  })\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined ]\n利用Map()\nMap对象是JavaScript提供的一种数据结构，结构为键值对形式，将数组元素作为map的键存入，然后结合has()和set()方法判断键是否重复。\nfunction removeDuplicate(arr) {\n  const map = new Map()\n  const newArr = []\n \n  arr.forEach(item =&gt; {\n    if (!map.has(item)) { // has()用于判断map是否包为item的属性值\n      map.set(item, true) // 使用set()将item设置到map中，并设置其属性值为true\n      newArr.push(item)\n    }\n  })\n \n  return newArr\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined, NaN ]\n利用对象\n其实现思想和Map()是差不多的，主要是利用了对象的属性名不可重复这一特性。\nfunction removeDuplicate(arr) {\n  const newArr = []\n  const obj = {}\n \n  arr.forEach(item =&gt; {\n    if (!obj[item]) {\n      newArr.push(item)\n      obj[item] = true\n    }\n  })\n \n  return newArr\n}\n \nconst result = removeDuplicate(arr)\nconsole.log(result) // [ 1, 2, &#039;abc&#039;, true, false, undefined, NaN ]\n\n\n                  \n                  注意❗ \n                  \n                \n注意：使用Map()也可对NaN去重，原因是Map进行判断时认为NaN是与NaN相等的，剩下所有其它的值是根据 === 运算符的结果判断是否相等。\n\n扩展阅读\n\n@JS数组去重的方式详细总结（7种） - 掘金\n"},"D-Unsorted/读书笔记":{"title":"读书笔记","links":["C-Knowledge/读书笔记/《微习惯》-书评","C-Knowledge/读书笔记/《技术写作指南-张鑫旭》读后整理","C-Knowledge/读书笔记/《稀缺》","C-Knowledge/读书笔记/《一直爱下去：黄磊家庭相册》","C-Knowledge/读书笔记/《人生护城河》","C-Knowledge/读书笔记/《被讨厌的勇气》","C-Knowledge/读书笔记/《只管去做》","C-Knowledge/读书笔记/《黑客与画家》Paul-Graham·著-阮一峰·译","C-Knowledge/读书笔记/《爱情笔记》阿兰·德波顿","C-Knowledge/读书笔记/《什么样的爱值得勇敢一次》","C-Knowledge/读书笔记/《愿你的青春不负梦想》俞敏洪","C-Knowledge/读书笔记/《卡片笔记写作法》","C-Knowledge/读书笔记/《养育女儿》史蒂夫·比达尔夫","C-Knowledge/读书笔记/《第二大脑》","C-Knowledge/读书笔记/《摄影入门：人像摄影超级简单》","C-Knowledge/读书笔记/《人生元编程》","C-Knowledge/读书笔记/《鹿鼎记》张一山版","C-Knowledge/读书笔记/《人生之路》有感","C-Knowledge/读书笔记/《简读中国史》","C-Knowledge/读书笔记/《Don't-Wait》","C-Knowledge/读书笔记/《牛奶可乐经济学》罗布特•弗兰克","C-Knowledge/读书笔记/《优秀到无法忽略》（《So-Good-They-Can't-Ignore-You》）卡尔·纽波特","C-Knowledge/读书笔记/《我会采更多的雏菊》","C-Knowledge/读书笔记/《爱你就像爱生命》","C-Knowledge/读书笔记/《爱情之秘》-(Love's-Secret)","C-Knowledge/读书笔记/《我想和你虚度时光》","C-Knowledge/读书笔记/《漫长的》","C-Knowledge/读书笔记/《爱》","C-Knowledge/读书笔记/《活过，爱过，写过》-李银河"],"tags":["场景/阅读"],"content":"\n《微习惯》-书评.md\n《技术写作指南-张鑫旭》读后整理.md\n《稀缺》.md\n《一直爱下去：黄磊家庭相册》.md\n《人生护城河》.md\n《被讨厌的勇气》.md\n《只管去做》.md\n《黑客与画家》Paul Graham·著 阮一峰·译.md\n《爱情笔记》阿兰·德波顿.md\n《什么样的爱值得勇敢一次》.md\n《愿你的青春不负梦想》俞敏洪.md\n《卡片笔记写作法》.md\n《养育女儿》史蒂夫·比达尔夫.md\n《第二大脑》.md\n《摄影入门：人像摄影超级简单》.md\n《人生元编程》.md\n《鹿鼎记》张一山版.md\n《人生之路》有感.md\n《简读中国史》.md\n《Don’t Wait》.md\n《牛奶可乐经济学》罗布特•弗兰克.md\n《优秀到无法忽略》（《So Good They Can’t Ignore You》）卡尔·纽波特.md\n《我会采更多的雏菊》.md\n《爱你就像爱生命》.md\n《爱情之秘》 (Love’s Secret).md\n《我想和你虚度时光》.md\n《漫长的》.md\n《爱》.md\n《活过，爱过，写过》-李银河.md\n[[C Knowledge/读书笔记/《事实》[瑞典] 汉斯·罗斯林 _ [瑞典] 欧拉·罗斯林 _ [瑞典] 安娜·罗斯林·罗朗德. md]]\n\n电视剧\n\n《人生之路》有感\n《鹿鼎记》张一山版\n\n历史\n\n《简读中国史》\n\n传记\n\n《一直爱下去：黄磊家庭相册》\n《活过，爱过，写过》-李银河\n\n爱情\n\n《什么样的爱值得勇敢一次》\n《爱情笔记》阿兰·德波顿\n\n诗\n\n《爱》\n《漫长的》\n《我想和你虚度时光》\n《爱情之秘》 (Love’s Secret)\n《爱你就像爱生命》\n《我会采更多的雏菊》\n《Don’t Wait》\n"},"E-Day-planner/2024/三月/如何封装一个超级好用的-Hook-！":{"title":"如何封装一个超级好用的 Hook ！","links":[],"tags":["编程/FE/Vue"],"content":"本文将通过介绍什么是 Hook、如何在 Vue 使用 Hook，以及在实践场景中如何封装自己的 Vue Hook，带你走进 Hook 的世界，写出更优雅的代码。如果你觉得这篇文章写的不错，可以点赞支持一下，如果文章中存在不足（代码量多，难免出现 bug，咳咳），欢迎在评论区指出！\n什么是 Hook\nVue3 官方文档是这样定义组合式函数的。A &quot;composable&quot; is a function that leverages Vue&#039;s Composition API to encapsulate and reuse stateful logic.，一个利用 Vue 的组合式 API 来封装和复用具有状态逻辑的函数。\n这个概念借鉴自 React 的 Hook。在 16.8 的版本中，React 引入了 React Hook。这是一项特别强大的技术，通过封装有状态的函数，极大提高了组件的编写效率和维护性。在下文中也是使用 Hook 来替代“组合式函数”进行叙述。\n在开发中，我们经常会发现一些可以重复利用的代码段，于是我们将其封装成函数以供调用。这类函数包括工具函数，但是又不止工具函数，因为我们可能也会封装一些重复的业务逻辑。以往，在前端原生开发中，我们封装的这些函数都是“无状态”的。为了建立数据与视图之间的联系，基于 MVC 架构的 React 框架和基于 MVVM 的 Vue 框架都引入了“状态”这一概念，状态是特殊的 JavaScript 变量，它的变化会引起视图的变化。在这类框架中，如果一个变量的变化不会引起视图的变化，那么它就是普通变量，如果一个变量已经被框架注册为状态，那么这个变量的变化就会引发视图的变化，我们称之为响应式变量。如果一个函数包含了状态（响应式变量），那么它就是一个 Hook 函数。\n在具备“状态”的框架的基础上，才有 Hook 这一说。Hook 函数与普通函数的本质区别在于是否具备“状态”。\n比如，在一个 Vue 项目中，我们可能同时引入了 lodash 库和 VueUse 库，这两个库都是提供一些方便的工具函数。工具函数库只引入一个不行吗，不会重复吗？或许不行，因为 lodash 的函数是无状态的，用来处理普通变量或者响应式变量中的数据部分，而 VueUse 提供的 api 都是 Hook。如果你的项目中既有普通变量又有响应式变量，你或许就会在同一个项目中同时接触到这两个库。\nReact 官方为我们提供了一些非常方便的 Hook 函数，比如 useState、useEffect（我们通常使用 use 作为前缀来标识 Hook 函数），但是这远远不够，或者说，它们足够通用但是不够具体。为了在具体业务下复用某些逻辑，我们往往会封装自己的 Hook，即自定义 Hook。为什么这里会反复提到 React 中呢？因为提到 Hook，就不可能避开 React。Hook 是 React 发扬光大的，使用 Hook 已经是 React 社区的主流。然而，只要框架具备“状态”这一概念，都可以使用 Hook 技术！下面文章将会介绍如何将 Hook 应用到 Vue 当中。\n在 Vue 中使用Hook\n下面我们来看一个简单的自定义 Hook（来自 Vue 官方文档）：\n需求：在页面实时显示鼠标的坐标。实现：没有使用 Hook。\n&lt;script setup&gt;  \nimport { ref, onMounted, onUnmounted } from &#039;vue&#039;  \n  \nconst x = ref(0)  \nconst y = ref(0)  \n  \nfunction update(event) {  \n  x.value = event.pageX  \n  y.value = event.pageY  \n}  \n  \nonMounted(() =&gt; window.addEventListener(&#039;mousemove&#039;, update))  \nonUnmounted(() =&gt; window.removeEventListener(&#039;mousemove&#039;, update))  \n&lt;/script&gt;  \n  \n&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;\n在没有封装的情况下，如果我们在另一个页面也需要这个功能，我们需要将代码复制过去。另外，可以看出，它声明了两个变量，并且在生命周期钩子 onMounted 和 onUnmounted 中书写了一些代码，如果这个页面需要更多的功能，那么会出现代码中存在很多变量、生命周期中存在很多逻辑写在一起的现象，使得这些逻辑混杂在一起，而使用 Hook 可以将其分隔开来（这也是为什么会有很多人使用 Hook 的原因，分离代码，提高可维护性！）\n使用 Hook：\n&lt;script setup&gt;  \nimport { useMouse } from &#039;./mouse.js&#039;  \n  \nconst { x, y } = useMouse()  \n&lt;/script&gt;  \n  \n&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;\n可以发现，比原来的代码更加简洁，这时如果加入其它功能的变量，也不会觉得眼花缭乱了。\n当然，我们需要在外部定义这个 Hook：\n// mouse.js  \nimport { ref, onMounted, onUnmounted } from &#039;vue&#039;  \n  \n// 按照惯例，组合式函数名以“use”开头  \nexport function useMouse() {  \n  // 被组合式函数封装和管理的状态  \n  const x = ref(0)  \n  const y = ref(0)  \n  \n  // 组合式函数可以随时更改其状态。  \n  function update(event) {  \n    x.value = event.pageX  \n    y.value = event.pageY  \n  }  \n  \n  // 一个组合式函数也可以挂靠在所属组件的生命周期上  \n  // 来启动和卸载副作用  \n  onMounted(() =&gt; window.addEventListener(&#039;mousemove&#039;, update))  \n  onUnmounted(() =&gt; window.removeEventListener(&#039;mousemove&#039;, update))  \n  \n  // 通过返回值暴露所管理的状态  \n  return { x, y }  \n}\n或许，你可以试着去 VueUse 库找到别人封装好的 useMouse！\nimport { useMouse } from &#039;VueUse&#039;\n恭喜你，掌握了 VueUse 库的使用方法。如果需要其它 Hook，你可以先试着去官方文档VueUse | VueUse(vueuse.org/)查找，使用现成的函数，而不是自己去封装。\n封装一（入门级的表格 Hook）\n在前面，我们介绍完了 Hook 的概念，完成了一个简单的自定义 Hook，还学会了使用社区提供的大量现成的 Hook 函数（VueUse 库），接下来，我们将结合实际业务，完成我们自己的 Hook 函数！\n场景分析\n首先定义一个表格：\n&lt;template&gt;  \n\t&lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;  \n\t&lt;el-table-column prop=&quot;date&quot; label=&quot;Date&quot; width=&quot;180&quot; /&gt;  \n\t&lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot; /&gt;  \n\t&lt;el-table-column prop=&quot;address&quot; label=&quot;Address&quot; /&gt;  \n\t&lt;/el-table&gt;  \n\t&lt;button @click=&quot;refresh&quot;&gt;refresh&lt;/button&gt;  \n&lt;/template&gt;\n表格的数据通过 api 获取（一般写法）：\n&lt;script lang=&quot;ts&quot; setup&gt;  \n\timport { onMounted, ref } from &quot;vue&quot;;  \n\timport { getTableDataApi } from &quot;./api.ts&quot;;  \n\t  \n\tconst tableData = ref([]);  \n\tconst refresh=async () =&gt; {  \n\tconst data = await getTableDataApi();  \n\ttableData.value = data;  \n\t}  \n\t  \n\tonMounted(refresh);  \n&lt;/script&gt;\n模拟 api：\n// api.ts  \nexport const getTableDataApi = () =&gt; {  \n  const data = [  \n    {  \n      date: &#039;2016-05-03&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-02&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-04&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-01&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n  ]  \n  return new Promise(resolve =&gt; {  \n    setTimeout(() =&gt; {  \n      resolve(data)  \n    }, 100);  \n  })  \n}\n如果存在多个表格，我们的 js 代码会变得比较复杂：\n&lt;script lang=&quot;ts&quot; setup&gt;  \n\timport { onMounted, ref } from &quot;vue&quot;;  \n\timport { getTableDataApi1, getTableDataApi2, getTableDataApi3 } from &quot;./api.ts&quot;;  \n\t  \n\tconst tableData1 = ref([]);  \n\tconst refresh1=async () =&gt; {  \n\t\tconst data = await getTableDataApi1();  \n\t\ttableData1.value = data;  \n\t}  \n\t  \n\tconst tableData2 = ref([]);  \n\tconst refresh2=async () =&gt; {  \n\t\tconst data = await getTableDataApi2();  \n\t\ttableData2.value = data;  \n\t}  \n\t  \n\tconst tableData3 = ref([]);  \n\tconst refresh3=async () =&gt; {  \n\t\tconst data = await getTableDataApi3();  \n\t\ttableData3.value = data;  \n\t}  \n\t  \n\tonMounted(refresh1);  \n&lt;/script&gt;\n封装实例\n封装我们的 useTable：\n// useTable.ts  \nimport { ref } from &#039;vue&#039;  \nexport function useTable(api) {  \n  const data = ref([])  \n  const refresh = () =&gt; { api().then(res =&gt; data.value = res) };  \n  refresh()  \n  return [data, refresh]  \n}\n改造代码：\n&lt;script lang=&quot;ts&quot; setup&gt;  \nimport { onMounted, ref } from &quot;vue&quot;;  \nimport { getTableDataApi1, getTableDataApi2, getTableDataApi3 } from &quot;./api.ts&quot;;  \nimport { useTable } from &#039;./useTable.ts&#039;  \n  \nconst [tableData1, refresh1] = useTable(getTableDataApi1);  \nconst [tableData2, refresh2] = useTable(getTableDataApi2);  \nconst [tableData3, refresh3] = useTable(getTableDataApi3);  \n  \nonMounted(refresh1);  \n&lt;/script&gt;\n封装技巧 - Hook 返回值\n\n一般自定义 Hook 有返回数组的，也有返回对象的，上面 useTable 使用了返回数组的写法，useMouse 使用了返回对象的写法。数组是对应位置命名的，可以方便重命名，对象对于类型和语法提示更加友好。两种写法都是可以替换的。\n因为 Hook 返回对象或者数组，那么它一定是一个非 async 函数（async 函数一定返回 Promise），所以在 Hook 中，一般使用 then 而不是 await 来处理异步请求。\n返回值如果是对象，一般在函数中通过 reactive 创建一个对象，最后通过 toRefs 导出，这样做的原因是可以产生批量的可以解构的 Ref 对象，以免在解构返回值时丢失响应性。\n\n// 使用 reactive 和 toRefs 可以快速创建多个ref对象，并在解构后使用时不丢失其响应性和与原先数据的关联性  \nfunction usePaginaion(){  \n const pagination = reactive({  \n  current: 1,  \n  total: 0,  \n  sizeOption,  \n  size: sizeOption[0]  \n })  \n ...  \n return {...toRefs(pagination)}  \n}  \n  \nconst { current,total } = usePagination()\n封装二（支持分页查询）\n需求分析\n上面我们封装了一个简单的 hook，但是实际应用中并不会如此简单，下面我列出一个比较完整的 useTable 在实践中应该具备的功能，并在后续的文章部分完成它。\n封装表格组件逻辑：\n\n维护 api 的调用和刷新（已完成）\n支持分页查询（页数、总条数、每页大小等）\n支持 api 参数。\n增加辅助功能（loading、立即执行等）\n\n下面我们将对 useTable 进行改造，使其支持分页器。\n先改造一些我们的 api，使其支持分页查询：\nexport const getTableDataApi = (page, limit) =&gt; {  \n  const data = [  \n    {  \n      date: &#039;2016-05-03&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-02&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-04&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2016-05-01&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2017-05-03&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2017-05-02&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2017-05-04&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n    {  \n      date: &#039;2017-05-01&#039;,  \n      name: &#039;Tom&#039;,  \n      address: &#039;No. 189, Grove St, Los Angeles&#039;,  \n    },  \n  ]  \n  return new Promise(resolve =&gt; {  \n    setTimeout(() =&gt; {  \n      resolve({  \n        total: data.length,  \n        data: data.slice((page - 1) * limit, (page - 1) * limit + limit)  \n      })  \n    }, 100);  \n  })  \n}\n如果没有使用 Hook，我们的 vue 文件应该是这样的：\n&lt;template&gt;  \n&lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;  \n&lt;el-table-column prop=&quot;date&quot; label=&quot;Date&quot; width=&quot;180&quot; /&gt;  \n&lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot; /&gt;  \n&lt;el-table-column prop=&quot;address&quot; label=&quot;Address&quot; /&gt;  \n&lt;/el-table&gt;  \n&lt;button @click=&quot;refresh&quot;&gt;refresh&lt;/button&gt;  \n&lt;!-- 分页器 --&gt;  \n&lt;el-pagination  \nv-model:current-page=&quot;current&quot;  \n:page-size=&quot;size&quot;  \nlayout=&quot;total, prev, pager, next&quot;  \n:page-sizes=&quot;sizeOption&quot;  \n:total=&quot;total&quot;  \n@size-change=&quot;handleSizeChange&quot;  \n@current-change=&quot;handleCurrentChange&quot;  \n/&gt;  \n&lt;/template&gt;  \n  \n&lt;script lang=&quot;ts&quot; setup&gt;  \nimport { onMounted, ref } from &quot;vue&quot;;  \nimport { getTableDataApi } from &quot;./api.ts&quot;;  \n  \nconst tableData = ref([]); // 表格数据  \nconst current = ref(1); // 当前页数  \nconst sizeOption = [10, 20, 50, 100, 200]; // 每页大小选项  \nconst size = ref(sizeOption[0]); //每页大小  \nconst total = ref(0); // 总条数  \n  \n// 每页大小变化  \nconst handleSizeChange = (size: number) =&gt; {  \n\tsize.value = size;  \n\tcurrent.value = 1;  \n\t// total.value = 0;  \n\trefresh();  \n};  \n  \n// 页数变化  \nconst handleCurrentChange = (page: number) =&gt; {  \n\tcurrent.value = page;  \n\t// total.value = 0;  \n\trefresh();  \n};  \n  \nconst refresh = async () =&gt; {  \nconst result = await getTableDataApi({  \n\tpage: current.value,  \n\tlimit: size.value,  \n});  \ntableData.value = result.data || [];  \ntotal.value = result.total || 0;  \n};  \n  \nonMounted(refresh);  \n&lt;/script&gt;\n可以看出，如果存在多个表格，会创建很多套变量和重复的代码。\n封装实例\n先写个 usePagination：该钩子接受一个回调函数，当页数改变时就会调用该函数。\nimport { reactive } from &quot;vue&quot;;  \nexport function usePagination(  cb: any,  \n  sizeOption: Array&lt;number&gt; = [10, 20, 50, 100, 200]): any {  \n  const pagination = reactive({  \n    current: 1,  \n    total: 0,  \n    sizeOption,  \n    size: sizeOption[0],  \n    // 维护page和size（一般是主动触发）  \n    onPageChange: (page: number) =&gt; {  \n      pagination.current = page;  \n      return cb();  \n    },  \n    onSizeChange: (size: number) =&gt; {  \n      pagination.current = 1;  \n      pagination.size = size;  \n      return cb();  \n    },  \n    // 一般调用cb后会还会修改total（一般是被动触发）  \n    setTotal: (total: number) =&gt; {  \n      pagination.total = total;  \n    },  \n    reset() {  \n      pagination.current = 1;  \n      pagination.total = 0;  \n      pagination.size = pagination.sizeOption[0];  \n    },  \n  });  \n  \n  return [  \n    pagination,  \n    pagination.onPageChange,  \n    pagination.onSizeChange,  \n    pagination.setTotal,  \n  ];  \n}\n与 useTable 结合：代码非常简单，在调用 api 时传入参数，并在接受返回值时更新 data 和 total。这里我们的 refresh 函数是一个返回 Promise 的函数，能够支持在调用 refresh 处再链接 then 进行下一层处理。\nexport function useTable(api: (params: any) =&gt; Promise&lt;T&gt;) {  \n  const [pagination, , , setTotal] = usePagination(() =&gt; refresh());  \n  const data = ref([]);  \n  \n  const refresh = () =&gt; {  \n    return api({ page: pagination.current, limit: pagination.size }).then(  \n      (res) =&gt; {  \n        data.value = res.data;  \n        setTotal(res.total);  \n      }  \n    );  \n  };  \n  return [data, refresh, pagination];  \n}\n注：我们新建一个文件 customHooks.js 并将 usePagination 和 useTable 放在里面。\n使用 useTable：\n&lt;template&gt;  \n&lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;  \n&lt;el-table-column prop=&quot;date&quot; label=&quot;Date&quot; width=&quot;180&quot; /&gt;  \n&lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot; /&gt;  \n&lt;el-table-column prop=&quot;address&quot; label=&quot;Address&quot; /&gt;  \n&lt;/el-table&gt;  \n&lt;button @click=&quot;refresh&quot;&gt;refresh&lt;/button&gt;  \n&lt;!-- 分页器 --&gt;  \n&lt;el-pagination  \nv-model:current-page=&quot;pagination.current&quot;  \n:page-size=&quot;pagination.size&quot;  \nlayout=&quot;total, prev, pager, next&quot;  \n:page-sizes=&quot;pagination.sizeOption&quot;  \n:total=&quot;pagination.total&quot;  \n@size-change=&quot;pagination.onSizeChange&quot;  \n@current-change=&quot;pagination.onCurrentChange&quot;  \n/&gt;  \n&lt;/template&gt;  \n  \n&lt;script lang=&quot;ts&quot; setup&gt;  \nimport { onMounted, ref } from &quot;vue&quot;;  \nimport { getTableDataApi } from &quot;./api.ts&quot;;  \nimport { useTable } from &#039;./customHooks.ts&#039;  \n  \nconst [tableData, refresh, pagination] = useTable(getTableDataApi);  \n  \nonMounted(refresh);  \n&lt;/script&gt;\n封装三（支持不同接口字段）\n封装分析\n上面我们封装了一个“看起来”比较使用的 useTable 函数，但实际上，你会发现很多问题：\n\n\n每次都要写 onMounted 来初始化数据。\n\n\n接口接受的格式可能不一样，比如，页数的字段为”currentPage”，而不是“page”。\n\n\n接口返回的格式可能不一样，比如，返回的 data 并不在 refresh 方法定义的“data”上。\n\n\n封装实例\n接下来，我们通过增加 useTable 函数的参数，来解决上面所有问题！\nimport { get, has, defaults } from &quot;lodash-es&quot;;  \ntype keyPath = Array&lt;string&gt; | string;  \nexport function useTable&lt;T&gt;(  \n  api: (params: any) =&gt; Promise&lt;T&gt;,  \n  options?: {  \n    path?: { data?: keyPath; total?: keyPath; page?: string; size?: string };  \n    immediate?: boolean;  \n  }  \n) {  \n  // 参数处理  \n  defaults(options, {  \n    path: { data: &quot;data&quot;, total: &quot;total&quot;, page: &quot;page&quot;, size: &quot;size&quot; },  \n    immediate: false,  \n  });  \n  \n  const [pagination, , , setTotal] = () =&gt; refresh();  \n  const data = ref([]);  \n  const loading = ref(false)  \n  \n  const refresh = () =&gt; {  \n loading.value = true  \n    return api({ [options?.path?.page]: pagination.current, [options?.path?.size]: pagination.size }).then(  \n      (res) =&gt; {  \n        data.value = get(res, options!.path?.data, []);  \n        setTotal(get(res, options!.path?.total, 0));  \n        // 友好提示  \n        if (!has(res, options!.path?.data) || !has(res, options!.path?.total)) {  \n          console.warn(&quot;useTable：响应数据缺少所需字段&quot;);  \n        }  \n      }.finally(() =&gt; {  \n        loading.value = false  \n      })  \n    );  \n  };  \n // 立即执行  \n  options!.immediate &amp;&amp; refresh();  \n  return [data, refresh, loading, pagination];  \n}\n这里引入了 lodash 库中的三个工具函数来辅助处理对象：\n\ndefaults，将后面参数的属性，赋值到第一个对象的值为 undefined 的属性上，用于初始化函数参数。\nget，获取对象属性，如果为 undefined，使用第三个参数的值。\nhas，判断对象属性。\n\n具体用法可以查看官方文档Lodash中文网(www.lodashjs.com/) 此外，还新增了 loading，可以挂载到 el-table 的 v-loading 上，展示数据加载中的效果。\n&lt;el-table v-loding=&quot;loading&quot; ...&gt;...&lt;/el-table&gt;\n改造后：不管接口接受的格式还是响应的格式字段是什么样的，都可以正常接收。设置 immediate 为 true，调用 useTable 时立即执行一遍 api，onMounted 都不用写了。\n&lt;script lang=&quot;ts&quot; setup&gt;  \nimport { onMounted, ref } from &quot;vue&quot;;  \nimport { getTableDataApi } from &quot;./api.ts&quot;;  \nimport { useTable } from &#039;./customHooks.ts&#039;  \n  \nconst [tableData, refresh, loading, pagination] = useTable(getTableDataApi, {  \n  path: {  \n    data: &#039;data&#039;,  \n    total: &#039;total&#039;,  \n    page: &#039;page&#039;,  \n    size: &#039;limit&#039;  \n  },  \n  immediate: true  \n});  \n  \n// onMounted(refresh);  \n&lt;/script&gt;\nJavaScript 函数传参技巧\n\n一般函数定义参数越少越好，最好不要超过两个，所以这里我只定义了两个参数 api 和options。\n在函数头上可以给参数定义默认值，但是如果参数是一个对象，只要传入一个属性，就不会使用默认值，比如：\n\nexport function useTable&lt;T&gt;(  api: (params: any) =&gt; Promise&lt;T&gt;,  \n  options: {  \n    path?: { data?: keyPath; total?: keyPath; page?: string; size?: string };  \n    immediate?: boolean;  \n  } = {  \n    path: { data: &quot;data&quot;, total: &quot;total&quot;, page: &quot;page&quot;, size: &quot;size&quot; },  \n    immediate: false,  \n  }  \n){...函数体}   \n  \nuseTable(xxxApi,{immediate:false})\n只要该位置的值非 undefined，那么 options 将不会使用默认值，这意味着，此时 options 的值为 {immediate:false}，其它地方的默认值不会生效，{path:undefined,}。所以对于函数参数为对象的，我们往往通过在函数体内赋默认值，比如：\n// 保证options只传入一个值，其它位置也会有默认值  \n{  \n  options.path = options.path || {}  \n  options.path.data = options.path.data || &#039;data&#039;  \n  options.path.total = options.path.total || &#039;total&#039;  \n  options.path.page = options.path.page || &#039;page&#039;  \n  options.path.size = options.path.size || &#039;size&#039;  \n  options.immediate = options.immediate ?? false  \n}\n需要注意元素的层次，在不存在 path 时，给 path. data 赋值会出现错误，需要先保证 path 有值，才能给 path 的下一层赋值。\n使用 defaults 可以快速给整个对象赋默认值：\n  defaults(options, {  \n    path: { data: &quot;data&quot;, total: &quot;total&quot;, page: &quot;page&quot;, size: &quot;size&quot; },  \n    immediate: false,  \n  });\n封装四（接口传参-定义时）\n封装分析\n现在，我们的 useTable 趋近完整了：\n\n维护 api 的调用和刷新（已完成）\n支持分页查询（已完成）\n支持 api 参数。\n增加辅助功能 loading、立即执行等。（已完成）\n\n我们还可以让我们的 api 接受参数。但是如何实现？还需要考虑一下。\n首先我们想一想那里可以接受 api 的参数？\nconst params = {  \n id:2  \n}  \n  \n// api本身  \ngetTableDataApi({limit:3,page:2,...params})  \n  \n// useTable也可以接受参数  \nconst [data,refresh]=useTable(getTableDataApi,params,api)  \n  \n// refresh也可以接受参数  \nrefresh(params)\n从使用上看，我们在 refresh 上接受参数，和我们在 getTableDataApi 的使用上感觉是最相似的，因为 refresh 本来就是在 api 的基础上增加 then 维护了页数而已。但是我们还是先从 useTable 传参开始讲起，最后我们两种方式都可以接受！\n方案一：在调用 useTable 的时候就接受参数，在 useTable 内部将这个参数传给 refresh。存在问题：如果我们传入的是值类型，那么这个值会被拷贝过去，并传给 refresh，后续调用 refresh，都是不变的参数。只适合需要传参但参数之后都不会变的接口，比如接受当前用户的 id。如果参数会变，这种方法是不行的。\nfunction useTable(api,id,options){  \n ...  \n const refresh=()=&gt;api(id).then(res=&gt;data=res)  \n return [data,refresh]  \n}  \n  \nconst [data,refresh]=useTable(api,id)  \nrefresh()  \nrefresh() // 都是id=2\n如果我们传入的是引用类型，那么在后续调用中，我们可以通过改变对象的属性值来改变 refresh 的参数（但是需要一些技巧，因为我们需要和分页参数进行结合）。\nconst params = { id:12 }  \nfunction useTable(api,params,options){  \n ...  \n // 错误，使用解构会丢失与原来对象的联系，导致原来的对象params更改，但这里仍使用旧值。  \n const refresh=()=&gt;api({[options.path.size]:pagination.size,[options.path.page]:pagination.page,...params}).then(res=&gt;data=res)  \n // 正确，可以保持与外部params的联系。  \n const refresh=()=&gt;api(Object.assign(params,{[options.path.size]:pagination.size,[options.path.page]:pagination.page})).then(res=&gt;data=res)  \n return [data,refresh]  \n}  \n  \nconst [data,refresh]=useTable(api,params)  \nrefresh() // id=12  \nparams.id = 10  \nrefresh() // id=10\n这样，我们就实现了 api 参数的传递，而且如果 params 的属性 id 是响应式的，还可以与页面结合，实现搜索功能！然而，使用同一个引用 params，可以解决传参问题，但是还是存在一些问题：在 refresh 中，Object. assign 会给原来的对象 params 增加两个属性，要注意避免在 params 中与这两个属性发生冲突。另外，我们可以看到这里的参数间存在了一种优先级，就是如果我们在 param 中也传入了分页参数，会在 refresh 中被 pagination 的分页参数覆盖调，pagination 的分页参数比 params 中的分页参数优先级更高，这样好吗？\n第一个问题，在 refresh 中每次都会被 pagination 的属性覆盖，所以并不会出现什么问题，除非你在 params 上保存相同属性名的数据，这将被覆盖掉。第二个问题和第一个问题本质是一样的，就是覆盖问题。根本原因就是都是引用同一个对象。如果我们能够额外创建一个对象，就不会改变原来的对象，但是如何保持新创建对象能够动态变化呢？\n方案二：试试 useTable 接受传入函数 params 如何？\nconst params={id:12}  \nconst paramsFn =()=&gt;{ id: params.id }  \nfunction useTable(api,paramsFn(),options){  \n ...  \n const refresh=()=&gt;api(Object.assign(paramsFn(),{[options.path.size]:pagination.size,[options.path.page]:pagination.page})).then(res=&gt;data=res)  \n return [data,refresh]  \n}  \n  \nconst [data,refresh]=useTable(api,paramsFn)  \nrefresh() // id=12  \nparams.id = 10  \nrefresh() // id=10\n完美解决。\n最后，兼容一下两种参数，让传入 useTable 的 api 参数既可以是函数，又可以是对象：\nexport function useTable&lt;T&gt;(  api: (params: any) =&gt; Promise&lt;T&gt;,  \n  params?: object | (() =&gt; object),  \n  options?: {  \n    path?: { data?: keyPath; total?: keyPath; page?: string; size?: string }  \n    immediate?: boolean  \n  },  \n) {  \n  // 参数处理  \n  defaults(options, {  \n    path: { data: &#039;data&#039;, total: &#039;total&#039;, page: &#039;page&#039;, size: &#039;size&#039; },  \n    immediate: false,  \n  })  \n  \n  const [pagination, , , setTotal] = usePagination(() =&gt;refresh())  \n  const loading = ref(false)  \n  const data = ref([])  \n  \n  const refresh = (extraData?: object | (() =&gt; object)) =&gt; {  \n    const requestData = {  \n      [options?.path?.page as string]: pagination.current,  \n      [options?.path?.size as string]: pagination.size,  \n    }  \n    if (params) {  \n      if (typeof params === &#039;function&#039;) {  \n        Object.assign(requestData, params())  \n      } else {  \n        Object.assign(requestData, params)  \n      }  \n    }  \n    loading.value = true  \n    return api(requestData)  \n      .then((res) =&gt; {  \n        data.value = get(res, options!.path?.data, [])  \n        setTotal(get(res, options!.path?.total, 0))  \n        if (!has(res, options!.path?.data) || !has(res, options!.path?.total)) {  \n          console.warn(&#039;useTable：响应数据缺少所需字段&#039;)  \n        }  \n      })  \n      .finally(() =&gt; {  \n        loading.value = false  \n      })  \n  }  \n  \n  options!.immediate &amp;&amp; refresh()  \n  \n  return [data as T, refresh, loading, pagination]  \n}\n这里代码主要新增了三处改变：\n\n如果 params 是对象，直接使用，如果是函数，则读取其返回值。\n优先级调整：paginaiton 的参数可以被 params 的同名属性覆盖，适用于开发者自己维护分页参数。\n定义了返回值的类型。\n\n使用示例\n试想一个常见，点击列表的某一项，就展示列表对应 id 的表格，如何实现？\n&lt;template&gt;  \n &lt;ul&gt;  \n  // 自定义组件，点击时emit发送onClick事件并传入item的id  \n  &lt;Item v-for=&quot;item in list&quot; :key=&quot;item.key&quot; :label=&quot;item.label&quot; @on-click=&quot;handleClick&quot;&gt;  \n  ...  \n &lt;/ul&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \n...  \n// 这里接受item的id  \nconst handleClick=(id:number)=&gt;{  \n params.id=number;  \n refresh()  \n}  \n...  \n&lt;/script&gt;\n封装五（接口传参-调用时）\n最后，来让 refresh 函数也能接受我们的传参。先看效果：\n&lt;script&gt;  \n...  \n// 这里接受item的id  \nconst handleClick=(id:number)=&gt;{  \n refresh({id})  \n}  \n...  \n&lt;/script&gt;\n可以省去 params 和 paramsFn 的定义了！\n实现代码：在定义 refresh 时允许加入参数。\nexport function useTable&lt;T&gt;(  api: (params: any) =&gt; Promise&lt;T&gt;,  \n  params?: object | (() =&gt; object),  \n  options?: {  \n    path?: { data?: keyPath; total?: keyPath; page?: string; size?: string }  \n    immediate?: boolean  \n  },  \n) {  \n  defaults(options, {  \n    path: { data: &#039;data&#039;, total: &#039;total&#039;, page: &#039;page&#039;, size: &#039;size&#039; },  \n    immediate: false,  \n  })  \n  \n  // 使用()=&gt;fn()而不是fn()区别在于后者只是一个值且立即执行  \n  const [pagination, , , setTotal] = usePagination((extraData?: object) =&gt;  \n    extraData ? refresh(extraData) : refresh(),  \n  )  \n  const loading = ref(false)  \n  const data = ref([])  \n  \n  const refresh = (extraData?: object | (() =&gt; object)) =&gt; {  \n    const requestData = {  \n      [options?.path?.page as string]: pagination.current,  \n      [options?.path?.size as string]: pagination.size,  \n    }  \n    if (extraData) {  \n      if (typeof extraData === &#039;function&#039;) {  \n        Object.assign(requestData, extraData())  \n      } else {  \n        Object.assign(requestData, extraData)  \n      }  \n    }  \n    if (params) {  \n      if (typeof params === &#039;function&#039;) {  \n        Object.assign(requestData, params())  \n      } else {  \n        Object.assign(requestData, params)  \n      }  \n    }  \n    loading.value = true  \n    return api(requestData)  \n      .then((res) =&gt; {  \n        // TODO 检查响应状态码  \n        data.value = get(res, options!.path?.data, [])  \n        setTotal(get(res, options!.path?.total, 0))  \n        // 友好提示  \n        if (!has(res, options!.path?.data) || !has(res, options!.path?.total)) {  \n          console.warn(&#039;useTable：响应数据缺少所需字段&#039;)  \n        }  \n      })  \n      .finally(() =&gt; {  \n        loading.value = false  \n      })  \n  }  \n  \n return[data,refresh,paginaiton,loading]  \n}\n需要注意的是，usePagination 处接受的回调函数也要适当修改。当然，pagination 也是要修改的了（增加回调函数有参数的情况，之前回调是没有参数的）。这里还额外新增了一个 reset 方法，用于重置分页器状态，这或许会有用！\nexport function usePagination(  cb: any,  \n  sizeOption: Array&lt;number&gt; = [10, 20, 50, 100, 200],): any {  \n  const pagination = reactive({  \n    current: 1,  \n    total: 0,  \n    size: sizeOption[0],  \n    sizeOption,  \n    onPageChange: (page: number, extraData?: object) =&gt; {  \n      pagination.current = page  \n      return extraData ? cb(extraData) : cb()  \n    },  \n    onSizeChange: (size: number, extraData?: object) =&gt; {  \n      pagination.current = 1  \n      pagination.size = size  \n      return extraData ? cb(extraData) : cb()  \n    },  \n    setTotal: (total: number) =&gt; {  \n      pagination.total = total  \n    },  \n    reset() {  \n      pagination.current = 1  \n      pagination.total = 0  \n      pagination.size = pagination.sizeOption[0]  \n    },  \n  })  \n  \n  return [  \n    pagination,  \n    pagination.onPageChange,  \n    pagination.onSizeChange,  \n    pagination.setTotal,  \n  ]  \n}\n使用：\n  &lt;!-- 分页器 --&gt;  \n  &lt;el-pagination  \n    v-model:current-page=&quot;current&quot;  \n    :page-size=&quot;size&quot;  \n    layout=&quot;total, prev, pager, next&quot;  \n    :page-sizes=&quot;sizeOption&quot;  \n    :total=&quot;total&quot;  \n    @size-change=&quot;(size)=&gt;handleSizeChange(size,params.id)&quot;  \n    @current-change=&quot;(page)=&gt;handleCurrentChange(page,params.id)&quot;  \n  /&gt;\n在此之前，需要保存 item. id 作为全局变量以供读取。\nconst handleClick=(id:number)=&gt;{  \n params.id=id;  \n}\n这样，我们就完成了一个功能相对完善的 Hook 函数。\n总结\n本文通过介绍 Hook 的概念和使用方法，并在实践的过程中封装了一个功能相对完善的 Hook 函数，但是它还有很多可以拓展的地方，比如 useTable 中可以再导出一个 clear 函数，用来将 data 赋值为空数组，以及对 data 数据的每一项进行查找、删除，或者新增一个 showData，用来过滤 data 并展示在视图上，总之，我们打开了 Hook 世界的大门，看到了 Hook 这项技术的强大之处：状态复用！\n因为本文主要讲解 Hook 封装，所以比较少提及组件封装。如果代码需要复用，首先考虑组件封装，因为它可以对 html、css 和 javacript 代码进行复用，而 Hook 只是复用 JavaScript 代码。如果将二者结合，能够高效地提高你的开发效率，以及项目的可维护性，帮助你写出优雅的代码。\n扩展阅读\n\n从零开始Vue3+Element Plus后台管理系统(16)——组合式函数hook二次封装el-table\n"},"E-Day-planner/2024/二月/2024_02_19｜星期一":{"title":"2024_02_19｜星期一","links":["Web-Clip/4大行业将因OpenAI超强Sora模型变天，给你3条应对变革小建议"],"tags":["Logs/日记"],"content":"文章学习\n\n4大行业将因OpenAI超强Sora模型变天，给你3条应对变革小建议\n\n\n本月计划\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新400天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/二月/2024_02_25｜星期日":{"title":"2024_02_25｜星期日","links":[],"tags":["Logs/日记"],"content":"文章学习\n\n年后面试，最好不要有这几种心态\n春招开始了\n前端简历在线修改，提高项目丰富度，包装项目重难点\n高级 Java 程序员，简历优化，模板和修改技巧\n前端 P 6 简历这样写\n这能学啥？winter 自爆简历\n4 年前端小伙简历出彩，快手已经来要简历了\n6 年小伙表达能力强，实践经验丰富，p 6 可以有，元芳你怎么看\np 7 简历这样写\n【【内推吐槽烩】简历点评 20210915：5 年前端帅哥多次获得大厂面试机会，两年前端经验的妹子就已经非常优秀了！转行经历应该如何处理？】 \n【【内推吐槽烩】简历点评 0901：8 年经验，2 家大厂经历，亮眼的项目经验！值得我们一起学习】 \n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新400天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/五月/2024_05_11｜星期六":{"title":"2024_05_11｜星期六","links":["Web-Clip/@Vue3-自定义hooks-大集合-你要的自定义hooks-都在这，快来看吧！---知乎","Web-Clip/@阿里面试：写一个倒计时功能刷掉了80-percent-的人","Web-Clip/@推荐两个CSS生成器，专治各种不规则形状，建议收藏","Web-Clip/@利用Interact.Js：轻松实现网页元素拖放交互","Web-Clip/@好烦啊，我真的不想写增删改查了！","Web-Clip/@专业前端都这么使用console!","E-Day-planner/2024/五月/去除后缀名","Web-Clip/@网站开发人员应该知道的61件事---阮一峰的网络日志"],"tags":["Logs/日记"],"content":"文章学习\n\n@Vue3 自定义hooks 大集合 你要的自定义hooks 都在这，快来看吧！ - 知乎\n@阿里面试：写一个倒计时功能刷掉了80% 的人\n@推荐两个CSS生成器，专治各种不规则形状，建议收藏\n@利用Interact.Js：轻松实现网页元素拖放交互\n@好烦啊，我真的不想写增删改查了！\n@专业前端都这么使用console!\n去除后缀名\n@网站开发人员应该知道的61件事 - 阮一峰的网络日志\n\n\n本月计划\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新 500天，近期目标 500天，中期目标 1年，远期目标 10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/五月/2024_05_13｜星期一":{"title":"2024_05_13｜星期一","links":["Web-Clip/@Virtual-DOM（虚拟DOM）-的地位再一次被挑战-！！！","Web-Clip/@知识管理软件-Zotero-的使用---chempeng","Web-Clip/@移动端适配原理与方案详解---掘金"],"tags":["Logs/日记"],"content":"文章学习\n\n@Virtual DOM（虚拟DOM） 的地位再一次被挑战 ！！！\n@知识管理软件 Zotero 的使用 - chempeng\n@移动端适配原理与方案详解 - 掘金\n\n本月计划\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新 500天，近期目标 500天，中期目标 1年，远期目标 10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/五月/去除后缀名":{"title":"去除后缀名","links":[],"tags":["编程/JavaScript"],"content":"name.substring(0, name.lastIndexOf(&quot;.&quot;))"},"E-Day-planner/2024/四月/2024_04_22｜星期一":{"title":"2024_04_22｜星期一","links":[],"tags":["Logs/日记"],"content":"文章学习\n\nSeek 策略以及在有 B 帧情况下的处理\n视频播放Seek的基本原理\n揭秘视频网站video视频倍速播放的实现\n视频音频两倍速 三倍速播放 原理是什么？如何实现的?\n洞察 video 超能力系列——玩转 mp4\n360视频云Web前端HEVC播放器实践剖析\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新426天，近期目标 500天，中期目标 1年，远期目标 10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/四月/2024_04_25｜星期四":{"title":"2024_04_25｜星期四","links":["E-Day-planner/2024/四月/CSS3实现无缝滚动scroll，实用=很丝滑+很漂亮+源码","Web-Clip/@obsidian和zotero连用（Citation插件介绍）-_-软通达","Web-Clip/@2024-抖音欢笑中国年(四)：渲染技术实践与探索","Web-Clip/@Notion-3.0-今年发布，野心真大","Web-Clip/@Jenkins-真得很牛逼！只是大部分人不会用而已~(保姆级教程)","Web-Clip/@小学生都开始学-Python-了！","Web-Clip/@【Notion】同步博客图片过期！！阿里云OSS+PicGo搭建自己的高性能图床","Web-Clip/@男人做到这4点，婚姻越来越幸福","Web-Clip/@前端常用的几种请求方式","Web-Clip/@🎶-SunoAI-音乐生成初体验","Web-Clip/@腾讯云4月8日故障复盘及情况说明","Web-Clip/@Three.Js动态场景实战","Web-Clip/@推荐几个不错的JS媒体库","Web-Clip/@TypeScript很麻烦，不想使用！","Web-Clip/@珠三角有多富！广东省有多穷！","Web-Clip/@玉伯这个中年男人也去创业了","Web-Clip/@一图搞懂_搜索引擎的工作原理","Web-Clip/@8秋API接口设计风格与11种API协议"],"tags":["Logs/日记"],"content":"文章学习\n\n\n中国十大最具发展潜力城市\n\n\n软件项目开发管理全流程\n\n\n\n\nCSS3实现无缝滚动scroll，实用=很丝滑+很漂亮+源码\n\n\n@obsidian和zotero连用（Citation插件介绍） _ 软通达\n\n\n@2024 抖音欢笑中国年(四)：渲染技术实践与探索\n\n\n@Notion 3.0 今年发布，野心真大\n\n\n@Jenkins 真得很牛逼！只是大部分人不会用而已~(保姆级教程)\n\n\n@小学生都开始学 Python 了！\n\n\n@【Notion】同步博客图片过期！！阿里云OSS+PicGo搭建自己的高性能图床\n\n\n@男人做到这4点，婚姻越来越幸福\n\n\n@前端常用的几种请求方式\n\n\n@🎶 SunoAI 音乐生成初体验\n\n\n@腾讯云4月8日故障复盘及情况说明\n\n\n@Three.Js动态场景实战\n\n\n@推荐几个不错的JS媒体库\n\n\n@TypeScript很麻烦，不想使用！\n\n\n@珠三角有多富！广东省有多穷！\n\n\n@玉伯这个中年男人也去创业了\n\n\n@一图搞懂_搜索引擎的工作原理\n\n\n@8秋API接口设计风格与11种API协议\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新 500天，近期目标 500天，中期目标 1年，远期目标 10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Day-planner/2024/四月/CSS3实现无缝滚动scroll，实用=很丝滑+很漂亮+源码":{"title":"CSS3实现无缝滚动scroll，实用=很丝滑+很漂亮+源码","links":[],"tags":["编程/FE/CSS"],"content":"这篇文章的诞生的原因是来自前段时间有个网友叫小编帮忙写一个图片列表水平滚动效果，不能出现闪跳，影响用户体验。\n于是小编思考良久，查阅相关资料和官方文档MDN，想找一些相应滚动案例和动画来参考，调研后发现，除了官网 animation 讲的很认真，其他的讲的都是概念，含糊其辞，或者上来就是一个不知道去哪里粘贴来的源码，不知其所以然，后面放弃了。还得自己动手！！！\n经过深思熟虑，采用了animation动画来滚动元素，因为能用关键帧控制动画属性，包括动画方向，动画执行时间和缓动函数。如果对动画animation不太理解的伙伴，可以去官方MDN上查阅。\n参考资源\n\n\n\n\n\n\n\n\n\n\n\n\n\n图片picsum.photos/images#2动画developer.mozilla.org/zh-CN/docs/Web/CSS/animation\n滚动原理解析\n考虑布局和滚动关系，于是乎就有了下方的结构图，所有代码就是围绕这个图来实现的。\n\n\n\n                  \n                  提示💡 \n                  \n                \n思路：用一个div作为容器parent-container，包括ul作为滚动列表scroll-container，容器宽度设置为max-width和min-width为50rem，设置溢出隐藏，配置相对定位用于实现左右遮罩效果，图中没体现，但源码里有，这里遮罩用的是伪类before和after。滚动容器内部的li放置图片，可以是任意多个，在js中克隆一遍现有元素li，此时容器内部就有两倍的图片数量，这样就可以看到不间断的滚动效果了，元素过多时可以去掉js中克隆的操作，避免多余元素，影响效果。最后使用animation+@keyframes来执行动画，可以通过父元素的data-reverse属性来改变动画向右滚动，默认是向左滚动的。当然，后面的开启动画属性也可以在css中写死，只是通过参数配置显得更加灵活。如果还需要控制其他属性比如动画时间快慢，也可以加到parent-container容器上，通过css变量来改变它。\n\n原理讲完了，图也看完了，这哈上源码，由于微信不支持大图且录制的gif看起来有怪怪的， 所以直接放截图。可以把源码放到html文件中查看效果，那才是实际的丝滑效果。\nCSS源码\n&lt;style&gt;\n body {\n    --bgcolor--: #001C30;\n    min-block-size: 100vh;\n    display: grid;\n    place-items: center;\n    background-color: var(--bgcolor--);\n    overflow: hidden;\n}\n.contianer {\n    max-width: 50rem;\n    min-width: 50rem;\n    overflow: hidden;\n    position: relative;\n}\n.contianer::before, .contianer::after {\n    content: &quot;&quot;;\n    width: 100px;\n    height: 100%;\n    position: absolute;\n    z-index: 1;\n}\n.contianer::before {\n    background: linear-gradient(-90deg, transparent,var(--bgcolor--) 80%, var(--bgcolor--) 20%, transparent);\n    left: -5%;\n    top: 0%;\n}\n.contianer::after {\n    background: linear-gradient(90deg, transparent,var(--bgcolor--) 80%, var(--bgcolor--) 20%, transparent);\n    right: -5%;\n    top: 0%;\n}\n.ul-list {\n    margin: 0;\n    padding-inline: 0;\n    list-style: none;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 1rem;\n}\n.ul-list li {\n    line-height: 1;\n    width: 12rem;\n    background: #10ac84;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    color: #fff;\n    text-align: center;\n}\n.ul-list li img {\n    border-radius: 0.5rem;\n    width: 100%;\n    aspect-ratio: 1 / 1;\n    object-fit: cover;\n}\n.contianer[data-animated=&#039;true&#039;] .scroll_item {\n    width: max-content;\n    flex-wrap: nowrap;\n    animation: scroll var(--animation-duration, 30s)\n            var(--animation-direction, forwards) linear infinite;\n}\n.contianer[data-reverse=&#039;true&#039;] {\n    --animation-direction: reverse;\n}\n@keyframes scroll {\n    to {\n        transform: translate(calc(-50% - 0.5rem));\n    }\n}\n&lt;/style&gt;\nHTML源码\n&lt;div class=&quot;contianer&quot; data-reverse=&quot;true&quot;&gt;\n    &lt;h2 style=&quot;color: #fff;&quot;&gt;布依前端--图片列表滚动案例&lt;/h2&gt;\n    &lt;ul class=&quot;ul-list scroll_item&quot;&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/37/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/55/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/57/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/58/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/55/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;img src=&quot;picsum.photos/id/60/367/267&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\nJavaScript源码\n&lt;script&gt;\nconst scroller = document.querySelector(&quot;.contianer&quot;);\nexcutionAnimate();\nfunction excutionAnimate() {\n    if (scroller) {\n        scroller.setAttribute(&quot;data-animated&quot;, true);\n        const scrollerInner = \n        scroller.querySelector(&quot;.scroll_item&quot;);\n        const children = Array.from(scrollerInner.children);\n        children.forEach((item) =&gt; {\n            const Item = item.cloneNode(true);\n            Item.setAttribute(&quot;aria-hidden&quot;, true);\n            scrollerInner.appendChild(Item);\n        });\n    }\n}\n&lt;/script&gt;\n最终动态效果在文章开头视频查阅。\n\n案例扩展\n可以把图片元素替换成文字，像这样。\n修改样式表。\n .ul-list li {\n    line-height: 1;\n    width: 12rem;\n    background: #10ac84;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    color: #fff;\n    text-align: center;\n}\n替换li内容为文本。\n &lt;ul class=&quot;ul-list scroll_item&quot;&gt;\n    &lt;li&gt;HTML&lt;/li&gt;\n    &lt;li&gt;CSS&lt;/li&gt;\n    &lt;li&gt;JavaScript&lt;/li&gt;\n    &lt;li&gt;Transtion&lt;/li&gt;\n    &lt;li&gt;Canvas&lt;/li&gt;\n    &lt;li&gt;animation&lt;/li&gt;\n    &lt;li&gt;SVG &lt;/li&gt;\n&lt;/ul&gt;\n为了更好体验，粘贴代码到HTML文件，用浏览器打开该文件，最终静态效果图如下：\n"},"E-Diary/2024_01_03｜周三｜☁️":{"title":"2024_01_03｜周三｜☁️","links":["D-Unsorted/2023-年-CSS-新特性大盘点"],"tags":["Logs/日记"],"content":"去年夏天 - QQ音乐\n\n\n文章学习\n\n2023 年 CSS 新特性大盘点\n2023 年 CSS 新特性大盘点2023 年 CSS 新特性大盘点2023 年 CSS 新特性大盘点\n\n面试｜职场\n2023年前端众生相\n\n知识管理\n![image.png](G%20Attachments/144e7f61458211236e0b90b91523a107_MD5.png /&gt; 我的知识管理工具和经验 | 程序员的喵 打造自己的工具 - Obweb | 程序员的喵\n\n国内远程办公招聘\ngithub.com/chenyukang/remote-jobs-cn\n\nMac电脑mds_store进程占用cpu过高\nMac电脑mds_store进程占用cpu过高_mdsstores占用cpu-CSDN博客\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新317天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_04｜周四｜☁️":{"title":"2024_01_04｜周四｜☁️","links":["D-Unsorted/Vue-新一代开发者工具正式开源！"],"tags":["Logs/日记"],"content":"南海姑娘 - QQ音乐\n\n\n文章学习\n\nVue 新一代开发者工具（DevTools）正式开源！\nVue 新一代开发者工具正式开源！\nVue 新一代开发者工具正式开源！\nVue 新一代开发者工具正式开源！\n\n面试题\n37.说一下什么是“同源策略”？_哔哩哔哩_bilibili\n\n大疆\n\n福利制度\n\n\n试用期不打折。\n\n![image.png](G%20Attachments/c45b53dbf5fdce812c57b386e49ee187_MD5.png /&gt;\n\n为什么离职\n\n\n什么人适合大疆\n![image.png](G%20Attachments/f2322824c05baf912d133e2ca5d7ea2a_MD5.png /&gt; 【面试必看】在DJI大疆工作是什么体验？3年老员工分享｜劝退or推荐？福利如何？为什么离职？什么人适合大疆？秋招面经_哔哩哔哩_bilibili\n\n询问面试官看法\n\n大疆面试通关宝典（上）_哔哩哔哩_bilibili 【大疆Vlog】大疆工程师的一天♂工作纪实_哔哩哔哩_bilibili\n\n程序员在工作中如何快速成长？\n\n1、每日阅读\n每天读 2 - 3 篇文章，可以是行业趋势、技术干货（自己的工作有关的方向）、经验分享、思维提升等。坚持一年，你就读了将近 1000 篇文章，相当于几十个教程，绝对大有裨益。文章从哪儿找？\n\n大厂的技术博客：适合想学硬核技术的同学，比如美团技术团队、阿里技术团队\n科技资讯类：量子位、差评、新智元、无敌信息差（我们自己的号）\n经验分享、编程趋势、技术干货：程序员鱼皮、小林 coding、java guide、程序喵、神光的编程笔记、小白 debug、古时的风筝、苏三、阿秀等（很多都是我们一起写文章的朋友）\n\n\n2、技术学习\n对程序员来说，一定要持续学习新技术。每天只需要抽不到 1 小时，看 2 - 3 集教程，那么坚持一个月，你就能看完一套课程。或者每天写 100 行代码，一周一个功能，那么坚持一个月，你就能做好一个项目。\n\n3、复盘总结\n之前也给大家分享过，这是我坚持多年的习惯。可以尝试做以下几件事：\n\n每天记录自己完成的工作，哪怕贴个需求链接啥的也可以\n每月记录自己这个月重点在做的事情，以及完成的工作、学习的情况等\n每半年或者每完成一个大事，做一个复盘总结。记录自己做这件事情的经历、过程、结果、好和不好的地方，防止后面踩同样的坑。\n\n\n4、整理自己的弹药库\n为什么有些人工作五年，感觉还和工作一年一样？可能就是没有做好 积累 ，把之前的经验忘完了！所以，积累真的很重要，大家可以从以下几个方面下手：\n\n整理属于自己的 Bug 库，记录你解决过的问题\n整理属于自己的经验库，记录你踩过的坑\n知识碎片积累：把你学过的所有知识点，以碎片的形式进行记录整理，后面要做项目时都可以复用\n软件库（工具库）：整理自己的常用软件、工具，保证自己工作的高效（换电脑能快速迁移环境）\n\n\n5、分享\n只要你做到了上面几件事，那么你一定是有非常多能分享的内容的。比如：\n\n分享自己的复盘总结和个人经历\n分享自己的弹药库\n分享自己学过的知识点\n帮助别人答疑解惑\n\n直接把自己之前记录的内容分享出来，就会对别人有帮助，也会收获别人的关注和认可，从而给自己获取正向激励再帮助自己更快地提升，然后再分享更多内容，这是一个非常好的良性循环。我也是通过这种方式，从自己背过的面试题、再到自己的个人经历、再到自己的项目，依次给大家分享出来，才慢慢收获了更多人的关注，成为了一个博主。谢谢大家！\n\n6、目标拆解\n工作后想持续学习，其实是非常难的，因为我们会本能地担心由于工作的影响，没有更多精力和时间干大事。这种时候，我们一定要学会将目标拆解。比如你想做一个大项目，可以把它依次拆解为做一个子系统、做一个小的功能、小的模块、学一个技术、看一套课程、看一节教程、看 10 分钟教程。只要把目标拆解地足够小，做好计划表，然后按照计划，每天坚持执行就好了。要是工作前就知道这个，该多好。 程序员在工作中如何快速成长？我的 6 个技巧分享_哔哩哔哩_bilibili 投几百份简历都没回复？请先做到这点！程序员找工作建议_哔哩哔哩_bilibili\n\n好用工具\n\n文字转音频｜也可使用微信读书\nSpeechify - Listen to text with Speechify\n\n文献管理神器 Zotero 学习路径指南\n文献管理神器 Zotero 学习路径指南 - 少数派\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新318天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_05｜周五｜🌁":{"title":"2024_01_05｜周五｜🌁","links":[],"tags":["Logs/日记"],"content":"故乡河 - QQ音乐\n\n\n文章学习\n\n为什么PPT不如备忘录\n贝佐斯说，书面的备忘录要比 PPT 演示，效果好得多，主要有以下几点原因。（1）PPT 的设计目的是说服，这是一种销售工具。但是在公司内部，你想要的是真相，而不是业务主管的推销。（2）PPT 的缺点是，**它对作者相对容易，对观众来说却很难抓住要点。**备忘录正好相反，写好一份六页的备忘录，对于作者是很难的。你可能需要两周的时间，先写出初稿，然后再重写，不断加工，确保你的文字是准确和可靠的。所以，备忘录对作者非常困难，但对观众就好多了，半小时的阅读就能搞清楚事情的来龙去脉，也看得出作者对这个问题的熟悉程度。（3）**备忘录可以节省会议时间。**如果是 PPT 演示，高管们会不停地打断提问，结果发现答案就在下一张幻灯片。但是，阅读备忘录时，你必须先把所有问题写在空白处，当你读到最后一页时，发现很多问题已经得到了解答，这就节省了当众提问的时间。（4）PPT 演示过程中，主讲人也许会根据现场情况，临时决定隐藏或修改一些讲法。备忘录就没有这个问题，主讲人必须事先给出完整描述，你更能了解他的真实想法。（5）PPT 通常只是一些要点，不是完整的句子，有利于隐藏很多草率的想法。而备忘录是完整的段落，必须有主题句，有动词和名词，你很难隐藏自己的草率思维。备忘录迫使作者处于最佳状态，你能得到一个人真正最好的想法。如果 PPT 演示，你们可能要讨论很久，发言人才能进入最佳状态。从长远来看，备忘录节省了你的时间。科技爱好者周刊（第 285 期）：为什么 PPT 不如备忘录 - 阮一峰的网络日志\n\n争夺太空的拉格朗日点\n”拉格朗日点”指的是受到地球和太阳引力相等的位置。处于这个位置的飞行器，不需要耗费能源，就可以长期停留。这样的位置一共有五个。本文是一家美国媒体的报道。“拉格朗日点”并没有军事价值，而且每个点其实都是一个巨大的区域，但是美国国会议员要求，美国要抢在中国前面，占据所有的拉格朗日点。\n\nPodman 与 Docker 的比较（英文）\nDocker 和 Podman 都是容器工具，很多功能是重合的。本文介绍它们各自的优缺点。\n\n解决团队分歧的四种方式\n团队成员之间，经常会因为不同意见发生分歧。有些分歧，最终会达成一致意见；另一些分歧，谁也无法说服谁，难以达成一致。团队内部无法达成一致时，可能会出现四种决策方式。方式一：我不同意，但一旦决策定了，我就会一起努力。亚马逊创始人贝佐斯说：“当我跟一个主管反复讨论后，他不同意我的看法。虽然我不认为他正确，但我愿意陪他赌一把。我们认识几十年了，我觉得他可能比我更接近真相。其实我也不知道自己的决定是否正确，干脆照着下属的想法走。“这样有几个好处：\n\n至少产生了一个大家同意的决策。\n事后不会互相埋怨。\n有利于形成真正的团队精神。\n\n方式二：双方各退一步，互相”妥协”（Compromise）。这种做法是在双方立场之间，找一个中间点作为决策。这个房间我认为12尺高，你认为11尺高，最后大家同意把它的高度定为11.5尺。这种决策方式很糟糕，因为11.5尺根本不是真相，只是因为找出真相需要耗费太多的能量，“妥协”让大家以一种节省能量的方式达成共识。真正可取的做法是，凡是可以找到真相的事情，都不应该妥协。方式三：比谁更固执。争论的双方进行持久战，最先坚持不下去的人就会投降。这种决策方式既没有得到真相，又大伤团队元气。所以，必须禁止这种方式，不允许用消耗对方的方式达成协议。方式四：提供给上级，由上级决定。这种方式可以外包决策过程，也不会伤害团队成员之间的感情。缺点是大家没有去尽力找寻真相，团队思想也没有真正达成统一。总结：建议采用第一种决策方式”不同意、但尽力去做”。这种方式不一定是正确决策，但是对于企业来说，有一个速度问题：决策速度必须要快，不能拖延，团队要始终保持高速度。第一种决策方式，至少可以保证决策会在短时间内产生，把事情向前推进。\n\n如何让自己走出信息茧房？\n信息茧房（Information Cocoon）是一个指个人或社群在网络环境下，由于个人喜好、算法推荐等因素，主动或被动地只接触和消费与自己观点相似或相符的信息，而忽视或排斥不同观点的信息的现象。这种现象通常发生在社交媒体、新闻网站等网络平台上。信息茧房会导致个人或群体的观点越来越极端化，减少与不同观点的交流和了解，从而可能形成偏见和误解。这对社会的多元化和包容性构成挑战，也可能对决策过程产生负面影响。虽然我们都不自觉地习惯于在各自的信息茧房中观察世界，但我们似乎又都不满只是陷于自己的信息茧房之中。怎么办？其实没有其它更好的办法。当务之急，是更多地去对方那里看看，更多地进行面对面间的交流，看到那些自己日常看不到的事实，去加深对这个共同生活的星球的完整理解。如何让自己走出信息茧房？\n\nMacBook换电池多少钱\nMacBook换电池多少钱？Mac电池循环次数多少需要换电池\n\n吴晓波年终秀\n![image.png](G%20Attachments/8ade45f18ecd02467c8ae44241988337_MD5.png /&gt;吴晓波工厂年终秀：预见2024·定力至上【视频完整版+演讲全文+PPT】_哔哩哔哩_bilibili阿里云盘分享\n\n好用工具\n\nvx.dev｜输入需求，直接生成网站\nVercel 的 v0.dev 可以通过输入需求，直接生成网站。这里是它的一个开源仿制品，通过逆向工程进行模仿，详见介绍文章。(@Yuyz0112 投稿)\n\nTriangle Patterns｜三角渐变图案生成\n![](G%20Attachments/1bb5cf2b4a0d9450a538e484bed14aff_MD5.webp /&gt;三角渐变图案的生成工具。（@zerosoul投稿）\n\nCopilot-GPT4-service｜使用 GPT-4 模型\n作者发现 Github Copilot Chat 的底层是调用 ChatGPT 接口，因此做了这个工具。它可以将 ChatGPT 请求转换为 Github Copilot Chat 的请求。只要拥有 Github Copilot 账号，就能无限制使用 ChatGPT 的 GPT-4 模型。\n\nBluestone Markdown（青石）｜ Markdown 桌面编辑器\n![](G%20Attachments/7577226cc97d52d375258fb61b05dfef_MD5.webp /&gt;一个所见即所得的 Markdown 桌面编辑器，集成了 Mermaid 图形与 Katex 公式，支持明亮和暗黑风格。（@1943time投稿）\n\nresume-json-pdf｜通过 JSON 文件，在线生成 PDF 简历\n![](G%20Attachments/9d0628889423ce60bb0872539924333f_MD5.webp /&gt;通过 JSON 文件，在线生成 PDF 简历。（@RylanBot投稿）这里还有一个类似的工具 Faultier-CV，通过 Markdown 格式编写简历，并能实时预览。\n\nfabritor｜图片编辑器\n![](G%20Attachments/67b30ee117fa6e4b8584ab8acf76e958_MD5.webp /&gt;一款基于 fabric.js 的创意图片编辑器，支持自己部署。（@sleepy-zone投稿）\n\nVue TSX Admin｜后台管理系统的前端模版\n![](G%20Attachments/3f6844e97eb57862d27b2cc33dfe3703_MD5.webp /&gt;一款开源的后台管理系统的前端模版，基于 Vue3 + TSX。（@manyuemeiquqi投稿）\n\nHTTPS Certification generator｜TLS｜一键生成 IP 地址的自签名 HTTPS 证书\n这个在线工具可以一键生成 IP 地址的自签名 HTTPS 证书，适合用于开发环境。\n\ncmd-wrapped｜命令行操作的历史记录\n这个工具可以读取你的命令行操作的历史记录，生成一份年度总结。支持 Zsh 和 Bash，并可指定年份。\n\n有趣站点\n\n中国历朝代视频讲解\n![](G%20Attachments/aa45d5de4396206b23c7e3d2fab6a05f_MD5.webp /&gt;一个开源网站，将 BiliBili 上面综合数据最高的一些中国历史视频，以时间轴的方式呈现。（@liujuntao123投稿）\n\n学习资源\n\nYUERGS｜自学吉他\n作者为了解决自学吉他过程遇到的痛点，开发了这个网站，支持吉他谱滚动播放、吉他调音、查和弦、节拍器、扒歌等相关功能。\n\n文本编辑器实时协同的原理和实现（英文）｜多人实时编辑\n文本编辑器如何支持多人实时编辑？本文以示例讲解原理。\n\nBeej 的网络概念指南（Beej’s Guide to Network Concepts）｜计算机网络底层概念\n著名技术作者 Beej 新发布的计算机网络底层概念的英文教程。\n\n经济学讲义通识\n【薛兆丰】《经济学讲义通识 》完整_哔哩哔哩_bilibili\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新319天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_07｜周日｜☀️":{"title":"2024_01_07｜周日｜☀️","links":[],"tags":["Logs/日记"],"content":"风姿花传 - QQ音乐\n\n\n文章学习\n\n搜索\n\n\n限定关键词：，“keyword”，匹配的结果必须完全精确包含keyword，而非谐音相同或相似的结果，可过滤很多结果\n限定标题:intitle: keyword； allintile: word1 word2\n\nallintitle: 李子柒回归 微念\n\n\n限定文本: intext:keyword; 精确在文本中，intext: “keyword”\n\nintext: “池晨晨” “浙江大学”\n\n\n限定来源: word inurl: cctv 来源必须是央视，也可以和上面组合\n\n李子柒 inurl:cctv\n\n\n限定网站来源， word site: 1991T.com zhihu.com\n限定图片分辨率：imagesize: 2560x1440\n限定文件格式：xxxx filetype:ppt\n\n大语言模型 filetype:pdf\n\n\n\n![image.png](G%20Attachments/362f5522954d1da354aa8b41f679e1fa_MD5.png /&gt;\n\n公众号：搜狗\nGithub/Stack overflow/CSDN\n前端必逛网站\n\n\n\n类似网站：cn.similarsites.com/\n\n\n\n谷歌学术搜索\nsci-hub\n鸠摩搜书： www.jiumodiary.com/\nbest free ebook download sites\nbest online learning websites\n\n\n\nbest sites for free stock videos\nbest sites for free bgm\nz-lib.is/\n百度网盘搜索引擎： pan.qianfan.app/\n免费视频资源：www.pexels.com/zh-cn/\nYoutube 视频下载：\n\nwww.9xyoutube.com/\nsave.tube/\n\n\n图片下载网站：steptodown.com/getty-images-downloader/\nrocket icon filetype:png\n\n\n\nPPT: islide 插件\n\ncanva.com\n\n\n需求+ online/在线\n替代软件：alternativeto.net/\nplugin（软件插件）/extension（浏览器插件）\n搜索知识： 得到\n\n![image.png](G%20Attachments/7a41c759ce187de34f339e689b83b5f2_MD5.png /&gt;【资源信息获取方法】 - 技术栈 超级搜索技术，普通人变强的唯一外挂 | 全套宝藏实操秘技_哔哩哔哩_bilibili\n\n【影视飓风】Tim分享后期流程和调色秘密\n\n色彩还原\n生成代理\n调色\n\n【影视飓风】Tim分享后期流程和调色秘密_哔哩哔哩_bilibili\n\n银杏\n银杏：活着，直到被死神遗忘_哔哩哔哩_bilibili\n\n追觅S10Plus扫地机器人全自动上下水扫拖洗烘除菌集尘一体机\n真菌为何把蚂蚁变成丧尸_哔哩哔哩_bilibili粉丝福利购\n\n农民工朋友被欠薪？来这个全国平台反映！\n![image.png](G%20Attachments/985708f2804d43c9ac15ba0f2e4e0ea3_MD5.png /&gt;农民工朋友被欠薪？来这个全国平台反映！\n\n亲密关系中最好的一种状态\n\n什么是亲密关系最好的状态\n对于亲密关系来说，我认为最好的状态应当是两个人无话不谈，对对方绝对信任，可以做到不查对方手机也能放心。自己的一切交往，都可以让对方知道，就连带点暧昧色彩的交往也应该让对方知道，而且确信对方能够容纳自己，不会对现存的关系伤筋动骨。这样的话，你就要轻松许多。\n\n学会给彼此空间\n在亲密关系里，每一个人首先应当忠诚于对方，这是非常重要的。与此同时，信任也很重要。我忠诚于你，你忠诚于我，与此同时，我相信你，你也相信我。如果一方总是背着另一方偷鸡摸狗、拈花惹草，这两人的关系就不是真正的相亲相爱、互相忠诚的关系了。这样当然不行。但是，**在相互忠诚的前提之下，也应该给对方一点点空间，这样的爱情才能更加持久、更加稳固。**如果你把他逼得特别死，盯得特别紧，一点空间都不给他，他甚至不能去结交一个异性朋友，不能和别人多说一句话，多看别人一眼，那么两人的关系最终会搞得非常僵。亲密关系中最好的一种状态\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新321天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_09｜周二｜☀️":{"title":"2024_01_09｜周二｜☀️","links":[],"tags":["Logs/日记"],"content":"New Soul - QQ音乐\n\n\n文章学习\n\n自由职业两年心得体会｜远程工作\n![image.png](G%20Attachments/80bca4b37f9cc6b4bd00fcba30abeb4d_MD5.png /&gt;\n\n现在做的业务钱是怎么赚来的。\n\n受众在哪里+怎么让他知道我（花钱获得受众）\n让受众付费（产品分层/免费+付费）\n\n\n\n![image.png](G%20Attachments/d8129af01d9fc55d173b7919e1cdf0c4_MD5.png /&gt;\n\n英语+算法\nSystem Design\n把家人当投资人\n社保：灵活就业+创建公司+代理公司（不合法）\n\n![image.png](G%20Attachments/125b129da5a2857a2a2b2519cf19ef13_MD5.png /&gt;自由职业两年心得体会_哔哩哔哩_bilibili 看看国外远程工作招聘要求，5 年编程经验以上_哔哩哔哩_bilibili\n\n地震\n提高地震应急能力是非常重要的，以下是一些建议：\t1.\t了解地震知识：学习地震的基本知识，包括地震的原因、地震波的传播、如何在地震中保护自己等。可以通过参加地震科普活动、阅读相关书籍或观看教育视频来增加对地震的了解。\t2.\t制定家庭应急计划：制定一份家庭应急计划，包括紧急联系方式、逃生路线、集合地点等。确保家人都知道应急计划的内容，并定期进行演练。\t3.\t准备应急物资：在家中准备一些应急物资，如食品、水、医疗用品、手电筒、毛毯等。确保这些物资易于取用，并定期检查和更新。\t4.\t加强建筑物的抗震能力：如果你居住在自己的房屋中，可以考虑采取一些措施来加强建筑物的抗震能力，如加固墙壁、固定家具等。\t5.\t参加应急培训和演练：参加当地组织的地震应急培训和演练，了解如何在地震发生时正确应对，如何进行自救互救等。\t6.\t关注官方信息和警报：关注当地政府和地震部门发布的地震预警和信息，遵循官方指示和建议。提高地震应急能力需要长期的准备和持续的学习。通过以上措施，可以增强自己和家人在地震发生时的应对能力，减少潜在的风险和损失。如果你在地震中受伤了，以下是一些应对措施：\t1.\t首先要保持冷静，判断自己的伤情。如果伤势较轻，可以尝试自行处理；如果伤势较重，应尽快寻求医疗救助。\t2.\t如果你在室内，应尽量躲到桌子、床下等结实的家具下面，用坐垫、枕头等柔软物品保护头部。如果你在户外，应远离建筑物、电线杆等易倒塌的物体，寻找空旷地带或草地等开阔地带躲避。\t3.\t在等待救援人员到来之前，可以尝试进行简单的自救。如果有伤口，可以用干净的纱布或毛巾进行包扎；如果出现呼吸困难，可以尝试进行人工呼吸等紧急处理。\t4.\t如果你身边有其他人受伤，应尽快向周围的人求助，或者拨打当地的紧急救援电话（如 120）寻求帮助。\t5.\t在接受医疗救助之前，应尽可能提供详细的伤情信息和个人信息，以便医生进行更好的治疗。总之，在地震中受伤后，要保持冷静，判断伤情，采取适当的自救措施，并尽快寻求医疗救助。同时，平时也要加强地震应急知识和技能的学习，提高自我保护能力。任何一座新建筑都不能在大地震中倒塌，倒了就犯法\n\n飞的\n![image.png](G%20Attachments/a0ce026486ab0e649d30a65476838352_MD5.png /&gt;为了方便旅客出行方便永川区交通部门还协调百度萝卜快跑无人驾驶出租车将服务区域延伸到了大安通用机场实现空地出行服务无缝对接永川首条航线开通！打着“飞的”去旅游🥰重庆市首批短途运输航线正式开航！！！限时可享20元立减！！！\n\n苹果电池\n苹果赔款到账，最低 658 元，不少人已经到账！\n\n东莞\n什么是真正的东莞？\n\n贵州\n这才是贵贵贵贵贵州！\n\n台湾\n中秋，宜团圆！这部《中国台湾地理》送给你【4K】_哔哩哔哩_bilibili\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新323天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_11｜周四｜☀️":{"title":"2024_01_11｜周四｜☀️","links":["tags/场景/城市"],"tags":["Logs/日记","场景/城市"],"content":"江南 (古筝版) - QQ音乐\n:::success\n12月9日，Google 发布了NotebookLM，可以上传英文文档，让AI进行学习后，可以就文档进行提问。这让我想到我正在构建的第二大脑，未来是不是可以将我的第二大脑扔给AI进行学习，然后对AI进行提问，就能快速找到我想查找的内容。少数派\n:::\n\n\n每日一句\n\n1、乔布斯\n不要把职业（career）当成某一件具体的事情，这是人类发明的最危险、最令人窒息的概念之一，也是大多数梦想和直觉的敌人。职业应该是一个抽象的概念，指的是一个人在日常的工作和生活中，不断探索、培训、实践、逐步进步的过程。—《乔布斯的遗产》\n\n2、杨二\n现在 sinqi.tools 的 logo 太丑了，当初随便找的，一直想换掉，尝试过多次 AI 生成，但始终没满意的结果，所以一直搁置。昨晚洗完澡，突然有灵感：\n\n闪电！象征着快速、高效、强大，与 Sinqi 的定位相符，而且与首字母“S”象形\n颜色！可以选几张女儿的照片，用 Sinqi 已有的工具，从图片提取出主要颜色，然后配色\n代码！我可以写个组件去画这个 logo，最后把 DOM 生成图片\n于是，就有了这个 logo，虽然不专业，但很满意，这个事情给我的启发：\n没灵感的时候，干点别的，让脑子休息下\n有灵感的时候，要及时记录下来，不然很快就忘了，最好立马开干\nAI 不是万能的，还是需要有爱（AI）\n勤洗澡 🛀\n\n\n文章学习\n\n新基建的政策选择\n”新基建”到底是指哪些项目？百度百科有一个”新基建”条目（上图），里面提到它包括七个领域。\n\n5G 基站\n特高压\n城际高速铁路，城市轨道交通\n新能源汽车充电桩\n大数据中心\n人工智能\n工业互联网\n\n也就是说，上面七个领域可能就是政府明年投资的主要方向。其中，除了第2项（特高压）、第3项（城际交通）和第4项（新能源充电桩），其他四项都是 IT 相关。\n\n5G 基站 ⇒ 数字通信\n大数据中心 ⇒ 算力\n人工智能 ⇒ 大模型应用\n工业互联网 ⇒ 制造业的软硬件。\n\n可以这样说，政府明年会大力投资 IT 领域，大部分投向上面四个方向。跟这些方向吻合的项目，会得到政府的大力扶植，也有最多的机会。我觉得，如果可能的话，大家可以做一些准备，往这些方向靠，规划自己下一步的发展。科技爱好者周刊（第 281 期）：新基建的政策选择 - 阮一峰的网络日志\n\n东数西算\n\n《加快新型基础设施建设》\n\n二氧化碳为什么会让地球变暖？\n太阳作为恒星，向宇宙源源不断发射电磁波。这些电磁波的波长很短，大部分以可见光的形式来到地球。这些电磁波携带能量，撞击地球以后，就让地球变暖。但是，地球作为行星，也会向宇宙发射电磁波！不过，地球因为温度低得多，发出的电磁波的波长要长得多，属于红外线。地球的温度就是由这两种电磁波决定的。太阳光带来热量，地球的红外线进行散热，带走热量。大气层在其中扮演了重要的角色。一些大气粒子阻止太阳光的进入，而另一些粒子阻止地球红外线的逃逸。二氧化碳、甲烷和一氧化二氮，就能阻止地球红外线的逃逸，但是允许太阳光通过。这意味着，这些气体的增加，会让更多的热量留在地球，使得大气温度升高，就像温室的效果一样，所以被统称为”温室气体”。人类使用煤炭、石油和天然气，都会产生大量二氧化碳，这就是全球变暖的主要原因。另一些气体会产生相反的效果，例如二氧化硫让红外线通过，但是会阻止太阳光的进入。火山的剧烈喷发会产生大量的二氧化硫，因此能使地球降温。所以，有一些科学家提出，为地球降温的一种方案，就是在大气中散播二氧化硫微粒。\n\nGitHub 2023年统计报告（英文）\n![](G%20Attachments/ed8c077dd68c4a108e7bd2b72a35bbb7_MD5.webp /&gt;GitHub 官方的报告，美国用户数量依然第一，中国去年被印度超过，从第二变到第三。（@WFANG12719投稿）另外，维基百科公布了今年访问量最大的页面，ChatGPT 第一，印度的板球世界杯和板球联赛第三和第四。印度在互联网世界的影响，真是越来越大了。\n\n《个人使用说明书》\n《个人使用说明书》\n\n毕业？躺平？创业！\n毕业？躺平？创业！\n\n广西城市\n秀甲天下！《新千里江山图·壮美广西》畅游八桂\n\n日记类应用 Journal（中文名：手记）\n![image.png](G%20Attachments/3fba19cc64aca22614d1e6b97a3f9682_MD5.png /&gt;看到苹果这个官方新 App，惊了\n\n中央定基调，明年经济工作这么干！\n中央定基调，明年经济工作这么干！\n\n好用工具\n\nllamafile 是运行 LLM 最方便的方法（英文）｜运行 AI 模型最方便的方法\n上周，Mozilla 发布 llamafile。这是运行 AI 模型最方便的方法，只要下载一个二进制文件，就能在本地运行模型。本文是操作步骤介绍。\n\nCloudscape\n一个 React 组件库，专为云产品设计的。\n\nVineJS｜Node.js 的表单验证库\n一个 Node.js 的表单验证库，只用于后端，支持大量验证规则，验证速度快。\n\nPython Online Compiler｜网页运行 Python 代码、显示运行结果的编译器\n一个在网页运行 Python 代码、显示运行结果的编译器，可以指定 Python 版本。\n\nIP 工具箱\n一个开源的本地网站，集成了 IP 相关的各种查询。\n\n33 字幕｜识别/制作音频和视频文件的双语字幕\n一个 Win/Mac 桌面软件，用于识别/制作音频和视频文件的双语字幕。\n\nvue-draggable-plus｜Vue2 &amp; Vue3 的拖拽组件\nVue2 &amp; Vue3 的拖拽组件。\n\n周刊工具搜索引擎\n![](G%20Attachments/9ba4c9aeac34d5d0b8113779bedb108c_MD5.webp /&gt;网友整理了周刊过去介绍的所有工具软件，做了一个搜索引擎，提供语义搜索。Aha Vector Search\n\n有趣站点\n\n3D 植物｜3D 植物构建器\n一个在线的 3D 植物构建器，可以调节各种参数，生成一个 3D 模型。\n\n学习资源\n\nLLM 可视化｜大型语言模型（LLM）原理讲解\n这个网站提供大型语言模型（LLM）原理讲解，每一步讲解都在右侧配上动画。\n\nJavaScript 中验证 URL 的新方法（英文）｜验证字符串是否为有效 URL\nJS 新增了一个 URL.canParse()方法，可以验证字符串是否为有效 URL。\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新325天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_12｜周五｜☀️":{"title":"2024_01_12｜周五｜☀️","links":["D-Unsorted/查理-·-芒格的100个思维模型","tags/场景/城市","D-Unsorted/埋点数据可视化的探索与实践"],"tags":["Logs/日记","场景/城市"],"content":"三春序 - QQ音乐\n\n\n每日一句、\n\n1、正则表达式\n正则表达式让程序员感觉像一个强大的魔法师，但这不是一件好事。复杂的正则表达式很难理解，也很难调试。我认为，应该尽可能避免使用它们，大部分正则表达式都可以用更易读的代码替代。— Terence Eden\n\n2、\n软件需要有人通盘理解它的运作机制，所以单个工程师有可能比一个职业开发团队造出更好的产品。因为单个工程师花时间，完整理解了他要构建的软件，而职业开发团队总是从一个项目转移到另一个项目。这也是为什么接手不熟悉的项目，比重建该项目要困难得多，以及为什么软件外包的质量总是如此糟糕。— 《突然间我懂了软件》\n\n3、\n未来的内容生产，就是两种趋势的斗争。一种是 GPT 工具快速、廉价地生产出大量的文章，造成巨大的内容污染。另一种是更多的人可以借助 GPT，更容易地创作更多优质的内容，内容行业的进入门槛会降低，对周围一切的理解将会更加深入。— 《AI 如何改变我们的知识》\n\n文章学习\n\n合同期满，单位提出不续签，要支付经济补偿吗？\n  合同期满，单位提出不续签，要支付经济补偿吗？\n\n《繁花》\n刚刚落幕，上海当年的水有多深！\n\n查理 · 芒格的100个思维模型\n查理 · 芒格的100个思维模型07｜查理 · 芒格的100个思维模型\n\n越南人口，已经超过河南了！城市\n经过了半个多世纪的高速增长，越南人口终于达到了一亿这个里程碑。这个结果并不让人惊讶，因为越南人口的增长一直是有迹可循的。1945年越南宣布从法国独立时，全国人口大概有2000万，在工业化、经济增长和短暂的和平期中人口迎来爆发。1976年南北越统一，户籍人口达到4700万，平均每个家庭约养育3个孩子，人口逐年上升。直到1988年10月，越南颁布家庭计划政策，规定每个家庭最多只能生育两个孩子，最低生育年龄至母亲22岁、父亲24岁，并且第一、二胎之间要间隔3年。该政策维系了30多年，至2020年5月才由时任越南总理阮春福更改，转向鼓励生育。越南人口，已经超过河南了！\n\n埋点数据可视化的探索与实践\n埋点数据可视化的探索与实践埋点数据可视化的探索与实践\n\n好用工具\n\nVisActor｜前端数据可视化\n![](G%20Attachments/745c5cf6a41c439e60047445f9494b3a_MD5.webp /&gt;一个字节出品的前端数据可视化解决方案，分成图表库 VChart和表格库 VTable。科技爱好者周刊（第 286 期）：蓝色指示灯的解决方案 - 阮一峰的网络日志\n\nh5player for tampermonkey｜油猴脚本｜H5 视频网站增强功能\n一个油猴脚本，为 H5 视频网站增强功能（多级播放速度、截图、画中画、调节亮度、饱和度、对比度等），支持各大主流视频网站。（@xxxily 投稿）照片修复小小助手｜消除图片中指定的人和物一个开源的微信小程序，用来消除图片中指定的人和物，纯客户端实现，无服务端。\n\nmdcat｜命令行显示 Markdown 文件渲染后的内容\n一个cat命令的替代品，可以在命令行显示 Markdown 文件渲染后的内容。\n\nSuperCopy（超级复制）\n![](G%20Attachments/ba6fc786178f48fe5e86e5440380a97a_MD5.webp /&gt;一个浏览器插件，用来解除网页限制（比如禁用右键），然后复制网页内容。SuperCopySuperCopy 插件\n\nVue DevTools Next\nVue 官方开发者工具的下一个迭代，旨在增强 Vue 开发者体验。\n\nyft-design｜片编辑应用\n基于 fabric.js 的名片编辑应用。\n\nant-codeAI｜代码生成\n![](G%20Attachments/866a93c6ce05597c1675bdf8fe463d54_MD5.webp /&gt;通过 OpenAI、Gemini 等模型，生成 Web（React，Vue，Tailwind CSS）和 native（react native）代码。（@sparrow-js投稿）\n\npaint-board｜画板项目\n一个开源的画板项目，汇聚了很多创意画笔，试用 demo。\n\nRead Copilot｜阅读器 App\n一个苹果设备的阅读器 App，支持 RSS 和 Read It Later 功能，并可以用 AI 生成总结、文章大纲和翻译。\n\n海豹 D2C｜将设计稿导出为 React、Vue、RN、微信小程序代码\n一款 Figma/MasterGo 的插件，将设计稿导出为 React、Vue、RN、微信小程序代码。\n\nvscode-common-intellisense｜代码提示\nVS Code 插件，为主流的前端框架提供代码提示（intellisense）。\n\ncreenshot Beautifier｜截图美化\n\n\n开源的页面截图美化工具，试用 Demo。\n\nYazi｜文件管理器\n一款运行在终端里面的文件管理器，跨平台，支持图片预览，使用 Rust 语言开发，速度快。\n\nAI 换脸\n上传图片和视频，可以对里面的人物进行换脸。\n\nAI Search｜搜索引擎｜结果的总结\n这是一个搜索引擎，除了搜索结果，它还会根据你选择的语言，给出搜索结果的总结。\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新326天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_13｜周六｜☀️":{"title":"2024_01_13｜周六｜☀️","links":["D-Unsorted/代码洁癖的前端工程师是如何写代码的！","D-Unsorted/拯救强迫症！前端统一代码规范","D-Unsorted/9亿人在朋友圈消失：为什么现在的人，都选择关闭朋友圈！"],"tags":["Logs/日记"],"content":"探窗 - QQ音乐\n\n\n每日一句\n\n1、\n每当你认为别人毁了你的生活时，实际上是你自己毁了你的生活。受害者心态是一种非常有害的心态。如果你换一种心态：无论情况多糟糕，这始终是你自己的问题，并且你尽力来解决它。我认为这更有效。— 查理·芒格，美国著名投资家，本周去世，享年99岁\n\n2、\n不要追随你的激情，追随你的努力。— 马克·库班，美国企业家\n\n3、知识错觉\n”知识错觉”（the illusion of knowledge）指的是，你自以为懂得或掌握了某种知识和技能，但是实际上并不懂。最近的一项研究表明，互联网可能会助长人们的”知识错觉”，过度自信自己的技能水平。研究人员让实验的参与者，重复观看某种技能的视频，例如投飞镖或者跳霹雳舞的视频，最多可以看20次。看完以后，参与者需要预估一下，自己对这项技能的掌握程度。大多数人表示，通过观看视频，他们已经一定程度上掌握了该项技能。而且，观看视频次数越多的人，回答越确定，自信心越强。然后，每个人需要当众展示该项技能。结果令人非常失望，他们显然都没有掌握。研究人员说”他们的实际表现没有显示出任何学会的迹象。“程序员尤其要小心这种错觉，千万不要看完教材或文档，就认为自己掌握了某项技能，一定要自己动手用它做过项目，才算学会。\n\n文章学习\n\n代码洁癖的前端工程师是如何写代码的？\n代码洁癖的前端工程师是如何写代码的？代码洁癖的前端工程师是如何写代码的！代码洁癖的前端工程师是如何写代码的？拯救强迫症！前端统一代码规范拯救强迫症！前端统一代码规范 - 掘金代码洁癖系列（一）：什么是整洁代码代码洁癖系列（二）：命名的艺术代码洁癖系列（三）：整洁的类和函数代码洁癖系列（四）：可忽略的注释代码洁癖系列（五）：外在的格式美代码洁癖系列（六）：处理错误代码洁癖系列（七）：单元测试的地位代码洁癖系列（八）：迭代的原则【译】微软如何进行代码审查\n\n9亿人在朋友圈消失：为什么现在的人，都选择关闭朋友圈？\n\n环境塑造人\n\n9亿人在朋友圈消失：为什么现在的人，都选择关闭朋友圈？9亿人在朋友圈消失：为什么现在的人，都选择关闭朋友圈！9亿人在朋友圈消失：为什么现在的人，都选择关闭朋友圈？\n\n把问题写下来，就能改善\n我们在自己的人生中会不断碰到问题，这是人类的宿命，没有人可以逃脱。**问题无疑会给人带来挑战、困扰甚至是烦恼，但是如果没有问题，人生又会过于平淡无奇。**因此无论是主观还是客观上，「没有问题」是一种几乎不可能出现的状态；而不断遇到问题，是人生的常态，无论你是男人、女人、老人、小孩、正在工作岗位奋斗着，还是在家平躺着。所以，我们的问题不是如何没有问题，而是如何面对问题？因为我们无法解决所有问题，所以我们的期待应该转化为「如何面对问题」，而不是「如何解决所有问题」。的确有一些问题无解，或者即使有解，一时半会也无法根本解决。而我最近有个认知，只要你能尝试把自己所遇到的问题写下来，就能有所改善。原因有几点：\n\n通过写作可以清晰地厘清问题。原本只是模糊的问题，但是通过书写的过程，就能做有效的澄清。\n通过写作可以拆解问题。原本可能是一个大问题，但是通过拆解为几个更小的问题，从而找到解决的可能。\n问题只要写下来，就能更好地向他人，甚至向ChatGPT、豆包之类的大模型工具求助。\n\n比如我最近正在面对的问题包括：1、中年人的最大挑战是什么？为何在中年时更难感受到生活的快乐，仿佛阈值抬升。2、如何面对孩子的教育问题？3、如何有更好的健康状态？4、如何找到更多写作的话题？5、如何拥有更多的自由时间？6、如何提升自己的管理能力？…不写不知道，一写就停不下来，看来要面临的问题还真是不少。我们从中找一个问题，进行更深入的求解。比如关于「中年人的挑战是什么」这个问题，我在朋友圈提出这个问题，得到的答案大都集中于「上有老，下有小带来的生活压力」。但对我而言，问题出在另一方面：如何能在日常的生活中获得更多的快乐。我忘了在哪里看过一篇文章，也在讨论类似的问题，大意是中年人可能是阈值提高或者生活状态改变的原因，所以原本一些让自己快乐的事情，现在无法带来那么多快乐了。比如以前两个人的时候在周末要么去逛商场，要么开车跑山。尤其是跑山这件事，蛮有意思的。一般是在地图上找一个点，规划一条路线，开车过去。那里有什么景点不重要，最重要的是一个没有去过的地方，最好路线也有全新的部分。然后一路开过去，再换一条路开回来，如此一来一回，一个美好的周末的就过去了。记得那时在跑山的时候经常碰到类似的人，要么骑着摩托车，要么开着各色的汽车。在一些小路处慢下来会车时，会摇下窗户打招呼，问「哥们，再往里有啥」，往往得到的回答是「啥也没有，瞎转」。看起来周末没事瞎转的人挺多，各有各的乐趣。但近些年，也不知道什么原因，这项乐趣离我们越来越远了。偶尔周末终于找个时间，说去怀柔的餐馆吃顿饭。饭后再找个借口往山里开，往往会被全家老小批判一顿，原因是「绕路」，大家晕车。于是找个就近的路口，老老实实往回开。为什么会发生这样的变化？显而易见，家庭的状态在变化，以前是两人世界，现在是三口之家，需求发生了明显的变化。而随着我日常余闲时间的减少，偶尔出现的余闲就必须精打细算，用在「性价比」最高的地方。在这个时候，去山里瞎转悠显然就不是一个「明智」的选择。而生活的乐趣往往就在于放下「功利性」的判断，随心所欲的分配时间，并且与计划之外的景色、人物和事件遭遇。任何事情一旦计划好了，甚至是精打细算，自然缺少惊喜感 —— 原来，乐趣不是计划出来、而是意外邂逅的。……如此这般，把我所遭遇的问题写一写，大体就获得了一种看问题的角度，能让我们从问题自身跳出来，站在一个全新的角度看到自身所遭遇的困境。即便没有一个完全的解题方法，也能让我们对当下的困境有一定的释然。这就是写下来的好处。所以，无论你是谁，无论你的生活状态如何，无论你正在遭遇什么样的困境，我有一个「秘籍」与诸位分享，即「把自己所遭遇的问题写下来」。只要写下来，我们就有机会重新审视问题，找到全新的角度，而面对问题的心态，也会发生变化。问题不会消失，新的问题会不断出现（甚至是涌现），让我们拿起纸和笔或者电脑键盘，与问题周旋 —— 也许，与问题周旋，就是人生最本质的一种乐趣。把问题写下来，就能改善AI模特换装的前端实现\n\n好用工具\n\n时间追踪工具\n![image.jpg](G%20Attachments/dc93bcffb96e3c6833d9d29e544f6e62_MD5.png /&gt;四款主流时间追踪工具及它们的隐私特性 - 少数派\n\nDeno Cron 发布（英文）｜定时运行功能 Deno Cron\n![](G%20Attachments/ecbfb142df4f842836a4c21ea1e6fa74_MD5.webp /&gt;JS 云服务 Deno Depoly 宣布，推出定时运行功能 Deno Cron。如果需要定时执行 JS 脚本，以后多一个选项。科技爱好者周刊（第 280 期）：机器点餐与宅文化 - 阮一峰的网络日志\n\nBiome｜JS 工具箱，零配置就能实现 JS 脚本的格式化和 Lint\nJS 语言格式化工具 Prettier，提出谁能用 Rust 语言重新实现它，并通过所有测试用例，就能获得2万美元，因为它们自己没有资源做这件事。![](G%20Attachments/93f7ca9784ef64ef52ec403adb97a761_MD5.webp /&gt;结果，只过了两个星期，Biome 就赢得了这场比赛。Biome 是一个 JS 工具箱，零配置就能实现 JS 脚本的格式化和 Lint，性能出众。\n\nIP Guide｜查询 IP 的地理位置\n该网站提供免费 API，查询 IP 的地理位置。\n\nChrome-macOS-Screen-Saver-Tab｜显示 macOS 的 4K 航拍屏保视频\nChrome/Edge 浏览器插件，让空白标签页显示 macOS 的 4K 航拍屏保视频，就像真屏保一样。\n\nstreamlit-shadcn-ui｜Python组件库\nPython 的 Web 框架 streamlit 的一个组件库。\n\nRsbuild｜取代 Webpack的Web 构建工具\n一个 Web 构建工具，可以取代 Webpack，减少 90% 的配置并获得 10 倍的构建速度。\n\nChatfairy｜网页聊天室\n一个极简的 Python 脚本，只用115行，实现一个网页聊天室，使用 SSE 进行后端消息推送，对 Python 全栈开发感兴趣的朋友可以参考。Gmeek｜issue博客网站超轻量级个人博客模板，将 GitHub 的 issue 转成博客网站。\n\nai-teacher｜ChatGPT 的前端开发示例\n一个 ChatGPT 的前端开发示例，可以当作代码参考。\n\nDevOpsGPT｜根据根据需求生成开发文档，然后生成软件代码\n一个 LLM 应用，根据根据需求生成开发文档，然后生成软件代码\n\nSDXL Turbo 体验站｜文生图\n免费使用 SDXL Turbo 模型，快速文生图，基本没有等待。\n\n技术播客节\n12月4日~12月8日，在主要的中文博客网站，每天会集中上架一批不同技术主题的中文博客。\n\n学习资源\n\nataiva.com｜Docker 和机器学习的系列教程\n一个英文的个人网站，里面有作者写的 Docker 和机器学习的系列教程。\n\n生成式 AI 初学者教程（Generative AI for Beginners）\n微软推出的入门课程，介绍生成式 AI，一共12课。\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新327天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_14｜周日｜☀️":{"title":"2024_01_14｜周日｜☀️","links":["D-Unsorted/那些年你读过的IT经典，都在这儿了！"],"tags":["Logs/日记"],"content":"寻春纪 - QQ音乐\n\n\n每日一句\n\n1、\n当你成为某个领域的专家，遇到的问题就会非常具体，很可能只有少数人遇到过。再想进一步前进，互联网也不是很有用，只能靠自己摸索、应用、实验和协作。这些都相当慢，这就是为什么专家再要提升自己，往往要花费数年时间。— 《像旅行者一样学习》\n\n2、\n遥远的事物总是对我有一种永恒的吸引。（I am tormented with an everlasting itch for things remote.）— 《白鲸》，美国经典小说\n\n文章学习\n\n如何用Notion打造第二大脑？手把手搭建最强笔记体系！永不遗忘！生产力MAX！\n\n只记录有共鸣的信息\n\nyoutu.be/pjPgmaHIDAE\n\n渐进式笔记\n\n\n\n自己的思考\n\n![image.png](G%20Attachments/b9c8510ee0c81460b23cbd06e6618098_MD5.png /&gt;如何用Notion打造第二大脑？手把手搭建最强笔记体系！永不遗忘！生产力MAX！_哔哩哔哩_bilibili\n\n【熬夜】有技巧吗？\n\n子午觉：12点觉要睡，打盹也行，10分钟-20分钟\n猫睡：学会打盹，只要有空就趴着\n数息：深度睡眠，数呼吸，从1-10，只数出气，走神重新开始\n晨昏打坐：早晚日出前后，5-10分钟的打坐冥想，全身放松\n\n【熬夜】有技巧吗？_哔哩哔哩_bilibili\n\n何谓【优秀】？何谓【卓越】？\n优秀：正常情况下能超常发挥。卓越：各种超常情况下都能正常发挥基本水平。比如是指悬崖绝壁 比如一步迈错了满盘皆输的情况，还能从容不定。 何谓【优秀】？何谓【卓越】？_哔哩哔哩_bilibili\n\n那些年你读过的IT经典，都在这儿了！\n那些年你读过的IT经典，都在这儿了！那些年你读过的IT经典，都在这儿了！\n\nAI原来可以让手机电脑这样⁉️ 夏威夷骁龙峰会VLOG🏝\n\nNPU\n\n点击查看【bilibili】\n\n用x光拍视频？！\n\n安全检查\n探伤\n医疗：CT/DR\n\n\n\n永艺腰撑椅子\n\n![image.png](G%20Attachments/f4c5a59c261e566ce9bcfa6a02c7c573_MD5.png /&gt;用x光拍视频？！_哔哩哔哩_bilibili\n\n网络社区的悲剧\n大多数社区都是这种模式，都会经历五个生命阶段，然后走向死亡。我觉得，他描述得非常精辟，我分享出来，大家看看是不是这样。\n\n第一阶段：社区成长期。\n共同的兴趣爱好让一小群用户聚在一起，所有人充满热情，在网上交换意见、分享知识。新人受到热烈欢迎，并得到耐心指点。\n第二阶段：社区流行期。\n加入社区的新成员快速增长，总是提一些相同的初级问题。老成员不断回答同样的问题，感到疲惫不堪，也非常无趣。有些人开始离开。\n第三阶段：社区规范期。\n为了避免讨论质量的下降，老成员开始制定一套详细的社区规范，以及冗长的常见问题解答。\n但是，新人从不认真阅读，有些人还认为这些规范令人不满或难以理解。于是，成员之间的冲突发生了，管理社区的核心成员对异议的容忍度下降，不同意见的人往往被赶走，社区发生分裂。\n第四阶段：社区滑坡期。\n新成员开始变少，社区逐渐冷清，大家热烈参与的话题越来越罕见，一些长期成员开始流失。\n第五阶段：社区终结期。\n社区陷入停滞，新成员和新内容都停止了增长，显得非常萧条，所用的软件平台也过时了。最后，只有少数彼此认识已久的成员还在，偶尔冒泡，聊一些无关的生活感想。\n\n科技爱好者周刊（第 279 期）：网络社区的悲剧 - 阮一峰的网络日志\n\n文档第一，会议第二\n”开会文化”对公司是有害的，创业公司尤其要避免大量的会议。创业公司应该少开会，多写文档。文档第一，会议第二。（1）创业公司争分夺秒，会议非常浪费时间。当然，并非所有的会议都是不必要的，但是原则上，会议应该尽量不开，参加人员也应该尽量精简。（2）不断开会恰恰表明一个更深层次的问题：缺乏清晰、可访问和可靠的文档。如果每个流程都有文档，就不需要一个小时的会议来澄清。**如果每个决定都有文档，就不需要满屋子的人来理解它的理由。**如果每个团队都有文档，就不需要在新成员加入团队时进行小组讨论。（3）**会议创造了生产力的幻觉。**你以为，开会提高了生产力，实际上它们正在阻碍它。每一次不必要的会议都是一种浪费。那些时间本可以用来改进算法，哪怕用来学习或者休息也很好啊。从本质上看，减少会议不仅仅可以节省时间，还可以让大家更专注、更多创新和创造，这恰恰是创业公司的命脉。（4）**会议往往会自动膨胀。**你召集了半小时的会议，快速讨论一个小问题。结果，在会议中发现一个意想不到的问题非常重要，你们的争论就一口气持续了两个小时。（5）**会议不容易确定细节。**你提到了一些别的事情，或者说话含糊不清，再或者双方沟通不畅，会议就会变得不那么清晰。解决方法到头来还是要写下来。（6）**会议往往偏向声音最大的人，而不一定偏向那些有最好想法的人。**这会扼杀创新和思想的多样性。作为对比，文档提供了公平的竞争环境，每个团队成员都可以表达他们的想法和见解，它促进了一种深思熟虑和反思的文化，而不是草率的判断和冲动的决定。（7）结论：你的时间和资源最好花在记录上，而不是花在会议上。大多数会议很容易被一份精心起草的、提供相关数据和建议、并征求反馈意见的文件所取代。\n\n好用工具\n\nElog｜发布到博客平台\n![](G%20Attachments/27d9d6c7c7b137a682705838e0f051aa_MD5.webp /&gt;该工具可以将写作平台（语雀/飞书/Notion/FlowUs）的内容，发布到博客平台（Hexo/Vitepress/Confluence/WordPress）等。elog.1874.cool/\n\nPPz’s chrome filter｜让页面变为暗模式\n一个极简的 Chrome 插件，让页面变为暗模式，只有11行 JS，可以用作入门示例。\n\nEpubPress｜制作成一本 epub 电子书\nChrome 浏览器插件，可以将打开的多个网页制作成一本 epub 电子书。\n\nvectorious｜矩阵计算\n一个用于矩阵计算的 JS 库。\n\nObsidian 系统教程\n(95) 也许是最全面的Obsidian教程！【Obsidian公开课 课时1】顶级知识管理神器、双链笔记先驱——OB保姆级教程 - YouTube\n\n日记模版\n视频地址：www.bilibili.com/video/BV1bW4y1K7rX/模版地址：resisted-circle-5ed.notion.site/6e5ceaa4c3654769923b52730be47b2d\n\n百词斩网页助手｜浏览器扩展，支持取词翻译、收藏单词等操作\n一个浏览器扩展，支持取词翻译、收藏单词等操作，可以与背单词 App”百词斩”配合使用，建立自己的单词本。\n\n有趣站点\n\nVAVE BG｜所有壁纸都是 AI 生成的\n一个壁纸仓库网站，所有壁纸都是 AI 生成的。\n\n柏林室内泳池\n德国首都柏林有一个传统，就是建造非常华丽的公共泳池。现在，柏林有60多个室内公共游泳池，许多都令人惊叹，感觉就像在宫殿里游泳一样。![](G%20Attachments/577517bacf3e1b38ca7ddd596adc06e6_MD5.webp /&gt;柏林每年有600万游客，很多人专门去这些泳池游玩。有些旅游书籍，专门有一个章节，介绍这些泳池。\n\n学习资源\n\n谷歌编程风格指南\n谷歌内部对各种语言的编程风格的要求。\n\nDeno 全指南（英文）\n一组系列文章，介绍 Deno 的基本用法，一共几十篇。\n\nChatGPT 使用入门（中文）\n作者结合自己的使用感受，详细介绍了ChatGPT 注册、开通、使用技巧和原理。\n\nLinux 命名管道简介（英文）\n\n\n本文是”Linux 进程间通信”的系列文章之一，作为初级教程，介绍命名管道的概念，写得简洁清晰。同系列的《套接字》和《Unix 信号》也可以看一下。\n\nTarget=“_Blank” 属性的安全漏洞（中文）\n一篇老文章，介绍网页标签的target=“_blank”属性打开新窗口时，会使得新窗口可以引用原始窗口，因此可能有安全风险。\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新328天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_15｜周一｜☀️":{"title":"2024_01_15｜周一｜☀️","links":["D-Unsorted/不同打包工具下的环境变量配置方式对比","D-Unsorted/如何使用-JavaScript-检测用户是否启用三方-Cookie-！","tags/编程/个人项目/dev-box","D-Unsorted/如何通过自动化流程保证前端代码质量"],"tags":["Logs/日记","编程/个人项目/dev-box"],"content":"芒种 (国语) - QQ音乐\n:::success\n国家的外交政策简直太厉害了，不用强硬手段而是将其孤立起来，但也有一个前提是中国自身必须强大。所以说不管是个人还是国家，首先都得自己先变好了，然后一切才会好起来。瑙鲁宣布同台湾“断交”、愿同中国复交，外交部回应\n:::\n\n\n文章学习\n\n不同打包工具下的环境变量配置方式对比\n不同打包工具下的环境变量配置方式对比不同打包工具下的环境变量配置方式对比不同打包工具下的环境变量配置方式对比\n\n这个视频有亿点“水”！为14亿人保卫江河，有多难？【4K】\n点击查看【bilibili】这个视频有亿点水……\n\n如何使用 JavaScript 检测用户是否启用三方 Cookie ？\n如何使用 JavaScript 检测用户是否启用三方 Cookie ！如何使用 JavaScript 检测用户是否启用三方 Cookie ？\n\nmarkdown也变脸，obsidian + hexo 在群晖NAS上的双剑合璧\n晨聊 篇十七：markdown也变脸，obsidian + hexo 在群晖NAS上的双剑合璧_NAS存储_什么值得买\n\n如何通过自动化流程保证前端代码质量dev-box\n如何通过自动化流程保证前端代码质量如何通过自动化流程保证前端代码质量\n\nJournal\n一系列的心理研究表明，写日记，我们可以重温某个特殊时刻的感受，反思自己的情绪，并表达感激之情，这些都能有效改善人们精神健康状况。MacTalk-池建强的随想录 | 让创作成为一种生活方式\n\n安利3种最顶级的学习方式\n李笑来在《财富自由之路》中说：一个人的学习能力，其实就是一个外挂，天生之外的装备。想想看吧，一个人若是需要什么就能学会什么，这简直就是作弊器啊！随后拥有的，那可是开挂的人生啊！很可惜，绝大数人在这一生中，一直处于装备不全，装备落后的状态……何谈开挂的人生？根据我对身边人的观察，我觉得现状比李笑来老师说的还要悲观。大部分人根本就没意识到需要学习精进，知道学习的人又没办法准确定义什么是学习，还有很多人甚至不知道从什么途径学习……你可以问问自己，这三个问题，能给出精准的答案吗？如果你暂时没有答案，那也没关系，接下来一段时间，老陈会分享这一系列答案，希望能帮到你。今天先聊聊3种最重要的学习方式：向书本学、向人学和向自己学。\n\n1、向书本学，自我教育\n向书本学，就是自我教育的过程，通过读书、上课等方式，精进自己。但读书就是学习吗？并不是，读书只是接收信息。只有能改变你行动的信息才是知识，才算真正的学习。那什么是人的改变呢？成甲老师曾说，单从学习改变行动的角度谈，我觉得大概有两种模式的改变，一种是修眉毛式的改变，一种是修气质式的变化。所谓修眉毛，是指“学以致用”式的学习：我们有明确的问题、目标要去解决、实现，学习的目的就是去解决这个问题。而修气质，是指“无用之用”式的学习：我们可能没有明确的任务和问题，只是享受着在纯粹满足好奇心的过程中，塑造和改变自己。修气质式的学习，听起来没什么功利性目的，但其实它也在改变我们的行为。只不过，它的发力点是我们行动背后的基石——内在的价值观、精神气质等。所谓“腹有诗书气自华”，大概就是这个意思。老陈觉得这两种学习方式并不是非黑即白的关系，大家在寻找学习方法的时候，也一定不要生搬硬套，必须要根据自己的实际情况，找到匹配的学习方案。比如，如果年龄比较大了，那么多读点修气质的书，享受人生最重要。如果还年轻，就要刻意学习，修炼自己的硬本领，也就是修眉毛。当然也不是完全不去修气质，我们可以建立自己的精学体系和泛学体系，实现内外兼修。所谓精学体系，就是那些需要至少花费1000+小时，持续投入、刻意练习的技能，比如我自己就要精学阅读、写作、时间管理、自媒体运营，我就会看大量这方面的书。泛学体系，就是那些扩大我们认知边界、世界观的书，我自己会用听书的方式进行泛学。听书确实转化率低，但它可以填补我们的碎片时间，比如走路、运动的时候都可以听书。还可以增加背景知识，扩大我们的理解力池子，也能帮我们选书，听完一本书如果很精彩，就可以再读一遍。你看，一罗列，听书的好处竟然有这么多，也不要小看这些碎片学习，听的多了，就会形成庞大的积累，这就是建立泛学体系的重要性。其实，修眉毛也并不影响我们提升修养，相反，从修眉毛入手，就多了一份实践、经验、能力和自我认识的积累，这既是为提升修养做准备，本身也是一个提升修养的过程。无论是修眉毛还是修气质，只要我们开始行动，投入足够多的时间、精力，在实践中不断迭代，就能逐步积累足够多正确的知识、拓展可靠的能力圈、赢得越来越多人的信任。此后，这些积累还会彼此发生化学反应，突破临界值，产生芒格所说的“lollapalooza effect”（叠加放大效应）。这个过程就可以被称为“复利人生”。\n\n2、向他人学，以人为镜\n所有的学习最开始都像是在照镜子，当我们学到了就换一个老师，换一面镜子，直到有一天你发现，你的新的镜子里是你自己，你就有你自己的方法了，你就可以做别人的镜子了。一个人如果只封闭在自我的世界，就很难发现自己的问题。关于向他人学习，我觉得猫叔的一个观点非常精彩：向上学，向下帮。有的人，习惯于当老师，在很多地方都展现出老师的姿态，常年做向下帮的事情，不愿意放下老师的架子去向人求教，于是很难得到高人的建议和帮助，自己的高度也上不去。而有的人，习惯于当学生，总是向别人请教，学到了很多东西，但却很少对外输出，很少帮助别人，于是，很难升级自己的影响力。该当老师的时候，好好输出，好好给其他人提供帮助，很好。该当学生的时候，谦逊有礼，用心吸收，争取学到精髓，很好。但千万不要只习惯于当老师，或者只习惯于当学生。两个角色不断切换，让自己不仅能好好向上学，也能好好地向下帮，成长速度会更快，赚钱也会容易很多。向上学，很努力；向下帮，也很努力。这是很多牛人的核心成功秘诀。我自己就正在践行这个方法，我会向我的老师逆熵増者、阿猫、公众号同行学习，我会付费购买他们的课程，也会拆解他们的文章。同时，我也在向下帮，我把我学的知识，都分享出来，希望帮助到更多人，影响更多人爱上读书。\n\n3、向自己学，复盘反思\n联想的创始人柳传志说，我们向书本学、向别人学，只占到30%，剩下70%都是向自己学。因为，学习是为了认识自己、改变自己，所以无论向书学也好，向人学也好，学习最终必须回到自己，去消化、吸收和转化，进而让自己发生改变。那么，该怎么向自己学呢？就是向自己过去的经验教训学习。过去发生的事情，现在也会发生，未来也有可能发生，所以一些过去发现的联系，现在也同样成立，关键就在于找到过去那些不变的联系，我们就可以做到预测未来。正如弗洛伊德所写：“一个人对过去和当下知道得越少，他对未来的判断就越没有保障。”就像你去做销售，卖一件东西，没卖出去，那一定是话术或产品某方面有问题，如果你不去找到问题的本质，还沿用原来的方法，那么你现在依然会卖不出去，未来也一定卖不出去。人最难消除的是自己的固有模式，我们做不成事情、反复失败，往往是受自己的固有模式影响，认知不变，行为就不变，结果就不会变。比如以前我经常三分钟热度，原来我以为就是自己毅力不行，现在发现真不是，就是因为没有一套成事心法，完全凭着热情瞎干肯定干不成啊。那应该如何从自己过去的经验教训学习呢？关键就是复盘、反思。刘澜先生还套用e=m×c²，提出了一个公式：知识=经验×反思²。这个公式的意思是：1）没有反思，就没有知识。当反思为0的时候，知识为0；2）即使是一件小事，如果有反思，也会有想想不到的收获。强大的反思，能够从有限的经验中提炼出惊人的知识，就像从小小的铀原子中释放出原子弹的能量。复盘是重新定义的过程，通过观察、反思，重新定义我们习以为常的事物，比如什么叫读书、什么叫学习、什么叫写作、什么叫工作。我们平常遇到大量的问题，很多是因为对底层概念定义不清导致的，如果你无法定义什么是读书，什么是好的读书，那你的读书收获肯定就特别小。以色列的时间专家瑞秋·卡尔尼奥尔说过：当人们的目标和回忆相互连接时，过去和现在以及想象中的未来可以在不经意间进入人们的思绪，让当下染上它的色彩，推动人们做出行动。人们可以用过去来指导未来的目标和计划，帮助他们实现之前选定的目标。最终，人们的目标也能影响他们提取、重构和解释记忆。这句话的意思是，你的过去、现在、未来，都会对你的行动产生重大影响，所以，若想实现自己想要的目标，就必须搞清楚自己的过去、现在和未来。怎么搞清楚？向自己学习，认识你自己。安利3种最顶级的学习方式\n\n碉堡了，外网刷屏的量子纠缠效果\n![640.gif](G%20Attachments/5e84b0c8c3513b6d9a99c0b99636bb33_MD5.gif /&gt;碉堡了，外网刷屏的量子纠缠效果\n\n分享我的工具库（2024年版）\n\nObsidian\n我目前的主力工具，从 2020 年初使用至今，见证了它一步步的迭代和优化，目前已经非常完善。尤其是 1.5.0 版本优化了表格编辑体验，加上计划中的数据库功能，几乎可以说没有什么短板了。再加上其轻便灵活的本体、强大的可定制性、丰富而庞大的生态系统，是一款上手难度很低而上限又极高的笔记工具。缺点是多平台同步不太方便，除了官方同步（非常贵）之外，就只能自己动手折腾了。还好目前市面上也有一些成熟方案，比如 iCloud、Remotely Save 和 Syncthing 等，不如官方方便，但基本也够用了。顺便一说，我的公众号文章（包括《打开心智》的初稿）也是用 Obsidian 写的。\n\nflomo\n很灵活又便捷的信息收集工具，我主要用来与 Obsidian 搭配使用。目前主要是三个场景：\n\n手机端快速记录想法，再整理到 Obsidian；\n遇到需要记录的事件时打个卡，留下一个时间记录，便于将来查询；\n有一些需要时刻翻阅的信息放在 flomo 里，方便在手机端随时查看。\n\n\n飞书 / 语雀\n两者的功能很相似，都是用来搭建团队知识库的。我主要用来辅助课程做答疑和内容分享使用。之前用语雀，现在在慢慢迁移到飞书上。主要是感觉飞书更新很勤，整体也更有活力一些。\n\nZotero\n我用来管理文献的软件，老牌文献阅读管理工具了，无需多说。7.0 版本优化了 PDF 的阅读和批注功能，方便了不少。我一般是先把文献全部储存在 Zotero 里，需要精读的文献就在里面阅读、做笔记，再用插件一键导入 Obsidian 里完善知识主题。分享我的工具库（2024年版）\n\n飞书-智能伙伴\n成为工作的入口。然后呢？然后让大模型渗透到工作的毛细血管之中。但具体怎么渗透呢？这块并没有什么确定的答案，业内不同的公司思路不一样，大家都还在摸索中。比如，微软接入大模型的方式是 Copilot——在产品的右侧增加一个 IM 式的对话入口。飞书的方式是智能伙伴，挺拟人化的。有了智能伙伴之后，打开飞书，在“消息”部分，除了可以和同事、客户沟通外，我们还可以和智能伙伴聊天，获取信息或者执行任务，是不是有点像 ChatGPT？说到这里我再多谈两句，ChatGPT 这一年迭代了很多新功能，它被很多人视作 ToC 产品的样板，我反而觉得它 90 %的能力，都极其适合嫁接到飞书这样的以 IM 为轴心的产品之中。一方面，聊天本身就是它的根基。另外一方面，它又是众多企业系统的入口，很适合做集成。具体到工作之中，智能伙伴又分为两部分，一部分是提升内部的协同效率，比如开完会帮忙做总结、建任务，写文档前快速生成模板，这些谈过很多了，不再赘述。另外一部分则是用于提升业务的处理效率，比如自动做数据分析，为业务场景定制专属的智能伙伴等等。为业务而定制的智能伙伴，其实我理解起来类似 ChatGPT 的 GPTs 模式，基于飞书的能力，客户可以自主添加数据源，连接业务系统，这样在聊天窗口中，就能直接通过对话的方式处理业务，而不再需要反复跳转。![](G%20Attachments/c11e871397420bf7df4a73f3e0603d3e_MD5.png /&gt;并且，飞书在底层模型上是开放的，作为一个开放的 AI 服务框架，企业可根据业务场景自主选择适合的底层大模型。飞书这次变化挺大的\n\n好用工具\n\nThings\n🔗 culturedcode.com/things/![](G%20Attachments/d0fdb441efc38717168086cb58d78096_MD5.png /&gt;iOS &amp; macOS 平台上的任务管理工具 Things 也加入了 2023 年「黑五」促销的大军，目前所有应用售价都在原价的基础上打七折，Mac 版本现在售价为 34.99 美元，iPad 版本售价 13.99 美元，至于 iPhone &amp; Watch 版本则直接降至 6.99 美元。今年「黑五」特惠，我们帮你找到了 20+ 个值得入手的软件、服务\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新329天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_19｜周五｜☀️":{"title":"2024_01_19｜周五｜☀️","links":["D-Unsorted/焕然一新的-Vue3-中文文档来了！","D-Unsorted/开发VSCode插件","tags/场景/旅行","tags/编程/FE/监控","D-Unsorted/浅谈前端埋点-and-监控","D-Unsorted/WebCodecs-开启-Web-音视频新篇章"],"tags":["Logs/日记","场景/旅行","编程/FE/监控"],"content":"至味 - QQ音乐\n\n\n每日一句\n\n1、\n有一个名词叫做”报复性熬夜”，指的是有些人明明在白天疲劳不堪，晚上却不愿意早睡，宁愿在床上玩手机。这是因为他们控制不了自己的生活，通过在晚上推迟睡觉，获得一点自己掌控时间的自由感。— 《报复性熬夜》\n\n2、\n我从来不想辩论，但如果必须辩论，我希望自己会输。我宁愿对方的观点是正确的，他来说服我，因为这样会比我的观点是正确的，我来说服他，对我更有趣。— 《我想输掉每一场辩论》\n\n文章学习\n\n学车\n学车两天过科目一！科目二过了！科目三顺利通过了！\n\n焕然一新的 Vue3 中文文档来了！\n焕然一新的 Vue3 中文文档来了！焕然一新的 Vue3 中文文档来了！焕然一新的 Vue3 中文文档来了！\n\n开发VScode插件\n开发VSCode插件开发VSCode插件在vscode中悄无声息地摸鱼\n\n一年、四季、十二道美景，酉阳让你一次赏个够! 旅行\n一年、四季、十二道美景，酉阳让你一次赏个够!\n\n韩国生育率全球最低的原因及启示\n启示：全面放开并鼓励生育刻不容缓，加快构建生育支持体系1.摒弃人口是负担观念，更加以人为本，加快促进人口长期均衡发展。人口是一个国家国力的重要支撑和标志，人是发展的基本要素和动力，一切经济社会的发展都是为了人。从中国历史看，人口增长往往是盛世的一个重要标志，开元盛世、康乾盛世等莫不是人口高峰。人口的质量也非常重要，随着受教育程度提高等，人口质量红利将部分抵消人口数量红利消失的影响。2.应立即全面放开生育，让生育权重新回到家庭。当前人口形势紧迫，正处于第三波婴儿潮中后期出生人口的生育窗口期。一旦错过第三轮婴儿潮，未来再想提升出生人口，则将事倍功半。全面放开，宜早不宜晚，必须尽快。全面放开生育，原本不想生的人还是不会生，但一些想生三孩的人能生，不用担心部分人群、部分地区会大幅多生导致出生人口激增。3.加快构建生育支持体系，大力鼓励生育。营造生育友好型社会环境，解除家庭（再）生育的后顾之忧，让更多的人想生、敢生且把孩子养好。1）实行差异化的个税抵扣及经济补贴政策，覆盖从怀孕保健到18岁或学历教育结束。2）加大托育服务供给，大力提升0-3岁入托率从目前的4%提升至40%，并对隔代照料发放补贴。3）进一步完善女性就业权益保障，并对企业实行生育税收优惠，加快构建生育成本在国家、企业、家庭之间合理有效的分担机制。4）加大教育医疗投入和改革，保持房价长期稳定，降低抚养直接成本。5）加强保障非婚生育的平等权利。尽管不鼓励非婚生育，但对非婚生育的女性及其子女仍需给予一切平等权利，特别是落户、入学等方面，不得歧视。6）完善辅助生殖顶层设计，给有需求家庭定向发放辅助生育补贴券，促进合理需求充分释放。韩国生育率全球最低的原因及启示\n\n浅谈前端埋点&amp;监控 监控\n浅谈前端埋点&amp;监控浅谈前端埋点&amp;监控浅谈前端埋点&amp;监控\n\n前端工程实践之数据埋点分析系统（一）\n前端工程实践之数据埋点分析系统（一）\n\nWebCodecs 介绍（中文）#前端/音视频\nWebCodecs 是一个新的浏览器 API，提供音视频的编解码能力的标准接口。本文介绍这个 API，并提供 demo。WebCodecs 开启 Web 音视频新篇章WebCodecs 开启 Web 音视频新篇章科技爱好者周刊（第 287 期）：禄丰恐龙谷记行 - 阮一峰的网络日志\n\n好用工具\n\nIP-Adapter-FaceID AI｜克隆的脸用于生成的图片\n很多科技媒体都报道了 IP-Adapter-FaceID 这个模型，可以克隆照片人物的脸部，然后通过文生图，将克隆的脸用于生成的图片。作者感觉这个模型效果不错，做了这个网站接入了该模型。\n\nGitblog｜GitHub Issues博客网站\n这个工具可以将 GitHub Issues 转成一个静态的博客网站，单个博客使用免费。\n\nKamera｜查看 EXIF 信息\n![](G%20Attachments/d0f96e6267b7e2d9ab0041ade12d13b5_MD5.webp /&gt;一个开源的照片展示网站，点击可以查看 EXIF 信息，支持 Docker 一键部署。\n\nweapp-tailwindcss｜CSS组件\n小程序使用 tailwindcss 的全面解决方案。\n\nvscode-eslint-disable｜不符合 ESlint 规则时，允许使用快捷键禁止\nVS Code 插件，当某行代码在 VS Code 里面显示不符合 ESlint 规则时，允许使用快捷键，将这个（或这些）规则禁止。\n\nFigureToCartoon｜图片转换成日漫风、3D 风、手绘风\n一键将图片转换成日漫风、3D 风、手绘风等等。\n\nGemini ChatUp｜Gemini Pro\n基于 Gemini Pro 和 Gemini Pro Vision API 的开源聊天应用。支持一键部署至 Vercel，需要 Gemini API Key。\n\nImgae matting｜支持人像和物体抠图\n基于开源模型的在线抠图，支持人像和物体抠图，可以 docker 运行 ，无需 GPU。\n\n优雅简历｜AI 修改、定制简历\n免费的在线简历生成工具，集成 ChatGPT，可以让 AI 修改、定制简历。\n\nGPUPixel｜图像和视频处理库\nC++11 编写的图像和视频处理库，内置美颜滤镜，适合为直播提供美颜，目前支持 iOS、Mac、Android。\n\n有趣站点\n\nreview-2023｜2023年个人总结\n这个仓库收集国内网友的2023年个人总结\n\n学习资源\n\nCSS 网格互动指南（An Interactive Guide to CSS Grid）\n一份 CSS 网格（grid）的教程，包含大量的互动示例。\n\n13个著名的 Node.js 库（英文）\n本文介绍一些 Node.js 的常用库。\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新333天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/2024_01_20｜周六｜☔️":{"title":"2024_01_20｜周六｜☔️","links":["D-Unsorted/我的-Obsidian-使用经验","D-Unsorted/开源、可定制的网页批注工具——Hypothesis"],"tags":["Logs/日记"],"content":"花醉岭南 - QQ音乐\n\n\n文章学习\n\n我的 Obsidian 使用经验\n点击查看【bilibili】我的 Obsidian 使用经验我的 Obsidian 使用经验我的 Obsidian 使用经验 | 程序员的喵\n\n开源、可定制的网页批注工具——Hypothesis\n开源、可定制的网页批注工具——Hypothesis开源、可定制的网页批注工具——Hypothesis开源、可定制的网页批注工具——Hypothesis - 少数派\n\n好用工具\n\n代码在线演示\nmp4-muxer实现纯画面mp4视频 » 张鑫旭-鑫空间-鑫生活参考 Codepen，我做了一个基于 iframe 的代码预览系统 - 掘金\n\n为网页添加按钮， 油猴｜ScriptCat\n油猴脚本初探[油猴脚本开发指南]脚本往页面上添加新元素-油猴中文网bilibili三连按钮demo - Code简介 | ScriptCat\n\n构建个人博客_Obsidian_github.io_hexo\n构建个人博客_Obsidian_github.io_hexohexo-theme-obsidian\n\n博客站点\n![image.png](G%20Attachments/47c12fa02b6f73ee5ef67c9ab4bc9136_MD5.png /&gt;VanBlog\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新334天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/域名备案通过｜2024_01_10｜周三｜☀️":{"title":"域名备案通过｜2024_01_10｜周三｜☀️","links":["D-Unsorted/文件上传下载，这样做最简单~","tags/场景/创业"],"tags":["Logs/日记","场景/创业"],"content":"济南济南 - QQ音乐\n\n\n每日一句\n\n1、\n创业公司几乎就是一个”生活在未来”的地方。在创业的早期，你就像活在未来，因为你只关注一件事，就是如何做出一个未来大受欢迎的新产品。— 《你的问题不是你独有的》\n\n2、\n任何不经常改主意的人，都大大低估了我们生活的世界的复杂性。— 贝佐斯，亚马逊创始人\n\n文章学习\n\n文件上传下载，这样做最简单~\n文件上传下载，这样做最简单~文件上传下载，这样做最简单~文件上传下载，这样做最简单~\n\n胡焕庸线\n 在中国，比“南北”更重要的是“东西”\n\n韩国｜人口\n经济学家早已对此做过深度剖析：限制人口生育很简单，一纸令下就足够，但鼓励生育却很难。尤其是当生育失去传宗接代、养儿防老的象征之后，生育率的快速下滑就会成为常态。更关键的是，人口惯性是跨代际的巨大力量，其反作用力将导致人口反方向变化，而教育和科技进步难以弥补人口的下降。与日本相比，韩国是全球“卷”王，财富不平等状况更为突出，且高房价悬之于顶，因此生育形势的滑落速度也更惨烈。面对这一局面，有韩国官员提议向单身人士征税，而这一说法甚至得到了21%的调查者的认可，其中，50多岁的受访者赞成比例最高为26%。“单身税”现在看起来是无稽之谈，但当发钱都无济于事，未来会不会强行上马，谁知道呢？出生人口下滑，对韩国影响有多大？其一，大量幼儿园、中小学被关停，部分大学也面临倒闭危机。根据韩国教育部的数据，截至2022年3月，包括小学和初高中在内，韩国共有3896所学校关停。由于人口下降对教育存在滞后效应，中小学先行一步，而大学也难以置身事外。据韩联社报道，最近5年间（2018～2022年），韩国地方大学共20余个专业已全部消失，2023年全韩国14所大学的26个专业无人报考。其二，养老金危机开始出现，等到韩国“95”退休时，或无养老金可领。人口数量并不关键，结构和质量更为重要，尤其是年轻人与老年人的比例，直接决定了养老体系的可持续性。据预测，韩国国民年金(National Pension Service)将在2055年耗尽资金。在这个亚洲第四大经济体面临低出生率和人口老龄化问题之际，这将加大政府实施养老金改革的压力。据韩国方面预计，全国将在2025年进入超老龄社会，届时65岁及以上人口占比将达到20%。受此影响，作为养老金大盘的韩国国民年金将从2041年开始出现赤字，到2055年完全耗尽。这意味着若不进行改革，韩国的“95后”们到退休时将再无退休金可领。其三，人口危机出现，不仅将拖累韩国长期经济增长，还会深度影响资产价格。人口是房价的长期之锚。当单身人口增多而出生人口减少，过去形成的房价泡沫，将没有足够多的人来接盘。虽然作为首都的首尔，房价仍旧维持在高位，过去几年涨幅一度冠绝全球，但大多数 “人口危险”地区，房价已出现大幅回调。总之，对于韩国来说，人口断崖的影响刚刚开始。这个亚洲国家，人口彻底崩了\n\n父母应该提升教育的下限，而不是上限｜香港🇭🇰\n我们展开第一点，香港教育优势，也是大家最关心的一点。——语言优势，三语两文未来，一定得看我们中国的市场。我在想从人才角度来看，一个具备中英文背景的中国人，会在市场竞争中脱颖而出，无论在中资背景前往世界，或者世界企业前往中国。讲到这里，我脑海里浮现很多人，李开复、李彦宏、蔡崇信。尤其是李开复的自传，更是映射了时代的发展，是改革开放，从外向内的时代需求。如果他在苹果，能做到副总裁，可以理解成能力和坚持，那么他来组建微软亚洲研究院，更多的就是肤色和血缘。我在想，未来对于人的需求是什么呢？不清楚，但我相信中国企业会更多往外走，有条件的话，外循环可能更加重要。——小班制，安全管理师生比例低至 1:5，最高不超过 1:22。同时，大部分学校配有校车接送，一人一座，并配有跟车保姆。在网上找到一组数据，对比了上海、深圳和香港。差不多，四分之一的上海人口，却有七成的学校。详细数据如下：小学，香港 0.80 所/万人，上海 0.27 所/万人；中学，香港 0.68 所/万人，上海 0.46 所/万人；预算，香港 1.51 亿/万人，上海 0.51 亿/万人。想起了我小时候，小学和中学都是 50-60 人一个班，现在小橙子幼儿园也是 30 人一个班。有时，并不能怪老师没有关注，或者只关注前几名的学生，是真的管不过来。——15 年连读，免费义务教育没有中考，中学是连读六年。有些小学有对口的中学，可以一直连读 12 年，其中官立和资助的，学费全免。同样对比国际学校，香港也有一定的价格优势，一般在 10-20 万港币/年；直资、私立学校的学费，一般在 1-10 万港币/年。父母应该提升教育的下限，而不是上限\n\n重庆未来有望成为“中国工业第一城”！\n重庆是中国的工业重镇重庆开埠后的百余年时间里，城市空间获得大发展，制造业主要有两大推手。**一是全球化。**重庆在1891年的开埠，客观上促进了重庆融入国际市场体系。**百余年前在南岸区龙门浩区域，形成了外商企业的集聚区，可谓是重庆最早的CBD和开发区。**到了改革开放后，重庆的西永、寸滩、空港、果园港、江北嘴等区域的大发展也是得益于重庆深度融入全球化，重庆也通过积极推动内陆开放高地建设，为中国争光。**二是工业化。**重庆在开埠后经历了本土工业萌发、抗战时期工业内迁、大三线建设和改革开放后的工业大发展，重庆的工业发展史，也是百余年来不断承接国内外产业转移并提升自身产业竞争力的历史。重庆成为具有基本的全产业链优势的制造业基地。工业化不但在历史上推动了大渡口、九龙坡，两江新区、重庆高新区等区域的发展，还促进着农民转户和“人的城市化”。先进制造业正与现代服务业联动发展，改变着重庆的面貌，也成为重庆产业链招商的一个重点。![image.png](G%20Attachments/dca4e1833381fcb0087b1837c69a6fe9_MD5.gif /&gt;重庆目前加快吸引全球产业链，正面临产业链领域的哪些全球大势呢？**一是东亚地区已经成为与欧洲、北美并列的三大产业聚集区。**据世界银行发布的《2020年世界发展报告：在全球价值链时代以贸易促发展》报告显示，日韩属于区域创新高地，而中国的优势则在于先进制造业和服务业的聚集，认为中国未来在创新驱动方面的发展，将进一步提升东亚区域的发展能级。二是入世以来中国在全球价值链分工中的地位越来越高。中国一举取代日本，与美国、德国一起成为全球三大价值链的枢纽国，东北亚和东南亚多国围绕中国形成了供应链跨国网络。根据国际货币基金组织发布的最新数据，2022年中国的工业总产值高达5.97万亿美元，不仅超过了美国这个世界第一大经济体，还远远高出日本和德国的总和。我国在制造业领域的主要挑战，是能不能抢占全球产业链的中高端，而不必过于担心越南和印度在中低端产业领域的“抢饭碗”。**三是成渝地区所在的中国内陆地区依旧有着产业升级的巨大需求和前景。**深居内陆的成渝地区，作为正在打造的带动全国高质量发展的重要增长极和新的动力源，正成为产业转移的洼地和产业升级高地、产业链供应链“安全舱”和具有全球竞争力的科创前沿地，成为开放平台、开放通道、开放产业密集的区域，以及未来包括4千万中等收入群体在内的1亿多人口、人均GDP1.5万—2万美元的区域，为全国的高质量发展和共同富裕做出突出贡献。重庆工业自1891年开埠以来（森昌洋火公司揭开重庆近代工业化序幕），工业发展先后经历了抗战时期、“三线建设”、改革开放和直辖等重要时期。目前已拥有全国41个工业大类中的39个，拥有制造业全部31个大类，构建起“1+10+1000”的汽车产业集群和世界级智能终端产业集群，汽车零部件本地配套化率达70%，全球三分之一PC“重庆造”。规模以上工业企业数量占西部地区比重达12.3%。其中，营业收入超50亿的企业49家，超100亿元的企业25家。中国500强制造业企业10家，居西部前列。2022年，重庆全市实现工业增加值8276亿元，全国城市排名第4、内陆城市排名第1。今年1—10月，全市规模以上工业增加值增长5.5%，高于全国平均1.4个百分点；制造业投资增长12%，高于全国平均5.8个百分点；今年前三季度，战略性新兴产业增加值占规模以上工业增加值比重提高至31.9%，“工业第二城”的成色越来越亮。重庆一些发达区域也在加快工业升级步伐，如两江新区正力争到2027年，构建“十百千万”企业集群，培育“百千万”产业集群，成为国家重要先进制造业中心核心承载区。2从工业大城向工业强城的升级之路重庆要想站稳我国的“工业第二城”，乃至成为“工业第一城”，必须要加快推进新时代新征程新重庆制造业高质量发展，深入推动新型工业化，加快将我市建设成为国家重要先进制造业中心，按照问题导向、目标导向和结果导向持续推动制造业做大做强。图源：七一客户端**一是工业投入仍需增加，特别是要加强对工业主管部门的投入。**大市的工业投入要有大市的格局和手笔。笔者对比了各地工业主管部门年度决算等公开资料，2022年度重庆市经信委共收入13.15亿元，而上海市经信委共收入126.87亿元、深圳市工信局共收入110.99亿元、北京市经信局共收入65.81亿元、合肥市经信局共收入27.58亿元、成都市工信局共收入14.65亿元，均高于重庆。要服务好“33618”现代制造业集群体系建设、迭代升级制造业产业结构、全力打造国家重要先进制造业中心，就需要重庆市财政加强政策和资金支持，特别是进一步加大对工业主管部门的经费支持，以保障建设具有完整性、先进性、安全性的现代制造业集群体系等方面的不断增大的刚性支出需求。**二是有效承接产业转移，特别是要加大承接全球产业转移和跨国产业链平台建设。**近年来，为促进产业转移和吸引日韩方向外资，2019年中日（成都）城市建设和现代服务业开放合作示范项目启动建设、成都日韩陆海贸易通道开行，带动2019年至2022年成都对日货物进出口总额接近1500亿，日本成为成都的第三大外资来源国，174个项目相继落户成都，日本企业在蓉投资超2000亿美元，落地成都日企已达239家。重庆在中新合作项目之外，还要进一步寻找有潜力的产业转移和外资来源地加强园区布局和通道建设。同时，还要用好越南总领事馆即将落地的机遇，向南宁等地取经，强化与越南的产业链协同布局，特别学习是南宁的向西向南通过南宁至越南经济走廊、平陆运河经济带与广西沿边临港产业园区联动发展的经验，强化重庆的区域综合布局提升。三是工业结构要升级，特别是通过高质量发展进一步改进产品结构。从重庆和深圳的《国民经济和社会发展统计公报》上看，2022年重庆规模以上工业主要产品有汽车（含新能源汽车等）、微型计算机设备（笔记本计算机等）、智能手机、液晶显示屏、钢材、铝材、水泥等，而2022深圳规模以上工业主要产品是石墨及碳素制品、新能源汽车、电子计算机整机、服务器、民用无人机、充电桩、光纤、手机、彩电、程控交换机、电子元件、半导体存储器，总体上较重庆先进。同时深圳是华为、比亚迪、中兴、康佳、创维、大疆、立讯精密等的总部，先进制造业知名企业较重庆为多。**重庆要为先进制造业企业提供“一企一策”、量身定制的精准化服务。**在两江新区、重庆高新区等重点区域，推动符合条件的先进制造业企业增加资产总量，扩大生产规模，开展兼并重组，不断拓展市场，通过技术改造、研发创新、绿色制造项目等参与国家重点工程、地方重大建设项目的招投标。针对“三高”（高技术、高成长、高附加值）企业在解决“卡脖子”领域的技术攻关方面加大财税支持和政策扶持力度，扩大优惠政策享受面和覆盖面。用好重庆已经获批的全球设计之都、正在逐步聚集的涉外服务机构，正在推进的服务业扩大开放综合试点，为重庆有生产性服务业支持的制造业高质量发展进行夯基强本。重庆未来有望成为“中国工业第一城”！\n\n年失业率与选择创业创业\n现在的青年失业率非常高。官方统计，今年7月份的16岁～24岁青年失业率达到了19.9%。![](G%20Attachments/32f72745a4f35528308a6f951483aaa3_MD5.webp /&gt;前景也不乐观。明年的高校毕业生创新高，超过1000万人加入求职大军。而且，市场上还有很多大龄失业者，也在找工作。这样严峻的就业形势意味着，最终有相当一部分人会考虑创业。我以前一直赞成创业，但是这几年想法有变化，认为创业有三个条件， 只有满足条件，才适合创业。我最近读过一篇文章，作者是美国最大的创业孵化器 Y Combinator 的创始人之一杰西卡·利文斯顿（Jessica Livingston）。她是四个创始人里面唯一的女性。![](G%20Attachments/75f51712cfd84127dc21f672dd76d010_MD5.webp /&gt;她回忆了自己为什么创业，文章的最后一段，她这样说：“你是一块特殊形状的拼图。你可以改变自己的形状，适应公司现有的空缺。那是传统的方案。但是，还有另一种对你和世界通常都更好的方案：围绕你自己的形状，发展出一幅新的拼图。这就是我所做的，我是一个非常奇怪的形状。“她的意思是，你为别人打工，就必须变成别人要求的样子。但这并不是你内心想要的，如果你想顺应自己的内心和天赋，就应该创业。这话没错，但是有一个前提才能成立：你已经定型了，很难被外界塑造了。 这个时候，你走自己的路，内心满意度会高一些。我觉得这是创业的第一个条件。据我观察，大部分的中国年轻人，达不到这个条件。他们都没有定型，人生观和世界观还在发展中。典型的表现就是，说不出自己想做什么，也不知道自己的竞争力在哪里。这种情况下，你不是一块特殊形状的拼图，而是没有自己的形状，还在塑造中。如果这样去创业，你的想法可能随着外界的变化，而不断变化，今天想东，明天想西，这是大忌。反而是给别人打工，公司明确告诉你成为什么形状，你就往这个方向努力。公司把你塑造成型，适合公司的需求，融合进公司的拼图。这就是为什么，大部分创业者都是离职后才创业，因为只有到了这个时候，他们才定型。创业的第二个条件是，要有可行的项目， 不能先注册公司，再找项目。而且，你的项目最好是用户愿意付费的，有的同学的创业项目是拍短视频和直播，我觉得不靠谱。创业的第三个条件是，能够承受负的现金流。 刚开始创业，很可能没有或很少收入，每天却要支出，压力巨大。只有满足上面三个条件，我认为，才适合创业。显而易见，刚毕业的学生不容易满足这些条件。前几年，有一种论调鼓励学生创业，这是不正确的。我的意思不是劝退创业，而是希望大家在越是困难时刻，越不要盲目。 面对失业率上升，你要做的第一位的事情，就是尽快把自己锻造成型，形成稳定的心智和人格，磨练自己的技能。科技爱好者周刊（第 235 期）：青年失业率与选择创业 - 阮一峰的网络日志\n\n2023年 CSS 发展总结（中文）\n![](G%20Attachments/4c2340d98054a38c008b3c8a0f4db892_MD5.webp /&gt;Chrome 团队的总结，2023年 CSS 增加了哪些功能。科技爱好者周刊（第 282 期）：电动皮卡 Cybertruck 的 48V 供电 - 阮一峰的网络日志\n\n一个越南程序员的阿里之旅（英文）\n作者是一个越南程序员，原来在 Lazada 工作。后来，Lazada 被阿里收购，他就来到阿里，在杭州西溪园区呆过一段时间。现在，他已经跳槽到 Booking.com，本文是他讲述自己的故事，以及对阿里的感受。\n\n我的区块链经历\n2022年，我得到了一个机会，一个人去葡萄牙首都里斯本，参加 NearCon 2022 会议。这是一场为期4天的区块链会议和黑客马拉松。参加会议期间，我要为自己的 Web3 项目寻找投资者，并尽我所能推销这个项目。我不习惯干推销，也没有信心详细解释它的加密机制，因为我主要从事前端开发工作。但是，我是一个非常自信的人，不害怕在公众面前讲话，所以第一天我就在大会讲台上进行了推销。我当时是21岁，许多人对我的自信和年龄产生了深刻的印象。我是最年轻的参会者之一，而且根据一些人的说法，我看起来比实际年龄还要年轻。这让我很快结识了很多人，包括开发者、投资者和从事各种加密相关工作的人。令我惊讶的是，NEAR 基金会为这次大会投入了疯狂的预算。考虑到它只是一种相当小众的加密货币，小众到没有在大多数交易所上市，所以会议的规格尤其令人难以置信。大会耗费巨资：免费而且非常好吃的食物、免费的夜总会派对、丰厚的黑客马拉松现金奖励、配有大摄像头和大屏幕的大型会议室，以及良好的大会整体筹备。这很奇怪啊，一家无人知晓的公司，为什么要在技术会议和公共活动上面投入如此多的资金。似乎对他们来说，取悦一些在里斯本度过一个凉爽周末的开发者和投资者，换取对方对他们的更多投资，不对他们实用性存疑的技术丧失信心，才是首等重要的大事。正是由于这件事，从此以后，我就对区块链的生态产生了怀疑。\n\n好用工具\n\nImagine｜免费文生图工具\nMeta 公司推出的文生图工具，使用 Facebook 和 Instagram 的11亿张图片训练，现在可以免费使用。\n\nNotebookLM｜文档提问\n谷歌发布的 AI 笔记工具，用户上传文档，然后可以对文档提问，并且自动生成笔记，目前对美国用户免费开放。参见谷歌的介绍文章。不过，它好像只支持上传英文的 PDF 文件。\n\nScalar API Reference｜开发文档\n一个开源工具，将 Swagger/OpenAPI 文件转成互动式 API 文档。\n\nRoomGPT｜AI 重新设计房间\n一个开源软件，你上传一张房间照片，它使用 AI 重新设计你的房间。\n\nComments｜对页面的各个部分拉框评论\n一个开源的网页评论系统，类似于 Vercel Comment，可以对页面的各个部分拉框评论。它采用 GitHub 的身份认证，数据放在 supabase。\n\nGPT Assistant｜ GPT 安卓客户端\n网友写的开源 GPT 安卓客户端，可以跟 AI 语音聊天，还可以发送图片到 GPT-4V，并基于安卓 WebView，让 GPT 访问任何网站。\n\nMD Video｜Markdown 文档转成一段短视频\n一个桌面软件，将 Markdown 文档转成一段短视频。\n\nCodeGeeX2｜AI 编程助手\nAI 编程助手，支持 VS Code、 IntelliJ IDEA、PyCharm、GoLand、WebStorm 等 IDE 编辑器，参见介绍文章。\n\nproxy｜抓包工具｜拦截 HTTP 请求\n一款抓包代理工具，可以拦截 HTTP 请求，配置文件是一个 JS 脚本。\n\nTrippy｜查看互联网通信的路径\n一个命令行工具，可以代替 traceroute 查看互联网通信的路径，分析网络状况。\n\n有趣站点\n\n最漂亮的网页游戏\nHacker News 的一个讨论帖，里面列举许多非常漂亮的网页游戏。上图出自游戏《短途旅行》（Short Trip）。\n\n学习资源\n\nMac 命令行命令\n这个网站收集各种有用的 Mac 命令行的命令。\n\n30天 Python 教程\n这个仓库是一个30天的 Python 入门课程，配有代码练习和视频。\n\n每日日记\n\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新324天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"E-Diary/防抖和节流｜2024_01_17｜周三｜☀️":{"title":"防抖和节流｜2024_01_17｜周三｜☀️","links":["D-Unsorted/谈谈前端开发中的防抖和节流","D-Unsorted/3-个令人惊艳的-GitHub-开源项目，诞生了！","tags/编程/性能","D-Unsorted/3.40秒到231.84毫秒，我用Performance面板分析性能瓶颈全流程","D-Unsorted/Midway.js探索与实践"],"tags":["Logs/日记","编程/性能"],"content":"逍遥诀 - QQ音乐\n\n\n文章学习\n\n谈谈前端开发中的防抖和节流\n谈谈前端开发中的防抖和节流谈谈前端开发中的防抖和节流谈谈前端开发中的防抖和节流\n\n[译]装饰器的10年历史｜ES6\n[译]装饰器的10年历史[[[译]装饰器的10年历史]][译]装饰器的10年历史\n\n3 个令人惊艳的 GitHub 开源项目，诞生了！\n3 个令人惊艳的 GitHub 开源项目，诞生了！3 个令人惊艳的 GitHub 开源项目，诞生了！3 个令人惊艳的 GitHub 开源项目，诞生了！\n\n用Performance面板分析性能瓶颈全流程]]性能\n3.40秒到231.84毫秒，我用Performance面板分析性能瓶颈全流程3.40秒到231.84毫秒，我用Performance面板分析性能瓶颈全流程\n\nMidway.js探索与实践｜Serverless 框架\nMidway.js探索与实践Midway.js探索与实践\n\n春运预约购票须知，务工人员春运预约订票功能和学生寒假订票专项服务\n![image.png](G%20Attachments/81baa23f7f2c3b817b72503e592415fc_MD5.png /&gt;春运预约购票须知，学生票核验最新规定！\n\n拒绝和被拒绝的勇气\n曾给某业界大佬发微信，希望让他帮忙牵线，我想和对方高管沟通一个组织设置问题，但他认为，如果我已经和他们的另一个专家聊过，就无须再和其他人聊了。我想他的意思是：「信息已经足够，无需浪费过多资源。」之前我的第一本书《人生护城河》出版时，也请一个业界牛人写推荐语。在我看来，不过是三两句话的事情，可以随手写出来，花不了多少时间，结果被他「断然拒绝」。这是两次典型的「被拒绝」的经历。当然生活工作中我被拒绝的经历更多，不一一陈述。借此谈谈我关于「拒绝」和「被拒绝」的感想。这些牛人、大佬在拒绝他人的时候，总是很干脆，没有任何拖泥带水，也不会有一丝犹豫，更看不出有任何亏欠感 —— 这种亏欠感，是我们自己在拒绝他人的时候经常产生的情绪。近些年有不少书找我写序言、推荐语，如果我对书籍内容感兴趣，基本上都会欣然答应。偶尔因为内容问题或者自己的时间精力问题不得不推掉，但推辞的过程拖泥带水，远谈不上干脆利落。我会想办法找一些借口，比如出差，封闭开会等。任何能减轻我亏欠感的事情，都是我拿来搪塞别人的理由。即便如此，如果对方一再邀约，自己内心多少还会有一些波澜。一方面，自己在拒绝他人的时候，显得犹犹豫豫，思前顾后；另一方面，自己遭到他人拒绝的时候，也会有很多内心戏，尤其要做自我安抚。每一次被拒绝，多多少少都会在内心中留下阴影。这也导致，自己再去找其他大佬、牛人的时候，因为担心被拒，从而犹犹豫豫。其实因为自己的切身体会，反倒能理解很多年轻朋友为何在职场上总显得犹犹豫豫，思前顾后。自己明明感觉给了大家直接沟通的窗口和机会，但总是不见对方举手示意 —— 其实也是因为在成长的过程中积累了一些「被拒绝」的故事。从这一点也能看出，所谓「同理心」，多半来自类似的痛苦或不堪的经历。当然，如果我们换个角度想问题，可能会有新的启发。之前看过一句话，大意是说：如果我们对大多数事情说Yes，我们该有多平庸。曾看过一篇文章，分析巴菲特成功的关键秘密是「几乎对一切杂事说No」。比如几乎拒绝了一切采访，拒绝了与华尔街分析师的交谈等等。他把几乎所有的时间都用来阅读、思考。当然，巴菲特每年也安排了一次盛大的、正式的、充分的对外沟通 —— 伯克希尔·哈萨维的公司年会。这是很多投资者一年一度的节日，看到年逾九十的巴菲特和查理·芒格在台上侃侃而谈、妙语连珠，不由得感叹：「倘若自己在八九十岁的时候，还有这番精力与睿智，该有多好！」今天想想，他们之所以精力十足，也与自己习惯于保护精力，对一切杂事说No有一定的关系。毕竟，人生的精力可能是有限的，一些事情上花的多了一些，另一些事情上就自然少了一些。道理上如果能相通，行动上就容易跟上。**其实我发现一个秘诀，当你没有十足的理由去答应一件事的时候，不妨果断说No，而且要立刻、马上说No。**无论是对一个陌生人还是熟悉的人，无论是对同事还是亲朋好友。一个干脆利索的No远胜过拖拖拉拉的Yeees。我自己之前偶尔尝试过立刻说No，但并未影响我与另一个人的关系。反倒是那些犹犹豫豫、啰啰嗦嗦，一会Yes一会No，给两人的关系留下了阴影。拒绝和被拒绝的勇气\n\n【首发】小米澎湃OS全家桶体验！开启主动智能时代？(上)\n点击查看【bilibili】点击查看【bilibili】点击查看【bilibili】\n\n财富自由\n财富自由观：怎么让收入比支出多一块钱昨天，写了一篇文章，提到了财富自由一个重要实现方式，先降低支出。摘要如下：一说起，财富自由，我们就想多挣钱。然后，又不自觉的多花钱，去犒劳自己，更好的奢侈品。财富自由的前提，是关注支出。不要在提升收入的同时，立马提升生活水平，最好延迟 1-2 档。也有一种说法：当被动收入，比支出多一块钱，就财富自由了。一个朋友饶有兴趣的问道，如何提升被动收入，可以展开说说么？我脑子一闪而过：打工是不太可能。但觉得这种回复，太消极和片面，就整理自己对财富自由的理解，主要对被动收入的理解。之所以，打工是很难的，主要原因在于不被动。而产生被动收入的主要三种实践路径，要尽可能多获取「三权」：第一，不动产权，享受城市发展的红利和杠杆的红利。这就是大家所熟知的房产，无论我们还是发达国家，都是走过城市化进程，土地永远是核心生产资料。但对于当下而言，不同城市的发展前景，已经开始分化。我特别反感一种唱衰的论调，就是拿美国的郊区或者破产城市的房价，和中国一二线城市对比，从而得出结论。如果他去过洛杉矶，在比弗利山庄，在日落大道走走，就不会觉得美国房产便宜了。另外，说一下发达国家房价洼地的德国，这两年也是暴涨。投资不动产，就是投资这个城市，投资这片区域土地。当然，我们已经过了买了就是赚了的时代，所以需要谨慎地区别对待城市和区域。另外，投资不动产中还有一个额外红利，就是合法的 3-4 倍杠杆，这会放大效益。当然，亏损也被放大，所以谨慎选择投资标的。第二，股权，享受高速发展群体的红利。创业，或者参与创业，是普通人获取大量低价股权的最直接方式。但实话说，这一部分有非常大的运气成分。然而，运气确实是一个人获取大量财富最大的变量，这和个人努力和选择的关系都不大。天道酬情，这几个字挂在老板办公室里，目的不是给老板看的，是给进老板办公室的打工人看的。如果积累一定资金量，去关注自己专业所擅长的上市公司，也是一条路径。我喜欢彼得林奇的投资理念，散户天生有比机构专业人员更强的投资优势。关注自己的专业领域中，还不被大众所知的、被低估的企业，或许是获取股权的一种好方式。一个搞云计算的，就不要轻易去买做袜子公司的股票，因为不专业，浪费自己最拿手的事情。此外，彼得林奇还说，我喜欢热门行业的冷门公司，或者冷门行业的热门公司，因为更容易出 10 倍收益的企业，但我从来不买热门行业的热门企业。第三，知识产权，享受个人体系化、产品化的红利。主要有著作权、专利权两部分组成。作家写作，歌手唱歌都是获取著作的方式。对于普通人而言，在墨问之类的付费平台上，发表自己的专业见解和奇特的生活体验，都有可能获取额外收益。这是典型的一次创作，多份收益。就在昨天，我提取了墨问的第一笔钱 3000 块，也是墨问的单日上限金额。对于技术类工作者，除了拿工资之外，将自己的技术产出写成专利，都是获取额外收入的重要方式。在公司写，肯定能享受专利奖金，这是专利法的要求；个人写专利，可以有机会获得技术转让费。在大厂写专利赚钱，我体验是非常深的，真的很挣钱，值得你去关注。最后，追求财富自由，是为了追求自由，从而有时间和条件，却追求我们的本性，去充分表达自我。不用眼睛一睁，就想着生活成本，就想着下一顿能吃什么，接下来要住在哪里？而财富本身，只是我们生前拥有的东西，它不是幸福本身。正如叔本华对于幸福的论断，追求拥有更多东西而达成幸福，和追求幸福，是南辕北辙的事情。财富自由观：怎么让收入比支出多一块钱\n\n\n每日小记，次日清晨更新。记录图形学、前端、科技、个人成长等领域值得分享的内容。已持续更新331天，近期目标400天，中期目标1年，远期目标10年，终极目标一辈子。如果对你有帮助，欢迎留下你的想法。最后，向世界敞开心扉，去影响更多的人，顺便留下一些痕迹。\n"},"Web-Clip/@2024-抖音欢笑中国年(四)：渲染技术实践与探索":{"title":"@2024 抖音欢笑中国年(四)：渲染技术实践与探索","links":[],"tags":["编程/FE/WebGL"],"content":""},"Web-Clip/@8秋API接口设计风格与11种API协议":{"title":"@8秋API接口设计风格与11种API协议","links":["C-Knowledge/前端/开发技术/JavaScript/WebSocket-教程","C-Knowledge/前端/开发技术/如何调试Webhooks","C-Knowledge/前端/编程基础/网络/OAuth2.0","C-Knowledge/前端/职业规划/前端面试宝典/八股文/什么是HTTP！-HTTP-和-HTTPS-的区别！"],"tags":["编程/API"],"content":"API 架构\n\n\nWebSocket 教程\n如何调试Webhooks\n\nAPI 协议\n\n授权方式\n\n\nOAuth2.0\n\n加密方式\n\n\n什么是HTTP！ HTTP 和 HTTPS 的区别！\n"},"Web-Clip/@Curl-的用法指南---阮一峰的网络日志":{"title":"@Curl 的用法指南 - 阮一峰的网络日志","links":[],"tags":["编程/服务器"],"content":""},"Web-Clip/@DNS-原理入门---阮一峰的网络日志":{"title":"@DNS 原理入门 - 阮一峰的网络日志","links":[],"tags":["编程/网络/DNS"],"content":"DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。\n本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。\n\n一、DNS 是什么？\nDNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。\n举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69。\n如果你不清楚为什么一定要查出IP地址，才能进行网络通信，建议先阅读我写的《互联网协议入门》。\n二、查询过程\n虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。\n工具软件dig可以显示整个查询过程。\n$ dig math.stackexchange.com\n上面的命令会输出六段信息。\n\n第一段是查询参数和统计。\n\n第二段是查询内容。\n\n上面结果表示，查询域名math.stackexchange.com的A记录，A是address的缩写。\n第三段是DNS服务器的答复。\n\n上面结果显示，math.stackexchange.com有四个A记录，即四个IP地址。600是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。\n第四段显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录。\n\n上面结果显示stackexchange.com共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com的IP地址是什么。\n第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。\n\n第六段是DNS服务器的一些传输信息。\n\n上面结果显示，本机的DNS服务器是192.168.1.253，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。\n如果不想看到这么多内容，可以使用+short参数。\n$ dig +short math.stackexchange.com\n \n151.101.129.69\n151.101.65.69\n151.101.193.69\n151.101.1.69\n上面命令只返回math.stackexchange.com对应的4个IP地址（即A记录）。\n三、DNS服务器\n下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名math.stackexchange.com的IP地址。\n首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。\n\nDNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。\n上例的DNS服务器是192.168.1.253，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level 3的4.2.2.2。\n本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。\n$ dig @4.2.2.2 math.stackexchange.com\n上面命令指定向DNS服务器4.2.2.2查询。\n四、域名的层级\nDNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。\n请仔细看前面的例子，每个域名的尾部都多了一个点。\n\n比如，域名math.stackexchange.com显示为math.stackexchange.com.。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。\n举例来说，www.example.com真正的域名是www.example.com.root，简写为www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。\n根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如www.example.com里面的.example，这一级域名是用户可以注册的；再下一级是主机名（host），比如www.example.com里面的www，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。\n总结一下，域名的层级结构如下。\n主机名.次级域名.顶级域名.根域名\n \n# 即\n \nhost.sld.tld.root\n五、根域名服务器\nDNS服务器根据域名的层级，进行分级查询。\n需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。\n所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。\n\n从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）\n从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）\n从”次级域名服务器”查出”主机名”的IP地址\n\n仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道”根域名服务器”的IP地址。回答是”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。\n下面是内置的根域名服务器IP地址的一个例子。\n\n上面列表中，列出了根域名（.root）的三条NS记录A.ROOT-SERVERS.NET、B.ROOT-SERVERS.NET和C.ROOT-SERVERS.NET，以及它们的IP地址（即A记录）198.41.0.4、192.228.79.201、192.33.4.12。\n另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。\n目前，世界上一共有十三组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET。\n六、分级查询的实例\ndig命令的+trace参数可以显示DNS的整个分级查询过程。\n$ dig +trace math.stackexchange.com\n上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。\n\n根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问math.stackexchange.com的顶级域名服务器com.的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。\n接着是第二段。\n\n上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。\n然后，DNS服务器向这些顶级域名服务器发出查询请求，询问math.stackexchange.com的次级域名stackexchange.com的NS记录。\n\n上面结果显示stackexchange.com有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。\n然后，DNS服务器向上面这四台NS服务器查询math.stackexchange.com的主机名。\n\n上面结果显示，math.stackexchange.com有4条A记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是ns-463.awsdns-57.com，IP地址为205.251.193.207。\n七、NS 记录的查询\ndig命令可以单独查看每一级域名的NS记录。\n$ dig ns com\n$ dig ns stackexchange.com\n+short参数可以显示简化的结果。\n$ dig +short ns com\n$ dig +short ns stackexchange.com\n八、DNS的记录类型\n域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，“记录”可以分成不同的类型（type），前面已经看到了有A记录和NS记录。\n常见的DNS记录类型如下。\n\n（1） A：地址记录（Address），返回域名指向的IP地址。\n（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\n（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。\n（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。\n（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。\n\n一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。\nCNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，facebook.github.io这个域名就是一个CNAME记录。\n$ dig facebook.github.io\n \n...\n \n;; ANSWER SECTION:\nfacebook.github.io. 3370    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  600 IN  A   103.245.222.133\n上面结果显示，facebook.github.io的CNAME记录指向github.map.fastly.net。也就是说，用户查询facebook.github.io的时候，实际上返回的是github.map.fastly.net的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改github.map.fastly.net这个域名就可以了，用户的facebook.github.io域名不用修改。\n由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。\nPTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录。\n$ dig -x 192.30.252.153\n \n...\n \n;; ANSWER SECTION:\n153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.\n上面结果显示，192.30.252.153这台服务器的域名是pages.github.com。\n逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。\ndig命令可以查看指定的记录类型。\n$ dig a github.com\n$ dig ns github.com\n$ dig mx github.com\n九、其他DNS工具\n除了dig，还有一些其他小工具也可以使用。\n（1）host 命令\nhost命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。\n$ host github.com\n \ngithub.com has address 192.30.252.121\ngithub.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 1 ASPMX.L.GOOGLE.COM.\n \n$ host facebook.github.com\n \nfacebook.github.com is an alias for github.map.fastly.net.\ngithub.map.fastly.net has address 103.245.222.133\nhost命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x &lt;ip&gt;。\n$ host 192.30.252.153\n \n153.252.30.192.in-addr.arpa domain name pointer pages.github.com.\n（2）nslookup 命令\nnslookup命令用于互动式地查询域名记录。\n$ nslookup\n \n&gt; facebook.github.io\nServer:     192.168.1.253\nAddress:    192.168.1.253#53\n \nNon-authoritative answer:\nfacebook.github.io  canonical name = github.map.fastly.net.\nName:   github.map.fastly.net\nAddress: 103.245.222.133\n \n&gt; \n（3）whois 命令\nwhois命令用来查看域名的注册情况。\n$ whois github.com\n十、参考链接\n\nDNS: The Good Parts, by Pete Keen\nDNS 101, by Mark McDonnell\n"},"Web-Clip/@DNS-查询原理详解---阮一峰的网络日志":{"title":"@DNS 查询原理详解 - 阮一峰的网络日志","links":[],"tags":["编程/网络/DNS"],"content":""},"Web-Clip/@GitHub-Actions-教程：定时发送天气邮件---阮一峰的网络日志":{"title":"@GitHub Actions 教程：定时发送天气邮件 - 阮一峰的网络日志","links":[],"tags":["编程/Git/GitHub"],"content":"action.yml\n核心代码为：\n- name: &#039;Checkout codes&#039;\n  uses: actions/checkout@v1\n- name: &quot;触发garden的GithubAction&quot;\n  run: bash ./garden.sh\n下面是完整代码：\nname: &#039;GitHub Actions Weather Bot&#039;\n \non:\n  push:\n  workflow_dispatch:\n  schedule:\n    - cron: &#039;0 21 * * *&#039;\n \njobs:\n  bot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: &#039;Checkout codes&#039;\n        uses: actions/checkout@v1\n      - name: &#039;Get Weather&#039;\n        run: bash ./weather.sh\n      - name: &#039;Get Date&#039;\n        run: echo &quot;REPORT_DATE=$(TZ=&#039;:Asia/Shanghai&#039; date &#039;+%Y-%m-%d %T&#039;)&quot; &gt;&gt; $GITHUB_ENV\n      - name: &#039;Send mail&#039;\n        uses: dawidd6/action-send-mail@master\n        with:\n          server_address: smtp.163.com\n          server_port: 465\n          username: ${{ secrets.MAIL_USERNAME }}\n          password: ${{ secrets.MAIL_PASSWORD }}\n          subject: Shanghai Weather Report (${{env.REPORT_DATE}})\n          html_body: file://result.html\n          to: yifeng.ruan@gmail.com\n          from: GitHub Actions\nweather.sh\n#!/bin/sh\n \nset -eux\n \nCITY=Shanghai\nLANGUAGE=&quot;zh-CN&quot;\nUNIT=m\nUA=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36&quot;\n \ncurl \\\n  -H &quot;Accept-Language: $LANGUAGE&quot; \\\n  -H &quot;User-Agent: $UA&quot; \\\n  -o result.html \\\n  wttr.in/$CITY?format=4\\&amp;$UNIT\n\nJS 脚本\n"},"Web-Clip/@JS函数链式调用的几种方式---掘金":{"title":"@JS函数链式调用的几种方式 - 掘金","links":[],"tags":["编程/思想"],"content":""},"Web-Clip/@JS数组去重的方式详细总结（7种）---掘金":{"title":"@JS数组去重的方式详细总结（7种） - 掘金","links":[],"tags":["编程/JavaScript"],"content":""},"Web-Clip/@Javascript-的-this-用法---阮一峰的网络日志":{"title":"@Javascript 的 this 用法 - 阮一峰的网络日志","links":[],"tags":["编程/JavaScript"],"content":"this是 JavaScript 语言的一个关键字。\n它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。\nfunction test() {\n　this.x = 1;\n}\n上面代码中，函数test运行时，内部会自动有一个this对象可以使用。\n那么，this的值是什么呢？\n函数的不同使用场合，this有不同的值。总的来说，this就是函数运行时所在的环境对象。下面分四种情况，详细讨论this的用法。\n情况一：纯粹的函数调用\n这是函数的最通常用法，属于全局性调用，因此this就代表全局对象。请看下面这段代码，它的运行结果是1。\nvar x = 1;\nfunction test() {\n    console.log(this.x);\n}\ntest();  // 1\n情况二：作为对象方法的调用\n函数还可以作为某个对象的方法调用，这时this就指这个上级对象。\nfunction test() {\n  console.log(this.x);\n}\n \nvar obj = {};\nobj.x = 1;\nobj.m = test;\n \nobj.m(); // 1\n情况三 作为构造函数调用\n所谓构造函数，就是通过这个函数，可以生成一个新对象。这时，this就指这个新对象。\nfunction test() {\n　this.x = 1;\n}\n \nvar obj = new test();\nobj.x // 1\n运行结果为1。为了表明这时this不是全局对象，我们对代码做一些改变：\nvar x = 2;\nfunction test() {\n  this.x = 1;\n}\n \nvar obj = new test();\nx  // 2\n运行结果为2，表明全局变量x的值根本没变。\n情况四 apply 调用\napply()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数。\nvar x = 0;\nfunction test() {\n　console.log(this.x);\n}\n \nvar obj = {};\nobj.x = 1;\nobj.m = test;\nobj.m.apply() // 0\napply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。\n如果把最后一行代码修改为\nobj.m.apply(obj); //1\n运行结果就变成了1，证明了这时this代表的是对象obj。"},"Web-Clip/@Jenkins-真得很牛逼！只是大部分人不会用而已~(保姆级教程)":{"title":"@Jenkins 真得很牛逼！只是大部分人不会用而已~(保姆级教程)","links":[],"tags":["编程/工程化/Jenkins"],"content":"什么是流水线\njenkins 有 2 种流水线分为声明式流水线与脚本化流水线，脚本化流水线是 jenkins 旧版本使用的流水线脚本，新版本 Jenkins 推荐使用声明式流水线。文档只介绍声明流水线。\n声明式流水线\n在声明式流水线语法中，流水线过程定义在 Pipeline{}中，Pipeline 块定义了整个流水线中完成的所有工作，比如\n参数说明：\n\n\nagent any：在任何可用的代理上执行流水线或它的任何阶段，也就是执行流水线过程的位置，也可以指定到具体的节点\n\n\nstage：定义流水线的执行过程（相当于一个阶段），比如下文所示的 Build、Test、Deploy， 但是这个名字是根据实际情况进行定义的，并非固定的名字\n\n\nsteps：执行某阶段具体的步骤。\n\n\n//Jenkinsfile (Declarative Pipeline)\npipeline {\n  agent any\n    stages {\n      stage(&#039;Build&#039;) {\n        steps {\n          echo &#039;Build&#039;\n        }\n      }\n      stage(&#039;Test&#039;) {\n        steps {\n          echo &#039;Test&#039;\n        }\n      }\n      stage(&#039;Deploy&#039;) {\n        steps {\n          echo &#039;Deploy&#039;\n      }\n    }\n  }\n}\n脚本化流水线\n在脚本化流水线语法中，会有一个或多个 Node（节点）块在整个流水线中执行核心工作\n参数说明:\n\n\nnode：在任何可用的代理上执行流水线或它的任何阶段，也可以指定到具体的节点\n\n\nstage：和声明式的含义一致，定义流水线的阶段。Stage 块在脚本化流水线语法中是可选的，然而在脚本化流水线中实现 stage 块，可以清楚地在 Jenkins UI 界面中显示每个 stage 的任务子集。\n\n\n//Jenkinsfile (Scripted Pipeline)\nnode {\n  stage(&#039;Build&#039;) {\n    echo &#039;Build&#039;\n  }\n  stage(&#039;Test&#039;) {\n    echo &#039;Test&#039;\n  }\n  stage(&#039;Deploy&#039;) {\n    echo &#039;Deploy&#039;\n  }\n}\n声明式流水线\n声明式流水线必须包含在一个 Pipeline 块中，比如是一个 Pipeline 块的格式\npipeline {\n  /* insert Declarative Pipeline here */\n}\n在声明式流水线中有效的基本语句和表达式遵循与 Groovy 的语法同样的规则，但有以下例外\n\n流水线顶层必须是一个 block，即 pipeline{}\n分隔符可以不需要分号，但是每条语句都必须在自己的行上\n块只能由 Sections、Directives、Steps 或 assignment statements 组成\n属性引用语句被当做是无参数的方法调用，比如 input 会被当做 input()。\n"},"Web-Clip/@Js-手动实现bind方法，超详细思路分析！---听风是风---博客园":{"title":"@Js 手动实现bind方法，超详细思路分析！ - 听风是风 - 博客园","links":[],"tags":["编程/JavaScript"],"content":""},"Web-Clip/@Notion-3.0-今年发布，野心真大":{"title":"@Notion 3.0 今年发布，野心真大","links":[],"tags":["Apps/Notion"],"content":"7、采访中，Ivan Zhao 透露，他们许多客户都是小型创业公司，甚至 YC 中有一半的团队都在用 Notion。这一点也是 Notion 最牛的地方，通过口碑传播，它不断渗透到中小团队中。但和国内一样，想拿下大客户，只靠口碑不行。所以，Notion 最近正在组建大客户销售团队。\n8、在产品上，Notion 一直信奉乐高积木式的设计。包括文档、数据库、表格、评论、权限等都是一个积木，用户基于积木之上构建自己想要的东西，这是他们一以贯之的理念。还看到 Ivan Zhao 转发了一个推文：“这个世界上最好的系统都是由几个模块和几个简单的规则组成的，这些规则产生了最大的自由度、可能性和复杂性，同时使事情尽可能直观和明显。设计软件也不例外。”\n9、“AI 会以新的方式来组合、驱动积木块。”这句话帮我理解了 Notion AI 的逻辑，目前 Notion AI 有三个功能：1 ）Q&amp;A 2 ）文档助手 3 ）数据库助手。AI 于积木块而言，像是新的引擎。感觉 Notion 产品结构真的好，很简单，扩展性又强。\n10、多说两句 Notion 的 Q&amp;A AI 功能，目前它还在内测中。这个功能很好理解，你想想，我们在 Notion 中存了很多信息，等数据一多，找起来就费劲了，没有 AI 之前，咱只能靠关键词检索。但有时候，我们容易忘记到底当时用的哪个关键词。现在，基于大模型的能力，可以直接问问题，Notion 来基于已有的信息给出答案。\n11、为什么我们要记笔记呢？担心忘记。但记了很多笔记后，又发现查找和检索成了新问题。这事情之前真的无解，但现在，有了大模型后，一切豁然开朗。当解决了私有信息快速查找的问题后，笔记真正可以成为我们的第二大脑了。\n12、Ivan Zhao 还提到了 Workflow Agent，我估计他们接下来也会干这事。Workflow Agent，你可以把它理解为办公场景中的 GPTs，与此类似的，今天钉钉还发布了他们的 AI 助理市场。工作中很多琐碎的事情都可以让 Agent 去干，确实能提效。要知道，与 OpenAI 不一样的是，Notion、钉钉有场景，有数据。Agent 是新时代的工作流落地方式。\n13、Notion 从创立到现在，我认为有两件事值得我们学习：第一，保持人员的精简，从一开始就考虑产品的盈利能力。第二，持续解决用户的刚需问题，而不是简单的堆叠功能。"},"Web-Clip/@Three.Js动态场景实战":{"title":"@Three.Js动态场景实战","links":[],"tags":["编程/FE/Three"],"content":""},"Web-Clip/@TypeScript很麻烦，不想使用！":{"title":"@TypeScript很麻烦，不想使用！","links":[],"tags":["编程/TypeScript"],"content":""},"Web-Clip/@Virtual-DOM（虚拟DOM）-的地位再一次被挑战-！！！":{"title":"@Virtual DOM（虚拟DOM） 的地位再一次被挑战 ！！！","links":[],"tags":["编程/FE/Vue"],"content":""},"Web-Clip/@Vue3-自定义hooks-大集合-你要的自定义hooks-都在这，快来看吧！---知乎":{"title":"@Vue3 自定义hooks 大集合 你要的自定义hooks 都在这，快来看吧！ - 知乎","links":["C-Knowledge/前端/开发技术/Vue/VueUse","C-Knowledge/前端/开发技术/Vue/vhook"],"tags":["编程/FE/Vue"],"content":"开源库与开源项目中的hooks\nvue3官方推荐社区项目：VueUse\n这个是我最推荐大家的hooks 平时没事的时候在里面逛一下 看看源码 绝对能学到很多，我平时用的比较多的是其中的 useResizeObserver、useTitle、useClipboard、useDraggable 等\nahooks-vue\nahooks 的 vue 实现。许多 hooks 是从ahooks移植过来的，但是不完全一致。包含了 useRequest、useAxios、useFullscreen、useTable等\n个人封装的hooks 库\n这个是我偶然发现的 一个hooks 库 感觉也是模仿其他库的，仅供参考\nvue-hooks\n主要包含了 useDate、useStore、useActions等\nvue-use-web\n跟 vueuse 有点像不知道是不是vueuse 前身，而且都是国外大佬维护的\nvue-hooks-plus\n其中包含47个高质量 &amp; 可靠 hook函数 其中useRequeset 、useWebSocket、useFetchs等都很优秀\n针对 Vue3 的实用Hooks集合\nuseRequest、 useDate、useVirtualList 我在项目中都用到了\n20kstars 的后台管理项目：vue-vben-admin\n这个是 点赞比较多的 vue3 后台管理项目 其中 我上面的分页hooks 就是抄他的 里面还有很多 表格表单hooks 大家也可以参考 其中包含了 useContext、useScroll、useEventListener、useTable、useTitle等\nvue3-antd-admin\n喜欢用 antd 的同学可以看看其中的useI18n useModal、useEventbus 方案都很优秀\n表格相关的\n一文学会vue3如何自定义hook钩子函数和封装组件\n【Vue3】如何封装一个超级好用的 Hook ！\nuseTable表格hooks封装和使用(Vue3)\nvue3流水线开发分页列表？ useTable了解一下： searchInitParam\nVue3自定义useTable\n在Vue3这样子写页面更快更高效\n基于vue3+Arco Design的table组件的hook二次封装\n\nForm表单组件封装和使用(Vue3)\n\n每个人封装的 表格 hook 其实都有区别 所以大家可以综合一下 总结出比较适合自己项目的，因为每个人项目中的 ui 分页等等 都不太一样 所以个人建议总结出一个 集成到自己项目中是最好的\n关于请求的 hook\nVue3 教你实现公司级网络请求的 Hook\nVue3使用hook封装常见的几种异步请求函数场景，让开发更加丝滑\n其他 hooks\nForm表单组件封装和使用(Vue3)\n他把antdvue 的form 二次封装了 并且搭配了自己的封装的hooks\n【vue3】写hook三天，治好了我的组件封装强迫症。\n封装了 下拉框选项从后端获取值得hooks 以及关于 loading 状态的 hook\nVue3自定义一个Hooks，实现一键换肤\n一键换肤的 hooks\nVue3使用hook封装媒体查询和事件监听，使Vue的开发更加丝滑\n聊聊Vue3+hook怎么写弹窗组件更快更高效\n【Vue3 Hook】实现 useTimeout 代替 setTimeout\n公共Hooks封装之文件下载useDownloadBlob\n在vue中封装useIntro来更好的使用Intro.js"},"Web-Clip/@obsidian和zotero连用（Citation插件介绍）-_-软通达":{"title":"@obsidian和zotero连用（Citation插件介绍） _ 软通达","links":[],"tags":["Apps/Obsidian"],"content":"安装 Better BibTeX 插件\n下载 Better BibTeX\n\n安装说明：retorque.re/zotero-better-bibtex/installation\n下载地址：github.com/retorquere/zotero-better-bibtex/releases/\n备用下载（下载后请解压缩）：wws.lanzous.com/iKkKnjdasbg\n\n打开zotero，点击工具-插件\n在弹出的窗口的右上角找到齿轮标志-选择“Install Add-on From File”\n选择刚刚下载的文件，例如“zotero-better-bibtex-5.2.95.xpi”，点击install now\n点击Restart，重启zotero，即可完成安装。\n设置zotero\n\n打开zotero，此时zotero必须要安装有Better BibTeX插件并已经启动该插件，安装步骤可以参考参考文末的​帮助文档。​\n点击文件，导出文献库\n选择“Better CSL JSON”（该选项是安装Better BibTeX插件之后才有的），点击ok，导出一个json文件。\n文件名可以自行命名，我个人建议以英文命名，本例中命名为“My bib.json”。将文件保存到自己所有的ob库文件夹下。\n"},"Web-Clip/@【Notion】同步博客图片过期！！阿里云OSS+PicGo搭建自己的高性能图床":{"title":"@【Notion】同步博客图片过期！！阿里云OSS+PicGo搭建自己的高性能图床","links":[],"tags":["场景/博客"],"content":""},"Web-Clip/@一图搞懂_搜索引擎的工作原理":{"title":"@一图搞懂_搜索引擎的工作原理","links":[],"tags":["场景/浏览器"],"content":"\n▶️ 第1步：爬虫网络爬虫在互联网上扫描网页。它们跟踪从一个页面到另一个页面的 URL 链接，并将 URL 存储在 URL 存储中。爬虫会发现新内容，包括网页、图像、视频和文件。SEO做得好，可以提高自己网站在搜索引擎的收录和排名。\n▶️ 第2步：索引一旦网页被抓取，搜索引擎就会解析该页面，并将该页面上的内容编入数据库的索引。对内容进行分析和分类。例如，评估关键字、网站质量、内容新鲜度和许多其他因素以了解页面的内容。\n▶️ 第3步：排名搜索引擎使用复杂的算法来确定搜索结果的顺序。这些算法考虑了各种因素，包括关键字、页面的相关性、内容质量、用户参与度、页面加载速度等等。一些搜索引擎还会根据用户过去的搜索历史、位置、设备和其他个人因素来个性化结果。例如站长工具可以查到自己网站的排名和权重。\n▶️ 第4步：查询当用户执行搜索时，搜索引擎会筛选其索引以提供最相关的结果。"},"Web-Clip/@万字长文爆肝-DNS-协议！-Dns协议详解":{"title":"@万字长文爆肝 DNS 协议！-Dns协议详解","links":[],"tags":["编程/网络/DNS"],"content":""},"Web-Clip/@互联网协议入门（一）---阮一峰的网络日志":{"title":"@互联网协议入门（一） - 阮一峰的网络日志","links":[],"tags":["编程/网络"],"content":""},"Web-Clip/@互联网协议入门（二）---阮一峰的网络日志":{"title":"@互联网协议入门（二） - 阮一峰的网络日志","links":["Web-Clip/@互联网协议入门（一）---阮一峰的网络日志","Web-Clip/子网掩码：IP地址是不是在同一个子网络"],"tags":["编程/网络"],"content":"上一篇文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。\n这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。\n==============================================================\n互联网协议入门（二）\n\n（接上文）\n七、一个小结\n先对前面的内容，做一个小结。\n我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：\n\n发送这个包，需要知道两个地址：\n\n对方的MAC地址\n对方的IP地址\n\n有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。\n\n上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。\n1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：\n\n发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。\n八、用户的上网设置\n8.1 静态IP地址\n你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？\n\n通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：\n\n本机的IP地址\n子网掩码\n网关的IP地址\nDNS的IP地址\n\n下图是Windows系统的设置窗口。\n\n这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。\n但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。\n8.2 动态IP地址\n所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。\n这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。\n前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？\nDHCP协议做了一些巧妙的规定。\n8.3 DHCP协议\n首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：\n\n　　（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。\n　　（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。\n　　（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。\n新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n8.4 上网设置：小结\n这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：\n\n本机的IP地址\n子网掩码\n网关的IP地址\nDNS的IP地址\n\n有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。\n九、一个实例：访问网页\n9.1 本机参数\n我们假定，经过上一节的步骤，用户设置好了自己的网络参数：\n\n本机的IP地址：192.168.1.100\n子网掩码：255.255.255.0\n网关的IP地址：192.168.1.1\nDNS的IP地址：8.8.8.8\n\n然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。\n\n这意味着，浏览器要向Google发送一个网页请求的数据包。\n9.2 DNS协议\n我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。\nDNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。\n\n然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。\n9.3 子网掩码\n接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到 子网掩码。\n已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。\n因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。\n9.4 应用层协议\n浏览网页用的是HTTP协议，它的整个数据包构造是这样的：\n\nHTTP部分的内容，类似于下面这样：\nGET / HTTP/1.1  \nHost: www.google.com  \nConnection: keep-alive  \nUser-Agent: Mozilla/5.0 (Windows NT 6.1) ......  \nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  \nAccept-Encoding: gzip,deflate,sdch  \nAccept-Language: zh-CN,zh;q=0.8  \nAccept-Charset: GBK,utf-8;q=0.7,*;q=0.3  \nCookie: ... ...\n我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。\n9.5 TCP协议\nTCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。\nTCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。\n9.6 IP协议\n然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。\nIP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\n9.7 以太网协议\n最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n\n9.8 服务器端响应\n经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。\n根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。\n本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。\n\n这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。"},"Web-Clip/@函数式编程入门教程---阮一峰的网络日志":{"title":"@函数式编程入门教程 - 阮一峰的网络日志","links":["Web-Clip/范畴"],"tags":["编程/思想"],"content":"你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。\n但是，你能说清楚，它到底是什么吗？\n\n网上搜索一下，你会轻松找到好多答案。\n\n与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。\n最主要的特征是，函数是第一等公民。\n强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。\n只有纯的、没有副作用的函数，才是合格的函数。\n\n上面代码中， 这些说法都对，但还不够，都没有回答下面这个更深层的问题。\n\n为什么要这样做？\n这就是，本文要解答的问题。我会通过最简单的语言，帮你理解函数式编程，并且学会它那些基本写法。\n需要声明的是，我不是专家，而是一个初学者，最近两年才真正开始学习函数式编程。一直苦于看不懂各种资料，立志要写一篇清晰易懂的教程。下面的内容肯定不够严密，甚至可能包含错误，但是我发现，像下面这样解释，初学者最容易懂。\n一、范畴论\n函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。\n\n理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的”范畴”（category）。\n1.1 范畴的概念\n什么是范畴呢？\n维基百科的一句话定义如下。\n\n\n                  \n                   范畴\n                  \n                \n“范畴就是使用箭头连接的物体。“（In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”. ）\n\n也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。\n\n上图中，各个点与它们之间的箭头，就构成一个范畴。\n箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。\n1.2 数学模型\n既然”范畴”是满足某种变形关系的所有对象，就可以总结出它的数学模型。\n\n所有成员是一个集合\n变形关系是函数\n\n也就是说，范畴论是集合论更上层的抽象，简单的理解就是”集合 + 函数”。\n理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。\n1.3 范畴与容器\n我们可以把”范畴”想象成是一个容器，里面包含两样东西。\n\n值（value）\n值的变形关系，也就是函数。\n\n下面我们使用代码，定义一个简单的范畴。\nclass Category {\n  constructor(val) { \n    this.val = val; \n  }\n \n  addOne(x) {\n    return x + 1;\n  }\n}\n上面代码中，Category是一个类，也是一个容器，里面包含一个值（this.val）和一种变形关系（addOne）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。\n\n\n                  \n                  注意❗ \n                  \n                \n注意，本文后面的部分，凡是提到”容器”的地方，全部都是指”范畴”。\n\n1.4 范畴论与函数式编程的关系\n范畴论使用函数，表达范畴之间的关系。\n伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的”函数式编程”。\n本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。\n所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n二、函数的合成与柯里化\n函数式编程有两个最基本的运算：合成和柯里化。\n2.1 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。\n\n上图中，X和Y之间的变形关系是函数f，Y和Z之间的变形关系是函数g，那么X和Z之间的关系，就是g和f的合成函数g·f。\n下面就是代码实现了，我使用的是 JavaScript 语言。注意，本文所有示例代码都是简化过的，完整的 Demo 请看《参考链接》部分。\n合成两个函数的简单代码如下。\nconst compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n函数的合成还必须满足结合律。\n\ncompose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n2.2 柯里化\nf(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。\n这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。\n// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n \nadd(1, 2) // 3\n \n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n \naddX(2)(1) // 3\n有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。\n三、函子\n函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。\n3.1 函子的概念\n函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。\n它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。\n\n上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。\n下面是一张更一般的图。\n\n上图中，函数f完成值的转换（a到b），将它传入函子，就可以实现范畴的转换（Fa到Fb）。\n3.2 函子的代码实现\n任何具有map方法的数据结构，都可以当作函子的实现。\nclass Functor {\n  constructor(val) { \n    this.val = val; \n  }\n \n  map(f) {\n    return new Functor(f(this.val));\n  }\n}\n上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。\n一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。\n下面是一些用法的示例。\n(new Functor(2)).map(function (two) {\n  return two + 2;\n});\n// Functor(4)\n \n(new Functor(&#039;flamethrowers&#039;)).map(function(s) {\n  return s.toUpperCase();\n});\n// Functor(&#039;FLAMETHROWERS&#039;)\n \n(new Functor(&#039;bombs&#039;)).map(_.concat(&#039; away&#039;)).map(_.prop(&#039;length&#039;));\n// Functor(10)\n上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。\n因此，学习函数式编程，实际上就是学习函子的各种运算。 由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。\n四、of 方法\n你可能注意到了，上面生成新的函子的时候，用了new命令。这实在太不像函数式编程了，因为new命令是面向对象编程的标志。\n函数式编程一般约定，函子有一个of方法，用来生成新的容器。\n下面就用of方法替换掉new。\nFunctor.of = function(val) {\n  return new Functor(val);\n};\n然后，前面的例子就可以改成下面这样。\nFunctor.of(2).map(function (two) {\n  return two + 2;\n});\n// Functor(4)\n这就更像函数式编程了。\n五、Maybe 函子\n函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。\nFunctor.of(null).map(function (s) {\n  return s.toUpperCase();\n});\n// TypeError\n上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。\nMaybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。\nclass Maybe extends Functor {\n  map(f) {\n    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);\n  }\n}\n有了 Maybe 函子，处理空值就不会出错了。\nMaybe.of(null).map(function (s) {\n  return s.toUpperCase();\n});\n// Maybe(null)\n六、Either 函子\n条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。\nEither 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。\nclass Either extends Functor {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n \n  map(f) {\n    return this.right ? \n      Either.of(this.left, f(this.right)) :\n      Either.of(f(this.left), this.right);\n  }\n}\n \nEither.of = function (left, right) {\n  return new Either(left, right);\n};\n下面是用法。\nvar addOne = function (x) {\n  return x + 1;\n};\n \nEither.of(5, 6).map(addOne);\n// Either(5, 7);\n \nEither.of(1, null).map(addOne);\n// Either(2, null);\n上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。\nEither 函子的常见用途是提供默认值。下面是一个例子。\nEither\n.of({address: &#039;xxx&#039;}, currentUser.address)\n.map(updateField);\n上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。\nEither 函子的另一个用途是代替try...catch，使用左值表示错误。\nfunction parseJSON(json) {\n  try {\n    return Either.of(null, JSON.parse(json));\n  } catch (e: Error) {\n    return Either.of(e, null);\n  }\n}\n上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象e。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。\n七、ap 函子\n函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。\nfunction addTwo(x) {\n  return x + 2;\n}\n \nconst A = Functor.of(2);\nconst B = Functor.of(addTwo)\n上面代码中，函子 代码中，函子A内部的值是2，函子B内部的值是函数addTwo。\n有时，我们想让函子B内部的函数，可以使用函子A内部的值进行运算。这时就需要用到 ap 函子。\nap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。\nclass Ap extends Functor {\n  ap(F) {\n    return Ap.of(this.val(F.val));\n  }\n}\n\n\n                  \n                  注意❗ \n                  \n                \n注意，ap方法的参数不是函数，而是另一个函子。\n\n因此，前面例子可以写成下面的形式。\nAp.of(addTwo).ap(Functor.of(2))\n// Ap(4)\nap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。\nfunction add(x) {\n  return function (y) {\n    return x + y;\n  };\n}\n \nAp.of(add).ap(Maybe.of(2)).ap(Maybe.of(3));\n// Ap(5)\n上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。\nAp.of(add(2)).ap(Maybe.of(3));\n八、Monad 函子\n函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。\nMaybe.of(\n  Maybe.of(\n    Maybe.of({name: &#039;Mulburry&#039;, number: 8402})\n  )\n)\n上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。\nMonad 函子的作用是，总是返回一个单层的函子。 它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。\nclass Monad extends Functor {\n  join() {\n    return this.val;\n  }\n  flatMap(f) {\n    return this.map(f).join();\n  }\n}\n上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。\n九、IO 操作\nMonad 函子的重要应用，就是实现 I/O （输入输出）操作。\nI/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。\nvar fs = require(&#039;fs&#039;);\n \nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, &#039;utf-8&#039;);\n  });\n};\n \nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。\n如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。\nreadFile(&#039;./user.txt&#039;)\n.flatMap(print)\n这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。\n由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。\nvar tail = function(x) {\n  return new IO(function() {\n    return x[x.length - 1];\n  });\n}\n \nreadFile(&#039;./user.txt&#039;)\n.flatMap(tail)\n.flatMap(print)\n \n// 等同于\nreadFile(&#039;./user.txt&#039;)\n.chain(tail)\n.chain(print)\n上面代码读取了文件user.txt，然后选取最后一行输出。\n十、参考链接\n\nJS 函数式编程指南\nTaking Things Out of Context: Functors in JavaScript\nFunctor.js\nMaybe, Either &amp; Try Functors in ES6\nWhy Category Theory Matters\n"},"Web-Clip/@函数式编程初探---阮一峰的网络日志":{"title":"@函数式编程初探 - 阮一峰的网络日志","links":[],"tags":["编程/思想"],"content":"诞生50多年之后，函数式编程（functional programming）开始获得越来越多的关注。\n不仅最古老的函数式语言Lisp重获青春，而且新的函数式语言层出不穷，比如Erlang、clojure、Scala、F#等等。目前最当红的Python、Ruby、Javascript，对函数式编程的支持都很强，就连老牌的面向对象的Java、面向过程的PHP，都忙不迭地加入对匿名函数的支持。越来越多的迹象表明，函数式编程已经不再是学术界的最爱，开始大踏步地在业界投入实用。\n也许继”面向对象编程”之后，“函数式编程”会成为下一个编程的主流范式（paradigm）。未来的程序员恐怕或多或少都必须懂一点。\n\n但是，“函数式编程”看上去比较难，缺乏通俗的入门教程，各种介绍文章都充斥着数学符号和专用术语，让人读了如坠云雾。就连最基本的问题”什么是函数式编程”，网上都搜不到易懂的回答。\n下面是我的”函数式编程”学习笔记，分享出来，与大家一起探讨。内容不涉及数学（我也不懂Lambda Calculus），也不涉及高级特性（比如lazy evaluation和currying），只求尽量简单通俗地整理和表达，我现在所理解的”函数式编程”以及它的意义。\n我主要参考了Slava Akhmechet的_“Functional Programming For The Rest of Us”_。\n一、定义\n简单说，“函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。\n它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式：\n(1 + 2) * 3 - 4\n\n传统的过程式编程，可能这样写：\nvar a = 1 + 2;\nvar b = a * 3;\nvar c = b - 4;\n函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：\nvar result = subtract(multiply(add(1,2), 3), 4);\n这就是函数式编程。\n二、特点\n函数式编程具有五个鲜明的特点。\n1. 函数是”第一等公民”\n所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。\nvar print = function(i){ console.log(i);};  \n[1,2,3].forEach(print);\n2. 只用”表达式”，不用”语句&quot;\n&quot;表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。\n原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。“语句”属于对系统的读写操作，所以就被排斥在外。\n当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。\n3. 没有”副作用”\n所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n4. 不修改状态\n上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。\n在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的”状态”。\nfunction reverse(string) {\n\tif(string.length == 0) {\n\t\n\t  return string;\n\t\n\t} else {\n\t\n\t  return reverse(string.substring(1, string.length)) + string.substring(0, 1);\n\t\n\t}\n}\n由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。\n5. 引用透明\n引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。\n有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。\n三、意义\n函数式编程到底有什么好处，为什么会变得越来越流行？\n1. 代码简洁，开发快速\n函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。\nPaul Graham在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。\n如果程序员每天所写的代码行数基本相同，这就意味着，“C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。“当然，这样的对比故意夸大了差异，但是”在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。“\n2. 接近自然语言，易于理解\n函数式编程的自由度很高，可以写出很接近自然语言的代码。\n前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：\nsubtract(multiply(add(1,2), 3), 4)\n对它进行变形，不难得到另一种写法：\nadd(1,2).multiply(3).subtract(4)\n这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：\nmerge([1,2],[3,4]).sort().search(&quot;2&quot;)\n因此，函数式编程的代码更容易理解。\n3. 更方便的代码管理\n函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。\n4. 易于”并发编程”\n函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。\n请看下面的代码：\nvar s1 = Op1();\nvar s2 = Op2();\nvar s3 = concat(s1, s2);\n由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。\n多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。\n5. 代码的热升级\n函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。"},"Web-Clip/@函数柯里化：三行代码实现-add(1)(2)(3)---掘金":{"title":"@函数柯里化：三行代码实现 add(1)(2)(3) - 掘金","links":[],"tags":["编程/思想"],"content":"add(1)(2)(3)\nconst add = x =&gt; y =&gt; z =&gt; x + y + z;\nconsole.log(add(1)(2)(3));\nadd(1, 2, 3);\nadd(1, 2)(3);\nadd(1)(2, 3);\n我们当然可以自己实现一个工具函数专门来生成 柯里化 函数。\n主要思路是什么呢，要判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数。\nconst curry = (fn, ...args) =&gt; \n    // 函数的参数个数可以直接通过函数数的.length属性来访问\n    args.length &gt;= fn.length // 这个判断很关键！！！\n    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数\n    ? fn(...args)\n    /**\n     * 传入的参数小于原始函数fn的参数个数时\n     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数\n    */\n    : (..._args) =&gt; curry(fn, ...args, ..._args);\n \nfunction add1(x, y, z) {\n    return x + y + z;\n}\nconst add = curry(add1);\nconsole.log(add(1, 2, 3));\nconsole.log(add(1)(2)(3));\nconsole.log(add(1, 2)(3));\nconsole.log(add(1)(2, 3));\nRamda\nRamda 中的函数所有都支持柯里化。也就是说，所有的多参数函数，默认都可以使用单参数函数。\n还是举上面的例子\nconst addThreeNumbers = (x, y, z) =&gt; x + y + z;\nconst curriedAddaddThreeNumbers = R.curry(addThreeNumbers);\nconst f = curriedAddaddThreeNumbers(1, 2);\nconsole.log(f(3));\n大名鼎鼎的 lodash 中也提供了 柯里化 函数 ，那么它和Ramda有什么区别呢\nlodash是一个很强大的工具函数库，比如 节流，防抖，深拷贝等等，只要引入 lodash ，我们就可以直接使用。 Ramda 是一个函数式编程风格的函数库。\n柯里化有什么作用\n主要有3个作用： 参数复用、提前返回和 延迟执行\n我们来简单的解释一下: 参数复用：拿上面 f这个函数举例，只要传入一个参数 z，执行，计算结果就是 1 + 2 + z 的结果，1 和 2 这两个参数就直接可以复用了。\n提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。\n扩展阅读\n\nRamda\nJS中的柯里化(currying)\nReact世界的函数式编程(Functional Programming)\n"},"Web-Clip/@前端常用的几种请求方式":{"title":"@前端常用的几种请求方式","links":[],"tags":["编程/网络/HTTP"],"content":"性能比较\n在比较性能时，需要考虑多个方面，包括执行速度、内存使用、兼容性、易用性和功能特性。下面是一个简化的表格，概述了 XMLHttpRequest、Fetch API、Axios 和 WebSocket 这四种方式的性能比较：\n\n最佳使用场景\n\nXMLHttpRequest (XHR): 适用于需要广泛兼容性的老旧系统或需要与多种后端系统交互的场景。\nFetch API: 适用于现代浏览器中，需要简洁语法和链式调用的场景。\nAxios: 适用于需要在项目中进行大量HTTP请求，且需要丰富配置和取消请求功能的场景，如与后端系统交互频繁的单页应用（SPA）。\nWebSocket: 适用于需要实时交互数据的场景，如实时聊天应用、在线游戏等。\n\n总结：在选择前端数据请求方式时，应根据项目的具体需求、兼容性要求以及性能考虑来决定使用哪种方法。每种方法都有其优点和局限性，理解它们的特点，可以帮助开发者更好地构建高效、稳定的前端应用。"},"Web-Clip/@好烦啊，我真的不想写增删改查了！":{"title":"@好烦啊，我真的不想写增删改查了！","links":[],"tags":["编程/思想"],"content":""},"Web-Clip/@如何远程触发-GitHub-Action-–-陈少文的网站":{"title":"@如何远程触发 GitHub Action – 陈少文的网站","links":["Web-Clip/curl"],"tags":["编程/Git/GitHub"],"content":"使用 curl 触发Github Action。\ncurl -X POST api.github.com/repos/:owner/:repo/dispatches \\\n    -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\\n    -H &quot;Authorization: token TRIGGER_TOKEN&quot; \\\n    --data &#039;{&quot;event_type&quot;: &quot;TRIGGER_EVENT&quot;}&#039;\n \ncurl -X POST api.github.com/repos/shaowenchen/wait-webhook-to-run/dispatches \\\n    -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\\n    -H &quot;Authorization: token ghp_xxxxxxxxxxxxxxxxxxxxxxxxxx&quot; \\\n    --data &#039;{&quot;event_type&quot;: &quot;webhook-1&quot;}&#039;\n \ncurl -X POST api.github.com/repos/shaowenchen/wait-webhook-to-run/dispatches \\\n    -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\\n    -H &quot;Authorization: token ghp_xxxxxxxxxxxxxxxxxxxxxxxxxx&quot; \\\n    --data &#039;{&quot;event_type&quot;: &quot;webhook-2&quot;}&#039;\n "},"Web-Clip/@小学生都开始学-Python-了！":{"title":"@小学生都开始学 Python 了！","links":[],"tags":["编程/Python"],"content":"为什么名字叫 “Python”？\n我们知道英文单词 “Python” 的中文翻译是 “蟒蛇” 或者 “巨蛇” 的意思。但作为一名编程语言的名称，Python 的初始意思并不是这样的。Python 这个名字，来自 Guido 所挚爱的电视剧 “Monty Python’s Flying Circus” 。他希望这个新的叫做 Python 的语言，能符合他的理想：创造一种 C 和 shell 之间，功能全面，易学易用，可拓展的语言。"},"Web-Clip/@我早就看现在的工作流不爽了！--前端使用-Jenkins":{"title":"@我早就看现在的工作流不爽了！- 前端使用 Jenkins","links":[],"tags":["编程/FE/工程化"],"content":"背景\n目前笔者所在的小公司的前端项目还是推送到git仓库后由另一名后端拉取代码到他电脑上再build，然后再手动同步到服务器上，比较麻烦，而且出现一个bug就要立即修复，笔者一天要说100次“哥，代码更新了，打包上传下吧，球球了”，终于我实在受不了了（上传代码的这位哥也受不了了），于是想通过 Jenkins 实现简单的前端项目自动打包部署。\n通过 docker 安装 Jenkins\n通过 ssh 连接上局域网服务器 192.168.36.2，在 home 目录下新建了一个 Jenkins 文件夹，后续我们的配置文件就放在其中。\n cd\n # 将 Jenkins 相关的文件都放在这里\n mkdir jenkins\n cd jenkins\n \n # 创建 Jenkins 配置文件存放的地址，并赋予权限\n mkdir jenkins_home\n chmod -R 777 jenkins_home\n \n pwd\n # /root/jenkins\n创建docker-compose.yml：\ntouch docker-compose.yml  \nvim docker-compose.yml\n version: &#039;3&#039;\n services:\n   jenkins:\n     image: jenkins/jenkins:latest\n     container_name: &#039;jenkins&#039;\n     restart: always\n     ports:\n       - &quot;8999:8080&quot;\n     volumes:\n       - /root/jenkins/jenkins_home:/var/jenkins_home\nJenkins 启动后会挂在8080端口上，本文笔者将其映射到8999端口，读者可以自行更改。\n关键在于将容器中的/var/jenkins_home目录映射到宿主机的/root/jenkins/jenkins_home目录，这一步相当于将 Jenkins 的所有配置都存放在宿主机而不是容器中，这样做的好处在于，后续容器升级、删除、崩溃等情况下，不需要再重新配置 Jenkins。\n使用:wq保存后可以开始构建了：\ndocker compose up -d\n这一步会构建容器并启动，看到如下信息就说明成功了：\n [+] Running 1/1  \n  ✔ Container Jenkins   Started           1.3s\n查看一下容器是否在运行：\n docker ps\n\n这个时候通过http://192.168.36.2:8999就可以访问 Jenkins 了。\nJenkins 初次配置向导\n解锁\n\n第一次打开会出现向导，需要填入管理员密码，获取密码有三种方式：\n\n通过宿主机\n\n cat /root/jenkins/jenkins_home/secrets/initialAdminPassword  \n   \n # 2bf4ca040f624716befd5ea137b70560\n\n通过 docker 进入容器\n\n docker exec -it jenkins /bin/bash  \n   \n #进入了docker  \n jenkins@1c151dfc2482:/$ cat /var/jenkins_home/secrets/initialAdminPassword  \n   \n # 2bf4ca040f624716befd5ea137b70560\n与方法一类似，因为目录映射，这两个目录其实是同一个。\n\n通过查看 docker log\n\n docker logs jenkins\n会出现一大串，最后能找到密码：\n\n填入密码，点击继续。\n安装插件\n\n选择安装推荐插件即可。\n安装插件可能会非常慢，可以选择换源。\n更换 Jenkins 插件源（可选）\n有两种方法：\n\n直接输入地址：\n\nhttp://192.168.36.2:8999/manage/pluginManager/advanced，在Update Site中填入清华源地址：\n mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\n点击Submit提交保存，并重启容器。\n\n直接更改配置文件：\n\n宿主机中操作：\n cd /root/jenkins/jenkins_home  \n vim hudson.model.UpdateCenter.xml\n替换其中的地址，然后重启容器即可。\n\n创建用户\n这一步建议用户名不为 admin ，不然会出现奇怪的问题，比如密码登录不上，需要用上一部的初始密码（2bf4ca040f624716befd5ea137b70560）才能登录。\n我这里创建了一个 root 用户（只是名字叫 root，防止用户名太多记不住而已）。\n\n点击保存并完成。\n实例配置按需调整即可，直接下一步，Jenkins 就准备就绪了。\n\n至此 Jenkins 安装就算完成了。\n安装插件\n笔者是一名前端，因此以前端项目为例。\n前端项目的打包需要 node 环境，打包完成后通过 ssh 部署到服务器上，并且构建结果通过钉钉机器人推送到群里，因此需要三个插件。\n\nNodeJS\nPublish Over SSH\nDingTalk（可选）\n\n在 系统管理 → 插件管理 → Available plugins 中搜索并安装。\n\n\n勾选安装后重启，让插件生效。\n插件配置\n我们安装了三个插件，分别进行配置。\nNodeJS\n这个插件可以在不同的项目中使用不同的 node 环境，例如 A项目 使用 node14，B项目 使用 node20 这样。\n进入 系统管理 → 全局工具配置 → NodeJS 安装 （在最下面）\n点击新增：\n\n默认的这个使用的是 nodejs.org 的官方源，虽然现在 nodejs.org 的官方源国内访问也还可以，但为了保险起见，笔者还是换成阿里巴巴源。\n\n点击红框里的 X 删除当前安装，在点击新增安装，选择 Install from nodejs.org mirror。\n\n镜像地址填入mirrors.aliyun.com/nodejs-release/，版本按需选择，笔者这里选择的是 node20-lts，并且安装了包管理工具 pnpm，如果读者的项目需要别的全局安装的包，也可以写在 Global npm packages to install ，比如 yarn、cnpm 之类的。\n记得起一个别名：\n\n配置好后点击保存。\n一般来说，在使用 npm 时，需要更改 npm 的源，同样在 Jenkins 中也是可以的。\n安装完 NodeJS 插件后，系统设置中会多一项 Managed files\n\n进入后选择左侧的Add a new Config，然后选择 Npm config file，然后点击 Next。\n\n\n新增一个 NPM Registry，填入阿里巴巴镜像源：registry.npmmirror.com。\n至此 NodeJS 相关的配置就完成了。\nSSH Server\n打包后需要通过 SSH 部署到服务器上，因此需要先配置好 SSH 服务器。\n打开 系统管理 → 系统配置 → Publish over SSH （在最下面）:\n\n然后根据实际情况进行填写：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n字段解释Name显示在 Jenkins 中的名称，可随意填写Hostname服务器地址，ip 或 域名UsernameSSH 登录的用户名Remote DirectorySSH 登录后进入的目录，必须是服务器中已经存在的目录，设置好之后所有通过 SSH 上传的文件只能放在这个目录下\n这里笔者使用用户名-密码的方式登录 SSH，如果要通过 SSH Key 的方式的话，需要在字段 Path to key 填入 key 文件的地址，或者直接将 key 的内容填入 Key 字段中:\n\nimage-20240403144737759\n设置好可以通过Test Configuration，测试 SSH 连通性：\n\n出现 Success 代表 SSH 配置成功。\n钉钉通知（可选）\n如果不需要通过钉钉通知，可以不装 DingTalk 插件，并跳过本节内容。\n钉钉部分设置\n该功能需要一个钉钉群，并打开钉钉群机器人：\n\n点击添加机器人，选择自定义：\n\nimage-20240403145604092\n这里笔者的安全设置选择了加签：\n\n将签名保存下来备用。\n点击完成后，出现了钉钉机器人的 Webhook 地址。\n\n将地址保存下来备用。\n至此钉钉部分的设置就结束了。\nJenkins 部分\n打开 系统设置 → 钉钉 （在最下面的未分类中）:\n\nimage-20240403145150439\n根据需要配置通知时机：\n\nimage-20240403145231249\n然后点击机器人-新增：\n\n将刚刚的钉钉机器人的签名和 Webhook 地址填入对应的地方，并点击测试：\n\n此时钉钉机器人也在群中发了消息：\n\n至此钉钉机器人配置完毕。\n创建任务（job）\n本文中，笔者将以存储在 Git 仓库中的项目为例。\nGithub 项目\n「注意，如果想让 Github 项目全自动构建的话，需要你的 Jenkins 能被公网访问到，例如部署在云服务器上，像笔者这样部署在本地局域网中，是无法实现“提交代码 → 自动构建 → 自动部署”的，只能实现“提交代码 → 手动点击开始构建 → 自动部署”」\n如果在 Jenkins 新手向导里选择了 安装推荐插件，那么现在就不需要额外安装 Github 相关的插件了，否则的话需要手动安装 Github 相关的插件：\n\n创建项目\n选择 Dashboard → 新建任务：\n\n选择构建一个自由风格的软件项目，点击确定。\nGeneral\n这部分可以添加钉钉机器人：\n\nimage-20240403151545166\n源码管理\n这里选择 Git：\n输入仓库地址：github.com/baIder/homepage.git\n\nimage-20240403151822101\n由于笔者这是一个私有仓库，因此会报错。\n在下面的Credentials中，添加一个。\n\n\n「注意，这里的用户名是 Github 用户名，但是密码不是你的 Github 密码，而是你的 Github Access Token！！！」\n\nimage-20240403152324115\n\nimage-20240403152429183\n可以在这里创建 Token，需要勾选 admin:repo_hook 、repo 权限。\n\nimage-20240403152535951\n\nimage-20240403152729685\n这里的报错是网络问题，连接 Github 懂得都懂。\n\nimage-20240403152824725\n分支可以根据实际情况选择。\n构建触发器\n勾选GitHub hook trigger for GITScm polling，这样在 Git 仓库产生提交时，就会触发构建，属于是真正的核心。\n\nimage-20240403153134664\n构建环境\n勾选 Provide Node &amp; npm bin/ folder to Path\n\nimage-20240403153444910\nBuild Steps\n到这里，可以理解为 Jenkins 已经将仓库克隆到本地，并且已经安装好了node、npm、pnpm，接下来就是执行命令：\n\nimage-20240403153625159\n我们需要执行命令：\n node -v    pnpm -v        rm -rf node_modules    rm -rf dist        pnpm install    pnpm build\n这里的pnpm build需要按情况更换为package.json中设定的命令。\n\nimage-20240403153850007\n\nimage-20240403153750787\n构建后操作\n经过所有的流程到这里，项目应该已经打包在dist目录下了。现在可以通过 SSH 将打包好的产物上传到服务器上了：\n\nimage-20240403154044658\n\nimage-20240403155757484\n这里的 Source files 字段一定要写成dist/**/**，如果写成dist/*，则只会将第一层的文件上传。\nRemove prefix 需要填写，否则会将dist这个目录也上传到服务器上。\nRemote directory 是相对于配置 SSH Server 时的 Remote directory 的，本例中就是 /data/sites/homepage 。\nExec command 是文件上传后执行的命令，可以是任何命令，可以是让nginx有权限访问这些数据，重启nginx等等，根据服务器实际情况更改。\n\n❝\n当然也可以在 Build Steps 中 build 完成后将 dist 目录打包，然后在通过 SSH 将压缩包上传到服务器，然后在 Exec command 中解压。\n❞\n\n至此所有的配置已经完成，保存。\n测试\n点击左侧的 立即构建：\n\nimage-20240403154858929\n\nimage-20240403154950197\n第一次构建会比较慢，因为需要下载node，安装依赖等等，可以从控制台看到，命令都如期执行了：\n\nimage-20240403155359524\n构建成功，钉钉机器人也提示了（因为 Github 访问失败的原因，多试了几次）：\n\nimage-20240403155855959\n笔者已经配置好了nginx，因此可以直接访问网页，查看效果：\n\nimage-20240403160008179\n通过 Git 提交触发构建\n目前虽然构建成功了，但是需要手动点击构建，接下来实现如何将代码提交 Git 后自动触发构建。\n打开仓库设置 → Webhooks 添加一个：\n\nimage-20240403160353025\n这里的 Payload URL 就是 Jenkins 地址 + /github-webhook，例如笔者的就如图所示。\n但是由于笔者的 Jenkins 部署在本地局域网，因此是不行的，Github 肯定是无法访问到笔者的局域网的，有公网地址的读者可以试试，在笔者的阿里云服务器上是没有问题的。所以目前如果是 Github 项目的话，笔者需要提交代码后手动点击 立即构建：\n\nimage-20240403161026497\nGitlab 项目\n实际上笔者所在公司是在局域网中部署了 Gitlab 的，因此针对 Gitlab 项目的自动化才是核心。\n安装 Gitlab 插件：\n\nimage-20240403161442736\n安装完毕后重启 Jenkins。\n获取 Gitlab token\n与 Github 的流程类似，也需要在 Gitlab 中创建一个 token：\n\nimage-20240403161807711\n创建好之后保存 token 备用。\n在 Jenkins 中配置 Gitlab\n打开 Jenkins → 系统管理 → 系统配置 → Gitlab\n\nimage-20240403162301361\n这里需要新建一个Credentials，点击下方的添加：\n类型选择GitLab API token，将刚刚保存的 token 填入到 API token 字段中。\n\nimage-20240403162144399\n点击Test Connection：\n\nimage-20240403162651637\n出现Success说明配置成功。\n创建项目\n大多数过程与 Github 项目雷同。\nGeneral\n会多出一个选项，选择刚刚添加的：\n\nimage-20240403163406501\n源码管理\nGit 仓库地址填 Gitlab 仓库地址，同样会报错，添加一个Credentials便可解决：\n\nimage-20240403163538105\n用户名密码填登录 Gitlab 的用户名密码即可。\n构建触发器\n按需选择触发条件，这里笔者仅选择了提交代码：\n这里红框中的 url 需要记下，后面要用。\n\nimage-20240403164252265\n其他配置\n与 Github 项目相同。\n测试构建\n点击立即构建，查看是否能构建成功：\n\nimage-20240403163945821\n构建成功：\n\nimage-20240403164002293\n提交代码自动构建\n进入 Gitlab 仓库 → 设置 → 集成：\n这里的 url 填入刚刚 Jenkins 构建触发器 中红框内的 url 地址。\n\nimage-20240403164203308\n看情况是否开启 SSL verification。\n点击 Add webhook：\n\nimage-20240403164449921\n测试一下：\n\nimage-20240403164513668\n可以看到 Jenkins 那边已经开始构建了：\n\nimage-20240403164551282\n构建成功：\n\nimage-20240403164606737\n测试 Git 提交触发构建\n目前页面：\n\nimage-20240403164712339\n我们将v2.0-f改成v2.0-g：\n\nimage-20240403164817371\n提交代码，Jenkins 开始了自动构建：\n\nimage-20240403164852625\n构建成功，页面也发生了变化：\n\nimage-20240403164912343\n至此，Gitlab 提交代码后自动打包并部署至服务器的流水线就完成了。\n后记\n本文实现了从提交代码到部署上线的自动化工作流，适合小公司的小型项目或自己的演示项目，大公司一定会有更规范更细节的流程，笔者也是从实际需求出发，希望本文能帮助到各位，由于笔者也是第一次使用 Jenkins，如有不足或错误之处，请读者批评指正。"},"Web-Clip/@手动实现call(),-apply(),-bind()---掘金":{"title":"@手动实现call(), apply(), bind() - 掘金","links":[],"tags":["编程/JavaScript"],"content":""},"Web-Clip/@手动实现call、apply、bind-_-awesome-coding-js":{"title":"@手动实现call、apply、bind _ awesome-coding-js","links":[],"tags":["编程/JavaScript"],"content":""},"Web-Clip/@推荐两个CSS生成器，专治各种不规则形状，建议收藏":{"title":"@推荐两个CSS生成器，专治各种不规则形状，建议收藏","links":[],"tags":["编程/FE/CSS"],"content":"在现代网页设计中，CSS（层叠样式表）是至关重要的一部分，它决定了网页的外观和布局。然而，对于许多人来说，编写和管理CSS代码可能是一个令人头疼的任务。但是，有幸的是，有许多工具和资源可以帮助简化这一过程，其中之一就是CSS生成器网站。\nCSS-generators介绍\nCSS-Generators为开发人员和设计人员提供了一种强大且灵活的方式来创建和设计网站，对大部分前端开发者来说，复杂样式Cascading Style Sheets (CSS)是非常伤脑筋的一件事情，想要实现不规则形状是非常困难的，不言而喻，编写复杂的 CSS 代码并不总是一件轻松的事情，特别是当涉及到复杂的样式和布局时，这就是 CSS-Generators 的作用的地方。\nCSS-Generators是一个集合多种 CSS 生成器的网站，旨在帮助开发者和设计人员快速生成他们需要的 CSS 代码。此网站提供了各种 CSS 生成器，包括渐变生成器、阴影生成器、转换生成器等，让开发者能够减少手写 CSS 代码的时间，并专注于更加重要的工作。\n\nCSS-Generators.com 的特性主要包括：\n\n\n丰富的 CSS 生成器： 网站提供了一系列的 CSS 生成器，满足开发者不同的需求。\n\n\n生成优化的 CSS 代码： 生成的代码是优化后的，可以直接应用在网站的开发中。\n\n\n易用性： 简单易用的界面让开发者可以快速找到他们所需的生成器。\n\n\n实时预览： 编辑 CSS 属性后，可以直接预览效果。\n\n\n节省开发时间： 通过使用这些生成器，开发者可以大大减少编写 CSS 代码的时间。\n\n\n如何使用 CSS-Generators\n使用 CSS-Generators.com 的过程非常简单。你只需要选择一个适合你需求的生成器，例如渐变生成器，然后在提供的选项中调整 CSS 属性，比如渐变的颜色、方向等。生成器会实时更新预览，让你能立即看到结果。最后，你只需要复制生成的代码，然后将它粘贴到你的 CSS 文件或者直接在 HTML 中使用。\n更多生成器请前往官方网站查阅，效果杠杠滴，css-generators.com/。\nbennettfeely介绍\nbennettfeely 是一个在线工具，旨在帮助用户生成各种独特的 CSS 路径裁剪（clip-path）代码。CSS 路径裁剪是一种强大的技术，允许您通过定义一个路径来裁剪元素的可见区域，从而创建出各种各样有趣的形状和效果。可以将裁剪路径导出为SVG，这样可以利用SVG的SMIL动画技术设置路径动画，从而使路径裁剪在页面上呈现出更加生动和引人注目的外观。\n关于bennettfeely 工具使用，小编之前写过一篇文章，这里就不再赘述了，感兴趣的小伙伴可以点击下方文章链接进行查看或者前往官方网站查阅更多内容。\n如何使用bennettfeely 工具更多操作细节的文章链接：CSS奇妙的属性clip-path，可画出任意图形\n\n总结\nCSS-Generators是一个强大和便利的工具，不仅适合 CSS 初学者快速掌握 CSS 技术，也非常适合经验丰富的开发人员节省时间、提高效率。面对 CSS 的各种挑战，CSS-Generators 提供了一个简洁、高效的解决方案，可以说是每个前端开发人员的必备工具。bennettfeely 也能生成各种独特的 CSS 路径裁剪（clip-path）代码。CSS 路径裁剪是一种强大的技术，通过定义一个路径来裁剪元素的可见区域，从而创建出各种各样有趣的形状和效果。CSS-Generators 和 bennettfeely 强强联合，解决web日常开发各种形状还不轻松拿捏了。"},"Web-Clip/@推荐几个不错的JS媒体库":{"title":"@推荐几个不错的JS媒体库","links":[],"tags":["编程/FE/第三方库"],"content":""},"Web-Clip/@玉伯这个中年男人也去创业了":{"title":"@玉伯这个中年男人也去创业了","links":[],"tags":["场景/创业"],"content":"人是环境的反应器。也可用这句话来看自己，人是大自然里的一阵风，人是河流里的一滴水，敬畏者谦卑。\n把事情变简单。把事情变复杂，人人都有能力。但是把事情变简单，是少数人的能力。把简单留给用户，同时把简单也留给自己。\n像园丁一样辛勤，同时像园丁一样有耐心。每个人都应该打造自己的数字花园。"},"Web-Clip/@珠三角有多富！广东省有多穷！":{"title":"@珠三角有多富！广东省有多穷！","links":[],"tags":["场景/城市"],"content":""},"Web-Clip/@男人做到这4点，婚姻越来越幸福":{"title":"@男人做到这4点，婚姻越来越幸福","links":[],"tags":["Areas/爱情","场景/书籍推荐"],"content":"夫妻之间不要搭伙过日子\n《爱的5种语言》是一本特别好的书，帮我们更好的明白爱、学习爱，可以让我们在表达爱上，颗粒度更丰富。\n\n这本书，从5个维度刻画了人际交往中表达爱的方式：\n\n肯定的言辞：在对方做了某些事后，实时的给予肯定和认可。\n服务的行动：当对方需要帮助或者忙碌的时候，实时分担一些事，减轻他的压力。\n身体的接触：这是亲密关系的重要表现，通过牵手、拥抱、亲吻等方式，建立身体上的默契和信任。\n精心的时刻：给予对方全部的注意力，可以是全神贯注的交流沟通，也可以是二人烛光晚餐，海边手拉手漫步…\n礼物：顾名思义，通过送礼物表达爱意和关怀。\n\n可见，亲密关系中爱另外一半的方式有很多。\n当对方做了一大桌菜，表达感谢，是一种爱；\n对方通过努力，达成某个目标，表达赞美和肯定，是一种爱；\n对方哄孩子睡觉时，我去洗碗和拖地，是一种爱；\n下班回家，给对方一个拥抱，是一种爱；\n特别的日子，找一个环境优美的地方约会，是一种爱；\n发红包买手机等，是一种爱；\n…\n无论通过哪种方式表达爱，都没关系，重要的是，对方真正”收到”了我们的爱。\n当然，如果想更好的爱到对方，可以多套组合试一试，避免只采用单一的方式，山珍海味再好吃，吃久了也会腻。\n做一个好队友，拒绝丧偶式育儿\n《看不见的女性》这本书，深刻描写了这一点。女性承担了75%的家庭照护工作，却得不到相应的报酬和社会支持，常常被忽视。\n传统中国家庭，多半是男主外女主内。男性只要负责在外打拼，赚钱养家即可，女性需要照顾年幼的孩子，年长的老人，还有永远做不完的家务。\n在一二线城市，这种情况可能会好一些，经济条件不允许，大部分家庭还是双职工，男性和女性都要上班，也要一起照顾家庭。但整体情况是，女性在家庭中付出的更多。\n用好做好家庭中短期和长期规划\n彼此成长相互成就"},"Web-Clip/@知识管理软件-Zotero-的使用---chempeng":{"title":"@知识管理软件 Zotero 的使用 - chempeng","links":[],"tags":["Apps/Zotero"],"content":""},"Web-Clip/@私有项目如何使用-github-action-打包-docker-镜像并部署到服务器---掘金":{"title":"@私有项目如何使用 github action 打包 docker 镜像并部署到服务器 - 掘金","links":[],"tags":["编程/Docker","编程/Git/GitHub"],"content":"由于 hub.docker.io 目前只支持一个 私有镜像，所以我们暂不考虑使用；推荐大家使用 github 自带的 镜像源 ghcr.io\n前置准备工作\n\n去 github.com/settings/to… 生成一个 token，注意此 token 需要读写 packages 等权限 详情请见这里\n准备好你的要部署的服务器的 账号 和密码（当前页可以使用秘钥登录，这里暂且使用密码）\n想好你的镜像名称（此处以 web-image 为例）\n\n在.github/workflows目录创建一个 publish-image.yml\nname: Publish Image\n \non:\n  push: # push 到主分支自动 发布\n    branches: [&quot;main&quot;]\n    paths-ignore: # 忽略一些不必要的文件\n      - &quot;.gitignore&quot;\n      - &quot;README.md&quot;\n      - &quot;.vscode/**&quot;\n  pull_request:\n    branches: [&quot;main&quot;]\n \njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v1\n        with:\n          registry: ghcr.io # 声明镜像源\n          username: ${{ github.actor }} # 当前github 用户名\n          password: ${{ secrets.HUB_GITHUB_TOKEN }} # 需要去 github.com/settings/tokens 生成一个 名为 token，注意此token 需要读写 packages 等权限 \n      - uses: actions/setup-node@v2\n        with:\n          node-version: &quot;16.14&quot;\n      - uses: actions/cache@v2\n        id: cache\n        with:\n          path: node_modules\n          key: ${{ runner.os }}-node-${{ hashFiles(&#039;package-lock.json&#039;) }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n        # Runs a single command using the runners shell\n      - name: pnpm install\n        run: npm install -g pnpm --registry registry.npm.taobao.org\n      - name: Install\n        if: steps.cache.outputs.cache-hit != &#039;true&#039;\n        run: npm config set registry registry.npm.taobao.org &amp;&amp; pnpm i\n \n      - name: Build\n        run: npm run build\n      - name: Show Dir\n        run: ls\n \n      - name: Build the  Docker image\n        run:\n          | # 使用 上一步写的 Dockerfile 构建镜像并发布到私有仓库； 发布完成可以去 github.com/MrGaoGang 查看\n          docker build . --file Dockerfile --tag ghcr.io/你的github名称/web-image:latest \n          docker push ghcr.io/你的github名称/web-image:latest\n      - name: 更新服务器\n        uses: appleboy/ssh-action@v0.1.10\n        with:\n          host: ${{ secrets.SERVER_HOST }} # 服务器ip地址 ; 需要去仓库的 settings/secrets/actions 去创建\n          username: ${{ secrets.SERVER_USER }} # 服务器用户名称；需要去仓库的 settings/secrets/actions 去创建\n          password: ${{ secrets.SERVER_PWD }} # 服务器密码；需要去仓库的 settings/secrets/actions 去创建\n          port: ${{ secrets.SERVER_PORT }} # 服务器端口，默认22；需要去仓库的 settings/secrets/actions 去创建\n          script: | # 重启更新镜像\n            docker stop web-image \n            docker rm web-image \n            docker login -u 你的github名称 -p 你的github token ghcr.io \n            docker pull ghcr.io/你的github名称/web-image:latest \n            docker run -dp 80:80  --restart=always --name web-image ghcr.io/你的github名称/web-image\n \n        # 上面使用 80端口启动，当然你也可以换成自己想要的端口\n扩展阅读\n\n确保工作流程访问您的包\n"},"Web-Clip/@移动端适配原理与方案详解---掘金":{"title":"@移动端适配原理与方案详解 - 掘金","links":[],"tags":["编程/FE/适配"],"content":""},"Web-Clip/@简明-JavaScript-函数式编程——入门篇---知乎":{"title":"@简明 JavaScript 函数式编程——入门篇 - 知乎","links":[],"tags":["编程/思想"],"content":""},"Web-Clip/@网站开发人员应该知道的61件事---阮一峰的网络日志":{"title":"@网站开发人员应该知道的61件事 - 阮一峰的网络日志","links":[],"tags":["编程/思想"],"content":""},"Web-Clip/@腾讯云4月8日故障复盘及情况说明":{"title":"@腾讯云4月8日故障复盘及情况说明","links":[],"tags":["编程/服务器"],"content":"改进措施\n综合盘点这次故障，最根本的原因是在版本变更过程中，没有有效执行沙箱验证和预案演练，暴露了在变更管理上的不足，接下来将从以下几个方面快速进行改进和完善，以减少故障的影响范围和影响时长。\n第一，提升系统韧性\n1、定期执行预定的变更策略模拟演练，确保在真实故障发生时，能够迅速切换到恢复模式，最小化服务中断时间。\n2、优化服务部署架构，通过分层架构、代码审查和监控等手段， 避免API服务中潜在的循环依赖问题。\n3、提供API服务逃生通道，当故障发生时，可供调用方快速切换。\n第二，强化变更管理与保护措施\n1、完善自动化测试用例库，在系统变更前通过沙箱环境对变更内容进行严格验证。\n2、实施灰度发布策略，逐步推广新功能或配置更改，按集群、可用区、地域逐步生效，以便在发现问题时能够迅速回滚。\n3、引入异常自动熔断机制，当检测到系统异常时，能够立即中断变更过程。\n第三，增强故障响应与沟通能力\n1、对故障处理流程进行全面升级，确保实时更新故障处理进度和预计恢复时间点，提升故障报告发布效率。\n2、在对外发布的故障通知中，清晰阐述受影响的业务范围、故障根因及预计修复时长，保持透明度。\n3、优化腾讯云健康状态看板（StatusPage）的信息展示逻辑，解除对云API等云服务的依赖，通过引入缓存和容灾机制，确保即使在云服务出现故障时，能准确、及时地传递故障信息。"},"Web-Clip/@阿里面试：写一个倒计时功能刷掉了80-percent-的人":{"title":"@阿里面试：写一个倒计时功能刷掉了80% 的人","links":["C-Knowledge/前端/开发技术/JavaScript/Countdown.js"],"tags":["编程/JavaScript"],"content":"首先我们在写倒计时的时候必须要考虑到两点：准确性、性能。接下来我们来一步一步实现一个准确的定时器。\nsetInterval：\n我们先来简单实现一个倒计时的函数：\nfunction example1(leftTime) {\n  let t = leftTime;\n  setInterval(() =&gt; {\n    t = t - 1000;\n    console.log(t);\n  }, 1000);\n}\nexample1(10);\n可以看到使用 setInterval 即可，但是 setInterval 真的准确吗？我们来看一下 MDN 中的说明：\n💡 如果你的代码逻辑执行时间可能比定时器时间间隔要长，建议你使用递归调用了 setTimeout()的具名函数。例如，使用 setInterval() 以 5 秒的间隔轮询服务器，可能因网络延迟、服务器无响应以及许多其他的问题而导致请求无法在分配的时间内完成。\n简单来说意思就是，js 因为是单线程的原因，如果前面有阻塞线程的任务，那么就可能会导致 setInterval 函数延迟，这样倒计时就肯定会不准确，建议使用 setTimeout 替换 setInterval。\nsetTimeout：\n按照上述的建议将 setInterval 换为 setTimeout 后，我们来看下代码：\nfunction example2(leftTime) {\n  let t = leftTime;\n  setTimeout(() =&gt; {\n    t = t - 1000;\n    if (t &gt; 0) {\n      console.log(t);\n      example2(t);\n    }\n    console.log(t);\n  }, 1000);\n}\nMDN 中也说了，有很多因素会导致 setTimeout 的回调函数执行比设定的预期值更久，比如嵌套超时、非活动标签超时、追踪型脚本的节流、超时延迟等等，详情见developer.mozilla.org/zh-CN/docs/…，总就就是和 setInterval 差不多，时间一长，就会有误差出现，而且 setTimeout有一个很不好的点在于，当你的程序在后台运行时，setTimeout也会一直执行，这样会严重的而浪费性能，那么有什么办法可以解决这种问题吗？\nrequestAnimationFrame\n这里就不得不提一个新的方法 requestAnimationFrame，它是一个浏览器 API，允许以 60 帧/秒 (FPS) 的速率请求回调，而不会阻塞主线程。通过调用 requestAnimationFrame 方法浏览器会在下一次重绘之前执行指定的函数，这样可以确保回调在每一帧之间都能够得到适时的更新。\n我们使用 requestAnimationFrame 结合 setTimeout 来优化一下之前的代码：\nfunction example4(leftTime) {\n  let t = leftTime;\n  function start() {\n    requestAnimationFrame(() =&gt; {\n      t = t - 1000;\n      setTimeout(() =&gt; {\n        console.log(t);\n        start();\n      }, 1000);\n    });\n  }\n  start();\n}\n为什么要使用 requestAnimationFrame + setTimeout呢？一个是息屏或者切后台的操作时，requestAnimationFrame 是不会继续调用函数的，但是如果只使用requestAnimationFrame 的话，函数相当于 1 秒的时候要调用 60 次，太浪费性能。\n在切后台或者息屏的实际执行时会发现，当回到页面时，倒计时会接着切后台时的时间执行，而没有更新到最新的时间，这样的bug是接受不了的。\ndiffTime差值计算：\n要解决上述的问题，最通用的办法就是通过时间差值每次进行对比就可以了。\nfunction example5(leftTime) {\n  const now = performance.now();\n  function start() {\n    setTimeout(() =&gt; {\n      const diff = leftTime - (performance.now() - now);\n      console.log(diff);\n      requestAnimationFrame(start);\n    }, 1000);\n  }\n  start();\n}\n上面的代码实现思路其实在实际的业务中已经能够满足我们的使用场景，但其实还是没有解决setTimeout会延迟的问题，当线程被占用之后，很容易出现误差，那么有什么更新的办法进行处理呢？\n最佳方案\n先要明确的是，setTimeout函数中执行代码的时间肯定是要大于等于setTimeout时间的，那么就可能出现设定的 1 秒，实际执行却执行了 2 秒的情况，那么我们的实现思路也很简单，每次计算一下setTimeout实际执行的时间，然后动态的调整下一次执行的时间，而不是设置固定的值\n我们来用图表举例推演一下每次执行的情况：\n\n从中可以看到：下次执行的时间 nextTime = 1000 - totleTime % 1000；这样我们就可以得出下次执行的时间，从而每次都去动态的调整多余消耗的时间，大大减小倒计时最终的误差\n还有需要考虑的是，实际业务中返回的剩余时间肯定不会是整数，所以我们的第一次执行的时间最好可以先让剩余时间变为整数，这样可以在倒计时到最后一秒时更加的精确。\n根据上述的思路来看一下最终封装出来的 react hooks：\nconst useCountDown = ({ leftTime, ms = 1000, onEnd }) =&gt; {\n  const countdownTimer = useRef();\n  const startTimer = useRef();\n  //记录初始时间\n  const startTimeRef = useRef(performance.now()); // 第一次执行的时间处理，让下一次倒计时时调整为整数\n  const nextTimeRef = useRef(leftTime % ms);\n  const [count, setCount] = useState(leftTime);\n  const clearTimer = () =&gt; {\n    countdownTimer.current &amp;&amp; clearTimeout(countdownTimer.current);\n    startTimer.current &amp;&amp; clearTimeout(startTimer.current);\n  };\n  const startCountDown = () =&gt; {\n    clearTimer();\n    const currentTime = performance.now(); // 算出每次实际执行的时间 const executionTime = currentTime - startTimeRef.current; // 实际执行时间大于上一次需要执行的时间，说明执行时间多了，否则需要补上差的时间\n    const diffTime =\n      executionTime &gt; nextTimeRef.current\n        ? executionTime - nextTimeRef.current\n        : nextTimeRef.current - executionTime;\n    setCount((count) =&gt; {\n      const nextCount = count - (Math.floor(executionTime / ms) || 1) * ms - nt;\n      return nextCount &lt;= 0 ? 0 : nextCount;\n    }); // 算出下一次的时间\n    nextTimeRef.current =\n      executionTime &gt; nextTimeRef.current ? ms - diffTime : ms + diffTime; // 重置初始时间\n    startTimeRef.current = performance.now();\n    countdownTimer.current = setTimeout(() =&gt; {\n      requestAnimationFrame(startCountDown);\n    }, nextTimeRef.current);\n  };\n  useEffect(() =&gt; {\n    setCount(leftTime);\n    startTimer.current = setTimeout(startCountDown, nextTimeRef.current);\n    return () =&gt; {\n      clearTimer();\n    };\n  }, [leftTime]);\n  useEffect(() =&gt; {\n    if (count &lt;= 0) {\n      clearTimer();\n      onEnd &amp;&amp; onEnd();\n    }\n  }, [count]);\n  return count;\n};\nexport default useCountDown;\n如果想要封装组件的话，可以在hooks的基础上进行二次封装。\n到这里，肯定会有人说，做了这么多的操作，有必要吗，就算差0点几秒，在实际体验中用户完全感受不出来。我想说的是，细节决定成败，有可能这零点几秒的内容就决定了面试的成败。如果做什么事都只做个差不多，那你永远不会有自己的”核心科技”。关注细节，从中去学一些解题的思路或者方法，然后积累沉淀，才能让自己持续成长。\n扩展阅读\n\nCountdown.js\n"},"Web-Clip/@🎶-SunoAI-音乐生成初体验":{"title":"@🎶 SunoAI 音乐生成初体验","links":[],"tags":["编程/AI"],"content":""},"Web-Clip/curl":{"title":"curl","links":["Web-Clip/@Curl-的用法指南---阮一峰的网络日志"],"tags":["编程/服务器"],"content":"\n@Curl 的用法指南 - 阮一峰的网络日志\n"},"Web-Clip/子网掩码：IP地址是不是在同一个子网络":{"title":"子网掩码：IP地址是不是在同一个子网络","links":[],"tags":["编程/网络"],"content":"已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。"},"Web-Clip/范畴":{"title":"范畴","links":[],"tags":["数学"],"content":"“范畴就是使用箭头连接的物体。“（In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”. ）"},"index":{"title":"首页","links":["C-Knowledge/读书笔记/《卡片笔记写作法》","A-Navigation/B-项目🧵","A-Navigation/C-科学-🔬","A-Navigation/D-文化🐲","A-Navigation/E-艺术-🎨","A-Navigation/F-时光日志📔"],"tags":[],"content":"hello 👋，我是宋兴国 ❄️，一名前端开发工程师。\n这里是一座「全开放式，每日更新」的数字花园，由原子化的 卡片笔记 编织而成。目前主要在浇灌这几个领域 ⭕：\n\nB 项目🧵\nC 科学 🔬\nD 文化🐲\nE 艺术 🎨\nF 时光日志📔\n\n这绝不是传统的博客，这是我思考过程的容器，所以可能有很多看起来令人费解的半成品内容，也会颠覆你传统的长文阅读习惯。当您漫步花园时，这里有 2 个不成熟的小建议 💁：\n\n尽量通过鼠标悬浮预览进行上下文不中断的阅读。\n尽量通过底部反向链接找回来时的路。\n\n这座花园里，我挖了很多坑 🕳，如果你想敦促我加速填坑，或有一些建议和问题，欢迎来 Github Discussions。或直接在下方自带的评论系统留言。如果方便的话，给个 star⭐️ 呗。\n最后，如果您发现了令人不适的内容，或我的个人隐私，请告知我，万分感谢 🦀🦀: [xg.song@qq.com](mailto: xg.song@qq.com)。"}}